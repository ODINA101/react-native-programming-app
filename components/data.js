export default Data = {
    htmlcss:{
    chapters:[
        {
            title:"თავი 1.HTML5-ის შესავალი",
            content:[
                {
                    title:"რა არის HTML",
                    data:`HTML (HyperText Markup Language) წარმოადგენს ჰიპერტექსტური მარკირების ენას, რომელიც ძირითადად გამოიყენება ინტერნეტის ქსელის დოკუმენტების შესაქმნელად. HTML სათავეს იღებს გასული საუკუნის 90-იანი წლებიდან, როგორც ვებგვერდების შესაქმნელი პრიმიტიული ენა, ხოლო დღეისთვის ინტერნეტი წარმოუდგენელია ამ ენის გარეშე. საიტების აბსოლუტური უმრავლესობა ასე თუ ისე იყენებს HTML-ს.

                    2014 წელს ოფიციალურად დასრულდა მუშაობა ახალ სტანდარტზე - HTML5-ზე, რომელმაც ფაქტიურად რევოლუციური ცვლილებები შეიტანა HTML-ში.
                    
                    კონკრეტულად რა მოიტანა HTML5-მა?
                    
                    HTML 5-მა განსაზღვრა პარსინგის ახალი ალგორითმი DOM-ის (Document Object Model) სტრუქტურის შესაქმნელად;
                    ახალი ელემენტების და ტეგების დამატება, როგორიცაა ელემენტები video, audio და სხვა;
                    HTML-ის არსებული ელემენტების გამოყენების წესების და სემანტიკის ხელახალი განსაზღვრა.
                    ახალი ფუნქციების დამატებით HTML5 გახდა არა უბრალოდ HTML-ის ახალი ვერსია, არამედ ფაქტიურად გახდა პლატფორმა პროგრამული უზრუნველყოფის შესაქმნელად, ხოლო მისი გამოყენების სფერო შორს გასცდა ინტერნეტის ფარგლებს: HTML5 გამოიყენება მობილური აპლიკაციებისთვის ანდროიდის, iOS, Windows Mobile ბაზაზე, ასევე დესკტოპ-პროგრამების შესაქმნელადაც.
                    
                    საბოლოოდ, HTML5 ძირითადად გამოიყენება შემდეგი დანიშნულებით:
                    
                    HTML5, როგორც ჰიპერტექსტური მარკირების განახლებული ენა, როგორც წინა HTML4-ის განვითარება;
                    HTML5, როგორც მძლავრი პლატფორმა ვებაპლიკაციების შექმნისთვის, რომელიც HTML5-თან ერთად ასევე მოიცავს პროგრამირების ენა JavaScript -ს და სტილების კასკადურ ცხრილებს CSS3-ს.
                    HTML5-ის განვითარებით დაკავებულია World Wide Web Consortium (შემოკლებით W3C  - მსოფლიო ქსელის კონსორციუმი) - დამოუკიდებელი საერთაშორისო ორგანიზაცია, რომელიც განსაზღვრავს HTML5-ის სტანდარტებს სპეციფიკაციების სახით. მიმდინარე სრული სპეციფიკაციის ნახვა შესაძლებელია მისამართზე https://www.w3.org/TR/html5/.
                    
                    ბრაუზერების მხარდაჭერა
                    
                    უნდა აღინიშნოს, რომ HTML5-ის სპეციფიკაციებსა და ვებბრაუზერების მიერ ამ ტექნოლოგიების გამოყენებას შორის ყოველთვის იყო სხვაობა, თუმცა ბრაუზერების უმეტესობამ ამ სტანდარტების დანერგვა დაიწყო ჯერ კიდევ მის ოფიციალურად გამოქვეყნებამდე და დღეისათვის ბრაუზერების ბოლო ვერსიების უმრავლესობა იყენებს HTML5-ის ფუნქციონალის უმეტეს ნაწილს (Google Chrome, Firefox, Opera, Internet Explorer 11, Microsoft Edge), ამასთნ ბრაუზერების ძველ ვერსიებს არ გააჩნიათ HTML5-ის მხარდაჭერა, მაგალითად Internet Explorer 8 და უფრო ადრეული ვერსიები, ხოლო IE 9, 10-ს გააჩნია სტანდარტების მხოლოდ ნაწილის მხარდაჭერა.
                    
                    ამასთან, იმ ბრაუზერებს, რომელთაც გააჩნიათ HTML5-ის სტანდარტების მხარდაჭერა, შესაძლოა არ გააჩნდეთ კონკრეტული ელემენტების მხარდაჭერა და ეს უნდა გავითვალისწინოთ მუშაობისას.
                    
                    ბრაუზერის მიერ HTML5-ს სტანდარტების მხარდაჭერის დონის შემოწმება შესაძლებელია სპეციალური სერვისის მეშვეობით მისამართზე: http://html5test.com.
                    
                    საჭირო ინსტრუმენტები
                    რა არის საჭირო HTML5-თან სამუშაოდ? პირველ რიგში საჭიროა ტექსტური რედაქტორი ვებგვერდის html-ის ტექსტის ასაკრეფად. ამ დროისათვის ერთ-ერთი ტექსტური რედაქტორი, რომელიც ფართოდ გამოიყენება არის Notepad++, მისი ნახვა და გადმოწერა შეიძლება შემდეგი მისამართიდან: http://notepad-plus-plus.org. მისი უპირატესობა მდგომარეობს იმაში რომ არის უფასო და გააჩნია კოდის შემოწმების ინსტრუმენტები.
                    
                    ასევე ფართოდ გამოიყენება კროსპლატფორმული ტექსტური რედაქტორი Visual Studio Code. მას გააჩნია უფრო მეტი შესაძლებლობები, ვიდრე Notepad++-ს და ასევე არის უფასო, გარდა ამისა, მისი გამოყენება შეიძლება როგორც Windows-ში, ასევე MacOS-ში და Linux-ის ბაზაზე არსებულ ოპერაციულ სისტემებში. ამ სახელმძღვანელოს შექმნის პროცესში გამოყენებულ იქნა Visual Studio Code.
                    
                    ასევე დაგვჭირდება ვებბრაუზერი შექმნილი ვებგვერდების გაშვებისა და შემოწმებისთვის. ამ მიზნებისთვის გამოდგება ნებისმიერი გავრცელებული ბრაუზერი - Google Chrome, Mozilla Firefox, Microsoft Edge, Opera.`
                },
                {
                    title:"HTML5-ის ელემენტები და ატრიბუტები",
                    data:`სანამ შევუდგებით საკუთარი ვებგვერდის შექმნას, განვიხილოთ ძირითადი სამშენებლო ბლოკები, აგურები, რისგანაც შედგება ვებგვერდი.

                    HTML5-ის დოკუმენტი, ისევე როგორც ნებისმიერი სხვა დოკუმენტი, შედგება ელემენტებისაგან, ხოლო ელემენტები შედგება ტეგებისაგან. როგორც წესი, ელემენტს გააჩნია საწყისი და საბოლოო ტეგი, რომლებიც მოქცეულია კუთხოვან ფრჩხილებში. მაგალითად:
                    
                    <div>div ელემენტის ტექსტი</div>
                    
                    აქ განსაზღვრულია ელემენტი div, რომელსაც გააჩნია საწყისი ტეგი <div> და საბოლოო ტეგი</div>. მათ შორის მოქცეულია div ელემენტის შიგთავსი. ამ შემთხვევაში შიგთავსის სახით წარმოდგენილია ტექსტი "div ელემენტის ტექსტი".
                    
                    ელემენტი ასევე შეიძლება შედგებოდეს ერთი ტეგისგან, მაგალითად ელემენტი <br />, რომლის დანიშნულებაა სტრიქონის გადატანა:
                    
                    <div>div ელემენტის <br />ტექსტი </div>
                    
                    ასეთ ელემენტს ასევე უწოდებენ ცარიელ ელემენტს. თუმცა მაგალითში გამოყენებულია სლეში ("/"), მაგრამ მისი გამოყენება შესაძლებელია სლეშის გარეშეც შემდეგი სახით: <br>.
                    
                    თითოეულ ელემენტს საწყის ტეგში შეიძლება ჰქონდეს ატრიბუტები, მაგალითად:
                    
                    <div style="color:red;">ღილაკი</div>    
                    <input type="button" value="დააჭირეთ">
                    აქ მოცემულია 2 ელემენტი: div და input. div ელემენტს გააჩნია ატრიბუტი style. ტოლობის ნიშნის შემდეგ ბრჭყალებში წერია ატრიბუტის მნიშვნელობა type="color:red;". ამ შემთხვევაში "color:red;" განსაზღვრავს, რომ ტექსტის ფერი არის წითელი. მეორე ელემენტს - input-ს გააჩნია 2 ატრიბუტი: type (მიუთითებს ელემენტის ტიპს - ღილაკი) და value (განსაზღვრავს ღილაკის ტექსტს).
                    
                    არსებობს გლობალური, ანუ ყველა ელემენტისათვის საერთო ატრიბუტები, როგორიცაა მაგალითად, style, და არის სპეციფიური, რომელიც გამოიყენება მხოლოდ ზოგიერთი ელემენტისათვის, მაგალითად type. ჩვეულებრივი ატრიბუტების გარდა არსებობს ლოგიკური ატრიბუტები, რომელთაც შეიძლება მნიშვნელობა არ მიენიჭოს, მაგალითად disabled:
                    <View style={{color:"red"}}>
                    <input type="button" value="დააჭირეთ" disabled>
                    </View>                    
                    ატრიბუტი disabled მიუთითებს, რომ ელემენტი არააქტიურია.
                    
                    გლობალური ატრიბუტები
                    
                    HTML5-ში არის გლობალური ატრიბუტები, რომლებიც გამოიყენება ყველა ელემენტისათვის:
                    
                    accesskey: განსაზღვრავს სწრაფ კლავიშს ელემენტისთვის
                    
                    class: ელემენტს ანიჭებს CSS-ის კლასს 
                    
                    contenteditable: განსაზღვრავს, რედაქტირებადია თუ არა ელემენტი
                    
                    contextmenu: განსაზღვრავს ელემენტის კონტექსტურ მენიუს,რომელიც გაიხსნება ელემენტზე მაუსის მარჯვენა კლავიშის დაჭერისას
                    
                    dir: განსაზღვრავს ტექსტის მიმართულებას ელემენტში
                    
                    draggable: განსაზღვრავს, შეიძლება თუ არა ელემენტის გადათრევა
                    
                    dropzone: განსაზღვრავს, კოპირდება თუ არა გადასატანი მონაცემები ელემენტზე გადათრევისას
                    
                    hidden: მალავს ელემენტს
                    
                    id: ელემენტის უნიკალური იდენტიფიკატორი. ვებგვერდზე იდენტიფიკატორი არ უნდა მეორდებოდეს
                    
                    lang: განსაზღვრავს ელემენტის ენას
                    
                    spellcheck: განსაზღვრავს, იქნება თუ არა მართლწერის შემოწმება გამოყენებული ელემენტის მიმართ
                    
                    style: განსაზღვრავს ელემენტის სტილს
                    
                    tabindex: განსაზღვრავს თანმიმდევრობას, რომლითაც მოხდება გადართვა ელემენტიდან ელემენტზე TAB კლავიშით
                    
                    title: ელემენტის დამატებითი აღწერა
                    
                    translate: განსაზღვრავს, უნდა ითარგმნოს თუ არა ელემენტის შინაარსი
                    
                    სამომხმარებლო ატრიბუტები
                    
                    წინა ვერსიებისგან განსხვავებით, HTML5-ში დაემატა სამომხმარებლო ატრიბუტები (custom attributes). ახლა უკვე ვებგვერდის შემქმნელს შეუძლია დაამატოს ნებისმიერი პარამეტრი, რომელსაც წინსართად უნდა ჰქონდეს data. მაგალითად:
                    
                    <input type="button" value="დააჭირეთ" data-color="red">
                    
                    აქ ელემენტზე დამატებულია სამომხმარებლო ატრიბუტი data-color, რომელსაც აქვს მნიშვნელობა red .
                    
                    ერთმაგი და ორმაგი ბრჭყალები
                    
                    ატრიბუტების მნიშვნელობის განსაზღვრისას შეიძლება გამოყენებულ იქნეს როგორც ერთმაგი, ისევე ორმაგი ბრჭყალები, თუმცა უფრო ხშირად გამოიყენება ორმაგი ბრჭყალები. ერთმაგი ბრჭყალები ძირითადად გამოიყენება იმ შემთხვევაში, როცა ატრიბუტის მნიშვნელობა თვითონ შეიცავს ბრჭყალებს. მაგალითად:
                    
                    <input type="button" value='ღილაკი "გამარჯობა, მსოფლიო"'>`
                },  {
                    title:"HTML5-ის დოკუმენტის შექმნა",
                    data:`ელემენტები წარმოადგენენ აგურებს, რომლებისგანაც შედგება html5-ის დოკუმენტი. დოკუმენტის შესაქმნელად საჭიროა შევქმნათ ტექსტური ფაილი და გაფართოება შევცვალოთ .html-ზე. შევქმნათ ფაილი და დავარქვათ index.html. შემდეგ გავხსნათ ეს ფაილი ნებისმიერი ტექსტური რედაქტორით და დავამატოთ შემდეგი ტექსტი:

                    <!DOCTYPE html>
                    <html>
                        
                    </html>
                    HTML5-ის დოკუმენტის შესაქმნელად პირველ რიგში საჭიროა 2 ელემენტი: DOCTYPE და html. ელემენტი doctype ანუ Document Type Declaration ამცნობს ბრაუზერს დოკუმენტის ტიპს, ჩვენს შემთხვევაში დოკუმენტის ტიპია html, რაც იმას ნიშნავს, რომ გამოიყენება HTML5 და არა რომელიმე წინა ვერსია. ხოლო html საწყის და საბოლოო ტეგებს შორის მოქცეული იქნება მთელი დოკუმენტი. html ელემენტის შიგნით დავამატოთ ორი ახალი ელემენტი: head და body. ელემენტი head შეიცავს ვებგვერდის მეტამონაცემებს: გვერდის სათაური, კოდირების ტიპი, და ა.შ., ასევე მიმართვებს რესურსებისადმი: სტილები, სკრიპტები, თუ ისინი გამოიყენება ვებ-გვერდზე. ელემენტი body კი შეიცავს ვებგვერდის მთელ შინაარსს.
                    
                    მოდით, შევცვალოთ index.html ფაილის შიგთავსი შემდეგი სახით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>HTML5-ის დოკუმენტი</title>
                        </head>
                        <body>
                            <div>HTML5-ის დოკუმენტის ტექსტი</div>
                        </body>
                    </html>
                    ელემენტში head გვაქვს ორი ელემენტი:
                    
                    ელემენტი title წარმოადგენს ვებგვერდის სათაურს
                    ელემენტი meta წარმოადგენს გვერდის მეტაინფორმაციას. ჩვენს შემთხვევაში ატრიბუტი charset="utf-8" უჩვენებს, რომ გვერდის კოდირება არის utf-8. ქართული ნაწერის კორექტულად გამოსაჩენად უნდა მივუთითოთ ეს კოდირება.
                    ელემენტ body-ის შიგნით გვაქვს მხოლოდ ერთი ელემენტი div, რომელიც განსაზღვრავს ცალკე ბლოკს. შიგნით უბრალო ტექსტია.
                    
                    შევინახოთ ფაილი და გავუშვათ ბრაუზერში:
                    
                    HTML5-ის დოკუმენტი
                    
                    ამგვარად, ჩვენ შევქმენით HTML5-ის დოკუმენტი, რომელსაც სათაურად აქვს "HTML5-ის დოკუმენტი" და ბრაუზერში ჩანართზე სწორედ ეს წარწერაა, ბრაუზერის ძირითად ველში კი ჩანს ის ტექსტი, რომელიც ჩავწერეთ body -ის div ელემენტში.`
                },  {
                    title:"HTML5-ის სინტაქსის სტილები",
                    data:`HTML5-ის დოკუმენტის შექმნისას შეიძლება გამოვიყენოთ ორი განსხვავებული სტილი: HTML და XML.

                    სტილი HTML ითვალისწინებს შემდეგ პრინციპებს:
                    
                    ელემენტს შეიძლება არ ჰქონდეს საწყისი და საბოლოო ტეგები
                    ელემენტს შეიძლება არ ჰქონდეს საბოლოო ტეგი
                    მხოლოდ ცარიელი ტეგები (მაგალითად br,img,link) შეიძლება დაიხუროს სლეშის მეშვეობით />
                    ტეგების და ატრიბუტების რეგისტრს არა აქვს მნიშვნელობა
                    ატრიბუტების მნიშვნელობები შეიძლება არ მოვაქციოთ ბრჭყალებში
                    ზოგიერთ ატრიბუტს შეიძლება არ ჰქონდეს მნიშვნელობა (checked, disabled)
                    სპეციალური სიმბოლოების ეკრანირება არ ხდება
                    დოკუმენტს უნდა ჰქონდეს ელემენტი DOCTYPE
                    ეს არის ე.წ. დაშვებული სტილი, რომელიც გარკვეულწილად ლოიალურია წესების მიმართ დოკუმენტის შექმნისას.
                    
                    HTML5 დოკუმენტი ასევე შეიძლება იყოს აღწერილი XML სინტაქსის მეშვეობით. ასეთ სტილს ასევე უწოდებენ XHTML. ის გამოიყენება, თუ დოკუმენტის თავში content type -ს აქვს მნიშვნელობა application/xml+xhtml. ამ სტილისათვის დამახასიათებელია შემდეგი წესები:
                    
                    ყველა ელემენტს უნდა ჰქონდეს საწყისი ტეგი
                    არაცარიელ ტეგებს ასევე უნდა ჰქონდეთ საბოლოო ტეგი
                    ნებისმიერი ელემენტის დახურვა შესაძლებელია სლეშით />
                    ტეგების და ატრიბუტების სახელები მგრძნობიარეა რეგისტრის მიმართ, როგორც წესი, იწერება დაბალ რეგისტრში
                    ატრიბუტების მნიშვნელობები უნდა იყოს მოქცეული ბრჭყალებში
                    არ დაიშვება ატრიბუტები მნიშვნელობის გარეშე (checked="checked" უბრალოდ checked-ის ნაცვლად)
                    უნდა მოხდეს სპეციალური სიმბოლოების ეკრანირება
                    შევადაროთ ეს ორი სინტაქსის სტილი. HTML5:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset=utf-8>
                        <title>სათაური</title>
                    </head>
                    <body>
                        <p>HTML5-ის დოკუმენტის ტექსტი<br>
                        <input type=button value=დააჭირეთ>
                    </body>
                    </html>
                    იგივე მაგალითი XHTML სტილში:
                    
                    <!doctype html>
                    <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                        <meta charset="utf-8">
                        <title>სათაური</title>
                        </head>
                    <body>
                        <p>HTML5-ის დოკუმენტის ტექსტი<br />
                        <input type="button" value="დააჭირეთ" /></p>
                    </body>
                    </html>
                    XHTML სტილის გამოყენებისას ასევე უნდა მივუთითოთ დოკუმენტის სახელების არე <html xmlns="http://www.w3.org/1999/xhtml">.
                    
                    კონკრეტული სტილის არჩევა პროგრამისტის ან ვებდიზაინერის სურვილზეა დამოკიდებული. ხშირად გამოიყენება შერეული სტილი, როცა წესები აღბულია როგორც ერთი, ასევე მეორე სტილისგან. ამასთან, საჭიროა გავითვალისწინოით, რომ ელემენტისთვის საწყისი და საბოლოო ტეგების არსებობა ამცირებს იმის ალბათობას, რომ ელემენტი არასწორად იქნება ინტერპრეტირებული ბრაუზერის მიერ. ასევე, ატრიბუტის მნიშვნელობების ბრჭყალებში ჩასმით თავს დავიზღვევთ მოსალოდნელი შეცდომებისაგან. მაგალითად, ატრიბუტმა კლასმა შეიძლება ერთდროულად რამდენიმე მნიშვნელობა მიიღოს: <div class="navmenu bigdesctop">. თუ მნიშვნელობას არ ჩავსვამთ ბრჭყალებში, ბრაუზერი class-ის მნიშვნელობად მიიღებს მხოლოდ navmenu-ს, ხოლო bigdesctop-ს ჩათვლის სხვა ატრიბუტად, რის გამოც ელემენტი არასწორად აისახება ბრაუზერში.
                    
                    იმის შესამოწმებლად, თუ რამდენად სწორადაა შედგენილი html დოკუმენტი, შეგვიძლია ვისარგებლოთ ვალიდატორით: https://validator.w3.org.`
                    
                },
            ]
        },
        {
          title:"თავი 2. HTML5-ის ელემენტები",  
          content:[
              {
                  title:"ელემენტი head  და ვებგვერდის მეტამონაცემები",
                  data:`როგორც წესი, html დოკუმენტის ერთ-ერთ უმნიშვნელოვანეს ელემენტს წარმოადგენს head, რომლის დანიშნულებაც მდგომარეობს ვებ-გვერდის მეტამონაცემების და თანმდევი ინფორმაციის განსაზღვრაში. მეტამონაცემები შეიცავენ ინფორმაციას ვებ-გვერდის შესახებ.

                  სათაური
                  
                  სათაურის მისათითებლად გამოიყენება ელემენტი title:
                  
                  <title>ვებ-გვერდის სათაური</title>
                  
                  ელემენტი base
                  
                  ელემენტი base განსაზღვრავს ვებ-გვერდის საბაზისო მისამართს, რომლის მიმართაც განისაზღვრება გვერდზე გამოყენებული სხვა მისამართები:
                  
                  <!doctype html>
                  <head>
                      <base href="content/">
                      <meta charset="utf-8">
                      <title>ვებ-გვერდის სათაური</title>
                  </head>
                  <body>
                      <a href="newpage.html">ახალ გვერდზე გადასვლა</a>
                  </body>
                  </html>
                  მიუხედავად იმისა, რომ ბმულს "ახალ გვერდზე გადასვლა" მისამართში უწერია "newpage.html", ფაქტიური მისამართი იქნება "content/newpage.html". ანუ ვებ-გვერდის საქაღალდეში უნდა იყოს ქვესაქაღალდე content და მასში ფაილი newpage.html.
                  
                  შეიძლება base ელემენტში მივუთითოთ სრული მისამართიც:
                  
                  <base href="http://microsoft.com/">
                  
                  ამ შემთხვევაში ბმული გადაგვიყვანს მისამართზე "http://microsoft.com/newpage.html".
                  ელემენტი meta
                  ელემენტი meta განსაზღვრავს ვებგვერდის მეტამონაცემებს.
                  
                  იმისათვის, რომ უნიკოდის ტექსტის შემცველი გვერდები კორექტულად გამოჩნდეს ბრაუზერში, აუცილებელია მივუთითოთ კოდირება utf-8:
                  
                  <meta charset="utf-8">
                  
                  ამასთან, თვითონ დოკუმენტის კოდირებაც უნდა ემთხვეოდეს meta კოდირებას.
                  ელემენტს meta ასევე აქვს 2 ატრიბუტი: name და content. name არის ატრიბუტის სახელი, content - ატრიბუტის მნიშვნელობა.
                  
                  HTML დოკუმენტში არის 5 ტიპის მეტამონაცემები:
                  
                  application name: ვებ-აპლიკაციის სახელი, რომლის ნაწილიცაა ეს დოკუმენტი
                  
                  author: დოკუმენტის ავტორი
                  
                  description: დოკუმენტის მოკლე აღწერა
                  
                  generator: პროგრამის სახელი, რომელშიც დაგენერირდა დოკუმენტი
                  
                  keywords: საკვანძო სიტყვები (გამოიყენება საძიებო სისტემების მიერ ძებნისთვის)
                  
                  უნდა აღინიშნოს, რომ მეტად მნიშვნელოვანი ატრიბუტია description. მის მნიშვნელობას საძიებო სისტემები ხშირად იყენებენ, როგორც ანოტაციას ვებგვერდისთვის.
                  
                  დავამატოთ დოკუმენტში რამდენიმე meta ელემენტი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <base href="content/">
                          <title>ვებგვერდის სათაური</title>
                          <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                          <meta name="author" content="ავტორი">
                      </head>
                      <body>
                          <a href="newpage.html">HTML5 დოკუმენტის შინაარსი</a>
                      </body>
                  </html>`
              },
              {
                title:"დაჯგუფების ელემენტები",
                data:`HTML-ში არის რიგი ელემენტებისა, რომლებიც განკუთვნილია ვებგვერდის შიგთავსის (content) დასაჯგუფებლად.

                ელემენტი div
                
                ელემენტი div გამოიყენება ვებგვერდის შიგთავსის სტრუქტურულად დაჯგუფებისთვის, ცალ-ცალკე ბლოკებში მოსაქცევად. div ქმნის ბლოკს, რომელიც ბრაუზერის მთელ სიგანეზე ვრცელდება (თუ სხვა რამეს არ მივუთითებთ). div-ის მომდევნო ელემენტი გადადის ახალ სტრიქონზე. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <div>დოკუმენტის სათაური</div>
                        <div>დოკუმენტის ტექსტი</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                პარაგრაფები
                
                პარაგრაფები იქმნება <p> და </p> ტეგების მეშვეობით. თითოეული პარაგრაფი იწყება ახალი სტრიქონიდან.მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <div>დოკუმენტის სათაური</div>
                        <div>
                            <p>პირველი პარაგრაფი</p>
                            <p>მეორე პარაგრაფი</p>
                        </div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                თუ ერთი პარაგრაფის ფარგლებში გვინდა სტრიქონის გადატანა, უნდა გამოვიყენოთ ელემენტი <br>:
                <p>პირველი სტრიქონი.<br />მეორე სტრიქონი.</p>
                
                ელემენტი pre
                ელემენტ pre-ს გამოაქვს წინასწარ დაფორმატებული ტექსტი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <pre>
                            პირველი სტრიქონი
                            მეორე სტრიქონი
                            მესამე სტრიქონი
                        </pre>
                    </body>
                </html>
                 
                HTML5-ის დოკუმენტი
                
                ელემენტი span
                ელემენტი span-თ ხდება გარკვეული ტექსტის შემოგარსვა მთელ სიგრძეზე და მის სტილიზაციას ემსახურება. განსხვავებით div ელემენტისაგან და პარაგრაფისგან, span-ს არ გადააქვს ტექსტი ახალ სტრიქონზე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5-ის დოკუმენტი</title>
                    </head>
                    <body>
                        <div>HTML5-ის დოკუმენტის სათაური</div>
                        <div>
                            <p><span style="color:red;">პირველი</span> პარაგრაფი</p>
                            <p><span>მეორე</span> პარაგრაფი</p>
                        </div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                აღსანიშნავია, რომ თვითონ span არაფერს არ აკეთებს, მეორე პარაგრაფში იგი არ ცვლის ტექსტს არანაირად. პირველ პარაგრაფში span-ს გააჩნია ატრიბუტი style="color:red;", რომელიც ცვლის ტექსტის სტილს (ცვლის ფერს).
                თუ div და p არის ბლოკის ტიპის ელემენტები და ისინი შეიძლება შეიცავდნენ ნებისმიერ ელემენტებს, span არის სტრიქონული ტიპის. ამასთან არაა რეკომენდირებული span-ის შიგნით მოვაქციოთ ბლოკური ელემენტები.`
            },
            {
                title:"სათაურები",
                data:`ელემენტები <h1>, <h2>, <h3>, <h4>, <h5> и <h6> ემსახურება სხვადასხვა დონის სათაურების შექმნას:

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>HTML5 -ის სათაურები</title>
                </head>
                <body>
                    <h1>პირველი დონის სათაური</h1>
                    <h2>მეორე დონის სათაური</h2>
                    <h3>მესამე დონის სათაური</h3>
                    <h4>მეოთხე დონის სათაური</h4>
                    <h5>მეხუთე დონის სათაური</h5>
                    <h6>მეექვსე დონის სათაური</h6>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სათაურებს გააჩნია გამუქებული შრიფტი და შრიფტის ზომა ყველაზე დიდი <h1> -დან ყველაზე პატარა <h6>-მდე.
                
                სათაურების დამატებისას უნდა გავითვალისწინოთ, რომ ვებგვერდს უნდა ჰქონდეს მხოლოდ ერთი პირველი დონის სათაური <h1>. ის ასრულებს ვებგვერდის ძირითადი სათაურის როლს.`
            },
            {
                title:"ტექსტის ფორმატირება",
                data:`html-ის მთელი რიგი ელემენტები განკუთვნილია ტექსტის ფორმატირებისთვის, მაგალითად გასამუქებლად, ხაზგასასმელად და ა. შ. განვიხილოთ ეს ელემენტები:

                <b>: ტექსტის გამუქება
                <del>: ტექსტის გადახაზვა 
                <i>: ტექსტის დახრა
                <em>: ტექსტის დახრა, ოღონდ <i>-საგან განსხვავებით, ატარებს ლოგიკურ ხასიათს და ხაზს უსვამს მის მნიშვნელობას
                <s>: ტექსტის გადახაზვა
                <small> ტექსტის დაპატარავება
                <strong> ტექსტის გამუქება, ოღონდ <b>-საგან განსხვავებით, ატარებს ლოგიკურ ხასიათს და ხაზს უსვამს მის მნიშვნელობას 
                <sub>: ტექსტის ჩამოწევა სტრიქონის ქვემოთ
                <sup>: ტექსტის აწევა სტრიქონის ზევით
                <u>: ტექსტის ხაზგასმა
                <ins>: ჩასმული (დამატებული) ტექსტი
                <mark>: ტექსტის გამოყოფა ფერით. ხაზს უსვამს მის მნიშვნელობას
                გამოვიყენოთ ეს ელემენტები:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ტექსტის ფორმატირება HTML5-ში</title>
                    </head>
                    <body>
                        <p>ფორმატირება <mark>HTML5</mark>-ში</p>
                        <p>ეს <b>გამუქებული</b> ტექსტია</p>
                        <p>ეს <strong>მნიშვნელოვანი</strong> ტექსტია</p>
                        <p>ეს <del>გადახაზული</del> ტექსტია</p>
                        <p>ეს <s>გაუქმებული</s> ტექსტია</p>
                        <p>ეს <em>მნიშვნელოვანი</em> ტექსტია</p>
                        <p>ეს ტექსტი <i>დახრილია</i> </p>
                        <p>ეს <ins>დამატებული</ins> ტექსტია</p>
                        <p>ეს <u>ხაზგასმული</u> ტექსტია</p>
                        <p>X<sub>i</sub> = Y<sup><small>2</small></sup> + Z<sup><small>2</small></sup></p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი`
            },
            {
                title:"სურათებთან მუშაობა",
                data:`სურათების გამოსატანად HTML-ში გამოიყენება ელემენტი <img>, რომელსაც გააჩნია ორი მნიშვნელოვანი ატრიბუტი: 

                src: სურათის მისამართი. ეს შეიძლება იყოს ფარდობითი ან აბსოლუტური მისამართი ფაილურ სისტემაში ან მისამართი ინტერნეტში
                alt: სურათის ტექსტური აღწერა. თუ რაღაც მიზეზით ვერ ხერხდება სურათის გამოტანა ეკრანზე, მის ნაცვლად გამოჩნდება alt ატრიბუტში მითითებული მნიშვნელობა
                alt-ს კიდევ ერთი დანიშნულება აქვს. საძიებო სისტემებში სურათის ინდექსირება ხდება სწორედ მისი მნიშვნელობით.
                
                იგივე საქაღალდეში, სადაც index.html-ია დავდოთ რამე სურათი და გამოვიტანოთ ის ვებგვერდზე:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <img src="kanioni.jpg" alt="martvilis kanioni">
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სტილებისა და ფორმატირების ელემენტების გამოყენებით შესაძლებელია სურათისა და ტექსტის კომბინირება. მაგალითად:
                
                 
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <div>
                        <img src="kanioni.jpg" alt="მარტვილის კანიონი" style="float:left; margin-right:10px;" />
                        <h1>Lorem Ipsum</h1>
                        <b>Lorem Ipsum</b> is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry....
                    </div>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სურათისთვის მნიშვნელოვანი ატრიბუტებია ასევე ზომები width და height. მათი მითითების გარეშე სურათი იღებს ორიგინალურ ზომებს, ხოლო მითითების შემთხვევაში - მითითებულს. შესაძლებელია მივუთითოთ მხოლოდ ერთ-ერთი (სიგანე ან სიმაღლე), მეორე პროპორციულად მიენიჭება ავტომატურად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <img src="kanioni.jpg" alt="martvilis kanioni" width="250px" height="165">
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი`
            },
            {
                title:"სიები",
                data:`სიების შესაქმნელად HTML5-ში გამოიყენება ელემენტები <ol> (დანომრილი სია) და <ul> (უნომრო სია):

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სიები HTML5-ში</title>
                </head>
                <body>
                    <h2>დანომრილი სია</h2>
                    <ol>
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ol>
                    <h2>უნომრო სია</h2>
                    <ul>
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თუ სპეციალურად არ მივუთითებთ, დანომრილ სიაში ნუმერაცია ხორციელდება ნატურალური რიცხვებით 1-დან, სოლო უნომრო სიაში - შავი მუქი წერტილით. საჭიროების შემთხვევაში ჩვენ შეგვიძლია შევცვალოთ ნუმერაცია სტილის list-style-type მეშვეობით. ჩამოვთვალოთ ძირითადი და ხშირად გამოყენებული სტილები:
                
                დანომრილი სიებისთვის:
                
                decimal: რიცხვები, ათვლა იწყება 1-დან
                decimal-leading-zero: რიცხვები, რომელთაც წინ უძღვის 0, მაგალითად 01,02,03,...98,99
                lower-roman: დაბალი რეგისტრის რომაული რიცხვები, მაგალითად, i, ii, iii, iv, v
                upper-roman: მაღალი რეგისტრის რომაული რიცხვები, მაგალითად, I, II, III, IV, V…
                lower-alpha: დაბალი რეგისტრის ლათინური ასოები,მაგალითად, a, b, c..., z
                upper-alpha: მაღალი რეგისტრის ლათინური ასოები,მაგალითად, A, B, C, … Z
                georgian: ქართული ანბანის ასოები, ა,ბ,გ,დ,...ჰ
                დანომრილ სიებს start ატრიბუტის მეშვეობით შეიძლება მივუთითოთ, თუ საიდან დაიწყება ნუმერაცია. მაგალითად:
                
                <h2>list-style-type = decimal</h2>
                    <ol style="list-style-type:decimal;" start="3">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ol>
                    <h2>list-style-type = upper-roman</h2>
                    <ol style="list-style-type:upper-roman;" start="10">
                        <li>iPhone 6S Plus</li>
                        <li>Galaxy S7 Edge</li>
                        <li>Nexus 6P</li>
                        <li>Lumia 950 XL</li>
                    </ol>
                    <h2>list-style-type = lower-alpha</h2>
                    <ol style="list-style-type:lower-alpha;">
                        <li>LG G 5</li>
                        <li>Huawei P8</li>
                        <li>Asus ZenFone 2</li>
                    </ol>
                    <h2>list-style-type = georgian</h2>
                    <ol style="list-style-type:georgian;">
                        <li>ერთი</li>
                        <li>ორი</li>
                        <li>სამი</li>
                        <li>ოთხი</li>
                        <li>ხუთი</li>
                    </ol>
                 
                
                HTML5-ის დოკუმენტი
                
                უნომრო სიებისთვის list-style-type-მა შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                
                disk: შავი წრე
                circle: ცარიელი წრე
                square: შავი კვადრატი
                მაგალითად:
                
                    <h2>list-style-type = disk</h2>
                    <ul style="list-style-type:disk;">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                    <h2>list-style-type = circle</h2>
                    <ul style="list-style-type:circle;">
                        <li>iPhone 6S Plus</li>
                        <li>Galaxy S7 Edge</li>
                        <li>Nexus 6P</li>
                        <li>Lumia 950 XL</li>
                    </ul>
                    <h2>list-style-type = square</h2>
                    <ul style="list-style-type:square;">
                        <li>LG G 5</li>
                        <li>Huawei P8</li>
                        <li>Asus ZenFone 2</li>
                    </ul>
                 
                
              
                
                კიდევ ერთ საინტერესო შესაძლებლობას სიებისთვის გვაძლევს სტილი list-style-image. მისი მეშვეობით შესაძლებელია სიის გვერდით გამოვიტანოთ სურათი. მაგალითად:
                
                <ul style="list-style-image:url(phone.jpeg);">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                 
                
                
                ჰორიზონტალური სია
                
                ჰორიზონტალური სიის მისაღებად სიის ყველა ელემენტისთვის უნდა დავაყენოთ სტილი display:inline:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სიები HTML5-ში</title>
                    <style>
                        ul#menu li {
                            display:inline;
                        }
                    </style>
                </head>
                <body>
                    <ul id="menu">
                        <li>|მთავარი|</li>
                        <li>|ბლოგი|</li>
                        <li>|ფორუმი|</li>
                        <li>|საიტის შესახებ|</li>
                    </ul>
                </body>
                </body
                </html>`
            },
            {
                title:"ელემენტი details",
                data:`ელემენტი details საშუალებას იძლევა შეიქმნას ჩამოშლადი ბლოკი, რომელიც თავდაპირველად დამალულია. ის შეიცავს ელემენტს summary, რომელიც ყოველთვის ჩანს, როგორც სათაური, ხოლო დანარჩენი ნაწილი გამოჩნდება ისარზე ან სათაურზე დაჭერის შემთხვევაში. მაგალითად:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტი details HTML5-ში</title>
                    </head>
                    <body>
                        <details>
                            <summary>2015 წლის ფლაგმანები</summary>
                            <ul>
                                <li>iPhone 6S Plus</li>
                                <li>Nexus 6P</li>
                                <li>Galaxy S6 Edge</li>
                                <li>Lumia 950 XL</li>
                            </ul>
                        </details>
                    </body>
                </html>
                 
                
                
                სათურზე ან ისარზე დაჭერისას გაიშლება დამალული ნაწილი:
                
                
                უნდა გავითვალისწინოთ, რომ ამ დროისთვის ამ ელემენტის მხარდაჭერა ყველა ბრაუზერს არა აქვს.`
            },
            {
                title:"განმარტებების სია",
                data:`განმარტებების სია (definition list) არის ისეთი სია, რომელიც შეიცავს ტერმინს და მის განმარტებას. ასეთი წყვილი - ტერმინი-განმარტება სიაში შეიძლება იყოს ბევრი. განმარტებების სიის შესაქმნელად გამოიყენება ტეგი <dl></dl>. ამ ტეგების შიგნით თავსდება სიის ელემენტები. თითოეული ელემენტი შედგება ტერმინისგან <dt></dt> (dt - "definition term") და განმარტებისგან <dd></dd>(dd- "definition description"). მაგალითად:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>განმარტებების სია HTML5-ში</title>
                    </head>
                    <body>
                        <dl>
                            <dt>რასობრივი დისკრიმინაცია</dt>
                            <dd>დანაშაული, რომელსაც პირი სჩადის ეროვნული ან რასობრივი მტრობის ან განხეთქილების
                                    ჩამოგდების, ეროვნული პატივისა და ღირსების დამცირების მიზნით.</dd>
                            <dt>რეაბილიტაცია</dt>
                            <dd>უკანონოდ ან დაუსაბუთებლად მსჯავრდებული ან ბრალდებული პირისათვის უფლებების
                                    აღდგენა, როდესაც დადგინდება მისი უდანაშაულობა გამამართლებელი განაჩენით, ან მის
                                    მიმართ გამოტანილი იქნება დადგენილება (განჩინება) სისხლისსამართლებრივი დევნის
                                    შეწყვეტის თაობაზე.</dd>
                            <dt>რესტიტუცია</dt>
                            <dd>პირვანდელი მდგომარეობის აღდგენა. სახელშეკრულებო ურთიერთობებში რესტიტუცია ხდება
                                    ხელშეკრულებიდან მხარეთა გასვლისას იმ დროს, რათა ისინი ამ ხელშეკრულების დადებამდე
                                    არსებულ ვითარებას დაუბრუნდნენ.</dd>
                        </dl>
                    </body>
                </html>
                 
                
                `
            },
            {
                title:"ცხრილები",
                data:`ცხრილების შესაქმნელად გამოიყენება ელემენტი table. თითოეული ცხრილი <table> და </table> ტეგებს შორის შეიცავს სტრიქონებს tr ელემენტის სახით, რომელიც თავის მხრივ შეიცავს უჯრებს td ელემენტის სახით.

                შევქმნათ მარტივი ცხრილი:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                </head>
                <body>
                    <table>
                        <tr>
                            <td>მოდელი</td>
                            <td>კომპანია</td>
                            <td>ფასი</td>
                        </tr>
                        <tr>
                            <td>Nexus 6P</td>
                            <td>Huawei</td>
                            <td>700</td>
                        </tr>
                        <tr>
                            <td>iPhone 6S PLus</td>
                            <td>Apple</td>
                            <td>650</td>
                        </tr>
                        <tr>
                            <td>Lumia 950 XL</td>
                            <td>Microsoft</td>
                            <td>450</td>
                        </tr>
                    </table>
                </body>
                </html>
                 
                
                
                ცხრილი შედგება სამი სვეტისგან და ოთხი სტრიქონიდან. პირველი სტრიქონი ასრულებს სათაურის მოვალეობას. თუმცა html5-ში გათვალისწინებულია ელემენტები, რომელთა საშუალებითაც შესაძლებელია ცხრილის სათაურის, სვეტების სათაურის, ცხრილის ტანისა და ქვედა ნაწილის გამოყოფა. ამისთვის გათვალისწინებულია ელემენტები: caption, thead,tbody,tfoot. შევცვალოთ ცხრილი შემდეგნაირად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                </head>
                <body>
                    <table>
                        <caption><b>2015 წლის პოპულარული სმარტფონები</b></caption>
                        <thead>
                        <tr>
                            <th>მოდელი</th>
                            <th>კომპანია</th>
                            <th>ფასი</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Nexus 6P</td>
                            <td>Huawei</td>
                            <td>700</td>
                        </tr>
                        <tr>
                            <td>iPhone 6S PLus</td>
                            <td>Apple</td>
                            <td>650</td>
                        </tr>
                        <tr>
                            <td>Lumia 950 XL</td>
                            <td>Microsoft</td>
                            <td>450</td>
                        </tr>
                        </tbody>
                        <tfoot>
                            <tr>
                                <th colspan="3">* 12 სექტემბრის მდგომარეობით</th>
                            </tr>
                        </tfoot>
                    </table>
                </body>
                </html>
                 
                
              
                
                სათურის სტრიქონი მოქცეულია thead ელემენტის შიგნით. სათაურის უჯრებისთვის გამოიყენება არა td, არამედ th. იგი სათურის ტექსტს ამუქებს. ცხრილის ქვედა ნაწილი - ფუტერი შეიცავს მხოლოდ ერთ უჯრას. სტრიქონის რამდენიმე უჯრის გასაერთიანებლად გამოიყენება ატრიბუტი colspan. მისი მნიშვნელობა "3" მიუთითებს, რომ გაერთიანებულია 3 უჯრა. ანალოგიურად, სვეტში რამდენიმე უჯრის გასაერთიანებლად გამოიყენება ატრიბუტი rowspan. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                    <style>
                        td {
                            width: 60px;
                            height: 60px;
                            border: solid 1px silver;
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                    <table>
                        <tr>
                            <td rowspan="2" style="background-color:green;">1</td>
                            <td>2</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td colspan="2" style="background-color:red;">7</td>
                        </tr>
                    </table>
                </body>
                </html>`
            },
            {
                title:"ბმულები",
                data:`ბმულები, რომლებიც წარმოდგენილია <a></a> ელემენტის სახით ასრულებენ მნიშვნელოვან როლს: ისინი უზრუნველყოფენ ნავიგაციას ცალკეულ დოკუმენტებს შორის. ამ ელემენტს გააჩნია შემდეგი ატრიბუტები:

                href: განსაზღვრავს ბმულის მისამართს
                hreflang: მიუტითებს დოკუმენტის ენას, სადაც გადავყავართ ბმულს
                media: განსაზღვრავს მოწყობილობას, რომლისთვისაცაა განკუთვნილი ბმული
                rel: განსაზღვრავს დამოკიდებულებას მიმდინარე დოკუმენტსა და იმ რესურსს შორის, სადაც გადავყავართ ბმულს
                target: განსაზღვრავს ბმულის გახსნის ადგილს
                type: განსაზღვრავს რესურსის mime-type-ს, სადაც გადავყავართ ბმულს
                ყველაზე მნიშვნელოვანი ატრიბუტია href:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბმულები</title>
                    </head>
                    <body>
                        <a href="content.html">HTML5-ის სახელმძღვანელო</a>
                    </body>
                </html>
                 
                
                
                აქ გამოყენებულია ფარდობითი მისამართი content.html, ანუ index.html-თან იგივე საქაღალდეში უნდა იყოს ფაილი content.html. ასევე შესაძლებელია ინტერნეტის სრული მისამართის გამოყენებაც.
                
                ნავიგაცია დოკუმენტის შიგნით
                
                ბმულების მეშვეობით შესაძლებელია ნავიგაცია ერთი დოკუმენტის შიგნით ბლოკებს შორის. ამისათვის მისამართად გამოიყენება დიეზი (#), რომელსაც მოსდევს იმ ელემენტის id, სადაც უნდა გადავყავდეთ ბმულს. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>შიდა ბმულები</title>
                    </head>
                    <body>
                        <a href="#paragraph1">პარაგრაფი 1</a> | <a href="#paragraph2">პარაგრაფი 2</a> | <a href="#paragraph3">პარაგრაფი 3</a>
                        <h2 id="paragraph1">პარაგრაფი 1</h2>
                        <p>პარაგრაფი 1-ის შინაარსი</p>
                        <h2 id="paragraph2">პარაგრაფი 2</h2>
                        <p>პარაგრაფი 2-ის შინაარსი</p>
                        <h2 id="paragraph3">პარაგრაფი 3</h2>
                        <p>პარაგრაფი 3-ის შინაარსი</p>
                    </body>
                </html
                 
                
                
                ატრიბუტი target
                
                მითითების გარეშე ბმული იხსნება იმავე ფანჯარაში, რომელშიც იმყოფება მიმდინარე დოკუმენტი. target ატრიბუტის მეშვეობით შესაძლებელია შევცვალოთ ეს ადგილი. იგი ღებულობს შემდეგ მნიშვნელობებს:
                
                _blank: დოკუმენტის გახსნა ბრაუზერის ახალ ფანჯარაში ან ჩანართში
                _self: დოკუმენტის გახსნა იგივე ფრეიმში ან ფანჯარაში
                _parent: დოკუმენტის გახსნა მშობელ ფრეიმში ან ფანჯარაში, თუ ბმული მოთავსებულია შიდა ფრეიმში
                _top: დოკუმენტის გახსნა ბრაუზერის მთელ ფანჯარაში
                framename: დოკუმენტის გახსნა ფრეიმში სახელად framename (ფრეიმის სახელი შეიძლება ნებისმიერი იყოს)
                მაგალითად, ბმულის გასახსნელად ახალ ფანჯარაში უნდა დავწეროთ:
                
                <a href="http://progbook.terasoft.ge/" target="_blank">HTML5-ის სახელმძღვანელო</a>
                
                ბმულების სტილიზაცია
                
                მითითბის გარეშე ბმულს გააჩნია ლურჯი ფერი და ხაზგასმულია. მაუსის დაჭერისას ბმული ხდება აქტიური და ფერი ხდება წითელი. დაჭერისა და ბმულის მისამართზე გადასვლის შემდეგ ბმული იცვლის ფერს, როგორც წესი, ხდება იისფერი. ასეთ სტილიზაციას ბმულს აძლევს ბრაუზერი, მაგრამ სურვილის შემთხვევაში შესაძლებელია შევცვალოთ სტილების მეშვეობით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბმულები</title>
                        <style>
                            a:link    {color:blue; text-decoration:none}
                            a:visited {color:green; text-decoration:none}
                            a:hover   {color:red; text-decoration:underline}
                            a:active  {color:yellow; text-decoration:underline}
                        </style>
                    </head>
                    <body>
                        <a href="index.html">HTML5-ის სახელმძღვანელო</a>
                    </body>
                </html>
                აქ განსაზღვრულია ბმულის სტილი სხვადასხვა მდგომარეობაში: 
                
                a:link ბმული ჩვეულებრივ მდგომარეობაში, როცა მაუსი არაა დაჭერილი ან მიმართული ბმულისკენ
                a:visited ბმული, რომელზეც უკვე იყო განხორციელებული გადასვლა
                a:hover ბმულის მდგომარეობა, როცა მაუსი მიმართულია მისკენ
                a:active ბმული მაუსის დაჭერის მომენტში
                სტილი color განსაზღვრავს ფერს, ხოლო text-decoration ხაზგასმას: none - ხაზგასმის გარეშე, underline - ხაზგასმული
                
                სურათი ბმული
                
                თუ მოვათავსებთ <a> ელემენტის შიგნით ელემენტს <img>, მივიღებთ სურათს ბმულით:
                
                    <a href="index.html">
                       <img src="cover.png" alt="HTML tutorial">
                    </a>`
            },
            {
                title:"ელემენტები figure და figcaption",
                data:`ელემენტი figure გამოიყენება ილუსტრაციების, დიაგრამების, სურათების ანოტაციისთვის. ხოლო figcaption შეიცავს სათაურს figure ელემენტის შიგთავსისთვის. 

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტი Figure HTML5-ში</title>
                    </head>
                    <body>
                        <div>
                            <p>Lorem ipsum dolor … </p>
                            <figure>
                                <figcaption>მარტვილის კანიონი</figcaption>
                                <img src="kanioni.jpg" alt="მარტვილის კანიონი">
                            </figure>
                            <p>Lorem ipsum dolor … </p>
                        </div>   
                    </body>
                </html
                 
                
                `
            },
            {
                title:"ფრეიმები",
                data:`ფრეიმები საშუალებას გვაძლევს ვებგვერდში ჩავაშენოთ სხვა ვებგვერდი. ამისთვის გამოიყენება ელემენტი iframe.

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფრეიმი HTML5-ში</title>
                    </head>
                    <body>
                        <h2>ელემენტი iframe</h2>
                        <iframe src="http://wikipedia.com" width="500" height="300">
                        </iframe>
                    </body>
                </html>
                 
                
                
                ელემენტ iframe გააჩნია შემდეგი ატრიბუტები:
                
                src: ჩასატვირთი ვებგვერდის სრული მისამართი
                width: სიგანე
                height: სიმაღლე
                უნდა აღინიშნოს, რომ ფრეიმებში ყველა საიტის ჩატვირთვა არ შეიძლება, რადგან ზოგიერთი ვებსერვერი კრძალავს საიტების ჩატვირთვას ფრეიმებში.`
            },
          ]
        },
        {
            title:"თავი 3. ფორმებთან მუშაობა",
            content:[
                {
                    title:"ფორმები",
                    data:`ფორმა წარმოადგენს მონაცემთა შეყვანისა და გაგზავნის ერთ-ერთ საშუალებას. ფორმის ყველა ველი თავსდება <form> და </form> ტეგებს შორის. შევქმნათ უმარტივესი ფორმა:

                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფორმები HTML5-ში</title>
                    </head>
                    <body>
                        <form  method="post" action="http://localhost:8080/login.php">
                            <input name="login"/>
                            <input type="submit" value="შესვლა"/>
                        </form>
                    </body>
                    </html>
                     
                    
                     
                    
                    
                    ფორმას შეიძლება განესაზღვროს შემდეგი ატრიბურები:
                    
                    method: მონაცემების სერვერზე გაგზავნის მეთოდი post და get
                    action: ვებსერვერის მისამართი
                    enctype: გადასაცემი ინფორმაციის ტიპი:
                    application/x-www-form-urlencoded: მონაცემების გადაცემის კოდირება იმ შემთხვევაში, თუ არ მივუთითებთ
                    multipart/form-data: კოდირება ფაილების გასაგზავნად
                    text/plain: უბრალო ტექსტი
                    ზემოთ მოყვანილ მაგალითში ფორმას გააჩნია post მეთოდი, ვებსერვისის მისამართია http://localhost:8080/login.php.
                    
                    როგორც წესი, მითითებულ მისამართზე მუშაობს ვებსერვისი, რომელიც იყენებს რომელიმე სერვისის ტექნოლოგიას(PHP, NodeJS, ASP.NET და სხვა). ახლა ჩვენ არ გავამახვილებთ ყურადღებას სერვერის ტექნოლოგიებზე, არამედ განვიხილავთ მონაცემების გაგზავნის მეთოდებს.
                    
                    ავტოშევსება
                    
                    ხშირად ბრაუზერები იმახსოვრებენ შეყვანილ მონაცემებს და მორიგი შესვლისას ჩნდება ჩამოსაშლელი დამახსოვრებული მონაცემებით:
                    
                    
                    საჭიროების შემთხვევაში შესაძლებელია ავტოშევსების გამორთვა, ამისთვის გამოიყენება ატრიბუტი autocomplete. ღებულობს მნიშვნელობებს on (ავტოშევსება ჩართულია) და off (ავტოშევსება გამორთულია). ეს ატრიბუტი შეიძლება მიეთიტოს როგორც ფორმას, ასევე მის ცალკეულ ელემენტს. ფორმაზე მითითებული ატრიბუტი ვრცელდება ყველა მის ელემენტზე, თუ თვითონ ელემენტს არა აქვს მითითებული იგივე ატრიბუტი განსხვავებული მნიშვნელობით. მაგალითად:
                    
                     
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფორმები HTML5-ში</title>
                    </head>
                    <body>
                        <form  method="post" autocomplete="off" action="http://localhost:8080/login.php">
                            <input name="login"  autocomplete="on" />
                            <input name="password" />
                            <input type="submit" value="შესვლა"/>
                        </form>
                    </body>
                    </html>
                     
                    
                    მოცემულ მაგალითში ავტოშევსება გამორთულია ყველა ელემენტზე, გარდა პირველისა, რადგან პურველ ელემენტს თვითონ აქვს მითითებული on.
                    
                     `
                },
                {
                  title:"ფორმის ელემენტები",
                  data:`ფორმა შედგება ერთი ან რამდენიმე მონაცემთა შეყვანის ელემენტისგან. შეყვანის ყველაზე გავრცელებულ ელემენტს წარმოადგენს ელემენტი input. ელემენტის რეალურ სახეს განსაზღვრავს ატრიბუტი type. ის ღებულობს შემდეგ მნიშვნელობებს:

                  text: ჩვეულებრივი ტექსტური ველი
                  password: ასევე ტექსტური ველი, ოღონდ შეყვანილი სიმბოლოების ადგილას გამოჩნდება ვარსკვლავი. ეს ველი ძირითადად გამოიყენება პაროლების შესაყვანად
                  radio: რადიოღილაკი ანუ გადამრთველი. რადიოღილაკების ჯგუფიდან შეიძლება მხოლოდ ერთის არჩევა
                  checkbox: ჩამრთველი ელემენტი (ალამი), რომელიც შეიძლება იყოს ჩართულ ან გამორთულ მდგომარეობაში
                  hidden: დამალული ველი
                  submit: ფორმის მონაცემების გაგზავნის ღილაკი
                  color: ფერის შესაყვანი ველი
                  date: თარიღის შესაყვანი ველი
                  datetime: თარიღის და დროის შესაყვანი ველი
                  datetime-local: სასაათო სარტყლის გაუთვალისწინებლად თარიღის და დროის შესაყვანი ველი
                  email: ელექტრონული მისამართის შესაყვანი ველი
                  month: თვისა და წლის შესაყვანი ველი
                  number: რიცხვების შესაყვანი ველი
                  range: გარკვეული დიაპაზონიდან რიცხვების ასარჩევი მცოცავი ველი
                  tel: ტელეფონის ნომრის შესაყვანი ველი
                  time: დროის შესაყვანი ველი
                  week: წლისა და კვირის შესაყვანი ველი
                  url: url მისამართის შესაყვანი ველი
                  file: გასაგზავნი ფაილის ასარჩევი ველი
                  image: ქმნის ღილაკს სურათის ფორმით
                  ელემენტი input-ის გარდა არის კიდევ რამდენიმე ელემენტი, რომლებიც გამოიყენება ფორმებთან მუშაობისას:
                  
                  button: ქმნის ღილაკს
                  select: ჩამოსაშლელი სია
                  label: ქმნის წარწერას, რომელიც გამოისახება შეყვანის ველის გვერდით
                  textarea: მრავალსტრიქონიანი ტექსტური ველი
                  ატრიბუტები name და value
                  
                  შეყვანის ყველა ელემენტს გააჩნია ატრიბუტები name და value. name ატრიბუტის მიხედვით შესაძლებელია ელემენტის იდენტიფიცირება, ხოლო value ანიჭებს ელემენტს მნიშვნელობას. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form method="get" action="index.html">
                          <input type="text" name="login" value="Tom"/>
                          <input type="password" name="password"/>
                          <input type="submit" value="შესვლა" />
                      </form>
                  </body>
                  </html>
                  </html>
                   
                  
                  
                  შესვლის ღილაკზე დაჭერისას შეიცვლება მისამართის ზოლი:
                  
                  
                  index.html-ის მერე მისამართს დაემატა კითხვის ნიშანი და login=Tom&password=qwerty. ასეთი სახით ხდება ფორმის მონაცემების გაგზავნა სერვერზე, წყვილების "გასაღები"="მნიშვნელობა" სახით, რომლებიც ერთმანეთთან & სიმბოლოთია გადაბმული. ამ მონაცემების მიღების შემდეგ სერვერი ღებულობს ფორმაში შეყვანილ მონაცემებს და აბრუნებს შესაბამის პასუხს.`
              },
              {
                  title:"ღილაკები",
                  data:`ღილაკები წარმოდგენილია ელემენტით button. მას გააჩნია კონფიგურაციის ბევრი შესაძლებლობა. ატრიბუტი type მიხედვით შეგვიძლია შევქმნათ ღილაკის შემდეგი ტიპები:

                  submit: ღილაკი ფორმის მონაცემების გაგზავნისთვის
                  reset: ღილაკი ფორმის მნიშვნელობების გასუფთავებისთვის
                  button: ღილაკი რამე სპეციალური დანიშნულების გარეშე
                  თუ ღილაკი განკუთვნილია მონაცემების გაგზავნისთვის, ანუ თუ მინიჭებული აქვს ატრიბუტი type="submit", შეგვიძლია მივანიჭოთ დამატებითი ატრიბუტები:
                  
                  form: განსაზღვრავს ფორმას, რომელზედაც არის მიმაგრებული ღილაკი
                  formaction: განსაზღვრავს მისამართს, რომელზეც იგზავნება ფორმის მონაცემები. თუ ელემენტს form მინიჭებული აქვს ატრიბუტი action, ხდება მისი ამოცვლა ფორმის formaction-ის მნიშვნელობით
                  formenctype: განსაზღვრავს მონაცემების გაგზავნის ფორმატს. თუ ელემენტს form  მინიჭებული აქვს ატრიბუტი enctype, ხდება მისი ამოცვლა ღილაკის formenctype-ის მნიშვნელობით
                  formmethod: განსაზღვრავს მონაცემების გაგზავნის მეთოდს (post ან get). თუ ელემენტს form მინიჭებული აქვს ატრიბუტი method, ხდება მისი ამოცვლა ღილაკის formmethod-ის მნიშვნელობით
                  მაგალითად, შევქმნათ ფორმა მონაცემთა გაგზავნის და გასუფთავების ღილაკებით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="login" /></p>
                          <p><input type="password" name="password" /></p>
                          <p>
                              <button type="submit" formmethod="get" formaction="index.html">გაგზავნა</button>
                              <button type="reset">გასუფთავება</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  გარდა ელემენტისა button ღილაკის შექმნა შეიძლება ასევე ელემენტით input , რომლის type ატრიბუტის მნიშვნელობა არის submit, reset an button. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="login" /></p>
                          <p><input type="password" name="password" /></p>
                          <p>
                              <input type="submit" formmethod="get" formaction="index.html" value="გაგზავნა" />
                              <input type="reset" value="გასუფთავება" />
                          </p>
                      </form>
                  </body>
                  </html>
                  ელემენტი input-სგან ატრიბუტის type="image"  გამოყენებით ვღებულობთ სურათს, რომელიც გამოიყენება, როგორც ღილაკი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <input type="text" name="search" />
                              <input type="image" src="search.png" name="submit" />
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  გარდა იმისა, რომ ღილაკს აქვს სურათი, მისი მოქმედება ისეთივეა როგორც ელემენტის input type="submit" ან button type="submit".`
              },
              {
                  title:"ტექსტური ველები",
                  data:`ერთსტრიქონიანი ტექსტური ველი იქმნება ელემენტით input რომელსაც ატრიბუტი type-ის მნიშვნელობა აქვს text.

                  <input type="text" name="login" />
                  დამატებითი ატრიბუტების მეშვეობით შესაძლებელია დავაკონფიგურიროთ ტექსტური ველი:
                  
                  dirname: ტექსტის მიმართულება
                  maxlength: სიმბოლოების მაქსიმალური რაოდენობა
                  pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი ტექსტი
                  placeholder: ტექსტი, რომელიც ჩანს ცარიელ ტექსტურ ველში
                  readonly: ამ ატრიბუტით ტექსტურ ველი ხდება მხოლოდ წაკითხვისთვის
                  required: უთითებს, რომ ველი აუცილებლად შესავსებია
                  size: ველის სიგანე ხილული სიმბოლოების რაოდენობით
                  value: ველის მნიშვნელობა ავტომატურად, სანამ არ შევცვლით
                  გამოვიყენოთ რამდენიმე ატრიბუტი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="userName" placeholder="შეიყვანეთ სახელი" size="26" /></p>
                          <p><input type="text" name="userPhone" placeholder="შეიყვანეთ ტელეფონის ნომერი" size="26" maxlength="11" /></p>
                          <p>
                              <button type="submit">შენახვა</button>
                              <button type="reset">გაუქმება</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  მოცემულ მაგალითში ტექსტურ ველს ერთდროულად 2 ატრიბუტი აქვს  maxlength და size. ამასთან  size ანუ ზომა უფრო მეტია, ვიდრე  maxlength ანუ დასაშვები სიმბოლოების რაოდენობა. მიუხედავად ამისა ჩვენ ვერ შევიყვანთ  maxlength-ზე მეტ სიმბოლოს ამ ტექსტურ ველში.
                  
                  ასევე მნიშვნელოვანია განვასხვავოთ ატრიბუტები value და placeholder. ორივე მათგანი ტექსტურ ველს ანიჭებს ხილულ ტექსტს, მაგრამ placeholder წარმოადგენს მხოლოდ მინიშნებას და ამიტომ იგი იწერება მკრთალად, მაშინ როდესაც value წარმოადგენს ველის მნიშვნელობას:
                  
                  <p><input type="text" name="userName" value="Tom" size="26" /></p>
                  <p><input type="text" name="userPhone" placeholder="შეიყვანეთ ტელეფონის ნომერი" size="26" maxlength="11" /></p>
                   
                  
                  
                  ატრიბუტები readonly და disabled ორივე ზღუდავს ტექსტური ველის რედაქტირებას, მაგრამ მათ განსხვავებული ვიზუალური ეფექტი ახლავს. თუ readonly ველს გარეგნულად არ ცვლის, disabled ველს ხდის ნაცრისფერს:
                  
                  <p><input type="text" name="userName" value="Tom" readonly /></p>
                  <p><input type="text" name="userPhone" value="123456789" disabled /></p>
                   
                  
                  
                  
                  
                  ტექსტური ველის ატრიბუტებს შორის აღსანიშნავია ატრიბუტი  list, რომელიც მიმართავს ელემენტს datalist. ეს უკანასკნელი შეიცავს ტექსტების ნაკრებს, რომელიც ტექსტურ ველზე გამოდის სიის სახით მინიშნებებისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <input list="phonesList" type="text" name="model" placeholder="აირჩიეთ მოდელი" />       
                          <button type="submit">შენახვა</button>     
                      </form>
                      <datalist id="phonesList">
                          <option value="iPhone 6S" label="54000"/>
                          <option value="Lumia 950">35000</option>
                          <option value="Nexus 5X"/>
                      </datalist>
                  </body>
                  </html>
                   
                  
                  
                  ტექსტური ველის ატრიბუტს list ენიჭება datalist-ის იდენტიფიკატორის (id) მნიშვნელობა. თვითონ datalist შეიცავს ელემენტებს option, რომლებიც წარმოადგენენ სიის ელემენტებს.
                  
                  ძებნის ველი
                  
                  ძებნის ველის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="search". ფორმით ის წარმოადგენს ჩვეულებრივ ტექსტურ ველს:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <input type="search" name="term" />
                          <input type="submit" value="ძებნა" />
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  პაროლის ველი
                  
                  პაროლის ველის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="password". მისი განმასხვავებელი ნიშანია ის, რომ შეყვანილი სიმბოლოების ნაცვლად მასში გამჩნდება წერტილები:
                  
                  <form>
                      <p><input type="text" name="login" /></p>
                      <p><input type="password" name="password" /></p>
                      <input type="submit" value="ავტორიზაცია" />
                  </form>
                   
                  
            `
              },
              {
                  title:"ნიშნულები და ავტოფოკუსი",
                  data:`შეყვანის ტექსტურ ველებთან ერთად ხშირად გამოიყენება ნიშნულები, რომლებიც იქმნება ელემენტის label მეშვეობით. ნიშნულები წარმოადგენენ ტექსტური ველის ანოტაციას ან სათაურს და უთითებენ, რისთვისაა ეს ველი განკუთვნილი:

                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ნიშნულები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="login">მომხმარებელი: </label>
                              <input type="text" id="login" name="login" />
                          </p>
                          <p>
                              <label for="password">პაროლი: </label>
                              <input type="password" id="password" name="password" />
                          </p>
                          <p>
                              <button type="submit">შესვლა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                  ტექსტურ ველს აქვს ატრიბუტი  id="login", ამიტომ მის შესაბამის ნიშნულს აქვს ატრიბუტი for="login". ნიშნულზე მაუსის დაჭერით მისი შესაბამისი ველი იღებს ფოკუსს:
                  
                  
                  ნიშნულების როლი ამით ამოიწურება. ასევე შეგვიძლია რომელიმე ველს მივანიჭოთ ავტოფოკუსი და გვერდზე შესვლისას ფოკუსი იქნება ამ ველზე. ამისთვის გამოიყენება ატრიბუტი autofocus:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ნიშნულები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="login">მომხმარებელი: </label>
                              <input type="text" id="login" name="login" autofocus />
                          </p>
                          <p>
                              <label for="password">პაროლი: </label>
                              <input type="password" id="password" name="password" />
                          </p>
                          <p>
                              <button type="submit">შესვლა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   `
              },
              {
                  title:"ელემენტები რიცხვების შესაყვანად",
                  data:`რიცხვების შესაყვანად გამოიყენება ელემენტი input ატრიბუტით type="number". მისი კონფიგურაცია შესაძლებელია შემდეგი დამატებითი ატრიბუტების გამოყენებით:

                  min: მინიმალური დასაშვები მნიშვნელობა
                  max: მაქსიმალური დასაშვები მნიშვნელობა
                  readonly: მხოლოდ წაკითხვისთვის
                  required: მიუთითებს, რომ ველის შევსება აუცილებელია
                  step: მნიშვნელობა, რომლითაც ხდება ველის ზრდა (ბიჯი)
                  value: თავდაპირველი მნიშვნელობა 
                  გამოვიყენოთ რიცხვითი ველი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="age">ასაკი: </label>
                                  <input type="number" step="1" min="1" max="100" value="10" id="age" name="age"/>
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                      </body>
                  </html>
                  მოცემულ მაგალითში რიცხვითი ველის თავდაპირველი მნიშვნელობაა 10, მინიმალური მნიშვნელობა 1, მაქსიმალური 100. ბიჯი ტოლია 1-ის.
                  
                  სხვადასხვა ბრაუზერში ეს ელემენტი გამოჩნდება სხვადასხვანაირად. მაგალითად:
                  
                  Google Chrome-ში
                  
                  
                  Microsoft Edge-ში
                  
                  
                  
                  
                  თუმცა თანამედროვე ბრაუზერების უმეტესობაში, გარდა IE 11-სა და Microsoft Edge-სი რიცხვით ველს მარჯვნივ აქვს ისრები მნიშვნელობის გაზრდა-შემცირებისთვის step ატრიბუტში მითითებული ბიჯით.
                  
                  როგორც ტექსტურ ველებში, რიცხვით ველებშიც შეგვიძლია გამოვიყენოთ სიები შესაძლო მნიშვნელობებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="price">ფასი: </label>
                                  <input type="number" list="priceList"
                                      step="1" min="3" max="100" value="10" id="price" name="price"/>
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                          <datalist id="priceList">
                              <option value="15" />
                              <option value="20" />
                              <option value="25" />
                          </datalist>
                      </body>
                  </html>
                   
                  
                
                  
                  მცოცავი ველი
                  
                  მცოცავი წარმოადგენს სკალას, სადაც შეიძლება მნიშვნელობების არჩევა. მის შესაქმნელად გამოიყენება ელემენტი input  ატრიბუტით type="range".  როგორც რიცხვით ველს, მასაც გააჩნია ატრიბუტები min, max, step და value:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="price">Цена:</label>
                                  <input type="range" step="1" min="0" max="100" value="10" id="price" name="price"/>100
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ალმები და გადამრთველები",
                  data:` 
                  ალამი წარმოადგენს ელემენტს, რომელსაც გააჩნია ორი მდგომარეობა: ჩართული და გამორთული. მის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="checkbox":
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ალამი HTML5-ში</title>
                  </head>
                  <body>
                      <h2>ტექნოლოგიები</h2>
                      <form>
                          <p>
                              <input type="checkbox" checked name="html5" />HTML5
                          </p>
                          <p>
                              <input type="checkbox" name="dotnet" />.NET
                          </p>
                          <p>
                              <input type="checkbox" name="java" />Java
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  ატრიბუტი checked საშუალებას გვაძლევს დავაყენოთ ალამი ჩართულ მდგომარეობაში.
                  
                  
                  
                  გადამრთველები
                  
                  გადამრთველები ანუ რადიოღილაკები ჰგავს ალმებს და მათაც გააჩნიათ ორი მდგომარეობა: ჩართული და გამორთული. მაგრამ გადამრთველები ერთიანდებიან ჯგუფებში და ერთ ჯგუფში მხოლოდ ერთი რადიოღილაკი შეიძლება იყოს ჩართული:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>გადამრთველები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <h2>მიუთითეთ სქესი</h2>
                          <p>
                              <input type="radio" value="man" checked name="gender" />კაცი
                          </p>
                          <p>
                              <input type="radio" value="woman" name="gender" />ქალი
                          </p>
                          <h2>აირჩიეთ ტექნოლოგია</h2>
                          <p>
                              <input type="radio" value="html5" checked name="tech" />HTML5
                          </p>
                          <p>
                              <input type="radio" value="net" name="tech" />.NET
                          </p>
                          <p>
                              <input type="radio" value="java" name="tech" />Java
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  მნიშვნელოვან ატრიბუტს წარმოადგენს value. იგი საშუალებას აძლევს სერვერს გაიგოს, თუ რომელი გადამრთველი იყო მონიშნული:
                  
                  
                  შენახვაზე დაჭერის შემდეგ სერვერს გადაეცემა ინფორმაცია gender=man და tech=html5 იმის მიხედვით, თუ რომელი გადამრთველები იყო ჩართული.`
              },
              {
                  title:"ელემენტები ფერის, url-ის, ელექტრონული ფოსტის და ტელეფონის ნომრისთვის",
                  data:`ფერის შეყვანის ველი

                  ფერის შეყვანის ველის მისაღებად ელემეტ input-ს უნდა მივანიჭოთ ატრიბუტი type="color":
                  
                  <label for="favcolor">აირჩიეთ ფერი</label>
                  <input type="color"  id="favcolor" name="favcolor" />
                   
                  
                  
                  ამ ელემენტის მნიშვნელობა იქნება თექვსმეტობითი რიცხვით გამოსახული არჩეული ფერის კოდი. 
                  
                  datalist-ის მეშვეობით ელემენტს შეიძლება დაემატოს სია, საიდანაც იქნება შესაძლებელი რეკომენდირებული ფერის არჩევა:
                  
                  <label for="favcolor">აირჩიეთ ფერი</label>
                  <input type="color" list="colors" id="favcolor" name="favcolor" />
                  <datalist id="colors">
                      <option value="#0000FF" label="blue">
                      <option value="#008000" label="green">
                      <option value="#ff0000" label="red">
                  </datalist>
                  
                  datalist-ის თითოეული ელემენტ option-ს მნიშვნელობად უნდა ჰქონდეს თექვსმეტობითი სახით წარმოდგენილი რიცხვი, მაგალითად "#0000FF". არჩევის შემთხვევაში ფერის შეყვანის ველი მიიღებს შესაბამის მნიშვნელობას.
                  
                  
                  
                  url-ის, email-ის და ტელეფონის შესაყვანი ველები
                  
                  input ელემენტზე სხვადასხვა type ატრიბუტის მინიჭებით შეიძლება მივიღოთ url-ის, email-ის და ტელეფონის შესაყვანი ველები. ამისათვის type-ს უნდა მივცეთ შესაბამისად შემდეგი მნიშვნელობები: url, email, tel. 
                  
                  მათი კონფიგურაციისთვის გამოიყენება იგივე ატრიბუტები, რაც ჩვეულებრივი ტექსტური ველებისთვის:
                  
                  dirname: ტექსტის მიმართულება
                  maxlength: სიმბოლოების მაქსიმალური რაოდენობა
                  pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი ტექსტი
                  placeholder: ტექსტი, რომელიც ჩანს ცარიელ ტექსტურ ველში
                  readonly: ამ ატრიბუტით ტექსტურ ველი ხდება მხოლოდ წაკითხვისთვის
                  required: უთითებს, რომ ველი აუცილებლად შესავსებია
                  size: ველის სიგანე ხილული სიმბოლოების რაოდენობით
                  value: ველის მნიშვნელობა ავტომატურად, სანამ არ შევცვლით
                  list: ველზე ებმება შესაბამისი datalist
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>HTML5</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="email">Email: </label>
                              <input type="email" placeholder="user@gmail.com" id="email" name="email"/>
                          </p>
                          <p>
                              <label for="url">URL: </label>
                              <input type="url" id="url" name="url"/>
                          </p>
                          <p>
                              <label for="phone">ტელეფონი: </label>
                              <input type="tel" placeholder="(XXX)-XXX-XX XX XX" id="phone" name="phone"/>
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  
                  ასეთი ველების ძირითადი უპირატესობა მდგომარეობს იმაში, რომ თუ ჩვენ შევიყვანთ არასწორ მნიშვნელობას და შევეცდებით მის სერვერზე გაგზავნას, ბრაუზერი შეგვატყობინებს შეცდომის შესახებ და მონაცემებს არ გააგზავნის:`
              },
              {
                title:"ელემენტები თარიღისა და დროის შესაყვანად",
                data:`თარიღისა და დროის შესაყვანად HTML5-ში განსაზღვრულია input ელემენტის შემდეგი ტიპები:

                datetime-local: თარიღი და დრო
                date: თარიღი
                month: თვე
                time: დრო
                week: კვირა
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form>
                            <p>
                                <label for="firstname">სახელი: </label>
                                <input type="text" id="firstname" name="firstname"/>
                            </p>
                            <p>
                                <label for="date">დაბადების თარიღი: </label>
                                <input type="date" id="date" name="date" value="1995-05-12"/>
                            </p>
                            <p>
                                <button type="submit">შენახვა</button>
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                თრიღის შესაყვანად შეიძლება ჩამოვშალოთ კალენდარი:
                
                 
                
                
                უნდა აღინიშნოს, რომ ამ ელემენტის მოქმედება დამოკიდებულია ბრაუზერზე. ზემოთ მოცემული სურათი აღებულია Google Chrome-დან. Microsoft Edge-ში მას ექნება შემდეგი სახე:
                
                
                ხოლო IE 11-ს და Firefox-ს საერთოდ არა აქვს ამ ელემენტის მხარდაჭერა.
                
                თარიღისა და დროის სხვა ელემენტების გამოყენებისთვის ვნახოთ მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form>
                            <p>
                                <label for="week">კვირა: </label>
                                <input type="week" name="week" id="week" />
                            </p>
                            <p>
                                <label for="localdate">თარიღი და დრო: </label>
                                <input type="datetime-local" id="localdate" name="date"/>
                            </p>
                            <p>
                                <label for="month">თვე: </label>
                                <input type="month" id="month" name="month"/>
                            </p>
                            <p>
                                <label for="time">დრო: </label>
                                <input type="time" id="time" name="time"/>
                            </p>
                            <p>
                                <button type="submit">შენახვა</button>
                            </p>
                        </form>
                    </body>
                </html>
                 `
            },  {
                title:"ფაილების გაგზავნა",
                data:`ფაილების გასაგზავნად გამოიყენება ელემენტი input ატრიბუტით type="file:"

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form enctype="multipart/form-data" method="post" action="http://localhost:8080/postfile.php">
                            <p>
                                <input type="file" name="file" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
              
                
                "Choose File" ღილაკზე დაჭერისას იხსნება ფაილის არჩევის ფანჯარა, ხოლო ფაილის არჩევის შემდეგ ღილაკის გვერდით გაჩნდება არჩეული ფაილის სახელი.
                
                მნიშვნელოვანია აღინიშნოს, რომ ფაილის სერვერზე გაგზავნის ფორმას უნდა ჰქონდეს ატრიბუტი enctype="multipart/form-data".
                
                ატრიბუტების მეშვეობით შეიძლება ელემენტის კონფიგურაციის შეცვლა:
                
                accept: ფაილის ტიპი, რომლის არჩევა იქნება შესაძლებელი
                multiple: საშუალებას იძლევა ავირჩიოთ რამდენიმე ფაილი
                required: ფაილის არჩევა აუცილებელია
                მაგალითად, მრავალი ფაილის არჩევის შესაძლებლობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form enctype="multipart/form-data" method="post" action="http://localhost:8080/postfile.php">
                            <p>
                                <input type="file" name="file" multiple />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                ამ შემთხვევაში ფაილის არჩევის ფანჯარაში შესაძლებელი იქნება რამდენიმე ფაილის არჩევა, ხოლო არჩევის მერე ღილაკის გვერდით გაჩნდება წარწერა არჩეული ფაილების რაოდენობით`
            },  {
                title:"ელემენტი select (სია)",
                data:` 

                ელემენტი select ქმნის სიას. ატრიბუტების მნიშვნელობების მიხედვით ეს შეიძლება იყოს ჩამოსაშლელი სია ან სია, რომელშიც შეიძლება ერთდროულად რამდენიმე ელემენტის არჩევა.
                
                შევქმნათ ჩამოსაშლელი სია:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label>
                                <select id="phone" name="phone">
                                    <option value="iphone 6s">iPhone 6S</option>
                                    <option value="lumia 950">Lumia 950</option>
                                    <option value="nexus 5x">Nexus 5X</option>
                                    <option value="galaxy s7">Galaxy S7</option>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                ელემენტ select-ის შიგნით მოთავსებულია ელემენტები option -სიის ელემენტები. თითოეულ სიის ელემენტს აქვს ატრიბუტი value. ამასთან, არაა აუცილებელი, რომ value-ს მნიშვნელობა ემთხვეოდეს ტექსტს.
                
                ატრიბუტის selected მეშვეობით შეგვიძლია მივუთითოთ არჩეული ელემენტი. მაგალითად:
                
                <select id="phone" name="phone">
                     <option value="iphone 6s">iPhone 6S</option>
                     <option value="lumia 950">Lumia 950</option>
                     <option value="nexus 5x">Nexus 5X</option>
                     <option value="galaxy s7">Galaxy S7</option>
                </select>
                disabled ატრიბუტის მეშვეობით შეგვიძლია სიის რომელიმე ელემენტის არჩევა შევზღუდოთ. იგი ძირითადად გამოიყენება სათურების შესაქმნელად:
                
                <select id="phone" name="phone">
                    <option disabled selected>აირჩიეთ მოდელი</option>
                    <option value="iphone 6s">iPhone 6S</option>
                    <option value="lumia 950">Lumia 950</option>
                    <option value="nexus 5x">Nexus 5X</option>
                    <option value="galaxy s7">Galaxy S7</option>
                </select>
                 
                
                
                
                ბევრი ელემენტის ასარჩევი სიის შესაქმნელად გამოიყენება ატრიბუტი multiple:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label> <br/>
                            
                                <select multiple id="phone" name="phone">
                                    <option value="iphone 6s">iPhone 6S</option>
                                    <option value="lumia 950">Lumia 950</option>
                                    <option value="nexus 5x">Nexus 5X</option>
                                    <option value="galaxy s7">Galaxy S7</option>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                Ctrl კლავიშზე დაჭერით და მაუსის მეშვეობით შესაძლებელია რემდენიმე ელემენტის ერთდროულად მონიშვნა:
                
                
                optgroup ტეგის გამოყენებით შესაძლებელია სიიის ელემენტების დაჯგუფება:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label>
                            
                                <select id="phone" name="phone">
                                    <optgroup label="Apple">
                                        <option value="iphone 6s">iPhone 6S</option>
                                        <option value="iphone 6s plus">iPhone 6S Plus</option>
                                        <option value="iphone 5se">iPhone 5SE</option>
                                    </optgroup>
                                    <optgroup label="Microsoft">
                                        <option value="lumia 950">Lumia 950</option>
                                        <option value="lumia 950 xl">Lumia 950 XL</option>
                                        <option value="lumia 650">Lumia 650</option>
                                    </optgroup>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
              
                
                დაჯგუფების გამოყენება შესაძლებელია როგორც ჩამოსაშლელი სიებისთვის, ასევე მრავალი არჩევის მქონე სიებისთვისაც.`
            },  {
                title:"ტექსტური არე (Textarea)",
                data:` 


                მრავალსტრიქონიანი ტექსტური ველისთვის გამოიყენება ელემენტი textarea:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="comment">თქვენი კომენტარი:</label><br/>
                                <textarea name="comment" id="comment" placeholder="არაუმეტეს 200 სიმბოლოსი" maxlength="200"></textarea>  
                            </p>
                            <p>
                                <input type="submit" value="დამატება" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5
                
                დამატებითი პარამეტრების cols და rows მეშვეობით შესაძლებელია სვეტების და სტრიქონების რაოდენობის განსაზღვრა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="comment">თქვენი კომენტარი:</label><br/>
                                <textarea name="comment" id="comment" placeholder="შეიყვანეთ კომენტარი"
                                    cols="30" rows="7"></textarea>  
                            </p>
                            <p>
                                <input type="submit" value="დამატება" />
                            </p>
                        </form>
                    </body>
                </html>`
            },  {
                title:"ფორმების ვალიდაცია",
                data:` 


                ხშირად საჭირო ხდება ფორმებში მონაცემების შეტანის დროს შეიზღუდოს გარკვეული მნიშვნელობების შეტანა, რადგან მომხმარებელს ხშირად შეჰყავს არასწორი მონაცემები, მაგალითად, ველში, სადაც მხოლოდ ციფრები უნდა შეჰყავდეს, შეჰყავს ასოები და ა. შ. ამის თავიდან ასაცილებლად HTML5-ში არსებობს ვალიდაციის მექანიზმი. ვალიდაციის უპირატესობა მდგომარეობს იმაში, რომ მომხმარებელი დროულად იგებს შეცდომის შესახებ და ასწორებს შეტანილ მონაცემებს.
                
                ვალიდაციისთვის გამოიყენება შემდეგი ატრიბუტები:
                
                required: მოითხოვს მნიშვნელობის აუცილებლად შეყვანას. გამოიყენება ელემენტებისთვის textarea, select, input (ტიპით text, password, checkbox, radio, file, datetime-local, date, month, time, week, number, email, url, search, tel)
                min და max: მინიმალური და მაქსიმალური მნიშვნელობა. გამოიყენება ელემენტისთვის input ტიპით datetime-local, date, month, time, week, number, range
                pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი მნიშვნელობა. გამოიყენება ელემენტისთვის input ტიპით text, password, email, url, search, tel
                ატრიბუტი required
                
                ატრიბუტი required გულისხმობს, რომ ელემენტს აუცილებლად უნდა ჰქონდეს მნიშვნელობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="login">მომხმარებელი:</label>
                                <input type="text" required id="login" name="login" />
                            </p>
                            <p>
                                <label for="password">პაროლი:</label>
                                <input type="password" required id="password" name="password" />
                            </p>
                            <p>
                                <input type="submit" value="შესვლა" />
                            </p>
                        </form>
                    </body>
                </html
                თუ ველებს არ შევავსებთ და დავაჭერთ შესვლას, გამოვა გაფრთხილება, რომ აუცილებელი ველები არაა შევსებული:
                
                HTML5
                
                ბრაუზერების მიხედვით შეუვსებელი აუცილებელი ველები სხვადასხვანაირად გამოისახება, მაგალითად Firefox-ში და Microsoft Edge-ში ასეთ ველებს უკეთდება წითელი ჩარჩო:
                
                Firefox
                
                HTML5
                
                Microsoft Edge
                
                HTML5
                
                ატრიბუტები min და max
                
                შესაყვანი მნიშვნელობების დიაპაზონის შესაზღუდავად გამოიყენება ატრიბუტები min და max:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="age">ასაკი:</label>
                                <input type="number" min="1" max="100" value="18" id="age" name="age"/>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5
                
                ატრიბუტი pattern
                
                ატრიბუტი pattern წარმოადგენს შაბლონს, რომელსაც უნდა შეესაბამებოდეს შეყვანილი მნიშვნელობები. შაბლონისთვის გამოიყენება ე. წ. რეგულარული გამოსახულებები (Regular expression). 
                
                განვიხილოთ მარტივი მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">ტელეფონი:</label>
                                <input type="text" placeholder="123-45-67"
                                        pattern="\d{3}-\d{2}-\d{2}-\d{2}" id="phone" name="phone" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                ტელეფონის ნომრის შაბლონისთვის გამოყენებულია რეგულარული გამოსახულება "\d{3}-\d{2}-\d{2}-\d{2}". \d ნიშნავს ნებისმიერ ციფრს 0-დან 9-ის ჩათვლით, \d{3} ნიშნავს, რომ ზედიზედ 3 ციფრი უნდა ეწეროს. \d{2} ნიშნავს ზედიზედ 2 ციფრს. საბოლოოდ შეყვანილ ტელეფონის ნომერს უნდა ჰქონდეს სახე 123-45-67. თუ შევიყვანთ ისეთ ტექსტს, რომელიც შაბლონს არ შეესაბამება, ბრაუზერი გამოგვიტანს შეცდომის შეტყობინებას:
                
                HTML5
                
                ტელეფონის ნომერი უნდა ეწეროს შემდეგი სახით: 577-12-55-01.
                
                ვალიდაციის გამორთვა
                
                ფორმის ვალიდაცია ყოველთვის არაა სასურველი. ამ შემთხვევაში ფორმას უნდა ჰქონდეს ატრიბუტი novalidate ან gagzavnis Rilaks formnofalidate.
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get" novalidate>
                            <p>
                                <label for="phone">ტელეფონი:</label>
                                <input type="text" placeholder="123-45-67"
                                        pattern="\d{3}-\d{2}-\d{2}-\d{2}" id="phone" name="phone" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" formnovalidate />
                            </p>
                        </form>
                    </body>
                </html>`
            },  {
                title:"ელემენტები fieldset და legend",
                data:`ფორმის ელემენტების დაჯგუფებისთვის ხშირად გამოიყენება ელემენტი fieldset. ის ავლებს საზღვრებს მასში მოქცეული ელემენტების გარეთ და ქმნის მათგან ჯგუფს. მასთან ერთად გამოიყენება ელემენტი legend, რომელიც ქმნის სათაურს ჯგუფისთვის:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <h2>საიტზე შესვლა</h2>
                        <form>
                            <fieldset>
                                <legend>შეიყვანეთ მონაცემები:</legend>
                                <label for="login">მომხმარებელი:</label><br>
                                <input type="text" name="login" id="login" /><br>
                                <label for="password">პაროლი:</label><br>
                                <input type="password" name="password" id="password" /><br>
                                <input type="submit" value="ავტორიზაცია">
                            </fieldset>
                        </form>
                    </body>
                </html>`
            }, 
            ]
        },
        {
            title:"	თავი 4. გვერდის სემანტიკური სტრუქტურა",
            content:[
                {
                    title:"ელემენტი article",
                    data:` 


                    ელემენტი article წარმოადგენს ინფორმაციის ერთიან ბლოკს ვებგვერდზე, რომელიც შეიძლება ცალკე განვიხილოთ და გამოვიყენოთ. მაგალითად, ეს შეიძლება იყოს პოსტი ფორუმზე ან სტატია ბლოგზე, მომხმარებლის კომენტარი.
                    
                    ერთი ელემენტი article შეიძლება შეიცავდეს რამდენიმე ელემენტს article. მაგალითად, შეიძლება ერთი article იყოს მთლიანად სტატია ბლოგზე, რომელიც შეიცავს სხვა ელემენტებს article, როგორც მომხმარებლების კომენტარებს ამ სტატიაზე.ანუ სტატია ბლოგზე ჩვენ შეგვიძლია განვიხილოთ, როგორც ცალკე სემანტიკური ერთეული, ამავე დროს თვითონ კომენტარებიც განვიხილოთ ცალკე, ვებგვერდის სხვა შიგთავსისგან დამოუკიდებლად.
                    
                    გამოვიყენოთ article ბლოგის სტატიისა და მისი კომენტარებისთვის:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სემანტიკური მარკირება HTML5-ში</title>
                    </head>
                    <body>
                        <article>
                            <h2>Lorem ipsum</h2>
                            <div>
                                Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna
                                aliquam erat ...
                            </div>
                            <div>
                                <h3>კომენტარები</h3>
                                <article>
                                    <h4>არა უშავს</h4>
                                    <p>ნორმალური სტატიაა...</p>
                                </article>
                                <article>
                                    <h4>სისულელეა</h4>
                                    <p>მე არ მომეწონა</p>
                                </article>
                                <article>
                                    <h4>გაუგებარია</h4>
                                    <p>ნეტა, რაზეა საერთოდ?</p>
                                </article>
                            </div>
                        </article>
                    </body>
                    </html>
                     
                    
                     
                    
                    
                    აქ მთლიანი სტატია მოქცეულია ერთ article ელემენტში, ამასთან ყოველი ახალი კომენტარი წარმოადგენს ცალკე article-ს.
                    
                    article გამოყენებისას უნდა გვახსოვდეს, რომ თითოეული ელემენტი უნდა იდენტიფიცირდებოდეს h1-h6 სათაურის მეშვეობით.`
                },
                {
                  title:"ელემენტი section",
                  data:` 
                  
                  
                  ელემენტი seqtion აერთიანებს html გვერდის ერთმანეთთან დაკავშირებულ ცალკეულ ნაწილებს და ქმნის მათგან ჯგუფს. მაგალითად, seqtion შეიძლება აერთიანებდეს ჩანართების ერთობლიობას, ახალ ამბებს, გაერთიანებულს კატეგორეიბად და ა.შ.
                  
                  თითოეული ელემენტი უნდა იდენტიფიცირდებოდეს h1-h6 სათაურის მეშვეობით.
                  
                  ერთი ელემენტი section შეიძლება შეიცავდეს რამდენიმე ელემენტ article-ს, ასევე, ერთი ელემენტი article შეიძლება შეიცავდეს რამდენიმე ელემენტ section-ს.
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სემანტიკური მარკირება HTML5-ში</title>
                  </head>
                  <body>
                      <article>
                          <h1>Lorem ipsum</h1>
                          <section>
                              <h2>შინაარსი</h2>
                              <p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh
                              euismod tincidunt ut laoreet dolore magna aliquam erat ...</p>
                          </section>
                          <section>
                              <h3>კომენტარი</h3>
                              <article>
                                  <h4>არა უშავს</h4>
                                  <p>ნორმალური სტატიაა</p>
                              </article>
                              <article>
                                  <h4>სისულელეა</h4>
                                  <p>მე არ მომეწონა...</p>
                              </article>
                              <article>
                                  <h4>გაუგებარია</h4>
                                  <p>ნეტა, რაზეა საერთოდ?</p>
                              </article>
                          </section>
                      </article>
                  </body>
                  </html>
                   
                  
                  
                  აქ ძირითადი შინაარსის ბლოკისთვის შეცმნილია სექცია, ასევე კომენტარებისთვისაც შექმნილია სექცია რამდენიმე არტიკლით.`
              },
              {
                  title:"ელემენტი nav",
                  data:` 


                  ელემენტი nav გამოიყენება იმ ელემენტების გასაერთიანებლად, რომელთა დანიშნულება საიტზე ნავიგაციაა. როგორც წესი, ეს დაუნომრავი სიაა ბმულებით.
                  
                  ერთ ვებგვერდზე შესაძლებელია გამოვიყენოთ რამდენიმე ელემენტი nav. მაგალითად, ერთი ელემენტი nav საიტის გვერდებზე გადასასვლელად, მეორე კი გვერდის შიგნით ნავიგაციისთვის.
                  
                  არაა აუცილებელი ყველა ბმული მოვათავსოთ ელემენტში nav. ზოგიერთი ბმულები შეიძლება არ წარმოადგენდნენ ურთიერთდაკავშირებულ ბლოკს ნავიგაციისთვის. მაგალითად, ბმული, რომელსაც გადავყავართ მთავარ გვერდზე, ბმული სალიცენზიო ხელშეკრულებაზე, რომლებიც ხშირად მოთავსებულია გვერდის ბოლოში, არაა აუცილებელი, რომ მოვაქციოთ ელემენტში nav.
                  
                  გამოვიყენოთ ელემენტი nav სანავიგაციო ბმულებისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სემანტიკური მარკირება HTML5-ში</title>
                  </head>
                  <body>
                      <nav>
                          <ul>
                              <li><a href="/">მთავარი</a></li>
                              <li><a href="/blog">ბლოგი</a></li>
                              <li><a href="/contacts">კონტაქტი</a></li>
                          </ul>
                      </nav>
                      <article>
                          <header>
                              <h2>მოთხრობა 2 ნაწილად</h2>
                          </header>
                          <nav>
                              <ul>
                                  <li><a href="#part1">ნაწილი 1</a></li>
                                  <li><a href="#part2">ნაწილი 2</a></li>
                              </ul>
                          </nav>
                          <div>
                              <section id="part1">
                                  <h2>ნაწილი 1</h2>
                                  <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.
                                  Lorem Ipsum has been the industry...</p>
                              </section>
                              <section id="part2">
                                  <h2>ნაწილი 2</h2>
                                  <p>There are many variations of passages of Lorem Ipsum available..</p>
                              </section>
                          </div>
                          <footer>
                              
                          </footer>
                      </article>
                      <footer>
                          <p><a href="/license">სალიცენზიო ხელშეკრულება</a> |
                          <a href="/about">საიტის შესახებ</a> |
                          <a href="/donation">Donations</a></p>
                          <p><small>© Copyright 2016 MyCorp.</small></p>
                      </footer>
                  </body>
                  </html>
                   
                  
                  
                  აქ გამოყენებულია ნავიგაციის 2 ბლოკი: ერთი გვერდებს შორის ნავიგაციისთვის, მეორე გვერდის შიგნით ნავიგაციისთვის.
                  
                  არაა აუცილებელი ყველა ბმული მოვათავსოთ ელემენტში nav. ზოგიერთი ბმული ამ გვერდზე მოთავსებულია ელემენტში footer.`
              },
              {
                  title:"ელემენტები header, footer და address",
                  data:` 

 
                  
                  ელემენტი header გამოიყენება როგორც შესავალი ნაწილი, რომელიც წინ უსწრებს ძირითად შინაარსს. აქ შეიძლება იყოს გვერდის სათაური, ნავიგაცია, სხვადასხვა დამხმარე საშუალებები. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <header>
                              <h1>ტელეფონების ონლაინ მაღაზია</h1>
                                  <nav>
                                      <ul>
                                          <li><a href="/apple">Apple</a>
                                          <li><a href="/microsoft">Microsoft</a>
                                          <li><a href="/samsung">Samsung</a>
                                      </ul>
                                  </nav>
                          </header>
                          <div>
                              ინფორმაცია მობილურების ბაზრის სიაახლეების შესახებ...
                          </div>
                      </body>
                  </html>
                  ელემენტ header-ში არ შეიძლება მოვათავსოთ ელემენტი address, footer ან სხვა header.
                  
                  footer
                  
                  ელემენტი footer როგორც წესი შეიცავს ინფორმაციას კონტენტის ავტორის, კოპირაიტის, პუბლიკაციის თარიღის შესახებ, ბმულების ბლოკს მსგავს რესურსებზე და ა. შ. როგორც წესი, მსგავსი ინფორმაცია თავსდება გვერდის ბოლოში, თუმცა footer არ გააჩნია მკაცრად განსაზღვრული ადგილი და შეიძლება მოთავსდეს ვებგვერდის სხვადასხვა ადგილას.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <h1>Xiaomi Mi 5</h1>
                          <div>
                              Xiaomi Mi 5 აღჭურვილია რვაბირთვიანი პროცესორით Qualcomm Snapdragon 820.
                              შიდა მეხსიერების მოცულობა - 32 ან 64 МБ.
                          </div>
                          <footer>
                              <p><a href="/license">სალიცენზიო შეთანხმება</a><br/>
                              Copyright © 2016. SomeSite.com</p>
                          </footer>
                      </body>
                  </html>
                  აქ footer განსაზღვრულია მთელი გვერდისთვის . მასში მოთავსებულია ბმული სალიცენზიო შეთანხმებაზე და ინფორმაცია კოპირაიტზე.
                  
                  footer არაა აუცილებელი იყოს მთელი გვერდისთვის. ის შეიძლება იყოს როგორც კონტენტის ცალკე სექცია:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <section>
                              <h1>ბოლო სტატიები</h1>
                              <article>
                                  <h2>ანონსი Samsung Galaxy S7</h2>
                                  <p>გამოვიდა ახალი ფლაგმანი კომპანიისგან Samsung Galaxy S7.....</p>
                                  <footer>
                                      გამოქვეყნების თარიღი: <time datetime="2016-03-16T15:16-00:00">16.03.2016 15:16</TIME>
                                  </footer>
                              </article>
                              <article>
                                  <h2>ფასდაკლებები Microsoft Lumia 950</h2>
                                  <p>1 მარტიდან Microsoft Lumia 950 ღირს 50 ლარით იაფი...</p>
                                  <footer>
                                      გამოქვეყნების თარიღი: <time datetime="2016-03-01T14:36-00:00">01.03.2016 14:36</TIME>
                                  </footer>
                              </article>
                          </section>
                      </body>
                  </html>
                  address
                  
                  ელემენტი address განკუთვნილია საკონტაქტო ინფორმაციისთვის, რომელიც დაკავშირებულია უახლოეს ელემენტთან article ან body. ხშირად იგი მოთავსებულია footer-ის შიგნით.
                  
                  <footer>
                      <address>
                          საკონტაქტო ინფორმაცია <a href="mailto:js@example.com">ტომ სმიტი</a>.
                      </address>
                      <p>© copyright 2016 Example Corp.</p>
                  </footer>`
              },
              {
                  title:"ელემენტი aside",
                  data:` 


                  ელემენტი aside განკუთვნილია შიგთავსისთვის, რომელიც ირიბადაა დაკავშირებული გვერდის დანარჩენ კონტენტთან და რომელიც შეიძლება განვიხილოთ მისგან დამოუკიდებლად. იგი შეიძლება გამოვიყენოთ საიდბარებისთვის, სარეკლამო ბლოკებისთვის და ა. შ.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <aside style="float:right; width:200px;">
                              <h2>ფასდაკლება Microsoft Lumia 950</h2>
                              <p>მხოლოდ 31 მარტამდე Microsoft Lumia 950 იქნება 50 ლარით იაფი. 
                                  ამასთან, საჩუქრად მიიღებთ უფასო ჩუპა-ჩუპსს. <a href="buy/id=3">ყიდვა</a></p>
                          </aside>
                          <article>
                              <h2>Samsung Galaxy S7</h2>
                              <p>კომპანია სამსუნგმა გამოუთვა ახალი სმარტფონი Samsung Galaxt S7. ახალ სმარტფონთან ერთად
                              სამსუნგმა წარმოადგინა ვირტუალური რეალობის ახალი შლემი Gear VR...</p>
                          </article>
                      </body>
                  </html>`
              },
              {
                  title:"ელემენტი main",
                  data:` 


                  ელემენტი main წარმოადგენს ვებგვერდის ძირითად ნაწილს. ეს წარმოადგენს უნიკალურ კონტენტს და იქ არ უნდა იყოს სხვადასხვა გვერდებზე განმეორებადი საიდბარები, ნავიგაციის ბმულები, ინფორმაცია კოპირაიტზე, ლოგოტიპები და ა. შ. გამოვიყენოთ ელემენტი main:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <main>
                              <h1>მოდელები Snapdragon 808-ით</h1>
                              <p>მოდელები, რომელთაც გააჩნიათ პროცესორი Snapdragon 808</p>
                              
                              <article>
                                <h2>Google Nexus 5X</h2>
                                <p>Nexus 5X წარმოადგენს კომპაქტურ და მძლავრ მოწყობილობას ყოველდღიური ამოცანების გადასაწყვეტად.
                                აღჭურვილია 5.2 დუიმიანი ეკრანით და ექვსბირთვიანი პროცესორით Snapdragon 808...</p>
                              </article>
                    
                              <article>
                                <h2>Microsoft Lumia 950</h2>
                                <p>Microsoft Display Dock-ის დახმარებით თქვენი სმარტფონი Lumia 950 Dual SIM გარე მონიტორით,
                                   კლავიატურით და მაუსით გადაიქცევა სრულფასოვან კომპიუტერად...</p>
                              </article>
                            </main>
                      </body>
                  </html>
                   
                  
                  
                  არაა საჭირო, რომ ვიფიქროთ, თითქოს მთელი ვებგვერდი უნდა მოვაქციოთ ელემენტშო main. მასთან ერთად ასევე უნდა გამოვიყენოთ სხვა ელემენტებიც, მაგალითად header,footer და ა. შ.
                  
                  <body>
                      <header>
                          ..............
                      </header>
                      <main>
                          .................  
                      </main>
                      <footer>
                          .................  
                      </footer>
                  </body>
                   
                  
                  უნდა გავითვალისწინოთ, რომ ელემენტი main არ შეიძლება იყოს მოქცეული ისეთი ელემენტების შიგნით, როგორიცაა article, aside, footer, header, nav.
                  
                  IE 11 და წინა ვერსიებს არ გააჩნიათ main ელემენტის მხარდაჭერა. ამიტომ სასურველია გამოვიტენოთ ასევე ატრიბუტი role:
                  
                  <main role="main">
                      ...
                  </main>`
              },
           
            ]
        },
        {
            title:"თავი 5. CSS3-ის საფუძვლები. სელექტორები",
            content:[
                {
                    title:"სტილები",
                    data:` 
                    
                    
                    რამდენ ელემენტსაც არ უნდა შეიცავდეს, html დოკუმენტი იქნება უსიცოცხლო სტილების გამოყენების გარეშე. სტილები, ანუ უფრო ზუსტად სტილების კასკადური ცხრილები (Cascading Style Sheets) ან უბრალოდ CSS განსაზღვრავს დოკუმენტის გარეგნულ იერსახეს.მოკლედ განვიხილოთ სტილების გამოყენება HTML5-ში.
                    
                    CSS სტილი წარმოადგენს წესს და უთითებს ბრაუზერს, თუ როგორ უნდა გამოისახოს ესა თუ ის ელემენტი, როგორ მოხდეს მისი ფორმატირება. ფორმატირება გულისხმობს ელემენტის ფერს, ფონს, შრიფტს, ზომებს და ა. შ.
                    
                    სტილის განსაზღვრა შედგება ორი ნაწილისგან: სელექტორი, რომელიც მიუთითებს ელემენტზე და სტილის გამოცხადების ბლოკი - ბრძანებების ნაკრები, რომლებიც ადგენენ ფორმატირების წესებს. მაგალითად:
                    
                    div{
                        background-color:red;
                        width: 100px;
                        height: 60px;
                    }
                    მოცემულ მაგალითში სელექტორს წარმოადგენს div. ეს სელექტორი მიუთითებს, რომ მოცემული სტილი გამოიყენება ყველა div ელემენტისთვის. სელექტორის შემდეგ ფიგურულ ფრჩხილებში მოცემულია სტილების გამოცხადების ბლოკი. ფიგურულ ფრჩხილებში მოქცეულია ბრძანებები, რომლებიც განსაზღვრავენ, თუ როგორ უნდა მოხდეს ელემენტების ფორმატირება.
                    
                    თითოეული ბრძანება შედგება თვისებისგან და მნიშვნელობისგან. მაგალითად ბრძანებაში 
                    
                    background-color:red;
                    background-color წარმოადგენს თვისებას, ხოლო red - მნიშვნელობას. თვისება განსაზღვრავს კონკრეტულ სტილს. თვისებები CSS-ში მრავლადაა. მაგალითად, background-color განსაზღვრავს ფონის ფერს. ორწერტილის შემდეგ მოდის ამ თვისების მნიშვნელობა. ზემოთ მოცემული ბრძანება განსაზღვრავს, რომ ფონის ფერი არის წითელი. ყოველი ასეთი ბრძანების ბოლოს იწერება წერტილმძიმე.
                    
                    ასეთი სტილების ერთობლიობას უწოდებენ სტილების ცხრილს ანუ CSS (Cascading Style Sheets). არსებობს სტილების გამოცხადების სხვადასხვა ხერხი.
                    
                    ატრიბუტი style
                    
                    სტილების გამოცხადების ერთ-ერთი ხერხი მდგომარეობს იმაში, რომ ხდება სტილის ჩაშენება უშუალოდ ელემენტში style ატრიბუტის სახით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                        </head>
                        <body>
                            <h2 style="color:blue;">სტილები</h2>
                            <div style="width: 100px; height: 100px; background-color: red;"></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    აქ მოცემულია ორი ელემენტი: სათაური h2 და div. სათურს განსაზღვრული აქვს ტექსტის ფერი თვისების color მეშვეობით, ხოლო div ელემენტს თვისებები სიგანე (width), simaRle(height) და ფონის ფერი (background-color).
                    
                    მეორე მეთოდი მდგომარეობს html დოცუმენტში style ელემენტის გამოყენება. იგი უთითებს ბრაუზერს, რომ მის შიგნით არსებული მონაცემები წარმოადგენს CSS კოდს, და არა html-ს:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                            <style>
                            h2{
                                color:blue;
                            }
                            div{
                                width: 100px;
                                height: 100px;
                                background-color: red;
                            }
                            </style>
                        </head>
                        <body>
                            <h2>სტილები</h2>
                            <div></div>
                        </body>
                    </html>
                    ამ შემთხვევაშიც შედეგი იქნება ზუსტად ისეთივე, როგორც წინა შემთხვევაში.
                    
                    ელემენტი style ძირითადად განისაზღვრება head ელემენტის შიგნით, თუმცა შეიძლება იყოს სხვა ადგილზეც. იგი შეიცავს სტილების ერთობლიობას. თითოეული სტილი შედგება სელექტორისგან და ფიგურულ ფრჩხილებში მოქცეული თვისებებისაგან თავისი მნიშვნელობებით. 
                    
                    
                    
                    პირველისგან განსხვავებით, მეორე ხერხი კოდს ხდის უფრო სუფთას სტილების ცალკე ელემენტად გამოტანის გამო. ასევე არსებობს მესამე ხერხიც, რომელიც მდგომარეობს სტილების ცალკე ფაილად გატანაში.
                    
                    შევქმნათ იგივე საქაღალდეში, სადაც ჩვენი html ფაილია, ფაილი styles.css და შიგნით ჩავწეროთ იგივე სტილები, რაც გვქონდა style ელემენტში.:
                    
                    h2{
                        color:blue;
                    }
                    div{
                        width: 100px;
                        height: 100px;
                        background-color: red;
                    }
                    თვითონ html ფაილის ტექსტი შევცვალოთ შემდეგნაირად:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                            <link rel="stylesheet" type="text/css" href="styles.css"/>
                            </style>
                        </head>
                        <body>
                            <h2>სტილები</h2>
                            <div></div>
                        </body>
                    </html>
                    html დოკუმენტში ახლა უკვე არა გვაქვს ელემენტი style, სამაგიეროდ დაემატა ელემენტი link, რომელიც ახდენს ჩვენს მიერ შექმნილი სტილების ფაილის styles.css ჩართვას: <link rel="stylesheet" type="text/css" href="styles.css"/>.
                    
                    ამგვარად, ცალკე ფაილში სტილების განსაზღვრის შედეგად html კოდი უფრო სუფთაა, გვერდის სტრუქტურა გამოყოფილია მისი სტილიზაციისაგან. ასეთი მიდგომისას უფრო იოლია სტილების მოდიფიცირება, ვიდრე იმ შემთხვევაში, თუ სტილები იქნებოდა ელემენტ style-ში ან თითოეული ელემენტის ატრიბუტ style-ში. შესაბამისად ასეთი მიდგომა უფრო მიღებული და უპირატესია HTML5-ში.
                    
                    ცალკე ფაილებში სტილების გატანა ამცირებს დატვირთვას ვებსერვერზე კეშირების მექანიზმის გამოყენებით. რადგან ვებბრაუზერს შეუძლია მოახდინოს CSS ფაილის კეშირება და შემდგომში მიმართავს კეშირებულ ფაილს სერვერის ნაცვლად.
                    
                    შესაძლებელია მოხდეს ამ სამი მეთოდის შერწყმა, როდესაც ერთი ელემენტის ზოგიერთი თვისება განსაზღვრულია ცალკე css ფაილში, ზოგი style ელემენტში, ხოლო ზოგი თვითონ ამ ელემენტის style ატრიბუტში. მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <link rel="stylesheet" type="text/css" href="styles.css"/>
                            <style>
                                div{
                                    width:200px;
                                }
                            </style>
                        </head>
                        <body>
                            <div style="width:120px;"></div>
                        </body>
                    </html>
                     
                    
                    div{
                        width:50px;
                        height:50px;
                        background-color:red;
                    }
                    მოცემულ მაგალითში div ელემენტისთვის ერთი და იგივე თვისება width განსაზღვრულია 3 ადგილას სხვადასხვა მნიშვნელობებით. რომელ მნიშვნელობას მიიღებს ელემენტი? მოქმედებს პრიორიტეტების შემდეგი სისტემა:
                    
                    თუ ელემენტს განსაზღვრული აქვს ჩაშენებული სტილები (inline-სტილი) style ატრიბუტის სახით, ისინი წარმოადგენენ უმაღლეს პრიორიტეტს. ჩვენს შემთხვევაში ელემენტის სიგანე იქნება 12 პიქსელი.
                    შემდეგი პრიორიტეტში მოდის სტილები, განსაზღვრული ელემენტში style.
                    ცალკე ფაილებში განსაზღვრულ სტილებს აქვთ ყველაზე დაბალი პრიორიტეტი.
                    html ატრიბუტები და CSS
                    
                    html-ის ბევრ ელემენტს აქვს შესაძლებლობა სტილები განესაზღვროს ატრიბუტების მეშვეობით. მაგალითად, ბევრ ელემენტს აქვს ატრიბუტები width და height სიგანისა და სიმაღლის მისათითებლად. თუმცა ყოველთვის უმჯობესია თავი ავარიდოთ სტილების ამგვარად განსაზღვრას და გამოვიყენოთ CSS სტილები. უმჯობესია html-ში მოცემული იყოს ვებგვერდის სტრუქტურა, ხოლო სტილიზაცია მოხდეს CSS სტილების მეშვეობით.
                    
                    CSS კოდის ვალიდაცია
                    
                    CSS კოდის დაწერისას შეიძლება წამოიჭრას კითხვები, სწორად არის ტუ არა განსაზღვრული სტილები, კორექტულია თუ არა ისინი. ასეთ შემთხვევაში შეიძლება ვისარგებლოთ CSS ვალიდატორით, რომელიც ხელმისაწვდომია მისამართზე: http://jigsaw.w3.org/css-validator/ .
                    
                    `
                },
                {
                  title:"სელექტორები",
                  data:` 
                  
                  
                  სტილის განსაზღვრა იწყება სელექტორით:
                  
                  div{
                      width:50px; /* სიგანე */
                      height:50px; /* სიმაღლე */
                      background-color:red; /* ფონის ფერი */
                      margin: 10px; /* დაშორება სხვა ელემენტებისგან */
                  }
                  მოცემულ მაგალითში სელექტორს წარმოადგენს div. რიგ სელექტორებს აქვთ იმ ელემენტის სახელი, რომლის ფორმატირებასაც ისინი ემსახურებიან. მაგალითად, div, p, h2 და ა. შ. ასეთი სელექტორებით განსაზღვრული სტილები ვრცელდება ყველა შესაბამის ელემენტზე. შესაბამისად, ზემოთ განსაზღვრული სტილი გავრცელდება გვერდის ყველა div ელემენტზე:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              div{
                                  width:50px;
                                  height:50px;
                                  background-color:red;
                                  margin: 10px;
                              }
                          </style>
                      </head>
                      <body>
                          <h2>სელექტორები</h2>
                          <div></div>
                          <div></div>
                          <div></div>
                      </body>
                  </html>
                  აქ სამი div ელემენტია და სამივე მიიღებს განსაზღვრულ სტილს:
                  
                  HTML5-ის დოკუმენტი
                  
                  კლასები
                  
                  ზოგჯერ ერთი და იგივე ელემენტებისთვის საჭიროა სხვადასხვანაირი სტილის მიცემა. ამისთვის გამოიყენება კლასები. კლასის სელექტორის განსაზღვრისთვის მისი სახელის წინ დაისმის წერტილი:
                  
                  .redBlock{
                      background-color:red;
                  }
                  კლასის დასახელება შეიძლება იყოს ნებისმიერი. ჩვენს მაგალითში კლასის სახელია redBlock. კლასის დასახელებაში დასაშვებია ასოების, ციფრების, ტირეს და ქვედა ტირეს გამოყენება, პირველი სიმბოლო აუცილებლად უნდა იყოს ასო.
                  
                  მნიშვნელობა აქვს ასოების რეგისტრს: "article" და "ARTICLE" იქნება სხვადასხვა კლასი.
                  
                  კლასის განსაზღვრის შემდეგ მისი გამოყენება შეიძლება ელემენტთან class ატრიბუტის სახით. მაგალითად:
                  
                  <div class="redBlock"></div>
                  განვსაზღვროთ და გამოვიყენოთ რამდენიმე კლასი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>კლასები</title>
                          <style>
                              div{
                                  width: 50px;
                                  height: 50px;
                                  margin: 10px;
                              }
                              .redBlock{
                                  background-color: red;
                              }
                              .blueBlock{
                                  background-color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <h2>კლასები</h2>
                          <div class="redBlock"></div>
                          <div class="blueBlock"></div>
                          <div class="redBlock"></div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                   
                  
                  
                  
                   
                  
                  იდენტიფიკატორები
                  
                  ვებგვერდის უნიკალური ელემენტების იდენტიფიცირებისთვის გამოიყენება იდენტიფიკატორები, რომლებიც გამოისახება ატრიბუტით id. მაგალითად, გვერდზე შეიძლება იყოს სათაურის ბლოკი:
                  
                  <div id="header"></div>
                  იდენტიფიკატორებისთვის სტილის განსაზღვრა კლასებისთვის სტილის განსაზღვრის იდენტურია, მხოლოდ სელექტორის წინ წერტილის ნაცვლად დაისმის სიმბოლო #:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>იდენტიფიკატორები</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid #222;
                              }
                              #header{
                                  height: 80px;
                                  background-color: #ccc;
                              }
                              #content{
                                  height: 180px;
                                  background-color: #eee;
                              }
                              #footer{
                                  height: 80px;
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">საიტის სათაური</div>
                          <div id="content">ძირითადი ნაწილი</div>
                          <div id="footer">ქვედა ნაწილი</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  უნდა აღინიშნოს, რომ იდენტიფიკატორები ძირითადად გამოიყენება არა სტილიზაციისთვის, არამედ ვებგვერდის სტრუქტურის ასაგებად. სტილიზაციისთვის ძირითადად გამოიყენება კლასები.
                  
                  უნივერესალური სელექტორი
                  
                  CSS-ში არის ე. წ. უნივერსალური სელექტორი ვარსკვლავის (8) სახით. ის ანიჭებს  სტილს ვებგვერდის ყველა ელემენტს:
                  
                  *{     
                      background-color: red;
                  }
                   
                  
                  სელექტორთა ჯგუფების სტილიზაცია
                  
                  ზოგჯერ სტილები განისაზღვრება სელექტორთა მთელი ჯგუფისთვის. მაგალითად, თუ გვინდა ყველა სათაურისთვის ხაზგასმის გამოყენება, შესაბამისი სელექტორები უნდა ჩამოვთვალოთ მძიმით გამოყოფილი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h1, h2, h3, h4{
                                  text-decoration: underline;
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <h1>CSS3<h1>
                          <h2>სელექტორები</h2>
                          <h3>სელექტორების ჯგუფი</h3>
                          <p>ტექსტი...</p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჯგუფში შეიძლება გაერთიანებული იყოს როგორც ტეგების, ასევე კლასების და იდენტიფიკატორების სელექტორები:
                  
                  h1, #header, .redBlock{   
                      color: red;
                  }`
              },
              {
                  title:"შთამომავლების სელექტორები",
                  data:` 
                  
                  
                  ვებგვერდს გააჩნია რთული ორგანიზაცია, რომლის დროსაც ერთი ელემენტები შეიცავენ სხვა ელემენტებს. ჩასმულ ელემენტებს (რომლებიც სხვა ელემენტის შიგნით არიან ჩასმული) მეორენაირად "შთამომავლებს" უწოდებენ, ხოლო კონტეინერს, რომელიც შეიცავს ამ ელემენტებს - მშობელს.
                  
                  ვთქვათ, ელემენტი body-ს აქვს შემდეგი სახე:
                  
                  <body>
                      <h2>სათაური</h2>
                      <div>
                         <p>ტექსტი</p>
                      </div>
                  </body>
                  body ელემენტის შიგნით გვაქვს სამი ჩასმული ელემენტი: h2, div და p. სამივე მათგანი წარმოადგენს body ელემენტის შთამომავალს.
                  
                  div ელემენტის შიგნით ჩასმულია ერთი ელემენტი p, ამიტომ div-ს მხოლოდ ერთი შთამომავალი გააჩნია.
                  
                  სპეციალური სელექტორების მეშვეობით შეგვიძლია მოვახდინოთ სტილიზაცია მკაცრად განსაზღვრული ელემენტების შთამომავლებისთვის. მაგალითად, შეიძლება გვქონდეს p ელემენტი როგორც ძირითადი ნაწილის შიგნით, ასევე ფუტერში, მაგრამ გვინდოდეს მათთვის სხვადასხვა შრიფტის მინიჭება.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              #main p{
                                  font-size: 16px;
                              }
                              #footer p{
                                  font-size: 13px;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="main">
                              <p>პირველი აბზაცი</p>
                              <p>მეორე აბზაცი</p>
                          </div>
                          <div id="footer">
                              <p>ფუტერის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩასმული ელემენტისთვის სტილის მისაყენებლად გამოიყენება სელექტორი, რომელიც შეიცავს ჯერ მშობელ ელემენტს და შემდეგ ჩასმულს:
                  
                  #main p{
                          font-size: 16px;
                   }
                  ეს სტილი გავრცელდება მხოლოდ იმ p ელემენტებზე, რომლებიც იმყოფებიან main იდენტიფიკატორის მქონე ელემენტის შიგნით.
                  
                  ვნახოთ მეორე მაგალითი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              li .redLink{
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <ul>
                              <li>Samsung: <a class="redLink">Galaxy S7 Edge</a></li>
                              <li>Apple: <a>iPhome SE</a></li>
                              <li>LG: <a class="redLink">LG G5</a></li>
                              <li>Microsoft: <a>Lumia 650</a></li>
                          </ul>
                      </body>
                  </html>
                  აქ სტილი გამოიყენება ელემენტებისათვის კლასით "redLink", რომლებიც <li>ელემენტის შიგნითაა:
                  
                  HTML5-ის დოკუმენტი
                  
                  მიაქციეთ ყურადღება, რომ li ელემენტსა და .redLink კლასს შორის ადგილია გამოტოვებული. ადგილის გამოტოვებას დიდი მნიშვნელობა აქვს. იგი მიუთითებს, რომ სტილი ეხება მხოლოდ იმ ელემენტებს, რომელთა კლასია "redLink" და ამასთან იმყოფებიან li ელემენტის შიგნით.
                  
                  თუ მოვაშორებთ ადგილის გამოტოვებას, სელექტორის შინაარსი შეიცვლება:
                  
                   
                  
                  li.redLink{
                      color: red;
                  }
                   
                  
                  ახლა უკვე სტილი ეხება იმ liელემენტებს, რომელთაც აქვთ კლასი "redLink". იგი ეხება ქვემოთ მოცემულ ელემენტს:
                  
                  <li class="redLink">Microsoft: <a>Lumia 650</a></li>
                  მაგრამ არა ამ ელემენტს:
                  
                  <li>LG: <a class="redLink">LG G5</a></li>`
              },
              {
                  title:"შვილი ელემენტების სელექტორები",
                  data:`HTML & CSS სახელმძღვანელო
                  "შვილი" ელემენტების სელექტორები
                  
                  
                  შვილი ელემენტების სელექტორები შთამომავლების სელექტორებისგან განსხვავდება იმით, რომ ეხება მხოლოდ პირველი დონის ჩასმულ ელემენტებს. მაგალითად:
                  
                  <body>
                      <h2>სათაური</h2>
                      <div>
                          <p>ტექსტი</p>
                      </div>
                  </body>
                  მოცემულ მაგალითში body ელემენტისთვის ჩასმულ ელემენტებს წარმოადგენენ h2, div და p, მაგრამ მათგან შვილი ელემენტი მხოლოდ ორია - h2 და div, რადგან იმყოფებიან პირველ დონეზე. 
                  
                  შვილი ელემენტებისადმი მიმართვის სელექტორში გამოიყენება კუთხოვანი ფრჩხილი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              .article > p{            
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <div class="article">
                              <p>სტატიის ანოტაცია</p>
                              <div class="content">
                                  <p>სტატიის ტექსტი</p>
                              </div>
                          </div>
                      </body>
                  </html>
                   
                  
                  ბლოკში კლასით "article" არის ორი პარაგრაფი p, მაგრამ სელექტორი .article>p ეხება მხოლოდ იმ პარაგრაფს, რომელიც უშუალოდ .article ბლოკის შიგნითაა:
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩვენ რომ გამოგვეყენებინა სელექტორი ადგილის გამოტოვებით კუთხოვანი ფრჩხილის ნაცვლად, სტილი გავრცელდებოდა ყველა p ელემენტზე, რადგან მივიღებდით სელექტორს შთამომავლებისთვის:
                  
                  .article p{   
                      color: red;
                  }`
              },
              {
                  title:"სელექტორები ერთი დონის ელემენტებისთვის",
                  data:`ერთი დონის ელემენტებს მეორენაირად სიბლინგებს (siblings)  ან დებს უწოდებენ.მაგალითდ:

                  <body>
                      <h2>Заголовок</h2>
                      <div>
                          <p>Текст первого блока</p>
                      </div>
                      <div>
                          <p>Текст второго блока</p>
                      </div>
                  </body>
                   
                  
                  მოცემულ მაგალითში ელემენტი h2 და ორივე ელემენტი div წარმოადგენს ერთი დონის ელემენტებს. ხოლო პარაგრაფის ელემენტები p არ წარმოადგენენ მათთვის იგივე დონის ელემენტებს, რადგან ისინი div ელემენტების შიგნით იმყოფებიან. 
                  
                  ერთ დონეზე მყოფი პირველი მომდევნო ელემენტის სტილიზაციისთვის სელექტორში გამოიყენება + ნიშანი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h2+div { color: red; }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <div>
                              <p>პირველი ბლოკის ტექსტი</p>
                          </div>
                          <div>
                              <p>მეორე ბლოკის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  სელექტორი h2+div საშუალებას იძლევა მოხდეს სტილიზაცია იმ div ბლოკის, რომელიც უშუალოდ h2 ელემენტის შემდეგ მოდის:
                  
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ამ სელექტორით div ბლოკის სტილიზაცია ხდება მხოლოდ იმ შემთხვევაში, თუ ის უშუალოდ h2 ელემენტის შემდეგაა. თუ შუაში სხვა ელემენტიც იქნება, სელექტორი div ბლოკს არ შეეხება.
                  
                  თუ ჩვენ გვინდა მოვახდინოთ h2 ელემენტთან ერთ დონეზე მყოფი ყველა div ელემენტის სტილიზაცია, მაშინ +-ს ნაცვლად უნდა გამოვიყენოთ სიმბოლო ~ :
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h2~div { color: red; }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <p>ანოტაცია</p>
                          <div>
                              <p>პირველი ბლოკის ტექსტი</p>
                          </div>
                          <div>
                              <p>მეორე ბლოკის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ფსევდოკლასები",
                  data:`ტეგების (ელემენტების), კლასების და იდენტიფიკატორების გარდა არსებობს ასევე სელექტორები ფსევდოკლასებისთვის, რომლებიც გვაძლევენ დამატებით შესაძლებლობებს. ჩამოვთვალოთ ისინი:

                  :root: საშუალებას გვაძლევს ავირჩიოთ ვებგვერდის ამოსავალი ელემენტი. ყველაზე ნაკლებგამოყენებადი სელექტორია, რადგან ვებგვერდზე ამოსავალი ელემენტი თითქმის ყოველთვის არის <html>
                  :link: გამოიყენება ბმულებისთვის და წარმოადგენს მათ ჩვეულებრივ მდგომარეობაში, ანუ როცა ამ ბმულიდან გადასვლა ჯერ არ განხორციელებულა
                  :visited: გამოიყენება ბმულებისთვის და წარმოადგენს ბმულს, რომლითაც გადასვლა უკვე განხორციელდა
                  :active: გამოიყენება ბმულებისთვის და წარმოადგენს მათ იმ მომენტისთვის, როცა მასზე ხდება დაჭერა
                  :hover: წარმოადგენს ელემენტს იმ მომენტში, როცა მისკენ მიმართულია მაუსი. ძირითადად გამოიყენება ბმულებისთვის, თუმცა შეიძლება გამოვიყენოთ სხვა ელემენტებისთვისაც, მაგალითად პარაგრაფისთვის
                  :focus: წარმოადგენს ელემენტს, რომელსაც მიღებული აქვს ფოკუსი მაუსით დაწერის ან Tab კლავიშით ელემენტზე გადასვლის დროს 
                  :not: შესაძლებლობას გვაძლევს გამოვრიცხოთ რაღაც ელემენტები სიიდან, რომელთათვისაც გამოიყენება სტილი
                  :lang: გვაძლევს საშუალებას ელემენტების სტილიზაციისთვის lang ატრიბუტის მიხედვით
                  :empty: ირჩევს ელემენტებს, რომლებიც ცარიელია, ანუ არ გააჩნიათ ჩასმული ელემენტები
                  ფსევდოკლასების წინ ყოველთვის იწერება ორწერტილი. მაგალითად, მოვახდინოთ ბმულების სტილიზაცია ფსევდოკლასების გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              a:link    {color:blue; text-decoration:none}
                              a:visited {color:pink; text-decoration:none}
                              a:hover   {color:red; text-decoration:underline}
                              a:active  {color:yellow; text-decoration:underline}
                              input:hover {border:2px solid red;}
                          </style>
                      </head>
                      <body>
                          <a href="index.html">CSS3-ის სახელმძღვანელო</a>
                          <input type="text" />
                      </body>
                  </html>
                   
                  
                  სელექტორი :not
                  
                  სელექტორი :not საშუალებას გვაძლევს ავირჩიოთ გარკვეული ტიპის ყველა ელემენტი, გარდა :not-ით მონიშნულისა, ანუ გამოვრიცხოთ რაღაც ელემენტები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:not(.blueLink) { color: red; }
                          </style>
                      </head>
                      <body>
                          <a>პირველი ბმული</a><br/>
                          <a class="blueLink">მეორე ბმული</a><br/>
                          <a>მესამე ბმული</a>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სელექტორი a:not(.blueLink) მიუთითებს, რომ სტილი გამოიყენება ყველა ბმულისთვის, გარდა იმათი, რომელთაც აქვთ კლასი "blueLink". ფრჩხილებში ფსევდოკლასს not  ეთითება ის ელემენტები, რომელთა ამოღებაც გვინდა სტილიდან.
                  
                  ფსევდოკლასი :lang
                  
                  ფსევდოკლასი :lang ირჩევს ელემენტებს  lang ატრიბუტის მიხედვით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              :lang(ka) {
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                             
                              <p lang="ka-GE">მე ვსწავლობ CSS3</p>
                              <p lang="ru-RU">Я изучаю CSS3</p>
                              <p lang="en-US">I study CSS3</p>
                          </form>
                      </body>
                  </html>`
              },
              {
                  title:"ფსევდოკლასები შვილი ელემენტებისთვის",
                  data:`ფსევდოკლასების ცალკე ჯგუფს შეადგენს ფსევდოკლასები შვილი ელემენტებისთვის, რომლებიც საშუალებას გვაძლევენ ავარჩიოთ განსაზღვრული შვილი ელემენტები:

                  :first-child: პირველი შვილი ელემენტი
                  :last-child: ბოლო შვილი ელემენტი
                  :only-child: ელემენტი, რომელიც ერთადერთია კონტეინერში
                  :only-of-type: ელემენტი, რომელიც ერთადერთი ამ ტიპის ელემენტია კონტეინერში
                  :nth-child(n): შვილი ელემენტი, რომელიც არის რიგით n კონტეინერში, მაგალითად, მეორე ელემენტი
                  :nth-last-child(n): შვილი ელემენტი, რომელიც არის რიგით n ბოლოდან კონტეინერში, მაგალითად, ბოლოდან მეორე ელემენტი
                  :nth-of-type(n): განსაზღვრული ტიპის შვილი ელემენტი, რომელიც არის რიგით n კონტეინერში
                  :nth-last-of-type(n): განსაზღვრული ტიპის შვილი ელემენტი, რომელიც არის რიგით n ბოლოდან კონტეინერში
                  ფსევდოკლასი first-child
                  
                  გამოვიყენოთ ფსევდოკლასი :first-child ბლოკში პირველი ბმულისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:first-child{            
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <h3>პლანშეტები</h3>
                          <div>
                              <a>Microsoft Surface Pro 4</a><br/>
                              <a>Apple iPad Pro</a><br/>
                              <a>ASUS ZenPad Z380KL</a>
                          </div>
                          <h3>სმარტფონები</h3>
                          <div>
                              <p>ტოპ-სმარტფონები 2016</p>
                              <a>Samsung Galaxy S7</a><br/>
                              <a>Apple iPhone SE</a><br/>
                              <a>Huawei P9</a>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სელექტორი a:first-child-ით განსაზღვრული სტილი გამოიყენება იმ ბმულებისთვის, რომელიც პირველი ელემენტია ნებისმიერი კონტეინერის შიგნით.
                  
                  პირველ ბლოკში ბმული პირველი ელემენტია, ამიტომ მასზე ვრცელდება სელექტორით განსაზღვრული სტილი. ხოლო მეორე ბლოკში ბმული არაა პირველი ელემენტი (პირველი ელემენტია პარაგრაფი), ამიტომ მასზე სტილი არ ვრცელდება.
                  
                  ფსევდოკლასი last-child
                  
                  გამოვიყენოთ ფსევდოკლასი :last-child ბლოკში ბოლო ბმულისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:last-child{            
                                  color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <h3>სმარტფონები</h3>
                          <div>
                              <a>Samsung Galaxy S7</a><br/>
                              <a>Apple iPhone SE</a><br/>
                              <a>Huawei P9</a>
                          </div>
                          <h3>პლანშეტები</h3>
                          <div>
                              <a>Microsoft Surface Pro 4</a><br/>
                              <a>Apple iPad Pro</a><br/>
                              <a>ASUS ZenPad Z380KL</a>
                              <p>2016 წლის მონაცემები</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი :last-child-ით განსაზღვრული სტილი გამოიყენება იმ ბმულებისთვის, რომელიც ბოლო ელემენტია ნებისმიერი კონტეინერის შიგნით.
                  
                  პირველ ბლოკში ბმული ბოლო ელემენტია, ამიტომ მასზე ვრცელდება სელექტორით განსაზღვრული სტილი. ხოლო მეორე ბლოკში ბმული არაა ბოლო ელემენტი (ბოლო ელემენტია პარაგრაფი), ამიტომ მასზე სტილი არ ვრცელდება.
                  
                  სელექტორი only-child
                  
                  სელექტორი :only-child გამოიყენება იმ ელემენტებისათვის, რომლებიც ერთადერთი შვილი ელემენტია თავის კონტეინერში:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                          p:only-child{
                              color:red;
                          }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <div>
                              <p>ტექსტი1</p>
                          </div>
                          <div>
                              <p>ტექსტი2</p>
                              <p>ტექსტი3</p>
                          </div>
                          <div>
                              <p>ტექსტი4</p>
                          </div>
                      </body>
                  </html>
                  მოცემულ მაგალითში ტექსტი1 და ტექსტი4 წარმოადგენენ ერთადერთ ელემენტს თავის კონტეინერში, ამიტომ მათზე ვრცელდება ფსევდოკლასით განსაზღვრული სტილი, ხოლო ტექსტი2 და ტექსტი3 ერთიდაიმავე კონტეინერშია მოთავსებული, შესაბამისად არ არიან ერთადერთნი თავის კონტეინერში და მათზე სტილი არ ვრცელდება.
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი only-of-type
                  
                  ფსევდოკლასი :only-of-type არჩევს ელემენტებს, რომლებიც ერთადერთი ამ ტიპის ელემენტია კონტეინერში. სხვა ტიპის ელემენტები იმავე კონტეინერში შეიძლება იყოს ნებისმიერი რაოდენობით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                          span:only-of-type{        
                              color: green;   /* зеленый цвет */
                          }
                          p:only-of-type{        
                              color: red; /* წითელი */
                          }
                          div:only-of-type{        
                              color: blue;    /* ლურჯი */
                          }
                          </style>
                      </head>
                      <body>
                          <div>
                              სათაური
                          </div>
                          <p>ერთადერთი პარაგრაფი და <span>ელემენტი span</span></p>
                          <div>
                              ფუტერი
                          </div>
                      </body>
                  </html>
                  თუმცა სტილი განსაზღვრულია divელემენტებისთვის, იგი არ იქნება გამოყენებული, ვინაიდან body ელემენტის შიგნით რამდენიმე div ელემენტია. სამაგიეროდ, body-ში არის ერთადერთი პარაგრაფი და მასზე გავრცელდება p:only-of-type სელექტორით განსაზღვრული სტილი. ასევე, p პარაგრაფში არის მხოლოდ ერთი ელემენტი span, შესაბამისად მასზე გავრცელდება შესაბამისი სტილი.
                  
                  HTML5-ის დოკუმენტი
                  
                  
                  
                  ფსევდოკლასი nth-child
                  
                  ფსევდოკლასი :nth-child საშუალებას  იძლევა მოხდეს ყოველი მეორე, ყოველი მესამე და ა. შ. ან კენტ ან ლუწ ადგილზე მყოფი ელემენტის სტილიზაცია. მაგალითად, მოვახდინოთ ცხრილის კენტი და ლუწი სტრიქონების სტილიზაცია:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              tr:nth-child(odd) { background-color: #32F39F; }
                              tr:nth-child(even) { background-color: #F5EE31; }
                          </style>
                      </head>
                      <body>
                          <h3>სმარტფონები</h3>
                          <table>
                              <tr><td>Samsung</td><td>Galaxy S7 Edge</td><td>60000</td></tr>
                              <tr><td>Apple</td><td>iPhone SE</td><td>39000</td></tr>
                              <tr><td>Microsoft</td><td>Lumia 650</td><td>13500</td></tr>
                              <tr><td>Alcatel</td><td>Idol S4</td><td>30000</td></tr>
                              <tr><td>Huawei</td><td>P9</td><td>60000</td></tr>
                              <tr><td>HTC</td><td>HTC 10</td><td>50000</td></tr>
                              <tr><td>Meizu</td><td>Pro 6</td><td>40000</td></tr>
                              <tr><td>Xiaomi</td><td>Mi5</td><td>35000</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  კენტი ელემენტების სტილიზაციისთვის სელექტორს პარამეტრად გადაეცემა odd:
                  
                  tr:nth-child(odd){background-color: #32F39F;}
                  ლუწი ელემენტების სტილიზაციისთვის სელექტორს პარამეტრად გადაეცემა even:
                  
                  tr:nth-child(even){background-color: #F5EE31;}
                  ასევე პარამეტრად შეიძლება გადავცეთ რიგითი ნომერი:
                  
                  tr:nth-child(3){background-color: #bbb;}
                  ამ შემთხვევაში ხდება რიგით მესამე ელემენტის სტილიზაცია.
                  
                  კიდევ ერთი შესაძლებლობაა ამ ფსევდოკლასის გამოყენების - შეგვიძლია პარამეტრად გადავცეთ ფორმულა n-ის შემცველობით:
                  
                  tr:nth-child(2n+1){background-color: #bbb;}
                  ამ შემთხვევაში სტილიზაცია ხდება იმ ელემენტების, რომელთა რიგით ნომერსაც მივიღებთ n-ის ნაცვლად მთელი რიცხვების ჩასმით დაწყებული 0-დან, ანუ 2*0+1=1,2*1+1=3,2*2+1=5 და ა. შ. ე.ი. მოხდება სტილიზაცია პირველი, მესამე, მეხუთე, მეშვიდე და ა. შ. ელემენტების.
                  
                  თუ ჩენ გვინდა ყოველი მესამე ელემენტის სტილიზაცია, დაწყებული მე-2-დან, უნდა დავწეროთ:
                  
                  tr:nth-child(3n+2){background-color: #bbb;}
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასს :nth-last-child გააჩნია ზუსტად იგივე ფუნქციონალი, ოღონდ ათვლა იწყება ბოლოდან:
                  
                  tr:nth-last-child(2){background-color: #81F760;}
                  tr:nth-last-child(2n+1){background-color: #83E3F8;}`
              },
              {
                  title:"ფორმის ფსევდოკლასები",
                  data:`რიგი ფსევდოკლასებისა გამოიყენება ფორმის ელემენტებთან სამუშაოდ:

                  :enabled: ელემენტები, რომლებიც ხელმისაწვდომია (ანუ რომელთაც არა აქვთ ატრიბუტი disabled)
                  :disabled: ელემენტები, რომლებიც არაა ხელმისაწვდომი (ანუ რომელთაც აქვთ ატრიბუტი disabled)
                  :checked: ელემენტები, რომელთაც აქვთ ატრიბუტი checked (ალმებისა და გადამრთველებისთვის (რადიოღილაკებისთვის))
                  :default: ელემენტი, რომელიც არის უპირატესი
                  :valid: ელემენტი, რომელიც გადის HTML5 ვალიდაციას
                  :invalid: ელემენტი, რომელიც ვერ გადის HTML5 ვალიდაციას
                  :in-range: ელემენტი, რომლის მნიშვნელობა გარკვეულ დიაპაზონშია (გამოიყენება ელემენტისთვის მცოცავი ველი)
                  :out-of-range: ელემენტები, რომელთა მნიშვნელობა გარკვეულ დიაპაზონს გარეთაა
                  :required: ელემენტები, რომელთაც მინიჭებული აქვთ ატრიბუტი required
                  :optional: ელემენტები, რომელთაც არა აქვთ მინიჭებული ატრიბუტი required
                  ფსევდოკლასები enabled და disabled
                  
                  ფსევდოკლასები enabled და disabled გამოიყენება იმის მიხედვით, აქვს თუ არა ელემენტს მინიჭებული ატრიბუტი disabled:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :enabled {
                                  border: 2px blue solid;
                                  color: green;
                              }
                              :disabled {
                                  border: 2px black solid;
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <p><input type="text" value="Enabled" /></p>
                          <p><input type="text" disabled value="Disabled" /></p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი checked
                  
                  ფსევდოკლასი :checked გამოიყენება ფორმის იმ ელემენტებისათვის, რომელთაც აქვთ ატრიბუტი checked:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :checked + span {
                                  color: red;
                                  font-weight: bold;            }
                          </style>
                      </head>
                      <body>
                              <h2>აირჩიეთ ტექნოლოგია</h2>
                              <p>
                                  <input type="checkbox" checked name="html5"/><span>HTML5</span>
                              </p>
                              <p>
                                  <input type="checkbox" name="dotnet"/><span>.NET</span>
                              </p>
                              <p>
                                  <input type="checkbox" name="java"/><span>Java</span>
                              </p>
                              
                              <h2>მიუთითეთ სქესი</h2>
                              <p>
                                  <input type="radio" value="man" checked name="gender"/><span>კაცი</span>
                              </p>
                              <p>
                                  <input type="radio" value="woman" name="gender"/><span>ქალი</span>
                              </p>
                      </body>
                  </html>
                  სელექტორი :checked+span საშუალებას გვაძლევს ავირჩიოთ span ელემენტი, რომელიც მოსდევს მონიშნულ ელემენტს:
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი default
                  
                  ფსევდოკლასი :default განკუთვნილია იმ ელემენტის სტილიზაციისთვის, რომელიც უპირატესია ფორმაზე. როგორც წესი, ასეთ ელემენტს ფორმაზე წარმოადგენს გაგზავნის ღილაკი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :default {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <input name="login"/>
                              <input type="submit" value="შესვლა" />
                          </form>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  
                  
                  ფსევდოკლასები valid და invalid
                  
                  ფსევდოკლასები valid და invalid ახდენენ ელემენტების სტილიზაციას იმის მიხედვით, გადიან ისინი ვალიდაციას თუ არა:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              input:invalid {
                                  border: 2px solid red;
                              }
                              input:valid {
                                  border: 2px solid green;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p><input type="text" name="login" placeholder="მომხმარებელი" required /></p>
                              <p><input type="password" name="password" placeholder="პაროლი" required /></p>
                              <input type="submit" value="შესვლა" />
                          </form>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასები in-range და out-of-range
                  
                  ფსევდოკლასები in-range და out-of-range გამოიყენება იმის მიხედვით, არის თუ არა ელემენტის მნიშვნელობა გარკვეულ დიაპაზონში ან მის გარე. ეს პირველ რიგში ეხება ელემენტს <input type="number" >.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :in-range {
                                  border: 2px solid green;
                              }
                              :out-of-range {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="age">თქვენი ასაკი:</label>
                                  <input type="number" min="1" max="100" value="10" id="age" name="age"/>
                              </p>
                              <input type="submit" value="შესრულება" />
                          </form>
                      </body>
                  </html>
                  აქ ატრიბუტები min და max განსაზღვრავს დიაპაზონს, რომელშიც უნდა იყოს მნიშვნელობა:
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასები required და optional
                  
                  ფსევდოკლასები required და optional გამოიყენება იმის მიხედვით, აქვს თუ არა ელემენტს ატრიბუტი required:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :optional {
                                  border: 2px solid blue;
                              }
                              :required {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="login">მომხმარებელი:</label>
                                  <input type="text" id="login" name="login" required />
                              </p>
                              <p>
                                  <label for="password">პაროლი:</label>
                                  <input type="password" id="password" name="password" required />
                              </p>
                              <p>
                                  <label for="name">სახელი:</label>
                                  <input type="text" id="name" name="name"/>
                              </p>
                              <input type="submit" value="რეგისტრაცია" />
                          </form>
                      </body>
                  </html>`
              },
              {
                title:"ფსევდოელემენტები",
                data:`ფსევდოელემენტები იძლევა დამატებით შესაძლებლობებს ვებგვერდის ელემენტების სტილიზაციისთვის და ჰგვანან ფსევდოკლასებს. ფსევდოელემენტებია:

                ::first-letter: იძლევა ტექსტის პირველი ასოს სტილიზაციის საშუალებას
                
                ::first-line: ახდენს ტექსტის პირველი სტრიქონის სტილიზაციას
                
                ::before: ამატებს შეტყობინებას (ტექსტს) ელემენტის წინ
                
                ::after: ამატებს შეტყობინებას (ტექსტს) ელემენტის შემდეგ
                
                ::selection: მომხმარებლის მიერ მონიშნული ტექსტის სტილიზაცია
                
                CSS2-ში ფსევდოელემენტების წინ, ისევე როგორც ფსევდოკლასების წინ იწერებოდა ერთი ორწერტილი, CSS3-ში ფსევდოელემენტების წინ იწერება ორი ორწერტილი, რათა გაემიჯნათ ფსევდოკლასებისგან. თუმცა ძველი ბრაუზერების თავსებადობისთვის დასაშვებია ერთი ორწერტილის გამოყენებაც - :before.
                
                ტექსტის სტილიზაციისთვის გამოვიყენოთ first-letter и first-line:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            ::first-letter { color:red; font-size: 25px; }
                            ::first-line { font-size: 20px; }
                        </style>
                    </head>
                    <body>
                        <p>ყმაწვილი კაცი... აღვწეროთ მისი პორტრეტი ერთი კალმის მოსმით.
                            წარმოიდგინეთ დონ კიხოტი, ოღონდ 18 წლისა; დონ კიხოტი მსუბუქად
                            ჩაცმული, უჯავშნოდ და უმუზარადოდ, დონ კიხოტი ლურჯი შალის ქურთუკით,
                            რომელიც ისე გახუნებულიყო, რომ რაღაც უცნაური, მომწვანო ცისფერი
                            მიეღო, წარმოიდგინეთ გრძელი და შავგვრემანი პირისახე; ამოწეული
                            ყვრიმალი — ცხადი ნიშანი ცბიერებისა; ყბები მეტისმეტად განვითარებული —
                            ამ ნიშნით გამოირჩევა გასკონელი, თუნდ ბერეტიც არ ეხუროს, ჩვენს გმირს კი
                            ეხურა სწორედ ასეთი ბერეტი, რომელიც რაღაც ფრთით დაემშვენებინა. </p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გამოვიყენოთ ფსევდოელემენტები before და after:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            .warning::before{ content: "ყურადღება! "; font-weight: bold; }
                            .warning::after { content: " იყავით ფრთხილად!"; font-weight: bold;}
                        </style>
                    </head>
                    <body>
                        <p><span class="warning">ნუ შეყოფთ ენას დენის წყაროში.</span></p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                აქ ფსევდოელემენტები გამოყენებულია ელემენტებისთვის კლასით "warning". ორივე ფსევდოელემენტს გააჩნია თვისება "content" რომელშიც ინახება დასამატებელი ტექსტი. ასევე ორივე ელემენტს გამუქებული აქვს შრიფტი, რისთვისაც გამოყენებულია თვისება font-weight: bold;.
                
                გამოვიყენოთ ფსევდოელემენტი selection მონიშნული ტექსტის სტილიზაციისთვის:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            ::selection {
                                color: white;
                                background-color: #DD0F0F;
                            }
                        </style>
                    </head>
                    <body>
                        <p>ფსევდოელემენტები CSS3-ში იძლევა ტექსტის სტილიზაციის საშუალებას.</p>
                    </body>
                </html>`
            },
            {
                title:"ატრიბუტთა სელექტორები",
                data:`ელემენტთა სელექტორების გარდა შეიძლება გამოვიყენოთ სელექტორები მათი ატრიბუტებისთვის. მაგალითად, ვებგვერდზე გვაქვს რამდენიმე ელემენტი input, მაგრამ გვინდა მხოლოდ ტექსტური ელემენტების ჩარჩოს ფერი იყოს წითლი. სწორედ ამ დროს გამოიყენება სელექტორები ატრიბუტებისთვის:

                input[type="text"]{    
                    border: 2px solid red;
                }
                ელემენტის შემდეგ კვადრატულ ფრჩხილებში მოდის ატრიბუტი და მისი მნიშვნელობა. ამ შემთხვევაში ყველა ტექსტურ ველს ექნება წითელი ჩარჩო 2 პიქსელი სისქის:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ატრიბუტთა სელექტორები</title>
                        <style>
                            input[type="text"]{
                                border: 2px solid red;
                            }
                        </style>
                    </head>
                    <body>
                        <p><input type="text" id="login" /></p>
                        <p><input type="password" id="password" /></p>
                        <input type="submit" value="გაგზავნა" />
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ატრიბუტების სელექტორის გამოყენება შეიძლება არა მხოლოდ ელემენტებისთვის, არამედ კლასებისა და იდენტიფიკატორებისთვისაც. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ატრიბუტთა სელექტორები</title>
                        <style>
                            .link[href="http://apple.com"]{            
                                color: red;
                            }
                        </style>
                    </head>
                    <body>
                        <a class="link" href="http://microsoft.com">Microsoft</a> |
                        <a class="link" href="https://google.com">Google</a> |
                        <a class="link" href="http://apple.com">Apple</a>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სპეციალური სიმბოლოებით სესაძლებელია მოხდეს ატრიბუტთა მნიშვნელობის დაკონკრეტება. მაგალითად, სიმბოლო ^ საშუალებას იძლევა ავარჩიოთ ყველა ატრიბუტი, რომელიც იწყება განსაზღვრული ტექსტით. მაგალითად, ვთქვათ გვინდა მოვახდინოთ სტილიზაცია ყველა ბმულის, რომელიც იყენებს https პროტოკოლს, ანუ იწყება "https://"-ით. ამისთვის გამოვიყენებთ შემდეგ სელექტორს:
                
                a[href^="https://"]{   
                    color: red;
                }
                თუ ატრიბუტის მნიშვნელობა უნდა ბოლოვდებოდეს გარკვეული ტექსტით, უნდა გამოვიყენოთ სიმბოლო $. მაგალითად, გვინდა ავირჩიოთ ყველა სურათი გაფართოებით .jpg. ამისთვის უნდა მოვძებნოთ ყველა ელემენტი, რომლის ატრიბუტი src ბოლოვდება ".jpg"-ით:
                
                img[src$=".jpg"]{      
                    width: 100px;
                }
                კიდევ ერთი სიმბოლო * საშუალებას გვაძლევს ავარჩიოთ ის ელემენტები, რომელთა ატრიბუტის მნიშვნელობა შეიცავს გარკვეულ ტექსტს (არა აქვს მნიშვნელობა თავში, ბოლოში თუ შუაში):
                
                a[href*="microsoft"]{   
                    color: red;
                }   `
            },
            {
                title:"სტილების მემკვიდრეობითობა",
                data:`სტილების განსაზღვრის გასამარტივებლად სტილებს გააჩნია მემკვიდრეობითობა. ჩასმულ ელემენტებს შეუძლიათ მიიღონ მათი მშობელი ელემენტის სტილები. ვთქვათ ვებგვერდზე გვაქვს პარაგრაფი და სათაური, რომელთაც უნდა ჰქონდეთ წითელი ფერი. ჩვენ შეგვიძლია თითოეულს ცალ-ცალკე განვუსაზღვროთ შრიფტის ფერი:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების მემკვიდრეობითობა</title>
                        <style>
                            p {color: red;}
                            h2 {color: red;}
                        </style>
                    </head>
                    <body>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </body>
                </html>
                მაგრამ ვინაიდან ორივე ეს ელემენტი არის ელემენტ body-ს შიგნით, მათ შეუძლიათ ბევრი სტილი მემკვიდრეობით მიიღონ body-სგან:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების მემკვიდრეობითობა</title>
                        <style>
                            body {color: red;}
                        </style>
                    </head>
                    <body>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </body>
                </html>
                მივიღებთ იგივე შედეგს.
                
                თუ არ გვინდა, რომ რომელიმე ელემენტმა მემკვიდრეობით მიიღოს სტილი მშობლისგან, შეგვიძლია ამ ელემენტს თვითონ განვუსაზღვროთ სტილი:
                
                     body {color: red;}
                     p {color: green;}
                მრავალდონიანი ჩასმული ელემენტების შემთხვევაში სტილის მემკვიდრეობით მიღება ხდება მხოლოდ უშუალო მშობლისგან:
                
                 
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სტილების მემკვიდრეობითობა</title>
                    <style>
                        body {
                            color: red;
                        }
                        div {
                            color: green;
                        }
                    </style>
                </head>
                <body>
                    <div>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </div>
                    <p>Copyright © MyCorp.com</p>
                </body>
                </html>
                 
                
                რადგან div ელემენტისთვის ცალკეა განსაზღვრული სტილი, მასში შემავალი ელემენტები მისგან იღებენ მემკვიდრეობით სტილს, ხოლო ელემენტი p რომელიც უშუალოდ body-ს შიგნითაა, იგი სტილს მემკვიდრეობით body-სგან ღებულობს:
                
                HTML5-ის დოკუმენტი
                
                მაგრამ CSS-ის ყველა თვისებისთვის არ მოქმედებს მემკვიდრეობითობის პრინციპი. მემკვიდრეობით არ გადაეცემა ტექსტის დაშორებები (margin, padding) და ჩარჩოები (border).
                
                გარდა ამისა ბრაუზერები, იმ შემთხვევაში, თუ სპეციალურად არაა განსაზღვრული, ცალკეული ელემენტების მიმართ იყენებენ განსაზღვრულ სტილებს. მაგალითად, სათაურებს (h1-h6) აქვთ გარკვეული სიმაღლე და ა. შ.`
            },
            {
                title:"სტილების კასკადურობა",
                data:`როცა ელემენტისთვის გამოიყენება ერთი სტილი, ყველაფერი შედარებით მარტივია. მაგრამ როცა ერთ ერთ ელემენტზე რამდენიმე სტილი მოქმედებს, ისმება კითხვა, რომელ სტილს მიიღებს ელემენტი?

                CSS-ში მოქმედებს კასკადურობის მექანიზმი, როგორც წესების ერთობლიობა, რომელიც განსაზღვრავს ერთი და იმავე ელემენტზე ბევრი სტილის მოქმედების თანმიმდევრობას.
                
                ვნახოთ მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            .redLink {color: red;}  /* ტექსტის წითელი ფერი */
                            .footer a {font-weight: bold;}  /* შრიფტის გამუქება */
                            a {text-decoration: none;}  /*ხაზგასმის მოხსნა */
                        </style>
                    </head>
                    <body>
                        <p class="footer">დამატებითი ინფორმაციისთვის გადადით ბმულზე:
                            <a class="redLink" href="css3.html">CSS3-ის საფუძვლები</a></p>
                    </body>
                </html>
                CSS-ში განსაზღვრულია სამი სტილი და სამივე მიესადაგება ბმულს. თუ ვებგვერდის ელემენტს მიესადაგება რამდენიმე სტილი, რომელიც ერთმანეთთან კონფლიქტში არ მოდის, ისინი ერთიანდება ერთ სტილში. მოცემულ შემთხვევაში სტილები ერთმანეთთან კონფლიქტში არ მოდის, შესაბამისად ბმულზე იმოქმედებს სამივე:
                
                HTML5-ის დოკუმენტი
                
                თუ სტილები კონფლიქტში მოდიან ერთმანეთთან, ამ შემთხვევაში მოქმედებს თითოეული სტილის მნიშვნელობის განსაზღვრის რთული სისტემა. ყველა ეს წესი აღწერილია CSS-ის სპეციფიკაციაში, რომლის სანახავად შეგიძლიათ გადახვიდეთ ბმულზე Calculating a selectors specificity. მოკლედ გავარჩიოთ ეს წესი.
                
                ელემენტის სტილის განსაზღვრისთვის გამოიყენება მრავალი სელექტორი. თითოეულის მნიშვნელობა ელემენტისთვის განისაზღვრება ქულებით. რაც უფრო მეტი ქულა აქვს სელექტორს, მით უფრო მეტია მისი მნიშვნელობა ელემენტისთვის და მას გააჩნია უფრო მაღალი პრიორიტეტი სხვა სელექტორებით განსაზღვრულ სტილებთან შედარებით.
                
                ტეგის სელექტორის მნიშვნელობა განისაზღვრება 1 ქულით
                კლასის, ატრიბუტის და ფსევდოკლასის მნიშვნელობა განისაზღვრება 10 ქულით
                იდენტიფიკატორის სელექტორის მნიშვნელობა განისაზღვრება 100 ქულით
                ელემენტში ჩაშენებული ინლინე-სტილის მნიშვნელობა განისაზღვრება 1000 ქულით
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            #index {color: navy;}   /* ტექსტის მუქი ლურჯი ფერი */
                            .redLink {color: red; font-size: 20px;} /* ტექსტის ფერი წითელი და შრიფტის ზომა 20 პიქსელი */
                            a {color: black; font-weight: bold;}    /* ტექსტის შავი ფერი და გამუქება */
                        </style>
                    </head>
                    <body>
                        <a id="index" class="redLink" href="index.php">CSS3-ის საფუძვლები</a>
                    </body>
                </html>
                მოცემულ მაგალითში ბმულისთვის განსაზღვრულია ერთდროულად 3 სტილი. მათ შორის 2 ერთმანეთთან კონფლიქტში არაა:
                
                font-size: 20px;
                font-weight: bold;
                ვინაიდან განსაზღვრულია მხოლოდ ერთ სტილში, შესაბამისად ისინი შეჯამდება და ორივე შეცვლის ბმულის სტილს.
                
                მაგრამ სამივე სტილი შეიცავს ტექსტის სხვადასხვა ფერს, შესაბამისად ისინი ერთმანეთთან კონფლიქტში მოდიან. მაგრამ ვინაიდან იდენტიფიკატორის სტილის მნიშვნელობა ელემენტისთვის უფრო მაღალია, ვიდრე კლასის და ტეგის სტილის, საბოლოოდ ელემენტს ექნება მუქი ლურჯი ფერი:
                
                #index {color: navy;} 
                თუ სელექტორი შედგენილია, მაშინ ხდება ქულების დათვლა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            a {font-size: 18px;}
                            .nav li a {color: red;}
                            #menu a {color: navy;} 
                            .nav .menuItem {color: green;}
                            a.menuItem:not(.newsLink) {color: orange;}
                            div ul li a {color: gray; }
                        </style>
                    </head>
                    <body>
                        <div id="menu">
                            <ul class="nav">
                                <li><a class="menuItem">მთავარი</a></li>
                                <li><a class="menuItem">ფორუმი</a></li>
                                <li><a class="menuItem">ბლოგი</a></li>
                                <li><a class="menuItem">საიტის შესახებ</a></li>
                            </ul>
                        </div>
                    </body>
                </html>
                CSS-ში განსაზღვრულია ხუთი სტილი, რომლებიც ბმულის ფერს ადგენს. იმისათვის, რომ გავიგოთ, რა ფერი ექნება ბმულს, შევადგინოთ ცხრილი:
                
                სელექტორი	იდენტიფიკატორი	კლასი	ტეგი	ჯამი
                .nav li a	0	1	2	12
                #menu a	1	0	1	101
                .nav .menuItem	0	2	0	20
                a.menuItem:not(.newsLink)	0	2	1	21
                div ul li a	0	0	4	4
                როგორც ცხრილიდან ჩანს, სელექტორს #menu a აქვს ყველაზე მაღალი ქულა 101, შესაბამისად ბმულის ფერსაც ის განსაზღვრავს და იქნება მუქი ლურჯი.
                
                წესი !important
                
                CSS-ში არის საშუალება სელექტორების მნიშვნელობებს ავუაროთ გვერდი. ამისთვის არსებობს ბრძანება !important:
                
                a {font-size: 18px; color: red !important;}
                #menu a {color: navy;}
                ასეთ დროს მიუხედავად სხვა სელექტორის არსებობისა უფრო მაღალი ქულებით, გამოიყენება წითელი ფერი, რადგანაც მონიშნულია ბრძანებით  !important.`
            },
           
            ]
        },
        {
            title:"თავი 6. CSS3-ის საფუძვლები. თვისებები",
            content:[
                {
                    title:"ფერი CSS-ში",
                    data:`CSS-ში ფართო გამოყენება აქვს ფერებს. ფერი ენიჭება ტექსტს, ფონს, ჩარჩოებს. მაგალითად, div ელემენტის ფონს მივანიჭოთ წითელი ფერი:

                    div{
                        background-color: red;
                    }
                     
                    
                    CSS-ში არის რამდენიმე თვისება, რომელსაც უნდა მიენიჭოს ფერი. ტექსტის ფერის მისანიჭებლად გამოიყენება თვისება color, ფონისთვის - border-color, ჩარჩოს ფერისთვის - border-color.
                    
                    ფერის განსაზღვრისთვის რამდენიმე ხერხი არსებობს:
                    
                    თექვსმეტობითი რიცხვი - თექვსმეტობით სისტემაში ხდება წითელი, მწვანე და ლურჯი ფერის მნიშვნელობების კოდირება. მაგალითად, #1C4463. პირველი ორი სიმბოლო 1C აღნიშნავს წითელს, მომდევნო ორი - 44 მწვანეს, ბოლო ორი - 63 ლურჯს. საბოლოო ფერი მიიღება ამ ფერების შეზავებით. თუ ყველა წყვილი განმეორებადი სიმბოლოებისგან შედგება, შეიძლება მათი შემცირება თითომდე, მაგალითად #5522AA-ს ნაცვლად შეიძლება ჩავწეროთ #52A, #eeeeee-ს ნაცვლად - #eee. ამასთან, რეგისტრს მნიშვნელობა არა აქვს.
                    RGB მნიშვნელობა - RGB წარმოადგენს წითელი, მწვანე და ლურჯი ფერების რიცხვით მნიშვნელობათა თანმიმდევრობას (Red - წითლი, Green - მწვანე, Blue - ლურჯი). რიცხვითი მნიშვნელობა შეიძლება იყოს გამოსახული პროცენტებში (0-დან 100 %-მდე) ან რიცხვებით (0-დან 255-მდე). მაგალითად:
                      background-color: rgb(100%,100%,100%);
                    აქ თითოეულ ფერს აქვს მნიშვნელობა 100%, შედეგად მივიღებთ თეთრ ფერს. თუ სამივე ფერი იქნებოდა 0%, მივიღებდით შავს.
                    
                    უფრო ხშირად გამოიყენება არა პროცენტული, არამედ რიცხვითი მნიშვნელობები. მაგალითად:
                    
                      background-color: rgb(28,68,99);
                    RGBA მნიშვნელობა - ეს იგივეა, რაც RGB, რომელსაც დამატებული აქვს გამჭვირვალობის კოეფიციენტი (Alpha). ის ღებულობს მნიშვნელობას 0-დან (სრულიად გამჭვირვალე) 1-მდე (გაუმჭვირვალე). მაგალითად:
                      background-color: rgb(28, 68, 99, 0.6);
                    HSL მნიშვნელობა - HSL წარმოადგენს აბრევიატურას: Hue - ტონი, Saturation - გაჯერებულობა, Lightness - განათებულობა. Hue არის კუთხე ფერების წრეში 0-დან 360 გრადუსამდე. Saturation მიუთითებს, რამდენად გაჯერებულია ფერი. იგი გამოისახება პროცენტებით 0-დან 100 %-მდე. Lightness განათებულობა ასევე პროცენტებში გამოისახება და ღებულობს მნიშვნელობას 0-დან (განათებულობის არარსებობა, ანუ შავი) 100%-მდე (მთლიანად განათებული, ანუ თეთრი). სუფთა ფერის მისაღებად გამოიყენება 50 %. მაგალითად:
                      background-color: hsl(206, 56%, 25%);
                    ეს ფერი წარმოადგენს #1C4463 და rgb(28, 68, 99) ფერების ეკვივალენტს.
                    
                    HSLA მნიშვნელობა - RGBA-ს ანალოგიურად მიიღება HSL-ისგან გამჭვირვალობის (Alpha)დამატებით. მაგალითად:
                      background-color: hsl(206, 56%, 25%, 0.6);
                    ტექსტური მნიშვნელობა - ზოგიერთი ფერისთვის არსებობს ტექსტური მნიშვნელობა, მაგალითად red - წითელი, green - მწვანე, blue - ლურჯი, yellow - ყვითელი და ა. შ. მაგალითად:
                      background-color: darkblue;
                    darkblue - მუქი ლურჯი, წარმოადგენს #00008B-ს ეკვივალენტს.
                    
                    გამჭვირვალობა
                    
                    ფერების მნიშვნელობებში გათვალისწინებულია გამჭვირვალობა (RGBA, HSLA). თუმცა CSS-ში არის ცალკე თვისებაც, რომელიც განსაზღვრავს გამჭვირვალობას. ეს თვისებაა opacity. ის ღებულობს მნიშვნელობას 0-დან (სრულად გამჭვირვალე) 1-მდე (გაუმჭვირვალე). მაგალითად:
                    
                    div{
                        width: 100px;
                        height: 100px;
                        
                        background-color: red;
                        opacity: 0.4;
                    }`
                },
                {
                  title:"შრიფტების სტილიზაცია",
                  data:`თვისება font-family განსაზღვრავს შრიფტის ოჯახს. მაგალითად:

                  body{
                      font-family: Arial;
                  }
                  მოცემულ შემთხვევაში გამოიყენება შრიფტი Arial. 
                  
                  ეს თვისება იმუშავებს მხოლოდ იმ შემთხვევაში, თუ მომხმარებელს კომპიუტერზე გააჩნია ასეთი შრიფტი. ამიტომ უპირატესად გამოიყენება ისეთი შრიფტები, რომლებიც ფართოდაა გავრცელებული, როგორიცაა Arial, Verdana და ა. შ. ასევე ხშირად ეთითება რამდენიმე შრიფტი. მაგალითად:
                  
                  body{
                      font-family: Arial, Verdana, Helvetica;
                  }
                  ამ შემთხვევაში ძირითადი შრიფტია Arial. თუ მომხმარებელს ეს შრიფტი არ აღმოაჩნდა, გამოიყენება მეორე - Verdana და ა. შ.
                  
                  თუ შრიფტის დასახელება რამდენიმე სიტყვისგან შედგება, უნდა ჩავსვათ ბრჭყალებში:
                  
                  body{
                      font-family: "Times New Roman";
                  }
                  კონკრეტული შრიფტების გარდა შეიძლება მიეთითოს საერთო უნივერსალური შრიფტები, რაც გამოისახება მნიშვნელობით sans-serif და serif:
                  
                  body{
                      font-family: Arial, Verdana, sans-serif;
                  }
                  შრიფტის სისქე
                  
                  თვისება font-weight განსაზღვრავს შრიფტის სისქეს. ის იღებს 9 მნიშვნელობას: 100,200,300,...,900. 100 ძალიან წვრილიდან 900 ძალიან სქელამდე.
                  
                  რეალობაში ძირითადად გამოიყენება ორი მნიშვნელობა: normal (ნორმალური, ჩვეულებრივი) და bold (ნახევრადსქელი):
                  
                  font-weight: normal;
                  font-weight: bold;
                  შრიფტის დახრა
                  
                  თვისება font-style საშუალებას გვაძლევს გამოვიყენოთ დახრილი შრიფტი. ამისთვის გამოიყენება მნიშვნელობა italic:
                  
                  font-style: italic;
                  თუ გვინდა დახრის გაუქმება,გამოიყენება მნიშვნელობა normal:
                  
                  font-style: normal;
                  შრიფტის ფერი
                  
                  თვისება color განსაზღვრავს შრიფტის ფერს:
                  
                  p {
                      color: red;
                  }`
              },
              {
                  title:"გარე შრიფტები",
                  data:`სტანდარტული შრიფტების გამოყენება ყოველთვის არ არის მისაღები. ხშირად საჭიროა რაღაც განსხვავებული შრიფტის გამოყენება, რომელიც არაა ფართოდ გავრცელებული და მომხმარებლის კომპიუტერზე შეიძლება არ აღმოჩნდეს. ასეთ შემთხვევაში გამოიყენება თვისება font-face:

                  @font-face {   
                              font-family: 'unicode_3d';
                              src: url(3d_unicode.ttf);
                           }
                  src ატრიბუტის მნიშვნელობა არის შრიფტის მისამართი. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სტილების კასკადურობა</title>
                      <style>
                          @font-face {   
                              font-family: 'unicode_3d';
                              src: url(3d_unicode.ttf);
                           }
                          @font-face {
                              font-family: 'bpg_extramt';
                              src: url(bpg_extrasquare_mtavruli_2009.ttf);
                          }
                          .mtavr {
                              font-family: bpg_extramt;           
                          }
                          .daxr {
                              font-family: unicode_3d;
                          }
                      </style>
                  </head>
                  <body>
                      <p class="mtavr">იყო არაბეთს როსტევან, მეფე ღმრთისაგან სვიანი,</p>
                      <p class="daxr">მაღალი, უხვი, მდაბალი, ლაშქარმრავალი, ყმიანი...</p>
                  </body>
                  </html> 
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  არსებობს შრიფტის სხვადასხვა ფორმატი: TrueType( გაფართოება ttf), Open Type (გაფართოება otf), Embedded Open Type (გაფართოება eot), Web Open Font Format (woff/woff2), Scalable Vector Graphic (svg). სხვადასხვა ბრაუზერს შეიძლება ჰქონდეს სხვადასხვა ტიპის შრიფტის მხარდაჭერა. ამ პრობლემის გადასაჭრელად, ხშირად შრიფტის შემქმნელები ერთი და იგივე შრიფტს ქმნიან სხვადასხვა ფორმატში და შესაძლებელია ერთდროულად რამდენიმე ფორმატის მითითება:
                  
                  @font-face {   
                     font-family:'FontAwesome';
                     src: url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.eot');
                     src: url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.eot?#iefix') format('embedded-opentype'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.woff2') format('woff2'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.woff') format('woff'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.ttf') format('truetype'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.svg') format('svg');
                  }
                  შრიფტის სხვადასხვა ვერსია
                  
                  ხანდახან შრიფტი შედგება არა ერთი, არამედ რამდენიმე ფაილისგან, მაგალითად შრიფტს ცალკე ფაილებში შეიძლება ჰქონდეს bold, italic, bold-italic და ა. შ. ვერსიები. ასეთ შემთხვევაში იქმნება რამდენიმე font-face და ფაილის მისამართთან ერთად ეთითება შრიფტის ტიპი. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Regular.ttf);
                                  font-weight: normal;
                                  font-style: normal;
                              }
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Italic.ttf);
                                  font-weight: normal;
                                  font-style: italic;
                              }
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Bold.ttf);
                                  font-weight: bold;
                                  font-style: normal;
                              }            
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-BoldItalic.ttf);
                                  font-weight: bold;
                                  font-style: italic;
                              }
                              p{
                                  font-family: Roboto;
                              }
                          </style>
                      </head>
                      <body>
                          <p>Font Roboto <i>Italic</i>, <b>Bold</b>, <b><i>Bold Italic</i></b></p>
                      </body>
                  </html> 
                   `
              },
              {
                  title:"შრიფტის ზომა",
                  data:`შრიფტისთვის ზომის მისაცემად გამოიყენება თვისება font-size:

                  div{
                      font-size: 18px;
                  }
                  მოცემულ მაგალითში შრიფტის ზიმა (სიმაღლე) არის 18 პიქსელი. პიქსელი წარმოადგენს ყველაზე ხშირად გამოყენებულ ზომის ერთეულს. ის არინიშნება "px"-ით, რომელიც იწერება რიცხვითი მნიშვნელობის შემდეგ.
                  
                  თუ ტექსტის ზომას არ მივუთითებთ, ჩვეულებრივი ტექსტისთვის შრიფტის ზომა იქნება 16 პიქსელი. სხვადასხვა ბაზურ ელემენტს სხვადასხვა სტანდარტული შრიფტის ზომა გააჩნია. მაგალითად, თუ პარაგრაფისთვის (p) იგი 16 პიქსელის ტოლია, h1 სათაურისთვის ის 32 პიქსელია, h2-სთვის 24 პიქსელი და ა. შ.
                  
                  შრიფტის ზომისთვის ასევე გამოიყენება სხვადასხვა ზომის ერთეულები.
                  
                  შრიფტის ტექსტური ზომები
                  
                  CSS-ში არის შემდეგი შრიფტის ზომები:
                  
                  medium: საბაზისო ზომა (16 პიქსელი)
                  small: 13 პიქსელი
                  x-small: 10 პიქსელი
                  xx-small: 9 პიქსელი
                  large: 18 პიქსელი
                  x-large: 24 პიქსელი
                  xx-large: 32 პიქსელი
                  მაგალითად:
                  
                  font-size: x-large;
                  
                  შრიფტის ზომა პროცენტებით
                  
                  პროცენტები საშუალებას გვაძლევს შრიფტის ზომა მივუთითოთ პროცენტებით საბაზისო ან მემკვიდრეობით მიღებული შრიფტის ზომისგან. მაგალითად:
                  
                  font-size: 150%;
                  
                  ამ შემთხვევაში შრიფტის ზომა იქნება საბაზისო ზომის (16px) 150% ანუ 24 px.
                  
                  შრიფტის ზომის პროცენტებით მითითებისას მემკვიდრეობითობამ შეიძლება შეცვალოს შრიფტის საბოლოო ზომა. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              div {font-size: 10px;}
                              p {font-size: 150%;}
                          </style>
                      </head>
                      <body>
                      <div>
                          <p>შრიფტის ზომა მემკვიდრეობითობის გათვალისწინებით.</p>
                      </div>
                      </body>
                  </html>
                  მოცემულ მაგალითში პარაგრაფი p ელემენტისგან div მემკვიდრეობით იღებს შრიფტის ზომას 10 პიქსელს. შესაბამისად, შრიფტის საბაზისო ზომა მისთვის იქნება არა 16, არამედ 10 პიქსელი, საიდანაც დაითვლება p სელექტორში მითითებული 150 % და მივიღებთ საბოლოო შრიფტის ზომას 15 პიქსელს.
                  
                  ზომის ერთეული em
                  
                  ზომის ერთეული em პროცენტის მსგავსია. 1em არის 100%, 0.5em - 50% და ა. შ.`
              },
              {
                  title:"ტექსტის ფორმატირება",
                  data:`თვისება text-transform ცვლის შრიფტის რეგისტრს. შეიძლება მიიღოს შემდეგი მნიშვნელობები:

                  capitalize: სიტყვის პირველი ასო გადაჰყავს მაღალ რეგისტრში
                  uppercase: მთლი სიტყვა გადაჰყავს მაღალ რეგისტრში
                  lowercase: მთელი სიტყვა გადაჰყავს დაბალ რეგისტრში 
                  none: სიმბოლოების რეგისტრი არ იცვლება
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>
                          
                          <style>
                              p.lowercase {text-transform: lowercase;}
                              p.uppercase {text-transform: uppercase;}
                              p.capitalize { text-transform: capitalize;}
                          </style>
                      </head>
                      <body>
                      <div>
                          <p class="capitalize">Text with capitalize</p>
                          <p class="lowercase">Text with lowercase</p>
                          <p class="uppercase">Text with uppercase</p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება text-decoration
                  
                  თვისება text-decoration უმატებს ტექსტს დამატებით ეფექტს. მან შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                  
                  underline: ტექსტის ხაზგასმა (გახაზვა ქვემოდან)
                  overline: ტექსტის გახაზვა ზემოდან
                  line-through: ტექსტის გადახაზვა
                  none: ტექსტზე არ გამოიყენება დეკორატიული ეფექტები
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              p.under {
                                  text-decoration: underline;
                              }
                              p.over {
                                  text-decoration: overline;
                              }
                              p.line {
                                  text-decoration: line-through;
                              }
                              p.mixed {
                                  text-decoration: underline line-through;
                              }
                              a.none {
                                  text-decoration: none;
                              }
                          </style>
                      </head>
                      <body>
                      <div>
                          <p class="under">ხაზგასმული ტექსტი</p>
                          <p class="over">ზემოდან გახაზული ტექსტი</p>
                          <p class="line">გადახაზული ტექსტი</p>
                          <p class="mixed">ხაზგასმული და გადახაზული ტექსტი</p>
                          <p>ეფექტის გარეშე <a href="index.php" class="none">ბმული<a></p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  საჭიროების შემთხვევაში შესაძლებელია მნიშვნელობების კომბინირება. ბოლოსწინა სტრიქონში ერთდროულად გამოყენებულია ხაზგასმა და გადახაზვა.
                  
                  დაშორება სიმბოლოებს შორის
                  
                  CSS-ის ორი თვისება შესაძლებლობას გვაძლევს დავარეგულიროთ ასოებსა და სიტყვებს შორის დაშორებები. ასოებს შორის ინტერვალის დასარეგულირებლად გამოიყენება თვისება letter-spacing, ხოლო სიტყვებს შორის ინტერვალისთვის - word-spacing. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              p.smallLetterSpace {
                                  letter-spacing: -1px;
                              }
                              p.bigLetterSpace {
                                  letter-spacing: 2px;
                              }
                              p.smallWordSpace{
                                  word-spacing: -1px;
                              }
                              p.bigWordSpace{
                                  word-spacing: 5px;
                              }
                          </style>
                      </head>
                      <body>
                      <div>
                          <h3>ჩვეულებრივი ტექსტი</h3>
                          <p>ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>letter-spacing: -1px;</h3>
                          <p class="smallLetterSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>letter-spacing: 1px;</h3>
                          <p class="bigLetterSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>word-spacing: -1px</h3>
                          <p class="smallWordSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>word-spacing: 1px</h3>
                          <p class="bigWordSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  text-shadow
                  
                  თვისება text-shadow -ის მეშვეობით შესაძლებელია ტექსტისთვის ჩრდილების მიცემა. მნიშვნელობა შედგება 4 პარამეტრისაგან: ჰორიზონტალური წანაცვლება, ვერტიკალური წანაცვლება, გაბნევის ხარისხი და ჩრდილის ფერი.მაგალითად:
                  
                  h1{
                      text-shadow: 5px 4px 3px #999;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ მაგალითში ჩრდილის წანაცვლება ხდება მარჯვნივ 5 პიქსელით, ქვევით 4 პიქსელით, გაბნევადობის ხარისხია 3 პიქსელი და ჩრდილის ფერი #999. თუ ჩრდილის წანაცვლება გვინდა მარცხნივ ან ზევით, სესაბამისი მნიშვნელობები უნდა იყოს უარყოფითი. მაგალითად:
                  
                  h1{
                      text-shadow: -5px -4px 3px #999;
                  }
                   `
              },
              {
                  title:"აბზაცების სტილიზაცია",
                  data:`CSS-ის თვისებების ცალკე ჯგუფი ემსახურება ტექსტის დიდი ფრაგმენტების სტილიზაციას. მათი მეშვეობით შესაძლებელია სტრიქონებს შორის დაშორების შეცვლა, ტექსტის გასწორება კიდეებზე და ა. შ.

                  line-height
                  
                  თვისების line-height დანიშნულებაა სტრიქონებს შორის დაშორების რეგულირება. მისი მნიშვნელობა გამოისახება პიქსელებით, პროცენტებით ან em ერთეულით. ძირითადად გამოიყენება პროცენტები და em. მაგალითად:
                  
                   
                  
                  p{
                      line-height: 150%;
                  }
                  თუ ეს თვისება არაა მინიჭებული, ამ შემთხვევაში გამოიყენება line-height:120%.
                  
                  HTML5-ის დოკუმენტი
                  
                  text-align
                  
                  თვისება text-align ემსახურება ტექსტის გასწორებას გვერდის კიდეების მიმართ. ის ღებულობს შემდეგ მნიშვნელობებს:
                  
                  left: ტექსტის გასწორება მარცხნივ
                  right: ტექსტის გასწორება მარჯვნივ
                  justify: გასწორება ორივე კიდის მიმართ სიტყვებს შორის დაშორებების ხარჯზე
                  center: გასწორება ცენტრში
                  მაგალითად:
                  
                  p{
                      text-align: left;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  text-indent
                  
                  თვისება text-indent არეგულირებს აბზაცის პირველი სტრიქონის დაშორებას კიდიდან. მნიშვნელობისთვის გამოიყენება სტანდარტული ზომის ერთეულები: px, em:
                  
                  p{
                      text-indent: 35px;
                  }
                   `
              },
              {
                  title:"სიების სტილიზაცია",
                  data:`list-style-type 

                  CSS-ში არის სპეციალური თვისებები სიების სტილიზაციისთვის. ერთ-ერთ ასეთ თვისებას წარმოადგენს list-style-type. მან შეიძლება მიიროს შემდეგი მნიშვნელობები დანომრილი სიებისთვის:
                 decimal: ათწილადები, ათვლა იწყება 1-დან
                 decimal-leading-zero: 0-ით დაწყებული ათწილადები: 01, 02, 03, ...,98,99
                 lower-roman: დაბალი რეგისტრის რომაული რიცხვები: i, ii, iii, iv, v
                 upper-roman: მაღალი რეგისტრის რომაული რიცხვები: I, II, III, IV, V…
                 lower-alpha: დაბალი რეგისტრის ლათინური ასოები: a, b, c..., z
                 upper-alpha: მაღალი რეგისტრის ლათინური ასოები: A, B, C, … Z
                 georgian: ქართული ანბანის ასოები: ა,ბ,გ,...ჰ
                 დაუნომრავი სიებისთვის:
                 
                 disc: შავი წრე
                 circle: წარიელი წრეწირი
                 square: შავი კვადრატი
                 როგორც დანომრილ, ასევე უნომრო სიებში მარკერის გამოსართავად გამოიყენება list-style-type:none.
                 
                 მაგალითად:
                 
                 ul{
                     list-style-type: square;
                 }
                  
                 ol{
                     list-style-type: georgian;
                 }
                  
                 
                 HTML5-ის დოკუმენტი
                 
                 თვისება list-style-type შეიძლება გამოვიყენოთ როგორც მთლიანად სიის, ასევე სიის ცალკეული ელემენტის მიმართ:
                 
                 <!DOCTYPE html>
                 <html>
                 <head>
                     <meta charset="utf-8">
                     <title>სიების სტილიზაცია</title>
                     <style>            
                             .decimal{
                                 list-style-type: decimal;
                             }
                             ol{
                                 list-style-type: upper-roman;
                             }
                         </style>
                     </head>
                     <body>
                         <ol>
                             <li>ელემენტი 1</li>
                             <li class="decimal">ელემენტი 2</li>
                             <li>ელემენტი 3</li>
                             <li>ელემენტი 4</li>
                         </ol>
                     </body>
                 </html>
                  
                 
                 HTML5-ის დოკუმენტი
                 
                 list-style-position
                 
                 list-style-position თვისების მეშვეობით შეგვიძლია ვცვალოთ სიის მარკერის პოზიცია. ღებულობს ორ მნიშვნელობას:
                 
                 outside: მარკერი გამოწეულია
                 inside მარკერი შეწეულია
                 HTML5-ის დოკუმენტი
                 
                 list-style-image
                 
                 list-style-image თვისება საშუალებას გვაძლევს სიის მარკერად გამოვიყენოთ სურათი:
                 
                 <ul style="list-style-image:url(phone.jpeg);">
                         <li>iPhone 6S</li>
                         <li>Galaxy S7</li>
                         <li>Nexus 5X</li>
                         <li>Lumia 950</li>
                     </ul>
                 მნიშვნელობაში გადაეცემა იმ სურათის მისამართი, რომელიც უნდა გამოვიყენოთ მარკერად.`
              },
              {
                  title:"ცხრილების სტილიზაცია",
                  data:`CSS-ში განსაზღვრულია თვისებები, რომელთა მეშვეობით შესაძლებელია ცხრილების სტილიზაცია:

                  border-collapse: მიმდებარე უჯრებს შორის ჩარჩოს სტილიზაცია
                  border-spacing: მიმდებარე უჯრებს შორის არის სტილიზაცია
                  caption-side: განსაზღვრავს სათაურის მდებარეობას
                  empty-cells: სარიელი უჯრების დახატვის რეჟიმი
                  table-layout: განსაზღვრავს ცხრილის ზომებს
                  ჩარჩოები
                  
                  ცხრილის ჩარჩოებისთვის ადრე გამოიყენებოდა ატრიბუტი border, მაგალითად:
                  
                  <table border="2px" >
                  მაგრამ დღეისათვის ტენდენციაა ყველანაირი სტილიზაცია მოხდეს CSS-ის სტილების მეშვეობით. ამისთვის CSS-ში არის თვისება border:
                  
                  table {
                      border: 1px solid #ccc;  /* მთელი ცხრილის ჩარჩო */
                  }
                  tr {
                      border: 1px solid #ccc;  /* ჩარჩო სტრიქონებს შორის */
                  }
                  td, th {
                      border: 1px solid #ccc;  /* ჩარჩო სვეტებს შორის */
                  }
                  მიმდებარე უჯრებს შორის ჩარჩოების სტილიზაციისთვის იყენებენ თვისებას border-collapse, რომელსაც აქვს შემდეგი მნიშვნელობები:
                  
                  collapse: მიმდებარე უჯრებს საერთო ჩარჩო აქვთ
                  separate: მიმდებარე უჯრებს თავ-თავისი ჩარჩო აქვთ, რომელთა შორის სიცარიელეა
                  თუ მიმდებარე უჯრებს ცალ-ცალკე ჩარჩო აქვთ, border-spacing თვისების მეშვეობით შეიძლება ვცვალოთ ჩარჩოებს შორის დაშორება:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }        
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .collapsed{
                              border-collapse: collapse;
                          }
                          .separated{
                              border-collapse: separate;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Collapse</h3>
                          <table class="collapsed">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td>Apple</td><td>630</td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Separate</h3>
                          <table class="separated">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                              <tr><td>HTC 10</td><td>HTC</td><td>545</td></tr>
                              <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ცარიელი უჯრები
                  
                  თვისება empty-cells განსაზღვრავს, გამოცნდეს ცარიელი უჯრები თუ არა. მისი მნიშვნელობებია:
                  
                  show: ცარიელი უჯრის გამოჩენა (მნიშვნელობა მიუთითებლობისას)
                  hide:  ცარიელი უჯრის დამალვა
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }
                          
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .hidden-empty-cells{
                              empty-cells: hide;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Collapse</h3>
                          <table>
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td></td><td></td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Separate</h3>
                          <table class="hidden-empty-cells">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                              <tr><td>HTC 10</td><td></td><td></td></tr>
                              <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სათაურის პოზიცია
                  
                  caption-side თვისების მეშვეობით შესაძლებელია ცხრილის სათაურის პოზიციის შეცვლა. ღებულობს შემდეგ მნიშვნელობებს:
                  
                  top: ცხრილის ზემოთ (მნიშვნელობა მიუთითებლობისას)
                  
                  bottom: ცხრილის ქვემოთ
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }        
                          caption {
                          
                              font-weight: bold;
                          }        
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .captionBottom{
                              caption-side: bottom;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Top</h3>
                          <table>
                              <caption>ფლაგმანები</caption>
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td>Apple</td><td>630</td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Bottom</h3>
                          <table class="captionBottom">
                                  <caption>სიახლეები</caption>
                                  <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                                  <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                                  <tr><td>HTC 10</td><td>HTC</td><td>545</td></tr>
                                  <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>   
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ცხრილის ზომები
                  
                  table-layout თვისების მეშვეობით შესაძლებელია ცხრილის ზომების მართვა. მიუთითებლად მისი მნიშვნელობა არის auto, რომლის დროსაც სვეტის სიგანე ამ სვეტის ყველაზე გრზელი უჯრის სიგანის ტოლია. ცალკეული სვეტების სიგანეთა ჯამი შეადგენს ცხრილის სიგანეს. თუ table-layout თვისებას მივანიჭებთ მნიშვნელობას fixed, ცხრილს შეიძლება მივანიჭოთ ფიქსირებული სიგანე:
                  
                  table {
                      border: 1px solid #ccc;
                      border-spacing: 3px;
                      table-layout: fixed;
                      width:350px;
                  }
                  უჯრების ტექსტის ვერტიკალური გასწორება
                  
                  როგორც წესი, უჯრის შიგთავსი ვერტიკალურად შუაში თავსდება, თუმცა vertical-align თვისების მეშვეობით შეგვიძლია პოზიციის ცვლილება. მისი მნიშვნელობებია:
                  
                  top: გასწორება ზემოთ
                  baseline: ტექსტის პირველი სტრიქონის გასწორება ზემოთ
                  middle: გასწორება შუაში
                  bottom: გასწორება ქვემოთ
                  თვისება vertical-align გამოიყენება მხოლოდ <th> და <td> ელემენტებისთვის:
                  
                  td, th{
                      border: solid 1px #ccc;
                      vertical-align: bottom;
                      height: 30px;
                  }`
              },{
                title:"ბლოკისებური მოდელი",
                data:`ბრაუზერისთვის გვერდის ელემენტები წარმოადგენენ კონტეინერებს ანუ ბლოკებს. ასეთ ბლოკებს შეიძლება ჰქონდეთ სხვადასხვა შიგთავსი - ტექსტი, სურათი, სია, ცხრილი და სხვა. ბლოკის შიდა ელემენტები თვითონაც გამოდიან ბლოკების როლში. 

                სქემატურად ბლოკისებური მოდელი შეიძლება შემდეგნაირად გამოვსახოთ:
                
                HTML5-ის დოკუმენტი
                
                ყველა ელემენტი მოთავსებულია გარკვეულ კონტეინერში. ეს შეიძლება იყოს body, div და ა. შ. სხვა ელემენტებისაგან ის გამოყოფილია ერთგვარი სივრცით - გარე დაშორებით, რომელიც CSS-ში აღიწერება თვისებით margin. ანუ margin თვისება განსაზღვრავს ელემენტის დაშორებას სხვა ელემენტებისგან ან კონტეინერის კიდედან. 
                
                ამის შემდეგ მოდის თვითონ ელემენტი, რომელიც იწყება ჩარჩოთი. ჩარჩოს CSS-ში განსაზღვრავს თვისება border.
                
                ჩარჩოს შემდეგ მოდის ელემენტის შიდა დაშორება, რომელიც CSS-ში განისაზღვრება თვისებით padding. შიდა დაშორება განსაზღვრავს მანძილს ელემენტის საზღვრიდან მის შიგთავსამდე. 
                
                ამის მერე მოდის შიდა ელემენტები, რომელთაც ასევე აქვთ ბლოკისებური მოდელი. 
                
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკური მოდელი</title>
                        <style>
                            div{
                                margin: 15px; /* გარე დაშორება */
                                padding: 11px; /* შიდა დაშორება */
                                border: 3px solid red; /* ჩარჩო - 3 პიქსელი სისქის უწყვეტი წითელი ხაზი */
                            }
                        </style>
                    </head>
                    <body>
                        <div>
                            <p>პირველი ბლოკი</p>
                        </div>
                        <div>
                            <p>მეორე ბლოკი</p>
                        </div>
                    </body>
                </html>
                ბრაუზერში გაშვების შემდეგ ჩვენ დავინახავთ კონკრეტული ელემენტების ბლოკისებურ მოდელს. ამისათვის მაუსის მარჯვენა კლავიშით გამოსულ კონტექსტურ მენიუში უნდა ავირჩიოთ შესაბამისი ბრძანება. სხვადასხვა ბრაუზერში ამ ბრძანებას სხვადასხვა სახელი აქვს. Google Chrome-ში უნდა ავირჩიოთ ბრძანება Inspect:
                
                 HTML5-ის დოკუმენტი
                
                Mozilla Firefox-ში და  Microsoft Edge-ში შესაბამის ბრძანებას ჰქვია Inspect element.
                
                ამ ბრძანების შესრულების მერე გაჩნდება პანელი, რომელშიც მოცემულია ელემენტის კოდი, მისი სტილი და ბლოკისებური მოდელი:
                
                HTML5-ის დოკუმენტი
                
                თუ არ მივუთითებთ margin, padding და border თვისებების მნიშვნელობებს, ბრაუზერი მათ მიანიჭებს სტანდარტულ მნიშვნელობებს.`
            },{
                title:"გარე დაშორებები (margin)",
                data:`margin თვისება განსაზღვრავს ელემენტის დაშორებას სხვა ელემენტებისგან ან კონტეინერის საზღვრებიდან. CSS-ში არსებობს სპეციალური თვისებები თითოეული მხარისათვის:

                margin-top: დაშორება ზემოდან
                margin-bottom: დაშორება ქვემოდან
                margin-left: დაშორება მარცხნიდან
                margin-right: დაშორება მარჯვნიდან
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div{
                                margin-top: 30px; /* დაშორება ზემოდან */
                                margin-left: 25px; /* დაშორება მარცხნიდან */
                                margin-right: 20px; /* დაშორება მარჯვნიდან */
                                margin-bottom: 15px; /* დაშორება ქვემოდან */                
                                border: 3px solid red; /* საზღვარი */
                            }
                        </style>
                    </head>
                    <body>
                        <div>
                            <p>პირველი ბლოკი</p>
                        </div>
                        <div>
                            <p>მეორე ბლოკი</p>
                        </div>
                        <div>
                            <p>მესამე ბლოკი</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                შეიძლება 4 თვისების ნაცვლად გამოვიყენოთ ერთი:
                
                margin: 30px 20px 15px 25px;
                თვისება ენიჭება შემდეგი ფორმატით:
                
                margin: დაშორება_ზემოდან დაშორება_მარჯვნიდან დაშორება_ქვემოდან დაშორება_მარცხნიდან;
                თუ ყველა დაშორება ერთნაირია, შეგვიძლია მივუთითოთ მხოლოდ ერთხელ:
                
                margin: 25px;
                ამ შემთხვევაში დაშორება ყველა მხარეს იქნება 25 პიქსელი.
                
                დაშორების მნიშვნელობა შეიძლება მივუთითოთ პიქსელებში (px), em ერთეულებში, პროცენტული მნიშვნელობებში, ასევე შეიძლება მივუთიტოთ მნიშვნელობა auto - ამ შემთხვევაში დაშორება იქნება სტანდარტული.
                
                მაგალითად:
                
                margin: 2em;
                მნიშვნელობა 2em ნიშნავს, რომ დაშორება ელემენტის შრიფტის ზომაზე 2-ჯერ მეტია.
                
                პროცენტების გამოყენებისას ბრაუზერი დაშორებას ითვლის იმ კონტეინერის სიგანიდან გამომდინარე, რომელშიც მოქცეულია ელემენტი.
                
                როცა რამდენიმე ელემენტი არის მიმდებარედ, ბრაუზერი დაშორებას ანიჭებს ამ ორი ელემენტის შესაბამისი დაშორებებიდან უდიდესის მნიშვნელობით. ზემოთ მოყვანილ მაგალითში :
                
                 
                
                div{
                    margin-top: 30px; /* დაშორება ზემოდან */
                    margin-left: 25px; /* დაშორება მარცხნიდან */
                    margin-right: 20px; /* დაშორება მარჯვნიდან */
                    margin-bottom: 15px; /* დაშორება ქვემოდან */
                }
                დაშორება პირველ და მეორე ელემენტს შორის იქნება 30 პიქსელი, რადგან მეორე ელემენტის დაშორება ზემოდან არის 30 პიქსელი და ის მეტია პირველი ელემენტის დაშორებაზე ქვემოდან (15 პიქსელი).`
            },{
                title:"შიდა დაშორებები (padding)",
                data:`თვისება padding განსაზღვრავს დაშორებებს ელემენტის საქღვრებიდან სიგთავსამდე. ისევე როგორც margin-ისთვის, CSS-ში შიდა დაშორებებისთვისაც არის თვისებები, რომლებიც განსაზღვრავს შიდა დაშორებას თითოეული მხარისთვის:

                padding-top: დაშორება ზემოდან
                padding-bottom: დაშორება ქვემოდან
                padding-left: დაშორება მარცხნიდან
                padding-right: დაშორება მარჯვნიდან
                მაგალითად:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div.outer{                
                                margin: 25px;
                                
                                padding-top:30px;
                                padding-right: 25px;
                                padding-bottom: 35px;
                                padding-left: 28px;
                                
                                border: 2px solid red;
                            }
                            div.inner{
                                
                                height: 50px;
                                background-color:blue;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            <div class="inner"></div>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ისევე როგორც mangin-ის შემთხვევაში, padding-ის მნიშვნელობა შეიძლება გამოისახოს პროცენტებით (ელემენტის ზომებიდან გამომდინარე).
                
                შიდა დაშორებების ჩაწერაც შეიძლება შემოკლებულად:
                
                padding: 30px 25px 35px 28px;
                თანმიმდევრობა აქაც იგივეა: დაშორება ზემოდან, დაშორება მარჯვნიდან, დაშორება ქვემოდან, დაშორება მარცხნიდან.
                
                თუ ოთხივე მნიშვნელობა ერთნაირია, შეიძლება მივუთიტოთ მხოლოდ ერთხელ:
                
                padding: 25px;`
            },{
                title:"ჩარჩოები",
                data:`ჩარჩო გამოყოფს ელემენტის შიგთავსს გარემოცვისაგან, ამავე დროს ჩარჩო წარმოადგენს ელემენტის შემადგენელ ნაწილს. 

                ჩარჩოს კონფიგურაციისთვის გამოიყენება რამდენიმე თვისება:
                
                border-width: ჩარჩოს სისქე
                border-style: ჩარჩოს სტილი
                border-color: ჩარჩოს ფერი
                ჩარჩოს სისქე border-width შეიძლება გამოისახოს px და em ერთეულებით:
                
                border-width: 2px;
                ასევე ჩარჩოს სისზე შეიძლება გამოისახოს კონსტანტებით: thin (თხელი - 1px), medium (საშუალო - 3 px), thick (სქელი - 5px).
                
                თვისება border-color მნიშვნელობად ღებულობს CSS-ის ფერებს:
                
                border-color: red;
                თვისება border-style განსაზღვრავს ჩარჩოს სტილს. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                none: ჩარჩოს გარეშე
                solid: ჩარჩო ჩვეულებრივი ხაზის სახით
                dashed: წყვეტილი ხაზი
                dotted: წერტილოვანი ხაზი
                double: წყვილი ხაზი
                groove: ხაზი სამგანზომილებიანი ეფექტით
                inset: ჩაზნექილი ხაზი
                outset: ამოზნექილი ხაზი
                ridge: ასევე სამგანზომილებიანი ეფექტით
                HTML5-ის დოკუმენტი
                
                საჭიროების შემთხვევაში ჩარჩოს სისქე, სტილი და ფერი შეიძლება განვსაზღვროთ თითოეული მხარისთვის ცალ-ცალკე: 
                
                /* ზედა ჩარჩო */
                border-top-width
                border-top-style
                border-top-color
                 
                /* ქვედა ჩარჩო */
                border-bottom-width
                border-bottom-style
                border-bottom-color
                 
                /* მარცხენა ჩარჩო */
                border-left-width
                border-left-style
                border-left-color
                 
                /* მარჯვენა ჩარჩო */
                border-right-width
                border-right-style
                border-right-color
                თვისება border
                
                ცალ-ცალკე თვისებების ნაცვლად შეიძლება გამოვიყენოთ ერთი თვისება border:
                
                border: სისქე სტილი ფერი;
                მაგალითად:
                
                border: 2px solid red;
                ცალ-ცალკე მხარეებისთვის გამოიყენება თვისებები:
                
                border-top
                border-bottom
                border-left
                border-right
                მაგალითად:
                
                border-top: 2px solid red;
                ჩარჩოს რადიუსი
                
                თვისება border-radius საშუალებას იძლევა მომრგვალდეს ჩარჩოს კუთხეები. იგი ღებულობს მნიშვნელობას px ან em ერთეულებში. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div{
                                width: 100px;
                                height:100px;
                                border: 2px solid red;
                                border-radius: 30px;
                            }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                ახლა ჩარჩოს ყველა კუთხე იქნება მომრგვალებული 30 პიქსელიანი რადიუსით:
                
                
                რადიუსი შეიძლება განისაზღვროს თითოეული კუთხისთვის ცალ-ცალკე. ამისთვის border-radius მიიღებს 4 მნიშვნელობას (ზედა მარცხენა, ზედა მარჯვენა, ქვედა მარჯვენა, ქვედა მარცხენა):
                
                border-radius: 15px 30px 5px 40px;
                 
                
                
                საერთო მნიშვნელობის ნაცვლად შეიძლება მივანიჭოთ მნიშვნელობები ცალ-ცალკე:
                
                border-top-left-radius: 15px;
                border-top-right-radius: 30px;
                border-bottom-right-radius: 5px;
                border-bottom-left-radius: 40px;
                შესაძლებელია კუთხე მომრგვალდეს ოვალურად, რისთვისაც გამოიყენება ორი რადიუსი:
                
                border-radius: 40px/20px;
                ამ დროს იგულისხმება, რომ X ღერძის მიმართ რადიუსი იქნება 40 პიქსელი, ხოლო Y ღერძის მიმართ - 20 პიქსელი:`
            },{
                title:"ელემენტის ზომები",
                data:`ელემენტებს ზომები ენიჭება თვისებებით width (სიგანე) და height (სიმაღლე).

                მიუთითებლობისას ამ თვისებების მნიშვნელობაა auto, ანუ ბრაუზერი ელემენტს ანიჭებს ამ ელემენტისთვის განკუთვნილ სტანდარტულ მნიშვნელობას. სიგანე და სიმაღლე გამოისახება ზომების სტანდარტული ერთეულებით: px და em, ასევე პროცენტებით:
                
                width: 150px;
                width: 75%;
                height: 15em;
                px - პიქსელი განსაზღვრავს ზუსტ სიგანეს და სიმაღლეს. em დამოკიდებულია ელემენტის შრიფტის ზომაზე - თუ შრიფტის ზომა 16 პიქსელია და ელემენტის ზომას მივუთითებთ 15em, ეს ნიშნავს რომ ზომა იქნება 15*16=240 px. თუ ელემენტს შრიფტის ზომა არა აქვს განსაზღვრული, აიღება მემკვიდრეობით მიღებული ზომა ან ზომა მიუთითებლობისას.
                
                პროცენტული მნიშვნელობა ნიშნავს, რომ ზომა გამოითვლება კონტეინერის ზომიდან პროცენტულად. მაგალითად, თუ body ელემენტის სიგანე 1000 პიქსელია, ხოლო მასში div ელემენტს სიგანე აქვს 75 %, ეს ნიშნავს, რომ ელემენტის სიგანე იქნება 1000*75/100=750 პიქსელი. თუ ბრაუზერის ფანჯრის სიგანეს შევცვლით, პროპორციულად შიცვლება div ელემენტის ზომა. ზუსტად ანალოგიურად ითვლება სიმაღლე პროცენტული მნიშვნელობისას - ოღონდ ამ შემთხვევაში კონტეინერის სიმაღლე მრავლდება მითითებულ პროცენტულ მნიშვნელობაზე.
                
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div.outer{
                            width: 75%;
                            height: 200px;
                            margin: 10px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                        }
                        div.inner{
                        
                            width: 80%;
                            height: 80%;
                            margin: auto;
                            border: 1px solid red;
                            background-color: blue;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            <div class="inner"></div>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ამავე დროს, ელემენტის ფაქტიური ზომები შეიძლება განსხვავდებოდეს width და height თვისებების მნიშვნელობებისაგან. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div.outer{
                            width: 200px;
                            height: 100px;
                            margin: 10px;
                            padding: 10px;
                            border: 5px solid #ccc;
                            background-color: #eee;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            ფაქტიური ზომები CSS3ში
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                როგორც სკრინშოტიდან ჩანს, თვისება width განსაზღვრავს ელემენტის შიგთავსს, ხოლო მთლიანად ბლოკისთვის გამოყოფილი ადგილი შედგება შიგთავსს (width) + შიდა დაშორება (padding) + ჩარჩოს სისქე (border-width) + გარე დაშორება (margin). შესაბამისად, თვითონ ელემენტის სიგანე ტოლი იქნება არა 200, არამედ 230 პიქსელისა ჩარჩოების ჩათვლით, ხოლო ელემენტისთვის გამოყოფილი სიგანე გარე დაშორების ჩათვლით იქნება 250 პიქსელი. ანალოგიურად გამოითვლება სიმაღლეც.
                
                დამატებითი თვისებების მეშვეობით შეიძლება შეიზღუდოს ელემენტის მინიმალური და მაქსიმალური ზომები:
                
                min-width: მინიმალური სიგანე
                max-width: მაქსიმალური სიგანე
                min-height: მინიმალური სიმაღლე
                max-height: მაქსიმალური სიმაღლე
                min-width: 200px;
                width:50%;
                max-width: 300px;
                ამ შემთხვევაში ელემენტის სიგანე მისი შემცველი კონტეინერის 50 %-ია, მაგრამ არანაკლებ 200 პიქსელისა და არაუმეტეს300 პიქსელისა.
                
                თვისება box-sizing
                
                box-sizing თვისების მეშვეობით შეიძლება შევცვალოთ ელემენტის ზომების დათვლის წესი. მან შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                
                content-box: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც ელემენტის რეალური ზომა შედგება width და height, მნიშვნელობებს დამატებული შიდა დაშორება და ჩარჩოს სისქე.
                padding-box: ამ დროს width და height მნიშვნელობები უკვე შეიცავენ შიდა დაშორებას და რეალური ზომის დასათვლელად ემატება მხოლოდ ჩარჩოს სისქე.
                border-box: ამ დროს width და height მნიშვნელობები უკვე შეიცავენ როგორც შიდა დაშორებებს, ასევე ჩარჩოს სისქესაც. შესაბამისად, width და height მნიშვნელობები შეადგენენ ელემენტის რეალურ ზომებს.
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div{
                            width: 200px;
                            height: 100px;
                            margin: 10px;
                            padding: 10px;
                            border: 5px solid #ccc;
                            background-color: #eee;
                        }
                        div.outer1{
                            box-sizing: content-box;
                        }
                        div.outer2{
                            box-sizing: border-box;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer1">
                            ელემენტის რეალური ზომები CSS3-ში
                        </div>
                        <div class="outer2">
                            ელემენტის რეალური ზომები CSS3-ში
                        </div>
                    </body>
                </html>
                პირველ შემთხვევაში ზომებს ემატება შიდა დაშორება და ჩარჩოს სისქე ამიტომ მისი ზომა უფრო დიდია:`
            },{
                title:"ელემენტის ფონი",
                data:`ელემენტის ფონი CSS-ში აღიწერება თვისებით background. ის ფაქტობრივად, ის წარმოადგენს შემდეგი თვისებების შემოკლებულ ვარიანტს:

                background-color: ფონის ფერი
                background-color: #ff0507;
                background-image: ელემენტის ფონად გამოიყენებს სურათს
                background-image: url(dubi.png);
                იგი ღებულობს ერთ მნიშვნელობას - url, რომელსაც მოსდევს ფრჩხილებში ჩასმული ფაილის მისამართი. მოცემულ შემთხვევაში იგულისხმება, რომ ვებგვერდთან ერთად იმავე საქაღალდეში არის ფაილი dubi.png. შეიძლება მიეთითოს ფაილის როგორც სრული მისამართი , ასევე ფარდობითი მისამართი:
                
                background-image: url(http://mysite.ge/files/dubi.png);
                background-image: url(../files/dubi.png);
                background-repeat: ფონური გამოსახულების განმეორების რეჟიმი
                background-size: ფონური გამოსახულების ზომა
                background-position: ფონური გამოსახულების მდებარეობა
                background-attachment: აწესრიგებს ფონური გამოსახულების ელემენტთან მიბმის რეჟიმს
                background-clip: განსაზღვრავს არეს, რომელიც ამოიჭრება სურათიდან და გამოიყენება ფონის სახით
                background-origin: განსაზღვრავს ფონური გამოსახულების საწყის პოზიციას
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 200px;
                            margin: 10px;
                     color: white;
                        }        
                        .colored{
                            background-color: #ff0507;
                        }        
                        .imaged{
                            background-image: url(kanioni.png);
                        }
                        </style>
                    </head>
                    <body>
                        <div class="colored">">პირველი ბლოკი</div>
                        <div class="imaged">">მეორე ბლოკი</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გამოსახულების გამეორება
                
                იმ შემთხვევაში, თუ ელემენტის ზომები მეტია ფონად გამოყენებული სურათის ზომებზე, ხდება სურათის გამეორება ისე, რომ ელემენტი მთლიანად შეივსოს ფონით. background-repeat თვისების მეშვეობით შესაძლებელია სურათის გამეორების მართვა. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                repeat-x: გამეორება მხოლოდ ჰორიზონტალურად
                repeat-y: გამეორება მხოლოდ ვერტიკალურად
                repeat: გამეორება ორივე მიმართულებით (მნიშვნელობა მიუთითებლობისას)
                space: სურათი მეორდება ელემენტის სრულად შესავსებად, მაგრამ არ წარმოქმნის არასრულ ფრაგმენტებს 
                round: ხდება სურათის მასშტაბირება ელემენტის სრულად შესავსებად
                no-repeat: სურათი არ მეორდება
                მაგალითად:
                
                background-image: url(nature.jpg);
                background-repeat: round;
                გამოსახულების ზომა
                
                background-size თვისების გამოყენებით შესაძლებელია შევცვალოთ ფონად გამოყენებული გამოსახულების ზომა. ზომები (თანმიმდევრობით სიგანე, სიმაღლე) შეიძლება მივუთითოთ სტანდარტული ზომის ერთეულებით (px, em), პროცენტებით ან ერთ-ერთი წინასწარ განსაზღვრული მუდმივათი:
                
                contain: ხდება სურათის მასშტაბირება უდიდესი მხარის მიხედვით პროპორციების შენარჩუნებით
                cover:ხდება სურათის მასშტაბირება უმცირესი მხარის მიხედვით პროპორციების შენარჩუნებით
                auto: მნიშვნელობა მიუთითებლობისას. სურათის ზომები არ იცვლება
                თუ გვინდა სურათის მასშტაბირება ისე, რომ მან სრულად შეავსოს ელემენტი გამეორებების გარეშე, სიგანეში და სიმაღლეში უნდა მივუთითოთ 100 %:
                
                background-size:100% 100%;
                ზომების მითითებისას ჯერ ეთითება სიგანე, მერე სიმაღლე:
                
                background-size:150px 100px;
                შეიძლება ერთი ზომა მივუთითოთ ზუსტად, მეორეში კი ჩავწეროთ auto და მეორე ზომას ბრაუზერი პროპორციულად გადათვლის:
                
                background-size:150px auto;
                 
                
                სურათის მდებარეობა
                
                background-position თვისება განსაზღვრავს ფონად გამოყენებული სურათის პოზიციას ელემენტის მიმართ. ის ღებულობს მნიშვნელობას ელემენტის მარცხენა ზედა კიდიდან ჰორიზონტალური და ვერტიკალური დაშორების სახით. მაგალითად:
                
                background-position: 30px 15px;
                ნიშნავს, რომ ფონის გამოსახულება მარცხენა კიდიდან დაშორებულია 30 პიქსელით, ხოლო ზემოთა კიდიდან - 15 პიქსელით.
                
                გარდა ამისა, აღნიშნულმა თვისებამ შესაძლოა მიიროს შემდეგი მნიშვნელობები:
                
                top: სურათი სწორდება ელემენტის ზედა კიდის მიმართ
                left: სურათი სწორდება ელემენტის მარცხენა კიდის მიმართ
                right:სურათი სწორდება ელემენტის მარჯვენა კიდის მიმართ
                bottom: სურათი სწორდება ელემენტის ქვედა კიდის მიმართ
                center: სურათი სწორდება ელემენტის ცენტრში
                მაგალითად:
                
                background-position: top right;
                აქ ფონის სურათი სწორდება ელემენტის ზედა და მარჯვენა კიდეებთან.
                
                background-attachment
                
                background-attachment თვისება განსაზღვრავს, თუ როგორ იქნება ფონის გამოსახულება მიმაგრებული ელემენტზე. ის ღებულობა შემდეგ მნიშვნელობებს:
                
                fixed: ფონი დაფიქსირებულია ელემენტის მიმართ და არ იცვლება ელემენტის შიგთავსის გადახვევისას (scroll)
                local: გადახვევისას (scroll) ელემენტის ფონი იცვლება (მიყვება გადახვევას)
                scroll: ფონი დაფიქსირებულია ელემენტის მიმართ და არ იცვლება ელემენტის შიგთავსის გადახვევისას (scroll). fixed-ისგან განსხვავებით, ამ შემთხვევაში ელემენტებს შესაძლებლობა აქვთ გამოიყენონ სხვადასხვა ფონი, fixed-ის შემთხვევაში ყველა ელემენტს საერთო ფონი აქვს.
                მაგალითად:
                
                div{
                    width: 300px;
                    height: 250px;    
                            
                    overflow:scroll;    /* გადახვევის დამატება  */
                    border: 1px solid #ccc;
                    
                    background-image: url(nature.png);
                    background-size: 512px 384px;
                    background-attachment: scroll;
                    background-repeat: no-repeat;
                }
                background-origin
                
                თვისება background-origin განსაზღვრავს პოზიციას, საიდანაც დაიწყება ელემენტის ფონის გამოსახულება. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                border-box: ფონი იწყება ელემენტის ჩარჩოდან
                padding-box: ფონი იწყება შიდა დაშორებიდან
                content-box: ფონი იწყება ელემენტის შიგთავსიდან
                გამოვიყენოთ სამივე მნიშვნელობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 155px;
                            margin: 10px;
                            display: inline-block;  /*მოვათავსოთ ბლოკები გვერდიგვერდ */
                            
                            padding:15px;
                            border: 15px solid rgba(0,0,165,0.2);
                            
                            background-image: url(tiger.jpg);
                            background-size: cover;
                            background-repeat: no-repeat;
                        }
                        .borderBox {background-origin: border-box;}
                        .paddingBox {background-origin: padding-box;}
                        .contentBox {background-origin: content-box;}
                        </style>
                    </head>
                    <body>
                        <div class="borderBox"></div>
                        <div class="paddingBox"></div>
                        <div  class="contentBox"></div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                
                background-clip
                
                background-clip თვისება განსაზღვრავს, სურატის რა ნაწილი გამოიყენება ფონად. ის ღებულობს იმავე მნიშვნელობებს, რასაც background-origin:
                
                border-box: სურათი ჩამოიჭრება ელემენტის ჩარჩოებთან
                padding-box: სურათი ჩამოიჭრება ელემენტის შიდა დაშორებასთან, ჩარჩოს ქვემოთ მოქცეული ნაწილი ჩამოიჭრება
                content-box: სურათი ჩამოიჭრება შიგთავსთან, შიდა დაშორებების ქვეშ მოქცეული ნაწილი ჩამოეჭრება
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 155px;
                            margin: 10px;
                            display: inline-block;  /*მოვათავსოთ ბლოკები გვერდიგვერდ */
                            
                            padding:15px;
                            border: 15px solid rgba(0,0,165,0.2);
                            
                            background-image: url(tiger.jpg);
                            background-size: cover;
                            background-repeat: no-repeat;
                        }
                        .borderBox {background-clip: border-box;}
                        .paddingBox {background-clip: padding-box;}
                        .contentBox {background-clip: content-box;}
                        </style>
                    </head>
                    <body>
                        <div class="borderBox"></div>
                        <div class="paddingBox"></div>
                        <div  class="contentBox"></div>
                    </body>
                </html>`
            },{
                title:"ელემენტის ჩრდილი",
                data:`ელემენტისთვის ჩრდილის მისაცემად გამოიყენება თვისება box-shadow. ის იღებს ერთდროულად რამდენიმე მნიშვნელობას:

                box-shadow: hoffset voffset blur spread color inset
                hoffset: ჩრდილის ჰორიზონტალური წანაცვლება ელემენტის მიმართ. დადებითი მნიშვნელობისას ჩრდილი წანაცვლებულია მარჯვნივ, უარყოფითისას - მარცხნივ
                voffset: ჩრდილის ვერტიკალურიწანაცვლება ელემენტის მიმართ. დადებითი მნიშვნელობისას ჩრდილი წანაცვლებულია ქვევით, უარყოფითისას - ზევით
                blur: არააუცილიებელი მნიშვნელობა. განსაზღვრავს ჩრდილის კუთხეების გაბნეულობის რადიუსს. რაც უფრო მეტია, მით უფრო ნაკლებად გამოხატულია კუთხეები. მიუთითებლობისას მისი მნიშვნელობა 0-ის ტოლია
                spread: არააუცილებელი მნიშვნელობა. განსაზღვრავს ჩრდილის მიმართულებას. დადებითი მნიშვნელობისას ჩრდილი მიმართულია ელემენტიდან გარეთ, ხოლო უარყოფითისას - ელემენტისკენ
                color: არააუცილებელი მნიშვნელობა. განსაზღვრავს ჩრდილის ფერს
                inset: არააუცილებელი მნიშვნელობა, რომელიდ ჩრდილს მიმართავს ელემენტის შიგნით
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ჩრდილი</title>
                        <style>
                        div{
                            width: 128px;
                            height: 96px;
                            margin: 20px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                            box-shadow: 10px 4px 10px 3px #888;
                        }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ერთ ელემენტს შეიძლება განესაზღვროს რამდენიმე ჩრდილი, ისინი გამოიყოფა მძიმეებით:
                
                box-shadow: 5px 3px 8px 3px #faa, 10px 4px 10px 3px #888 inset;`
            },{
                title:"ელემენტის კონტურები",
                data:`ელემენტის კონტურების გამოყენება ჩარჩოების მსგავსია, მაგრამ მათ სხვადასხვა დანიშნულება აქვთ. კონტურები გამოიყენება რაღაც ელემენტების სხვებისაგან გამოსაყოფად, ყურადღების მისაქცევად. კონტურები ელემენტის გარეთაა ჩარჩოს შემდეგ.

                კონტურებისთვის CSS3-ში გამოიყენება თვისება outline, რომელიც შემდეგი თვისებების შემოკლებაა:
                
                outline-color: კონტურის ფერი
                outline-offset: კონტურის წანაცვლება
                outline-style: კონტურის სტილი, იღებს იმავე მნიშვნელობებს, რასაც border-style:
                none: კონტურის გარეშე
                solid: კონტური ჩვეულებრივი ხაზით
                dashed: წყვეტილი ხაზი
                dotted: წერტილოვანი ხაზი
                double: ორმაგი ხაზი
                outline-width: კონტურის სისქე
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>კონტურები</title>
                        <style>
                        div{
                            width: 128px;
                            height: 96px;
                            margin: 20px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                            outline-color: red;
                            outline-style: dashed;
                            outline-width: 2px;
                        }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                 
                
                 
                
                
                outline თვისების გამოყენებით შეიძლება ეს ყველაფერი შემოკლებულად ჩავწეროთ:
                
                outline: red dashed 2px;`
            },{
                title:"თვისება float",
                data:`როგორც წესი, ვებგვერდის ყველა ბლოკი და ელემენტი ბრაუზერში გამოჩნდება იმ თანმიმდევრობით, რა თანმიმდევრობითაც არის ისინი html კოდში. მაგრამ თვისება float საშუალებას იძლევა მოვახდინოთ ობიექტების მიმაგრება კიდეებზე. იგი ღებულობს შემდეგ მნიშვნელობებს:

                left: ელემენტი გადაადგილდება მარცხნივ, ხოლო ყველა მისი მომდევნო ელემენტი გარსშემოედინება მას მრჯვნიდან
                right: ელემენტი გადაადგილდება მარჯვნივ
                none: აუქმებს გარსშემოდინებას და ობიექტი ბრუნდება ჩვეულებრივ პოზიციაში
                float თვისების გამოყენებისას გარდა img ელემენტისა სასურველია გამოვიყენოთ თვისება width.
                
                ვნახოთ float თვისების გამოყენება კონკრეტულ მაგალითზე. განვალაგოთ ერთი და იგივე ელემენტები float თვისების გამოყენების გარეშე და მისი გამოყენებით.
                
                float თვისების გამოყენების გარეშე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>        
                         .image {
                            margin:10px;
                            margin-top:0px;
                        }
                        .sidebar{
                            border: 2px solid #ccc;
                            background-color: #eee;
                            width: 150px;
                            padding: 10px;
                            margin-left:10px;
                            font-size: 20px;
                        }
                        p{
                            text-align: justify;
                        }
                        </style>
                    </head>
                    <body>
                        <div>
                            <div class="sidebar">ნოდარ დუმბაძე.<br />მე, ბებია, ილიკო და ილარიონი</div>
                            <img src="cover.jpg" class="image" alt="მე, ბებია, ილიკო და ილარიონი" />
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის
                                ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული,
                                რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდგილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება.
                                მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო
                                მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი,
                                ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                float თვისების გამოყენებით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>        
                         .image {
                            float:left;
                            margin:10px;
                            margin-top:0px;
                        }
                        .sidebar{
                            border: 2px solid #ccc;
                            background-color: #eee;
                            width: 200px;
                            padding: 10px;
                            margin-left:10px;
                            font-size: 20px;
                            float: right;
                        }
                        p{
                            text-align: justify;
                        }
                        </style>
                    </head>
                    <body>
                        <div>
                            <div class="sidebar">ნოდარ დუმბაძე.<br />მე, ბებია, ილიკო და ილარიონი</div>
                            <img src="cover.jpg" class="image" alt="მე, ბებია, ილიკო და ილარიონი" />
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის
                                ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული,
                                რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდგილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება.
                                მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო
                                მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი,
                                ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ელემენტებს, რომლებზეც გამოყენებულია თვისება float, მცურავ ელემენტებსაც (floating elements) ეძახიან.
                
                გარსშემოდინების აკრძალვა. თვისება clear
                
                ხანდახან საჭიროა გარსშემოდინების აკრძალვა. ეს საჭირო ხდება იმ შემთხვევაში, როცა გვინდა მომდევნო ბლოკის გადატანა ახალ სტრიქონზე და არა მცურავი ელემენტის გარსშემოდინება.მაგალითად, ფუტერი უნდა იყოს მკაცრად გვერდის ბოლოში მთელ სიგანეზე და არ უნდა შემოედინებოდეს სხვა ელემენტებს. ამისთვის გამოიყენება თვისება clear. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                left: ელემენტი გარსშემოედინება მცურავ ელემენტს მარჯვნიდან, ხოლო მარცხნიდან - არა
                right: ელემენტი გარსშემოედინება მცურავ ელემენტს მარცხნიდან, ხოლო მარჯვნიდან - არა
                both: ელემენტი გარსშემოედინება მცურავ ელემენტს, მაგრამ გადაადგილდება მის მიმართ ქვემოთ
                none: ელემენტი იქცევა სტანდარტულად, ანუ გარსშემოედინება მცურავ ელემენტებს
                მაგალითად, ვთქვათ გვაქვს ვებგვერდი ფუტერით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>
                        .image {
                            float:left;
                            margin:10px;
                            margin-top:0px;
                        }
                        .footer{
                            border-top: 1px solid #ccc;
                        }
                        </style>
                    </head>
                    <body>    
                        <img src="tiger.jpg" class="image" alt="ვეფხვი" />
                        <div class="footer">Copyright © MyCorp. 2017</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თუ შევცვლით ფუტერის სტილს, იგი გადაინაცვლებს ქვევით:
                
                .footer{
                    border-top: 1px solid #ccc;
                    clear:both;
                }
                 `
            },{
                title:"ელემენტების გადახვევა",
                data:`ვებგვერდის შექმნის დროს ხშირად არის სიტუაცია, როცა ელემენტის შიგთავსი უფრო დიდია, ვიდრე თვითონ ელემენტის ზომები. ასეთ დროს ბრაუზერი მაინც აჩენს შიგთავსს მთლიანად, მიუხედავად იმისა, რომ ის გამოდის ელემენტის საზღვრებს გარეთ.

                თვისება overflow საშუალებას გვაძლევს დავამატოთ ასეთ დროს გადახვევა (scroll) ელემენტზე. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                auto: თუ ელემენტის შიგთავსი (კონტენტი) გამოდის ელემენტის საზღვრებს გარეთ, ჩნდება გადახვევის ზოლი (ჰორიზონტალური, ვერტიკალური). სხვა დროს გადახვევის ზოლები არ ჩანს
                hidden: ჩანს შიგთავსის მხოლოდ ის ნაწილი, რაც ეტევა ელემენტის ზომებს შიგნით. გადახვევის ზოლები არ ჩნდება
                scroll: გადახვევის ზოლები ჩანს ყოველთვის, მაშინაც, როცა სიგთავსი ეტევა ელემენტის შიგნით
                visible: მნიშვნელობა მიუთითებლობისას. გადახვევის ზოლები არ ჩნდება, შიგთავსი ჩანს იმის მიუხედავად, ეტევა ელემენტის საზღვრებში თუ არა
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>გადახვევის ზოლი</title>
                        <style>
                        .article1{
                            width: 300px;
                            height: 150px;
                            margin:15px;
                            border: 1px solid #ccc;
                            overflow: auto;
                        }
                        .article2{
                            width: 300px;
                            height: 150px;
                            margin:15px;
                            border: 1px solid #ccc;
                            overflow: hidden;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="article1">
                        <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                            შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული, რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდნილ
                            წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება. მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                            მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                            სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი, ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                        <div class="article2">
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული, რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდნილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება. მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი, ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თვისება overflow მართავს ელემენტის გადახვევას როგორც ჰორიზონტალური, ასევე ვერტიკალური მიმართულებით. დამატებითი თვისებებით overflow-x და overflow-y შეიძლება ელემენტს ცალ-ცალკე განესაზღვროს გადახვევა ჰორიზონტალური და ვერტიკალური მიმართულებისთვის. ისინი ღებულობენ იმავე მნიშვნელობებს, რასაც overflow. მაგალითად:
                
                overflow-x: auto;
                overflow-y: hidden;`
            },
            {
                title:"წრფივი გრადიენტი",
                data:`გრადიენტი წარმოადგენს ერთი ფერის თანდათანობით გადასვლას მეორეში. CSS3-ში არსებობს ჩაშენებული გრადიენტები, რომლებიც შიძლება გამოვიყენოთ ელემენტის ფონად.

                გრადიენტისთვის CSS-ში არაა ცალკე თვისება, იგი გამოისახება მნიშვნელობით, რომელიც უნდა მივანიჭოთ თვისებას background-image.
                
                წრფივი გრადიენტი იწყება ელემენტის ერთი ბოლოდან და ვრცელდება მოპირდაპირე ბოლომდე, ამასთან ფერი თანდათანობით გადადის ერთიდან მეორეში.
                
                წრფივი გრადიენტის შესაქმნელად უნდა მივუთითოთ დაწყების ადგილი და რამდენიმე ფერი:
                
                background-image: linear-gradient(left,blue,red);
                მოცემულ მაგალითში გრადიენტი იწყება ელემენტის მარცხენა ბოლოდან (left) ლურჯი ფერით (blue) და ვრცელდება მარჯვენა ბოლომდე, ამასთან ფერი თანდათანობით გადადის წითლში (red).
                
                გრადიენტის გამოყენებას გააჩნია ერთი ნაკლი: ბრაუზერების მრავალფეროვნების გამო აუცილებელია მივუთითოთ შესაბამისი პრეფიქსი:
                
                -webkit- : ბრაუზერებისთვის Google Chrome, Safari, Microsoft Edge, Opera მე-15 ვერსიის ზევით
                -moz- : ბრაუზერისთვის Mozilla Firefox 
                -o- : ბრაუზერისთვის Opera მე-15 ვერსიამდე
                ბრაუზერების გათვალისწინებით გრადიენტის გამოყენება შემდეგნაირად გამოიყურება:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>გრადიენტი</title>
                    <style>
                        div {
                            width: 200px;
                            height: 100px;
                            background-image: linear-gradient(left,blue,red,gold);
                            background-image: -o-linear-gradient(left,blue,red,gold);
                            background-image: -moz-linear-gradient(left,blue,red,gold);
                            background-image: -webkit-linear-gradient(left,blue,red,gold);
                        }
                    </style>
                </head>
                <body>
                    <div></div>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გრადიენტის დაწყების ადგილის მისათითებლად გამოიყენება მნიშვნელობები:
                
                left: მარცხნიდან მარჯვნივ
                right: მარჯვნიდან მარცხნივ
                top: ზემოდან ქვემოთ
                bottom: ქვემოდან ზემოთ
                მაგალითად, გრადიენტი ქვემოდან ზემოთ:
                
                background-image: linear-gradient(bottom,blue,red);
                ასევე შეიძლება დიაგონალური გრადიენტის მიღება ორი მნიშვნელობის მითითებით:
                
                background-image: linear-gradient(top left,blue,red);
                 
                
                HTML5-ის დოკუმენტი
                
                მიმართულების განსაზღვრისთვის კონკრეტული მნიშვნელობების გარდა (top left) შეიძლება მიეთითოს კუთხის გრადუსული მნიშვნელობა 0-დან 360 გრადუსამდე. კუთხის რიცხვითი მნიშვნელობის მერე იწერება deg:
                
                background-image: linear-gradient(30deg,blue,red);
                მაგალითად, 0 გრადუსი ნიშნავს, რომ გრადიენტი იწყება მარცხენა ბოლოდან და მიემართება ჰორიზონტალურად მარჯვენა ბოლომდე, ხოლო 45 გრადუსის შემთხვევაში, გრადიენტი იწყება მარცხენა ქვედა კუთხეში და 45 გრადუსიანი კუთხით მიემართება მეორე ბოლოსკენ.
                
                გრადიენტის დაწყების ადგილის მერე ეთითება ფერები. ფერი შეიძლება იყოს რამდენიმე. გრადიენტში თითოეული ფერი თანაბრად ნაწილლდება. თუმცა შესაძლებელია მიეთითოს კონკრეტული ფერის ადგილი. ამისთვის ფერის მერე ეთითება მეორე მნიშვნელობა, რომელიც განსაზღვრავს ამ ფერის ადგილს:
                
                background-image: linear-gradient(left, #ccc, red 20%, red 80%, #ccc);
                განმეორებადი გრადიენტი
                
                repeating-linear-gradient-ის მეშვეობით შესაძლებელია განმეორებადი გრადიენტის შექმნა. მაგალითად:
                
                background-image: repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                background-image: -moz-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                background-image: -webkit-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                 
                
                მოცემულ მაგალითში გრადიენტი იწყება მარცხნიდან ნაცრისფერი 20 პიქსელიანი ზოლით, შემდეგ 30 პიქსელამდე მიდის გადასვლა წითელში, შემდეგ 40 პიქსელამდე გადადის ღია ცისფერში. ამის შემდეგ ბრაუზერი იმეორებს ყველაფერს თავიდან ელემენტის ბოლომდე.`
            },
            {
                title:"რადიალური გრადიენტი",
                data:`წრფივი გრადიენტისგან განსხვავებით, რადიალური გრადიენტი ვრცელდება ცენტრიდან კიდეებისკენ წრიულად. რადიალური გრადიენტის შესაქმნელად საკმარისია მივუთითოთ ფერი, რომელიც იქნება ცენტრში და მეორე ფერი, რომელშიც თანაბრად გადავა. ეს ფერები გადაეცემა ფუნქციას radial-gradient. მაგალითად: 

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>გრადიენტი</title>
                    <style>
                        div {
                            width: 200px;
                            height: 200px;
                            border-radius: 100px;            
                            background-color: #eee;
                            background-image: radial-gradient(white, black);
                            background-image: -moz-radial-gradient(white, black);
                            background-image: -webkit-radial-gradient(white, black);
                        }
                        p{
                            margin: 0;
                            padding-top: 60px;
                            text-align: center;
                            color: #eee;
                        }
                        </style>
                    </head>
                    <body>
                        <div><p>რადიალური გრადიენტი</p></div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ისევე, როგორც წრფივი გრადიენტის შემთხვევაში, აქაც საჭიროა პრეფიქსების გამოყენება სხვადასხვა ბრაუზერების მხარდაჭერისათვის.
                
                რადიალურ გრადიენტს შეიძლება ჰქონდეს ორი ფორმა: წრიული და ელიფსური. ელიფსური ფორმა წარმოადგენს გრადიენტის გავრცელებას ელიფსური სახით და ამისთვის მიეთითება მნიშვნელობა ellipse:
                
                background-image: radial-gradient(ellipse, white, black);
                ვინაიდან ეს მნიშვნელობა არის მნიშვნელობა მიუთითებლობისას, შესაძლებელია ის გამოვტოვოთ.
                
                წრიული გრადიენტისთვის გამოიყენება circle:
                
                background-image: radial-gradient(circle, white, black);
                როგორც წესი, გრადიენტი იწყება ელემენტის ცენტრიდან, მაგრამ შესაბამისი პარამეტრებით შევცვალოთ დაწყების ადგილი, ამისათვის ეთითება პარამეტრი background-position:
                
                background-image: radial-gradient(25% 30%, circle, white, black);
                25% 30% ნიშნავს, რომ გრადიენტის ცენტრი მდებარეობს ელემენტის მარცხენა საზღვრიდან 25%-ის და ზედა საზღვრიდან 30%-ის დაშორებით.
                
                HTML5-ის დოკუმენტი
                
                სპეციალური დამატებითი პარამეტრების მეშვეობით შეიძლება შევცვალოთ გრადიენტის ზომა:
                
                closest-side: გრადიენტი ვრცელდება ცენტრიდან ელემენტის უახლოეს მხარემდე, ანუ გრადიენტი ელემენტის შიგნით რჩება
                closest-corner: გრადიენტის სიგქანე ითვლება ცენტრიდან უაზლოეს კუთხემდე. შესაბამისად, გრადიენტი შეიძლება გავიდეს ელემენტის საზღვრებს გარეთ
                farthest-side: გრადიენტი ვრცელდება ცენტრიდან ყველაზე დაშორებულ მხარემდე
                farthest-corner: გრადიენტის სიგანე ითვლება ცენტრიდან ყველაზე დაშორებულ კუთხემდე
                background-image: radial-gradient(25% 30%, circle farthest-corner, white, black);`
            },
            



              
            ]
        },
        {
            title:"თავი 7. გვერდის მაკეტის შექმნა",
            content:[
                {
                    title:"ბლოკისებური მაკეტი. 1-ლი ნაწილი",
                    data:`როგორც წესი, ვებგვერდი შედგება უამრავი ელემენტისაგან, რომელთაც შეიძლება ჰქონდეთ რთული სტრუქტურა. ამიტომ ვებგვერდის შექმნის პროცესში მნიშვნელოვანია ამ ელემენტების პოზიციონირება და სტილიზაცია, რათა მათ ჰქონდეთ საჭირო განლაგება. ამ დროს წარმოიქმნება გვერდის მაკეტის შექმნის აუცილებლობა.

                    არსებობს გვერდის მაკეტის შექმნის სხვადასხვა მეთოდები და მიდგომები. თავიდან გავრცელებული იყო ვებგვერდის მაკეტი ცხრილების საფუძველზე, რადგანაც ცხრილები საშუალებას იძლევა მარტივად დავყოთ გვერდი სვეტებად და სტრიქონებად. სვეტების და სტრიქონების მართვა შედარებით ადვილია და მათში ელემენტების პოზიციონირებაც მარტივია, რაც განაპირობებდა ამ მეთოდის პოპულარობას.
                    
                    მაგრამ ცხრილური მაკეტი არაა საკმარისად მოქნილი დიზაინის კუთხით, ვინაიდან მომხმარებელთა ეკრანის გაფართოება მეტად განსხვავებულია ფართოეკრანიანი ტელევიზორებიდან დაწყბული დამთავრებული პლანშეტებით და ტელეფონებით. გაფართოების ასეთი მრავალფეროვანი მოთხოვნების დასაკმაყოფილებლად ცხრილური მაკეტი არ აღმოჩნდა მოხერხებული. ამიტომ ნელ-ნელა მისი ადგილი დაიკავა ე. წ. ბლოკისებურმა მაკეტმა. ბლოკისებური მაკეტი პირობითი სახელწოდებაა ვებგვერდის მაკეტისა, სადაც ძირითადად გამოიყენება თვისება float, ხოლო ვებგვერდის ელემენტები ძირითადად მოქცეულია ელემენტებში <div> ანუ ბლოკებში. ამ ელემენტების მეშვეობით შესაძლებელია რამდენიმე სვეტიანი მაკეტის შექმნა, რომელიც გაცილებით უფრო მოქნილია, ვიდრე ცხრილები.
                    
                    წინა თემებში განხილული იყო float თვისების მოქმედება. გამოვიყენოთ იგი ორსვეტიანი ვებგვერდის ასაწყობად. ვთქვათ, გვინდა გვერდი შედგებოდეს სათაურისა და ქვედა ნაწილისგან (ფუტერისგან), ხოლო შუაში იყოს ორი სვეტი: ერთი მენიუთი ან ნავიგაციის პანელით და მეორე ძირითადი ნაწილით.
                    
                    ჯერ განვსაზღვროთ ყველა ბლოკი. float თვისების გამოყენებისას მნიშვნელობა აქვს ელემენტების თნმიმდევრობას. მცურავი ელემენტი უნდა მოდიოდეს იმ ელემენტის წინ, რომელიც გარს უნდა შემოეკრას. ჩვენს შემთხვევაში ეს არის ნავიგაციის პანელი (საიდბარი).
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ბლოკისებური მაკეტი</title>
                            <style>
                                div{
                                    margin: 10px;
                                    border: 1px solid black;
                                    font-size: 20px;
                                    height: 80px;
                                }
                                #header{
                                    background-color: #ccc;
                                }
                                #sidebar{
                                    background-color: #ddd;
                                }
                                #main{
                                    background-color: #eee;
                                    height: 200px;
                                }
                                #footer{
                                    background-color: #ccc;
                                }
                            </style>
                        </head>
                        <body>
                            <div id="header">საიტის სათაური</div>
                            <div id="sidebar">საიდბარი</div>
                            <div id="main">ძირითადი შიგთავსი</div>
                            <div id="footer">ფუტერი</div>
                        </body>
                    </html>
                    შედეგად ვღებულობთ ჯერ-ჯერობით შემდეგ გვერდს:
                    
                    HTML5-ის დოკუმენტი
                    
                    ბლოკების სიმაღლე, ჩარჩოები და დაშორებები დამატებულია მხოლოდ იმისთვის, რომ შეგვეძლოს ბლოკების იდენტიფიცირება და ერთმანეთისგან გარჩევა.
                    
                    საიდბარის ძირითადი ბლოკის მარცხნივ მოსათავსებლად საჭიროა მას მივცეთ თვისება float:left. სიგანე უნდა იყოს ფიქსირებული, მაგალითად 150px ან 8em. ასევე შეიძლება პროცენტების გამოყენება, მაგალითად 30%. ერთის მხრივ, ფიქსირებული სიგანის ბლოკების მართვა უფრო ადვილია, მაგრამ პროცენტული მნიშვნელობისას ისინი უფრო მოქნილნი არიან ბრაუზერის ზომების შეცვლისას.
                    
                    რადგანაც ელემენტი, რომელიც გარსშემოედინება მცურავ ელემენტს გარს ეკვრის მას არა მხოლოდ მარჯვნიდან, არამედ ქვემოდანაც, აუცილებელია მას მივუთითოთ გარე დაშორება არანაკლებ მცურავი ელემენტის სიგანისა. თუ საიდბარის სიგანე იქნება 150 პიქსელი, ძირითადი ბლოკის გარე დაშორება მივუთითოთ 170 პიქსელი, რათა დარჩეს ცარიელი ადგილი საიდბარსა და ძირითად ბლოკს შორის. ამასთან ძირითად ბლოკს უმჯობესია არ მივცეთ ზუსტი სიგანე და ამ შემთხვევაში ის შეავსებს მთლიანად ბრაუზერის დარჩენილ ნაწილს.
                    
                    შევცვალოთ შესაბამისად საიდბარისა და ძირითადი ბლოკის სტილიზაცია:
                    
                    #sidebar{
                        background-color: #ddd;
                        float: left;
                        width: 150px;
                    }
                    #main{
                        background-color: #eee;
                        height: 200px;
                        margin-left: 170px;           
                    }
                    შედეგად მივიღებთ საიდბარს ძირითადი ბლოკის მარცხნივ:
                    
                    HTML5-ის დოკუმენტი
                    
                    ბლოკების სიმაღლე მითითებულია თვალსაჩინოებისთვის, სინამდვილეში სიმაღლეს კონტენტიდან გამომდინარე ბრაუზერი მიანიჭებს ავტომატურად.
                    
                    მარჯვენა საიდბარის შექმნა ანალოგიურია, უბრალოდ საიდბარს ექნება თვისება float:right და ძირითად ბლოკს გარე დაშორება მიეთითება მარჯვნიდან:
                    
                    #sidebar{
                        background-color: #ddd;
                        float: right;
                        width: 150px;
                    }
                    #main{
                        background-color: #eee;
                        height: 200px;
                        margin-right: 170px;           
                    }
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    თვითონ html-ის ტექსტი არ შეიცვლება, საიდბარი ისევ წინ უნდა იყოს ძირითად ბლოკზე.`
                },
                {
                  title:"ბლოკისებური მაკეტი. მე-2 ნაწილი",
                  data:`წინა თემაში განხილული იყო გვერდის შექმნა ორი სვეტით. ანალოგიურად ჩვენ შეგვიძლია გვერდის შექმნა უფრო მეტი სვეტებით და უფრო რთული სტრუქტურით. მაგალითად, დავამატოთ მეორე საიდბარი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid black;
                                  font-size: 20px;
                                  height: 80px;
                              }
                              #header{
                                  background-color: #ccc;
                              }
                              #leftSidebar{
                                  background-color: #ddd;
                              }
                              #rightSidebar{
                                  background-color: #bbb;
                              }
                              #main{
                                  background-color: #eee;
                                  height: 200px;
                              }
                              #footer{
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">საიტის სათაური</div>
                          <div id="leftSidebar">მარცხენა საიდბარი</div>
                          <div id="rightSidebar">მარჯვენა საიდბარი</div>
                          <div id="main">ძირითადი შიგთავსი</div>
                          <div id="footer">ფუტერი</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თითოეული საიდბარის html კოდი წინ უნდა უსწრებდეს ძირითადი ბლოკის კოდს, რომელიც გარს უნდა შემოეკრას ამ საიდბარებს.
                  
                  ახლა მოვახდინოთ საიდბარების და ძირითადი ბლოკის სტილიზაცია:
                  
                  #leftSidebar{
                      background-color: #ddd;
                      float: left;
                      width: 150px;
                  }
                  #rightSidebar{
                      background-color: #bbb;
                      float: right;
                      width: 150px;
                  }
                  #main{
                      background-color: #eee;
                      height: 200px;
                      margin-left: 170px;
                      margin-right: 170px;
                  }
                   `
              },
              {
                  title:"ჩასმული მცურავი ბლოკები",
                  data:`ხშირად არის სიტუაცია, როდესაც ბლოკში, რომელიც გარსშემოედინება სხვა ელემენტებს, ჩასმულია მცურავი ელემენტები. მაგალითად, ძირითადი ბლოკი შეიძლება შეიცავდეს ძირითად შიგთავსს და მენიუს. ასეთი ბლოკებისადმი გამოიყენება იგივე პრინციპები. 

                  ჯერ განვსაზღვროთ ვებგვერდის ბლოკები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid black;
                                  font-size: 20px;
                                  height: 80px;
                              }
                              #header{
                                  background-color: #ccc;
                              }
                              #sidebar{
                                  background-color: #bbb;
                                  float: right;
                                  width: 150px;
                              }
                              #main{
                                  background-color: #fafafa;
                                  height: 200px;
                                  margin-right: 170px;
                              }
                              #menu{
                                  background-color: #ddd;
                              }
                              #content{
                                  background-color: #eee;
                              }
                              #footer{
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">გვერდის სათაური</div>
                          <div id="sidebar">მარჯვენა საიდბარი</div>
                          <div id="main">
                              <div id="menu">მენიუ</div>
                              <div id="content">ძირითადი შინაარსი</div>
                          </div>
                          <div id="footer">ფუტერი</div>
                      </body>
                  </html>
                  ძირითად ბლოკში ელემენტები მოთავსებულია საჭირო თანმიმდევრობით: ჯერ მენიუ, შემდეგ ძირითადი შინაარსი.
                  
                  HTML5-ის დოკუმენტი
                  
                  ახლა კი მივანიჭოთ საჭირო თვისებები ელემენტებს:
                  
                  #menu{
                      background-color: #ddd;
                      float: left;
                      width: 160px;
                  }
                  #content{
                      background-color: #eee;
                      margin-left: 180px;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად შეიძლება მენიუ გადავიტანოთ მარჯვნივ:
                  
                  #menu{
                      background-color: #ddd;
                      float: right;
                      width: 160px;
                  }
                  #content{
                      background-color: #eee;
                      margin-right: 180px;
                  }`
              },
              {
                  title:"სვეტების გათანაბრება სიმაღლეში",
                  data:`გვერდის ბლოკისებურად აწყობის დროს შეიძლება გაჩნდეს პრობლემა სვეტების სიმაღლეთა შორის განსხვავების გამო, განსაკუთრებით მაშინ, როცა მათ გააჩნიათ სხვადასხვა ფონი. განვიხილოთ მაგალითი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              body, h2, p{
                                  margin:0;
                                  padding:0;
                              }
                              body{
                                  font-size: 18px;
                              }
                              #header{
                                  background-color: #eee;
                                  border-bottom: 1px solid #ccc;
                                  height: 80px;
                              }
                              #menu{
                                  background-color: #ddd;
                                  float: left;
                                  width: 150px;
                              }
                              #main{
                                  background-color: #f7f7f7;
                                  border-left: 1px solid #ccc;
                                  margin-left: 150px;
                                  padding: 10px;
                              }
                              #footer{
                                  border-top: 1px solid #ccc;
                                  background-color: #dedede;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header"><h2>Сайт MySyte.com</h2></div>
                          <div id="menu">
                              <ul>
                                  <li><a href="#">მთავარი</a></li>
                                  <li><a href="#">ბლოგი</a></li>
                                  <li><a href="#">კონტაქტები</a></li>
                                  <li><a href="#">საიტის შესახებ</a></li>
                              </ul>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
                                  incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis
                                  nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                                  Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
                                  fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
                                  culpa qui officia deserunt mollit anim id est laborum.
                                  has been the industry...</p>
                          </div>
                          <div id="footer">
                              <p>Copyright © MySyte.com, 2016</p>
                          </div>
                      </body>
                  </html>
                  აქ უკვე გაკეთებულია გარსშემოდინება და იგი კარგად მუშაობს, მაგრამ შიგთავსის მიხედვით ერთი სვეტი უფრო მაღალია, ვიდრე მეორე:
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში, მენიუს ბლოკს აქვს არასაკმარისი სიმაღლე.
                  
                  ყველაზე გავრცელებული მეთოდი აღნიშნული ხარვეზის გამოსასწორებლად არის ძირითადი ნაწილის და მენიუს ჩასმა კონტეინერში, რომელსაც ენიჭება ფონი და ეს ფონი ექნება უფრო დაბალი სიმაღლის მქონე ბლოკს, ჩვენს შემთხვევაში მენიუს. მეორე ბლოკს ეძლევა თავისი ფონი და შესაბამისად, იქმნება ილუზია, რომ სვეტები ერთი და იმავე სიმაღლისაა:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ბლოკისებური მაკეტი</title>
                      <style>
                          body,
                          h2,
                          p {
                              margin: 0;
                              padding: 0;
                          }
                          body {
                              font-size: 18px;
                          }
                          #header {
                              background-color: #eee;
                              border-bottom: 1px solid #ccc;
                              height: 80px;
                          }
                          #wrapper {
                              background-color: #ddd;
                          }
                   
                          #menu {
                              float: left;
                              width: 150px;
                          }
                          #main {
                              background-color: #f7f7f7;
                              border-left: 1px solid #ccc;
                              margin-left: 150px;
                              padding: 10px;
                          }
                          #footer {
                              border-top: 1px solid #ccc;
                              background-color: #dedede;
                          }
                      </style>
                  </head>
                   
                  <body>
                      <div id="header">
                          <h2>Сайт MySyte.com</h2>
                      </div>
                      <div id="wrapper">
                          <div id="menu">
                              <ul>
                                  <li>
                                      <a href="#">მთავარი</a>
                                  </li>
                                  <li>
                                      <a href="#">ბლოგი</a>
                                  </li>
                                  <li>
                                      <a href="#">კონტაქტები</a>
                                  </li>
                                  <li>
                                      <a href="#">საიტის შესახებ</a>
                                  </li>
                              </ul>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
                                  magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
                                  consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
                                  Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
                                  has been the industry...</p>
                          </div>
                      </div>
                      <div id="footer">
                          <p>Copyright © MySyte.com, 2016</p>
                      </div>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში ძირითადი ნაწილი და მენიუ ჩასმულია კონტეინერში wrapper, რომელსაც აქვს მენიუს ფონი, ხოლო ძირითად ნაწილს მიცემული აქვს თავისი ფონი.`
              },
              {
                  title:"თვისება display",
                  data:`გარდა float თვისებისა, რომელიც საშუალებას იძლევა შევცვალოთ ელემენტის ადგილმდებარეობა, CSS-ში არის კიდევ ერთი მნიშვნელოვანი თვისება display. ის საშუალებას იძლევა ბლოკის მართვის შესაძლებლობას და ასევე გავლენა აქვს მის პოზიციაზე სხვა ელემენტების მიმართ.

                  თვისება display იღებს შემდეგ მნიშვნელობებს:
                  
                  inline: ელემენტი ხდება სტრიქონული, როგორც სიტყვები სტრიქონში
                  block: ელემენტი ხდება ბლოკისებური, როგორც პარაგრაფი
                  inline-block: ელემენტი თავსდება როგორც სტრიქონი
                  list-item: ელემენტი იღებს პოზიციას, როგორც სიის ელემენტი, როგორც წესი, მარკერის დამატებით წერტილის ან რიგითი ნომრის სახით
                  run-in: ბლოკის ელემენტის ტიპი დამოკიდებულია გარემომცველ ელემენტებზე
                  flexbox: იძლევა ელემენტების მოქნილი პოზიციონირების საშუალებას
                  table, inline-table: საშუალებას იძლევა განლაგდეს ელემენტები ცხრილის სახით
                  none: ელემენტი არ ჩანს
                  მაშასადამე, მნიშვნელობა block იძლევა ბლოკისებური ელემენტის განსაზღვრის საშუალებას. ასეთი ელემენტი ვიზუალურად გამოიყოფა სხვა ელემენტებისაგან სტრიქონის გადატანით, როგორც, მაგალითად, პარაგრაფი p ან ბლოკი div, რომლებიც მიუტითებლობისას წარმოადგენენ ბლოკისებურ ელემენტებს.
                  
                  ელემენტი span მათგან განსხვავებით არ წარმოადგენს ბლოკისებურ ელემენტს. ვნახოთ, როგორ შეიცვლება მისი მდებარეობა display:block მნიშვნელობის მინიჭებით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              span{
                                  color: red;
                              }
                              .blockSpan{
                                  display: block;
                              }
                          </style>
                      </head>
                      <body>
                          <div>ეს <span>სტრიქონული</span> span ელემენტია</div>
                          <div>ეს <span class="blockSpan">ბლოკისებური</span> span ელემენტია</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ მოცემულია ორი ელემენტი span. ერთ მათგანს მინიჭებული აქვს სტილი display:block. ამიტომ ეს ელემენტი გადატანილია ახალ სტრიქონზე.
                  
                  ბლოკისებური ელემენტებისგან განსხვავებით სტრიქონული ელემენტები თავსდება სტრიქონში, რადგან მათ მინიჭებული აქვს მნიშვნელობა display:inline. span ელემენტს მიუტითებლობისას სწორედ ეს მნიშვნელობა აქვს მინიჭებული, ამიტომაც თავსდება სტრიქონში და არ გადადის ახალ სტრიქონში, როგორც პარაგრაფი p და div. ახლა div ელემენტი გავხადოთ სტრიქონული:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              div{
                                  display: inline;
                              }
                          </style>
                      </head>
                      <body>
                          <div>პირველი სტრიქონული ელემენტი div.</div>
                          <div>მეორე სტრიქონული ელემენტი div.</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  გასათვალისწინებელია, რომ როცა ვიყენებთ მნიშვნელობას display:inline, ბრაუზერი იგნორირებას უკეთებს ზოგიერთ თვისებას, როგორიცაა width, height, margin.
                  
                  inline-block
                  
                  კიდევ ერთი მნიშვნელობა - inline-block წარმოადგენს ელემენტს, რომელიც წარმოადგენს ბლოკისებური და სტრიქონული ელემენტის ნარევს. მეზობელი ელემენტების მიმართ ის წარმოადგენს სტრიქონულს, ანუ, არ გამოიყოფა  მათგან ახალ სტრიქონზე გადატანით. თუმცა ჩასმული ელემენტებისთვის წარმოადგენს ბლოკისებურს. ასეთი ელემენტებისათვის გამოიყენება თვისებები width, height, margin.
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              span{
                                  width: 100px;
                                  height: 30px;
                                  background-color: #aaa;
                              }
                              .inineBlockSpan{
                                  display: inline-block;
                              }
                          </style>
                      </head>
                      <body>
                          <p>ნახეს, უცხო <span>მოყმე</span> ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <p>ნახეს, უცხო <span class="inineBlockSpan">მოყმე</span> ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველი ელემენტი span წარმოადგენს სტრიქონულს, ვინაიდან მას აქვს მნიშვნელობა inline, ამიტომ მისთვის width და height თვისებების გამოყენებას აზრი არა აქვს. სამაგიეროდ, მეორე ელემენტი span ბლოკისებურია და ის იღებს შესაბამის ზომებს. ასევე შეიძლება მისთვის დაშორებების გამოყენება.
                  
                  run-in
                  
                  მნიშვნელობა run-in განსაზღვრავს ელემენტს, რომელიც დამოკიდებულია მეზობელ ელემენტებზე. არსებობს სამი შესაძლო ვარიანტი:
                  
                  როცა ელემენტი გარშემორტყმულია ბლოკისებური ელემენტებით, ფაქტიურად თვითონაც აქვს მნიშვნელობა display:block, ანუ ხდება ბლოკისებური
                  როცა ელემენტი გარშემორტყმულია სტრიქონული ელემენტებით, ფაქტიურად თვითონაც აქვს მნიშვნელობა display:inline, ანუ ხდება სტრიქონული
                  ყველა სხვა შემთხვევაში ელემენტი არის ბლოკისებური
                  ცხრილისებური წარმოდგენა
                  
                  მნიშვნელობა table ელემენტს აქცევს ცხრილად. ვნახოთ სიის მაგალითზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              ul{
                                  display: table;
                                  margin: 0;
                              }
                              li{
                                  list-style-type: none;
                                  display: table-cell;
                                  padding: 10px;
                              }
                          </style>
                      </head>
                      <body>
                          <ul>
                              <li>Item 1</li>
                              <li>Item 2</li>
                              <li>Item 3</li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ ცხრილი პრაქტიკულად გადაიქცა ცხრილად, ხოლო სიის თითოეული ელემენტი - უჯრად. ამისათვის სიის ელემენტებს მინიჭებული აქვთ თვისება display: table-cell. ფაქტიურად, სიის ნაცვლად შეგვეძლო გამოგვეყენებინა სტანდარტული ცხრილი.
                  
                  ელემენტის დამალვა
                  
                  მნიშვნელობა none საშუალებას იძლევა დავმალოთ ელემენტი:
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              .invisible{
                                  display: none;
                              }
                          </style>
                      </head>
                      <body>
                          <p>პირველი პარაგრაფი</p>
                          <p class="invisible">მეორე პარაგრაფი</p>
                          <p>მესამე პარაგრაფი</p>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ნავიგაციის პანელის შექმნა",
                  data:`ნავიგაციის პანელი მნიშვნელოვან როლს ასრულებს საიტზე, იგი უზრუნველყოფს გადასვლას საიტის გვერდებზე თუ გარე რესურსებზე. ვნახოთ მარტივი ნავიგაციის პანელის შექმნა.

                  პრაქტიკულად, ნავიგაციის პანელი არის ბმულების ერთობლიობა, ხშორად უნომრო სიის სახით. ნავიგაციის პანელი მრავალნაირი შეიძლება იყოს: ჰორიზონტალური ან ვერტიკალური, ერთდონიანი ან მრავალდონიანი, მაგრამ ნავიგაცია ყოველთვის დაფუძნებულია <a> ელემენტზე. ამიტომ ნავიგაციის პანელის შექმნისას შეიძლება შეგვხვდეს ბმულის ელემენტის შეზღუდვებთან დაკავშირებული სიძნელეები. <a> ელემენტი წარმოადგენს სტრიქონულს და ამიტომ არ შეგვიძლია მას მივუთითოთ სიგანე, სიმაღლე, დაშორებები. ბმული ავტომატურად იკავებს იმ ადგილს, რამდენიც მას სჭირდება ტექსტიდან გამომდინარე.
                  
                  ვერტიკალური მენიუ
                  
                  აღნიშნული პრობლემის ერთ-ერთი ყველაზე გავრცელებული გადაწყვეტაა ბმულის გადაქცევა ბლოკისებურ ელემენტად display:block თვისების გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              ul.nav a {
                                  display: block;
                                  width: 7em;
                                  padding:10px;
                                  background-color: #f4f4f4;
                                  border-top: 1px dashed #333;
                                  border-right: 1px dashed #333;
                                  border-left: 5px solid #333;
                                  text-decoration: none;
                                  color: #333;
                              }
                              ul.nav li:last-child a {
                                  border-bottom: 1px dashed #333;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჰორიზონტალური მენიუ
                  
                  ჰორიზონტალური მენიუს შესაქმნელად შეიძლება გამოვიყენოთ ორი მეთოდი: პირველი მდგომარეობდ მცურავი ელემენტების გამოყენება (თვისება float), მეორე - ბმულების სტრიქონის შექმნა display: inline-block თვისების გამოყენებით.
                  
                  float თვისების გამოყენება
                  
                  float თვისების გამოყენებისას სიის ელემენტებს ენიჭებათ მნიშვნელობა float:left, ხოლო თვითონ ბმულებს - display:block,  რათა შეგვეძლოს მათთვის სიმაღლის, სიგანისა და დაშორებების მინიჭება.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              .nav li {
                                  float: left;
                              }
                              ul.nav a {
                                  display: block;
                                  width: 7em;
                                  padding:10px;
                                  margin: 0 5px;
                                  background-color: #f4f4f4;
                                  border: 1px dashed #333;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              ul.nav a:hover{
                                  background-color: #333;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">ბლოგი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  inline და inline-block
                  
                  ჰორიზონტალური პანელის შესაქმნელად სიის ელემენტებს უნდა მივანიჭოთ თვისება display:inline, ხოლო თვითონ ბმულებს display:inline-block:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              .nav li {
                                  display: inline;
                              }
                              ul.nav a {
                                  display: inline-block;
                                  width: 7em;
                                  padding:10px;
                                  background-color: #f4f4f4;
                                  border: 1px dashed #333;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              ul.nav a:hover{
                                  background-color: #333;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">ბლოგი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>`
              },
              {
                  title:"მცურავი ელემენტების გასწორება",
                  data:`მცურავ ელემენტებტან მუშაობისას ხშირია შემთხვევა, როცა ელემენტი ამოვარდნილია გვერდიდან. ამ პრობლემას აქვს სხვადასხვა ასპექტი და მათი გადაწყვეტა. განვიხილოთ ეს ასპექტები.

                  ვთქვათ, გვაქვს შემდეგი ბლოკი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                          <style>
                              #sidebar{
                                  float: left;
                                  width: 25%;
                                  padding: 10px;
                              }
                              #main{
                                  border-left: 1px solid #ccc;
                                  width:75%;
                                  padding: 15px;
                                  margin-left: 25%;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="sidebar">
                              <h2>The standard Lorem Ipsum passage</h2>
                              <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
                                  eiusmod tempor incididunt ut labore et dolore...</p>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, in quis eu leo,
                              sapien iaculis pede montes id cras nulla, sed in.
                              Mattis risus, donec risus quisque augue cum, dui
                              lacus vel est magna. Proin cras sodales tortor lectus
                              pretium id. Amet orci, nulla nibh, lorem velit. Molestie accumsan et,
                              ut vestibulum maecenas sed arcu. Arcu viverra illum luctus ac in pellentesque,
                              turpis sed, auctor orci a vestibulum duis vestibulum auctor, tellus suspendisse.
                              Lacus scelerisque pellentesque odio nec enim cum. Lorem adipisci, orci ante
                              consectetuer facilisis ac sem porta.</p>
                          </div>
                      </body>
                  </html>
                  საიდბარში საკმაოდ დიდი ტექსტია, ველოდებით რომ, ეფექტურად ჩაჯდება მცურავი ელემენტის საზღვრებში.
                  
                  HTML5-ის დოკუმენტი
                  
                  სინამდვილეში ვხედავთ, რომ საიდბარიდან ასოები გადმოდის საზღვრის გარეთ, მიუხედავად იმისა, რომ მას აქვს 10 პიქსელი შიდა დაშორებაც მარჯვენა მხარეს.
                  
                  რატომ ხდება ასე? ხშირად ბრაუზერები თავისებურ ინტერპრეტაციას აძლევენ ელემენტის ზომებს. კერძოდ, ყველა ელემენტს მიუთითებლობისას box-sizing თვისების მნიშვნელობა აქვს content-box. ამ დროს ელემენტის ზომებს (width, height) ემატება ჩარჩოების და შიდა დაშორებების ზომები. ამიტომ ხშირად ყველა ელემენტისთვის უთითებენ box-sizing თვისების მნიშვნელობად border-box-ს, შესაბამისად ყველა ელემენტი იზომება ერთნაირად:
                  
                  *{
                       box-sizing: border-box;
                   }
                  თუ ჩვენს მიერ განხილულ მაგალითში დავამატებთ ამ თვისებას, მივიღებთ სულ სხვა შედეგს:
                  
                  HTML5-ის დოკუმენტი
                  
                  განვიხილოთ სხვა პრობლემა, რომელიც დაკავშირებულია მცურავი ელემენტის პოზიციონირებასთან კონტეინერის შიგნით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              #header{
                                  background-color: #eee;
                              }
                              #nav{
                                  background-color: #f4f4f4;
                                  border-top: 1px solid #ccc;
                                  border-bottom: 1px solid #ccc;
                              }
                              #nav ul{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              #nav li {
                                  float: left;
                              }
                              #nav ul a {
                                  display: block;
                                  width: 9em;
                                  padding:10px;
                                  border-left: 1px solid #ccc;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              #nav ul li:last-child a {
                                  
                                  border-right: 1px solid #ccc;
                              }
                              #nav ul a:hover{
                                  background-color: #aaa;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">
                              <h1>კეთილი იყოს თქვენი მობრძანება</h1>
                              <div id="nav">
                                  <ul>
                                      <li><a href="#">მთავარი</a></li>
                                      <li><a href="#">ბლოგი</a></li>
                                      <li><a href="#">კონტაქტი</a></li>
                                      <li><a href="#">საიტის შესახებ</a></li>
                                  </ul>
                              </div>
                          </div>
                          <div id="content"><p>helo world</p></div>
                      </body>
                  </html>
                  HTML5-ის დოკუმენტი
                  
                  როგორც სურათიდან ჩანს, არის შემდეგი პრობლემები: სათურის ზემოთ და მარცხნივ არის გაურკვეველი დაშორებები, მენიუს ზოლი, მიუხედავად იმისა, რომ განსაზღვრულია header-ის შიგნით, ვიზუალურად აშკარად მის გარეთაა, ბლოკი "hello world" ჩაჯდა მენიუში.
                  
                  დაშორებების პრობლემა გამოწვეულია იმით, რომ ელემენტებს გააჩნიათ დაშორებები მიუთითებლობისას. ამის თავიდან ასაცილებლად ხშირად ყველაზე ფართოდ გამოყენებულ ელემენტებს აშორებენ მიუთითებლობის ზოგიერთ პარამეტრს:
                  
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd,
                  ol, ul, li, form, table, caption, tr, th, td, article, aside, footer, header{
                                 
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  მეორე პრობლემა - div ელემენტის მენიუში ჩაჯდომა მარტივად სწორდება. საკმარისია ამ ელემენტს მივუთიტოთ სტილი:
                  
                  clear: both;
                  ცოტა უფრო რთულია მცურავი ელემენტების კონტეინერიდან ამოვარდნის პრობლემა. აქ შეიძლება გამოვიყენოთ გადაწყვეტის ორი ვარიანტი. პირველი გადაწყვეტა მდგომარეობს იმ ელემენტისთვის, რომელიც წარმოადგენს ნავიგაციის პანელს, შემდეგი სტილის დამატებაში:
                  
                  ul:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  მეორე გადაწყვეტა მდგომარეობს იმაში, რომ თვითონ ნავიგაციის პანელი გავხადოთ მცურავი ელემენტი:
                  
                  #nav{
                      background-color: #f4f4f4;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                      
                      float:left;
                      width: 100%;
                      clear: both;
                  }
                  თუ შევცვლით ვებგვერდის სტილებს ზემოთ მითითებული შესწორებების მიხედვით (html-ის ტექსტი უცვლელი რჩება), მივიღებთ:
                  
                  *{
                      box-sizing: border-box;
                  }
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd,
                  ol, ul, li, form, table, caption, tr, th, td, article, aside, footer, header{
                                  
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  #header{
                      background-color: #eee;
                  }
                  #header h1{
                      font-size: 1.3em;
                      padding: 15px;
                  }
                  #nav{
                      background-color: #f4f4f4;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav ul{
                      margin-left: 0px;
                      padding-left: 0px;
                      list-style: none;
                  }
                  #nav li {
                      float: left;
                  }
                  #nav ul a {
                      display: block;
                      width: 7em;
                      padding: 10px;
                      border-left: 1px solid #ccc;
                      text-decoration: none;
                      color: #333;
                      text-align: center;
                  }
                  #nav ul li:last-child a {
                                  
                      border-right: 1px solid #ccc;
                  }
                  #nav ul a:hover{
                      background-color: #aaa;
                      color: #f4f4f4;
                  }
                  #nav ul:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  #content{
                      clear: both;
                  }
                  ვებგვერდი მიიღებს სასურველ სახეს:`
              },
              {
                  title:"მარტივი მაკეტის შექმნა",
                  data:`წინა თემებში შესწავლილი მასალის მიხედვით შევქმნათ მარტივი ვებგვერდის მაკეტი. პირველ რიგში განვსაზღვროთ გვერდის სტრუქტურა:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <link href="styles.css" rel="stylesheet">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                      </head>
                      <body>
                          <div id="header">
                              <h1>MySyte.com - Lorem Ipsum</h1>
                              <div id="nav">
                                  <ul>
                                      <li><a href="#">მთვარი</a></li>
                                      <li><a href="#">ბლოგი</a></li>
                                      <li><a href="#">ფორუმი</a></li>
                                      <li><a href="#">კონტაქტი</a></li>
                                      <li><a href="#">საიტის შესახებ</a></li>
                                  </ul>
                              </div>
                          </div>
                          <div class="wrapper">
                              <div id="sidebar1" class="aside">
                                  <h2>The standard Lorem Ipsum passage</h2>
                                  <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                                  ut labore et dolore magna aliqua..."</p>
                                  </div>
                              <div id="sidebar2" class="aside">
                                  <h2>1914 translation by H. Rackham</h2>
                                  <p>It is a long established fact that a reader will be distracted by the readable
                                  content of a page when looking at its layout.</p>
                                  <h3>Options</h3>
                                  <ul>
                                      <li>Item1</li>
                                      <li>Item2</li>
                                      <li>Item3</li>
                                  </ul>
                              </div>
                              <div id="article">
                                  <h2>What is Lorem Ipsum?</h2>
                                  <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry...</p>
                                  <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of
                                  classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock,
                                  a Latin professor at Hampden-Sydney College in Virginia...</p>
                              </div>
                          </div>
                          <div id="footer">
                              <p>Contacts: admin@mysyte.com</p>
                              <p>Copyright © MySyte.com, 2016</p>
                          </div>
                      </body>
                  </html>
                  ჯერ მოდის საიტის ქუდი - ბლოკი header, რომელიც შეიცავს გვერდის სათაურს და ნავიგაციის პანელს. შემდეგ მოდის ბლოკი wrapper რომელშიც მოთავსებულია ორი საიდბარი და გვერდის ძირითადი შიგთავსი. ბოლოს კი ფუტერი.
                  
                  ვებგვერდის დასაწყისში განსაზღვრულია styles.css ფაილის ჩაბმა. ეს ფაილი განსაზღვრავს სტილს ვებგვერდის ელემენტებისთვის. ამისათვის ვებგვერდთან ერთად იმავე საქაღალდეში უნდა შევქმნათ ფაილი styles.css და ჩავწეროთ მასში შემდეგი სტილები:
                  
                  * {
                      box-sizing: border-box;
                  }
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, ul, li{
                                  
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  body {
                      font-family: Verdana, Arial, sans-serif;   
                      background-color: #f7f7f7;
                  }
                  #header{
                      background-color: #f4f4f4;
                  }
                  #header h1 {
                      font-size: 24px;
                      text-transform: uppercase;
                      font-weight: bold;
                      padding: 30px 30px 30px 10px;
                      clear: both;
                  }
                  #nav {
                      background-color: #eee;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav li {
                      float: left;
                      list-style: none;  
                  }
                  #nav a {
                      display: block;
                      color: black;
                      padding: 10px 25px;
                      text-decoration: none;
                      border-right: 1px solid #ccc;
                  }
                  #nav li:last-child a {
                      border-right: none;
                  }
                  #nav a:hover {
                      font-weight: bold;
                  }
                  #nav:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  .wrapper{
                      background-color: #f7f7f7;
                  }
                  .aside h2 {
                      font-size: 0.95em;
                      margin-top: 15px;
                  }
                  .aside h3 {
                      font-size: 0.85em;
                      margin-top: 10px;
                  }
                  .aside p, .aside li {
                      font-size: .75em;
                      margin-top: 10px;  
                  }
                  .aside li{
                      list-style-type: none;
                  }
                  #sidebar1 {
                      float: left;
                      width: 20%;
                      padding: 0 10px 0 20px;
                  }
                  #sidebar2 {
                      float: right;
                      width: 20%;
                      padding: 0 20px 0 10px;
                  }
                  #article{
                      background-color: #fafafa;
                      border-left: 1px solid #ccc;
                      border-right: 1px solid #ccc;
                      margin-left: 20%;
                      margin-right: 20%;
                      padding: 15px;
                      width: 60%;
                  }
                  #article:after{
                      clear:both;
                      display:table;
                      content:'';
                  }
                  #article h2{
                      font-size: 1.3em;
                      margin-bottom:15px;
                  }
                  #article p{
                      line-height: 150%;
                      margin-bottom: 15px;
                  }
                  #footer{
                      border-top: 1px solid #ccc;
                      font-size: .8em;   
                      text-align: center;
                      padding: 10px 10px 30px 10px;
                  }
                  #nav ul, #header h1, .wrapper, #footer p {
                      max-width: 1200px;
                      margin: 0 auto;
                  }
                  .wrapper, #nav, #header, #footer{
                      min-width: 768px;
                  }
                  პირველი სამი სტილი აუქმებს ელემენტების თვისებებს მიუთითებლობისას და ადგენს სტილს body-სთვის.
                  
                  მომდევნო ორი სტილი განსაზღვრავს ქუდის და გვერდის სათაურის სტილს:
                  
                  #header{
                      background-color: #f4f4f4;
                  }
                  #header h1 {
                      font-size: 24px;
                      text-transform: uppercase;
                      font-weight: bold;
                      padding: 30px 30px 30px 10px;
                      clear: both;
                  }
                  შემდეგი რამდენიმე სტილი განსაზღვრავს ჰორიზონტალური ნავიგაციის პანელის იერსახეს:
                  
                  #nav {
                      background-color: #eee;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav li {
                      float: left;
                      list-style: none;  
                  }
                  #nav a {
                      display: block;
                      color: black;
                      padding: 10px 25px;
                      text-decoration: none;
                      border-right: 1px solid #ccc;
                  }
                  #nav li:last-child a {
                      border-right: none;
                  }
                  #nav a:hover {
                      font-weight: bold;
                  }
                  #nav:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  ჰორიზონტალური ნავიგაციის პანელის შექმნა დაწვრილებით იყო აღწერილი წინა თემებში.
                  
                  შემდეგ მოდის გვერდის შუა ნაწილისკერძოდ, საიდბარების იერსახის განმსაზღვრელი სტილები:
                  
                  .wrapper{
                      background-color: #f7f7f7;
                  }
                  .aside h2 {
                      font-size: 0.95em;
                      margin-top: 15px;
                  }
                  .aside h3 {
                      font-size: 0.85em;
                      margin-top: 10px;
                  }
                  .aside p, .aside li {
                      font-size: .75em;
                      margin-top: 10px;  
                  }
                  .aside li{
                      list-style-type: none;
                  }
                  #sidebar1 {
                      float: left;
                      width: 20%;
                      padding: 0 10px 0 20px;
                  }
                  #sidebar2 {
                      float: right;
                      width: 20%;
                      padding: 0 20px 0 10px;
                  }
                  wrapper კლასის სტილი საშუალებას გვაძლებს განვსაზღვროთ ფონი გვერდითა პანელებისთვის. თითოეული საიდბარისთვის გამოყოფილია გვერდის სიგანის 20 %. პროცენტული ზომები საშუალებას გვაძლევს ავტომატურად ვცვალოთ საიდბარების ზომები ბრაუზერის ზომების შეცვლისას. 
                  
                  შემდეგ მოდის გვერდის ძირითადი შიგთავსის და ფუტერის სტილიზაცია. 
                  
                  #article{
                      background-color: #fafafa;
                      border-left: 1px solid #ccc;
                      border-right: 1px solid #ccc;
                      margin-left: 20%;
                      margin-right: 20%;
                      padding: 15px;
                      width: 60%;
                  }
                  #article:after{
                      clear:both;
                      display:table;
                      content:'';
                  }
                  #article h2{
                      font-size: 1.3em;
                      margin-bottom:15px;
                  }
                  #article p{
                      line-height: 150%;
                      margin-bottom: 15px;
                  }
                  #footer{
                      border-top: 1px solid #ccc;
                      font-size: .8em;   
                      text-align: center;
                      padding: 10px 10px 30px 10px;
                  }
                  რადგანაც გვერდითა პანელებს აქვთ სიგანე 20 %, ძირითადი ნაწილისთვის სიგანე მითითებულია 60 % და მარჯვენა და მარცხენა გარე დაშორებები 20 %-ის ოდენობით.
                  
                  სულ ბოლოს მოდის ორი საკმაოდ მნიშვნელოვანი სტილი:
                  
                  #nav ul, #header h1, .wrapper, #footer p {
                      max-width: 1200px;
                      margin: 0 auto;
                  }
                  .wrapper, #nav, #header, #footer{
                      min-width: 768px;
                  }
                  ჯერ განსაზღვრულია ძირითადი სელექტორებისთვის მაქსიმალური სიგანე 1200 პიქსელი. რაც იმას ნიშნავს, რომ ამ ელემენტების სიგანე არ იქნება 1200 პიქსელზე მეტი. ავტომატური გარე დაშორებები მარჯვნიდან და მარცხნიდან ვებგვერდს გაასაშუალებს ჰორიზონტალურად. შესაბამისად, თუ ბრაუზერის სიგანე იქნება 1200 პიქსელზე მეტი, მაგალითად, 1400 პიქსელი, ყველა ელემენტი მოთავსდება 1200 პიქსელ სიგანეში და მარჯვნივ და მარცხნივ გაჩნდება (1400-1200)/2=100 პიქსელის სიგანის გარე დაშორება.
                  
                  მეორე სტილი ზღუდავს მინიმალურ სიგანეს და თუ ბრაუზერის სიგანე ჩამოცდება 768 პიქსელს, გაჩნდება ჰორიზონტალური გადახვევის ზოლი.
                  
                  შედეგად ვღებულობთ ასეთ ვებგვერდს:`
              },
              {
                  title:"პოზიციონირება",
                  data:`CSS იძლევა ელემენტების პოზიციონირების საშუალებას, ანუ ელემენტის მოთავსებას ვებგვერდის გარკვეულ ადგილას. ძირითადი თვისება, რომელიც ამისთვის გამოიყენება არის position. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  static: სტანდარტული პოზიციონირება, მნიშვნელობა მიუთითებლობისას
                  absolute: ელემენტის პოზიციონირება ხდება მისი შემცველი ელემენტის, კონტეინერის მიმართ, თუ  კონტეინერს არ აქვს მნიშვნელობა position:static
                  relative: ელემენტის მდებარეობა განისაზღვრება მიუთითებლობისას მისი პოზიციის მიმართ. როგორც წესი ის გამოიყენება არა ელემენტის პოზიციის განსაზღვრისთვის, არამედ მასში შემავალი ელემენტებისთვის ათვლის წერტილის დასადგენად აბსოლუტური პოზიციონირებისას
                  fixed: ელემენტის პოზიცია განისაზღვრება ბრაუზერის ფანჯრის მიმართ, რაც საშუალებას გვაძლევს შევქმნათ ფიქსირებული ელემენტები, რომლებიც უძრავნი რჩებიან გადახვევისას
                  არ შეიძლება float თვისებასთან ერთად პოზიციონირების გამოყენება static მნიშვნელობის გარდა.
                  
                  აბსოლუტური პოზიცია
                  
                  აბსოლუტური პოზიცია განისაზღვრება მნიშვნელობით absolute. ბრაუზერს გააჩნია ზედა, ქვედა, მარჯვენა და მარცხენა კიდეები. თითოეული მათგანისთვის CSS-ში არის შესაბამისი თვისება: left (დაშორება მარცხნიდან), right (დაშორება მარჯვნიდან), top (დაშორება ზემოდან), bottom (დაშორება ქვემოდან). მათი მნიშვნელობები მიეთითება პიქსელებში px, em  ერთეულებში ან პროცენტებში. არაა აუცილებელი ოთხივე კიდიდან დაშორების მითითება, როგორც წესი, საკმარისია ზედა და მარცხენა კიდეებიდან დაშორების მითითება:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .header {
                                  position: absolute;
                                  left: 100px;
                                  top: 50px;
                                  width: 430px;
                                  height: 100px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="header"></div>
                          <p>HELLO WORLD</p>
                      </body>
                  </html>
                  ელემენტი div აბსოლუტური პოზიციონირებით იქნება მოთავსებული ბრაუზერის მარცხენა კიდიდან 100 პიქსელის და ზედა კიდიდან 50 პიქსელის დაშორებით
                  
                  HTML5-ის დოკუმენტი
                  
                  ამასთან, არა აქვს მნიშვნელობა, რომ div ელემენტის მერე კიდევ მოდის სხვა ელემენტები. მას მიუხედავად ყველაფრისა ექნება ეს პოზიცია.
                  
                  თუ ელემენტი, რომელსაც აქვს აბსოლუტური პოზიცია, მოთავსებულია სხვა ელემენტის (კონტეინერის) შიგნით და ამ კონტეინერის position თვისების მნიშვნელობა განსხვავებულია static-საგან, ელემენტი პოზიციას პიიღებს კონტეინერის მიმართ. 
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .outer {
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 430px;
                                  height: 100px;
                                  border: 1px solid #ccc;
                              }
                              .inner{
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 50px;
                                  height: 50px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="outer">
                              <div class="inner"></div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფარდობითი პოზიცია
                  
                  ფარდობითი პოზიცია განისაზღვრება მნიშვნელობით relative. კონკრეტული პოზიციის მისათითებლად, თუ რამდენზე ხდება პოზიციის წანაცვლება, გამოიყენება იგივე თვისებები: left, right, top, bottom:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .outer {
                                  position: relative;
                                  left: 80px;
                                  top: 40px;
                                  width: 300px;
                                  height: 100px;
                                  border: 1px solid #ccc;
                              }
                              .inner{
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 50px;
                                  height: 50px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="outer"><div class="inner"></div></div>
                      </body>
                  </html>
                   
                  
                  თვისება z-index
                  
                  მიუთითებლობისას, თუ ორი ელემენტის მდებარეობა იკვეთება ერთმანეთში, ზემოდან გამოჩნდება ის ელემენტი, რომელიც html-ში არის აღწერილი ბოლოს. z-index თვისების მეშვეობით შესაძლებელია ამ თანმიმდევრობის შეცვლა. z-index ღებულობს რიცხვით მნიშვნელობებს. ელემენტი, რომლის z-index მეტია, გამოჩნდება ზემოდან.
                  
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              body{
                                  margin:0;
                                  padding:0;
                              }
                              .content{
                                  position: relative;
                                  top: 15px;
                                  left: 20px;
                                  width: 250px;
                                  height: 180px;
                                  background-color: #eee;
                                  border: 1px solid #ccc;
                              }
                              .redBlock{
                                  position: absolute;
                                  top: 20px;
                                  left:50px;
                                  width: 80px;
                                  height: 80px;
                                  background-color: red;
                              }
                              .blueBlock{
                                  position: absolute;
                                  top: 80px;
                                  left: 80px;
                                  width: 80px;
                                  height: 80px;
                                  background-color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <div class="content">
                              <div class="redBlock"></div>
                              <div class="blueBlock"></div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მივუთითოთ z-index ბლოკისთვის redBlock:
                  
                  .redBlock{
                      z-index: 100;
                                                  
                      position: absolute;
                      top: 20px;
                      left:50px;
                      width: 80px;
                      height: 80px;
                      background-color: red;
                  }
                  z-index მნიშვნელობა მითითებულია 100, თუმცა ვინაიდან მეორე ელემენტს z-index მითითებული არა აქვს და, შესაბამისად ნულის ტოლია, საკმარისია მივუთითოთ ნებისმიერი ნულზე მეტი რიცხვი.
                  
                  ახლა უკვე წითელი ელემენტი გადაფარავს ლურჯს:`
              },
              {
                title:"ფიქსირებული პოზიცია",
                data:`ფიქსირებული პოზიცია წარმოადგენს ელემენტების ბრაუზერში უძრავად მოთავსების გავრცელებულ მეთოდს. საკმაოდ ხშირად საიტებზე შეიძლება ვნახოთ ნავიგაციის პანელი, რომელიც არ იცვლის პოზიციას და არის უძრავად გადახვევის დროს.

                ელემენტისთვის ფიქსირებული პოზიციის მისაცემად საჭიროა მივანიჭოთ მნიშვნელობა position: fixed და left, right, top, bottom თვისებებით განვუსაზღვროთ მდებარეობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>პოზიციონირება</title>
                        <style>
                            body{
                                margin:0;
                                padding:0;
                                overflow: auto;
                            }
                            .toolbar{
                                position: fixed;
                                top: 0;
                                left: 0;
                                right: 0;
                                background-color: #222;
                                border-bottom: 1px solid #ccc;
                            }
                            .toolbar a{
                                color: #eee;
                                display: inline-block;
                                padding: 10px;
                                text-decoration: none;
                                font-family: Verdana;
                            }
                            .content{
                                margin-top: 50px;
                                padding: 10px;              
                            }
                        </style>
                    </head>
                    <body>
                        <div class="toolbar">
                            <a href="#">მთავარი</a>
                            <a href="#">ბლოგი</a>
                            <a href="#">კონტაქტი</a>
                            <a href="#">საიტის შესახებ</a>
                        </div>
                        <div class="content"><h3>XXXV ღამით ყველა კატა ნაცრისფერია</h3>
                                მოუთმენლად ელოდნენ ამ საღამოს პორთოსი და დ'არტანიანი და, როგორც
                                იქნა, ეღირსათ დაღამება.
                                დ'არტანიანი, ჩვეულებრივ, ცხრა საათზე მივიდა მილედის სანახავად. მას
                                არასოდეს არ მიუღია იგი ასე კარგად. გასკონელმა მაშინვე იგრძნო, რომ
                                ქალბატონისათვის კეტის მიერ გადაცემული წერილი იყო მიზეზი მისი
                                მხიარულებისა.
                                შემოვიდა კეტი და შარბათი მოართვა. მასაც მხიარული, აღტაცებული სახით
                                შეჰყურებდა მილედი და ტკბილად უღიმოდა. მაგრამ ისეთი დაღონებული იყო
                                საბრალო გოგო, რომ ვერც კი შეამჩნია თავისი ქალბატონის გულკეთილობა.
                                დ'არტანიანი ხან ერთ ქალს შეხედავდა, ხან მეორეს და იძულებული იყო,
                                ეღიარებინა თავისი თავის წინაშე, რომ შეცდომა დაეშვა ბუნებას ამ ქალების
                                შექმნაში, როდესაც ცნობილი ქალბატონისათვის საზიზღარი, სათნოების
                                უარმყოფელი სული ჩაედგა, ხოლო მოახლისათვის, პირიქით, — დიდებულის</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                იმისათვის, რომ ფიქსირებული ბლოკი გაიშალოს ბრაუზერის მთელ სიგანეზე, მას ენიჭება სამი მნიშვნელობა:
                
                top: 0;
                left: 0;
                right: 0;
                ფიქსირებული ბლოკი (ისევე როგორც აბსოლუტური პოზიციის მქონე) თითქოს არ არსებობს დანარჩენი ბლოკებისთვის, რადგან იგი ამოვარდნილია html-ის ჩვეულებრივი თანმიმდევრობისაგან. ამიტომ ფიქსირებული ელემენტებით შეიძლება გადაიფაროს სხვა ელემენტები. ასე რომ არ მოხდეს, ძირითადი ბლოკისთვის მიცემულია დაშორება ზემოდან margin-top:50px. ვინაიდან ეს დაშორება ითვლება ზედა ბრაუზერის კიდიდან (და არა ფიქსირებული ელემენტიდან), იგი მეტი უნდა იყოს ფიქსირებული ელემენტის სიმაღლეზე.`
            }
           
            ]
        },
        {
            title:"	თავი 8. ტრანსფორმირება, გადასვლები და ანიმაციები",
            content:[
                {
                    title:"ტრანსფორმირება",
                    data:`CSS3-ის ერთ-ერთი სიახლე წინა ვერსიებთან შედარებით არის ჩაშენებული ელემენტის ტრანსფორმირების შესაძლებლობა. ტრანსფორმირების ქვეშ იგულისხმება ელემენტის ბრუნვა, მასშტაბირება, დახრა ან გადაადგილება ჰორიზონტალური ან ვერტიკალური მიმართულებით. ტრანსფორმირებისთვის გამოიყენება თვისება transform.

                    ბრუნვა
                    
                    ელემენტის მოსატრიალებლად თვისება transform იყენებს ფუნქციას rotate:
                    
                    transform: rotate(30deg);
                    სიტყვა rotate-ს შემდეგ ფრჩხილებში იწერება ბრუნვის კუთხე გრადუსებში, ჩვენს შემთხვევაში 30 გრადუსი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .rotated{
                                    transform: rotate(30deg);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="rotated">rotate(30deg)</div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    უნდა აღინიშნოს, რომ ტრიალისას ელემენტი შეიძლება გადაეფაროს სხვა ელემენტებს, ვინაიდან ჯერ ხდება ელემენტისთვის ადგილის გამოყოფა და მერე ტრიალი.
                    
                    ბრუნვის კუთხე შეიძლება იყოს უარყოფითიც. ამ შემთხვევაში ელემენტი ტრიალდება საპირისპირო მიმართულებით.
                    
                    მასშტაბირება
                    
                    მასშტაბირებას აქვს შემდეგი სახე:
                    
                    transform: scale(1.5);
                    მოცემულ მაგალითში ელემენტის ზომები იზრდება 1.5-ჯერ.
                    
                    ვნახოთ მაგალითი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .halfScale{
                                    transform: scale(0.5);
                                }
                                .doubleScale{
                                    transform: scale(2);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="doubleScale">scale(2)</div>
                            <div></div>
                            <div class="halfScale">scale(0.5)</div>
                        </body>
                    </html>
                    1-ზემეტი მნიშვნელობისას ელემენტის ზომები იზრდება, 1-ზე ნაკლებისას - მცირდება.
                    
                    მასშტაბირება შეიძლება გამოვიყენოთ ცალ-ცალკე ვერტიკალური და ჰორიზონტალური მიმართულებებისთვის:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .scale1{
                                    transform: scale(2, 0.5);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="scale1">scale(2, 0.5)</div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    მოცემულ მაგალითში ჰორიზონტალურად ხდება სკალირება კოეფიციენტით 2 (იზრდება ორჯერ), ხოლო ვერტიკალურად - კოეფიციენტით 0.5 (მცირდება ორჯერ).
                    
                    ასევე შეიძლება სკალირება მხოლოდ ერთი მიმართულებით ფუნქციების: scaleX() -სკალირება ჰორიზონტალურად და scaleY() - სკალირება ვერტიკალურად, მეშვეობით.
                    
                    სკალირებისთვის უარყოფითი მნიშვნელობის მინიჭებით შესაძლებელია მივიღოღ სარკისებური ანარეკლის ეფექტი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .scale1{
                                    transform: scaleX(-1);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="scale1">scaleX(-1)</div>
                            <div></div>
                        </body>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გადაადგილება
                    
                    ელემენტის გადასასდგილებლად გამოიყენება ფუნქცია translate:
                    
                    transform: translate(offset_X, offset_Y);
                    offset_X-ის მნიშვნელობა განსაზღვრავს, რამდენით გადაადგილდება ელემენტი ჰორიზონტალური მიმართულებით, offset_Y - ვერტიკალური მიმართულებით. მაგალითად, გადავაადგილოთ ბლოკი 30 პიქსელით ქვევით და 50 პიქსელით მარჯვნივ:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .translated{
                                    transform: translate(50px, 30px);
                                    background-color:red;
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="translated"></div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გადაადგილების ერთეულებად შეიძლება CSS-ის ნებისმიერი ერთეულის გამოყენება: px, em, % და ა. შ.
                    
                    დამატებითი ფუნქციების მეშვეობით შესაძლებელია გადაადგილება მხოლოდ ჰორიზონტალური (ფუნქცია translateX()) ან ვერტიკალური (ფუნქცია translateY()) მიმართულებით.
                    
                    უარყოფითი მნიშვნელობების მინიჭებით შესაძლებელია გადაადგილება საწინააღმდეგო მიმართულებებით.
                    
                    დახრა
                    
                    ელემენტის დახრისთვის გამოიყენება ფუნქცია skew().
                    
                    transform: skew(X, Y);
                    პირველი პარამეტრი განსაზღვრავს დახრის კუთხეს X ღერძის მიმართ, მეორე - Y ღერძის მიმართ.
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .skewed{
                                    transform: skew(30deg, 10deg);
                                    background-color:red;
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="skewed"></div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    ელემენტის დასახრელად მხოლოდ ერთი ღერძის მიმართ, მეორე ღერძის მიმართ დახრის 0-ის ტოლი კუთხე უნდა მივუთითოთ.
                    
                    მაგალითად, 45 გრადუსით მხოლოდ X ღერძის მიმართ:
                    
                     
                    
                    transform: skew(45deg, 0);
                    45 გრადუსით მხოლოდ Y ღერძის მიმართ:
                    
                    transform: skew(0,45deg);
                    მხოლოდ X და Y ღერძის მიმართ დახრისთვის არსებობს დამატებითი ფუნქციებიც: skewX() და skewY(). მაგალითად:
                    
                    transform: skewX(45deg);
                    დახრის კუთხე შეიძლება იყოს უარყოფითი. ამ შემთხვევაში ელემენტის დახრა ხდება საწინააღმდეგო მიმართულებით:
                    
                    transform: skewX(-30deg);
                    კომბინირება
                    
                    თუ ერთდროულად რამდენიმე ტრანსფორმირების განხორციელება გვინდა, შესაძლოა მათი კომბინირება:
                    
                    transform: translate(50px, 100px) skew(30deg, 10deg) scale(1.5) rotate(90deg);
                     
                    
                    ტრანსფორმაციის ამოსავალი წერტილი
                    
                    მიუთითებლობისას ტრანსფორმირების ამოსავალ წერტილად (რომლის მიმართაც ხდება ელემენტის ტრანსფორმირება) ბრაუზერი იყენებს ელემენტის ცენტრს. transform-origin თვისების მეშვეობით შესაძლებელია ამოსავალი წერტილის შეცვლა. იგი იღებს მნიშვნელობას px, em და % ერთეულებში. magaliTad:
                    
                    transform-origin: 20% 40%;
                    ასევე შეიძლება მიეთითოს ელემენტის ერთ-ერთი კუთხე:
                    
                    left top: მარცხენა ზედა კუთხე
                    left bottom: მარცხენა ქვედა კუთხე
                    right top: მარჯვენა ზედა კუთხე
                    right bottom: მარჯვენა ქვედა კუთხე
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 100px;
                                    height: 100px;
                                    margin: 80px 30px;
                                    float: left;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                }
                                .transform1{
                                    transform: rotate(-45deg);
                                }
                                .transform2{
                                    transform-origin: left top;
                                    transform: rotate(-45deg);
                                }
                                .transform3{
                                    transform-origin: right bottom;
                                    transform: rotate(-45deg);
                                }
                            </style>
                        </head>
                        <body>
                            <div class="transform1"></div>
                            <div class="transform2"></div>
                            <div class="transform3"></div>
                        </body>
                    </html>`
                },
                {
                  title:"გადასვლები",
                  data:`გადასვლა (transition) წარმოადგენს ანიმაციას ერთი სტილიდან მეორეში გარკვეული პერიოდის განმავლობაში.

                  გადასვლისთვის პირველ რიგში, საჭიროა ორი განსხვავებული სტილი ელემენტისთვის: ერთი - საწყისი, რომელიც ეექნება ელემენტს თავიდან და მეორე - გადასვლის შედეგი. ვნახოთ გადასვლის მარტივი მაგალითი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>გადასვლები</title>
                          <style>
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                  
                                  background-color: #ccc;
                                  transition-property: background-color;
                                  transition-duration: 2s;
                              }
                              div:hover{
                                  background-color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  აქ ხდება div ელემენტის ფონის ანიმაცია. როცა გადავატარებთ მაუსს ფერი შეიცვლება წითელზე არა ერთბაშად, არამედ 2 წამის განმავლობაში და როცა მოვაშორებთ მაუსს დაუბრუნდება საწყის ფერს ასევე 2 წამის განმავლობაში. 
                  
                  იმისათვის, რომ მივუთითოთ თუ რომელი თვისების ანიმირება ხდება, ეს თვისება უნდა მივუთითოთ მნიშვნელობად თვისებას transition-property.
                  
                  transition-property: background-color;
                  შესაძლებელია სხვა თვისებების ანიმირებაც. მაგალითად: color, background-color, border-color. იმ თვისებების სრული სია, რომელთა ანიმირებაც შესაძლებელია, შეგიძლიათ ნახოთ მისამართზე: http://www.w3.org/TR/css3-transitions/#animatable-properties.
                  
                  გადასვლას უნდა მიეთითოს ხანგრძლივობა:
                  
                  transition-duration: 2s;
                  მისი მნიშვნელობა შეიძლება განისაზღვროს წამებით (s) ან მილიწამებით (ms):
                  
                  transition-duration: 500ms;
                  და ბოლოს, საჭიროა ანიმაციის ინიციატორი და ანიმირებადი თვისების ფინალური მნიშვნელობა. ინიციატორს წარმოადგენს მოქმედება, რომლის დროსაც ხდება ერთი სტილის შეცვლა მეორით. ჩვენს შემთხვევაში ინიციატორს წარმოადგენს ფსევდოკლასო :hover. ანუ ანიმაცია მოქმედებაში მოდის მაუსის გადატარებისას.
                  
                  :hover ფსევდოკლასის გარდა ინიციატორად შეიძლება გამოვიყენოთ სხვა ფსევდოკლასებიც, მაგალითად :active (ბმული მაუსის დაჭერის დროს), :focus (ელემენტის მიერ ფოკუსის მიღება).
                  
                  ასევე გადასვლის ანიმაციის გასაშვებად შეიძლება JavaScript-ის გამოყენებაც.
                  
                  ანიმაცია რამდენიმე თვისებით
                  
                  საჭიროებისას შესაძლებელია ერთდროულად CSS-ის რამდენიმე თვისების ანიმირება. მაგალითად, შევცვალოთ წინა მაგალითში სტილები:
                  
                  div{
                      width: 100px;
                      height: 100px;
                      margin: 40px 30px;
                      border: 1px solid #333;
                      background-color: #ccc;
                      
                      transition-property: background-color, width, height, border-color;
                      transition-duration: 2s;
                  }
                  div:hover{
                      background-color: red;
                      width: 120px;
                      height: 120px;
                      border-color: blue;
                  }
                  აქ ხდება ერთდროულად 4 თვისების ანიმირება. ანიმაციის დრო თოთოეულისთვის არის 2 წამი. თუმცა შესაძლებელია თითოეული თვისებისთვის სხვადასხვა დრო მიეთითოს:
                  
                  transition-property: background-color, width, height, border-color;
                  transition-duration: 2s, 3s, 1s, 2s;
                  ისევე როგორც transition-property-ში არის ჩამოთვლილი თვისებები, transition-duration-სი ჩამოთვლილია შესაბამისი ხანგრძლივობები იგივე თანმიმდევრობით. მაგალითად, width თვისების ანიმაციის ხანგრძლივობა იქნება 2 წამი.
                  
                  მძიმეებით ჩამოთვლის გარდა შესაძლებელია მიეთითოს ერთდროულად ყველა თვისების ანიმაცია. ამისთვის მიეთითება all:
                  
                  ​​​​​​​transition-property: all;
                  transition-duration: 2s;
                  ანიმაციის ფუნქციები
                  
                  თვისება transition-timing-function საშუალებას იძლევა გაკონტროლდეს ანიმაციის ხანგრძლივობა და შესრულება. ანუ ეს თვისება განსაზღვრავს, როდის აჩქარდეს ან შენელდეს ანიმაცია. იგი იღებს შემდეგ მნიშვნელობებს:
                  
                  linear: წრფივი ფუნქცია, რომლის დროსაც ანიმაცია თანაბრად სრულდება
                  ease: ფუნქცია, რომლის დროსაც ანიმაცია სწრაფდება შუისკენ და ნელდება ბოლოსკენ. იგი უზრუნველყოფს ანიმაციის უფრო ბუნებრივ შესრულებას
                  ease-in: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის დასაწყისში
                  ease-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის ბოლოს
                  ease-in-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება დასაწყისში და ბოლოსკენ
                  cubic-bezier: ანიმაციისთვის გამოიყენება ბესიეს კუბური ფუნქცია
                  გამოვიყენოთ ფუნქცია ease-in-out:
                  
                  ​​​​​​​<!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>გადასვლები</title>
                          <style>
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                  
                                  background-color: #ccc;
                                  transition-property: background-color, width;
                                  transition-duration: 2s, 10s;
                                  transition-timing-function: ease-in-out;
                              }
                              div:hover{
                                  background-color: red;
                                  width: 200px;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  ბეზიეს კუბური ფუნქციის გამოყენებისთვის მას უნდა გადავცეთ გარკვეული პარამეტრები:
                  
                  transition-timing-function: cubic-bezier(.5, .6, .24, .18);
                  გადასვლის დაყოვნება
                  
                  თვისება transition-delay საშუალებას გვაძლევს დავაყოვნოთ გადასვლის დაწყება:
                  
                  transition-delay: 500ms;
                  დრო ასევე მიეთითება წამებში (s) ან მილიწამებში (ms).
                  
                  თვისება transition
                  
                  თვისება transition წარმოადგენს ზემოთ განხილული ყველა თვისების შემოკლებულ ჩანაწერს. ნაცვლად შემდეგი ჩამონათვალისა:
                  
                  transition-property: background-color;
                  transition-duration: 3s;
                  transition-timing-function: ease-in-out;
                  transition-delay: 500ms;​​​​​​​
                  შეგვიძლია ჩავწეროთ შემოკლებულად:
                  
                  transition: background-color 3s ease-in-out 500ms;`
              },
              {
                  title:"ანიმაცია",
                  data:`
                  ანიმაცია ელემენტის სტილის ანიმირების მრავალფეროვან საშუალებას იძლევა. თუ გადასვლის დროს ჩვენ გვაქვს მხოლოდ საწყისი და საბოლოო სტილის მითითების საშუალება, ანიმაციის დროს ასევე შეგვიძლია მრავალი შუალედური სტილის მინიჭებაც.
                  
                  ანიმაცია ეყრდნობა საკვანძო კადრების (keyframes) თანმიმდევრულ ცვლას. თითოეული საკვანძო კადრი წარმოადგენს თვისებების ნაკრებს. მათი თანმიმდევრული ცვლა ქმნის ანიმაციას.
                  
                  საკვანძო კადრების გამოცხადება ხდება შემდეგნაირად:
                  
                  @keyframes ანიმაციის_დასახელება {
                      from {
                          /* საწყისი CSS სტილი */
                      }
                      to {
                          /* საბოლოო CSS სტილი */
                      }
                  }
                  საკვანძო სიტყვას @keyframes მოსდევს მისი დასახელება. შემდეგ ფიგურულ ფრჩხილებში ხდება სულ მცირე, ორი სტილის განსაზღვრა. from სიტყვის შემდეგ მოდის სტილი, რომელიც ელემენტს გააჩნია ანიმაციის დასაწყისში, to-ს შემდეგ კი - სტილი, რომელსაც ელემენტი იღებს ანიმაციის ბოლოს. თითოეული სტილი ფორმირდება ჩვეულებრივი CSS-ის სტილის მსგავსად ერთი ან რამდენიმე თვისების მითითებით.
                  
                  მაგალითად, შევქმნათ ანიმაცია ელემენტის ფონის ფერისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ანიმაცია</title>
                          <style>
                              @keyframes backgroundColorAnimation {
                                  from {
                                      background-color: red;
                                  }
                                  to {
                                      background-color: blue;
                                  }
                              }
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                   
                                  background-color: #ccc;
                                  animation-name: backgroundColorAnimation;
                                  animation-duration: 2s;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  მოცემულ მაგალითში ანიმაციის სახელია "backgroundColorAnimation". ზოგადად, ანიმაციის სახელი შეიძლება ნებისმიერი იყოს.
                  
                  ამ ანიმაციაში ხდება წითელი ფერიდან ლურჯში გადასვლა. ანიმაციის დასრულების შემდეგ ელემენტი მიიღებს იმ ფერს, რომელიც განსაზღვრული აქვს ელემენტს შესაბამისი სტილით.
                  
                  იმისათვის, რომ ანიმაცია გამოვიყენოთ ელემენტისთვის, ამ ელემენტს სტილში ეთითება თვისება animation-name, რომლის მნიშვნელობაშიც უნდა მივუთიტოთ იმ ანიმაციის სახელი, რომლის გამოყენებაც გვსურს. ელემენტს ასევე ეთითება თვისება animation-duration, რომელიც ანიმაციის ხანგრძლივობას განსაზღვრავს. მოცემულ შემთხვევაში - 2 წამი.
                  
                  აღწერილ შემთხვევაში ანიმაცია იწყება გვერდის ჩატვირთვისას. თუმცა შეიძლება ანიმაციის გაშვება მომხმარებლის მოქმედებისას. მაგალითად, ფსევდოკლასის :hover გამოყენებით ანიმაცია გაიშვებს ელემენტზე მაუსის გადატარებისას:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ანიმაცია</title>
                          <style>
                            @keyframes backgroundColorAnimation {
                              from {
                                  background-color: red;
                              }
                              to {
                                  background-color: blue;
                              }
                          }
                          div{
                              width: 100px;
                              height: 100px;
                              margin: 40px 30px;
                              border: 1px solid #333;
                              background-color: #ccc;
                          }
                          div:hover{                         
                              animation-name: backgroundColorAnimation;
                              animation-duration: 2s;
                          }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  ბევრი საკვანძო კადრი
                  
                  როგორც უკვე აღინიშნა, გარდა საწყისი და საბოლოო კადრისა, შეიძლება ასევე შუალედური კადრების განსაზღვრაც. შუალედურ კადრებს ეთითება პროცენტული მნიშვნელობა, რომლიდანაც ეს კადრი იმოქმედებს.
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                      }
                      25%{
                          background-color: yellow;
                      }
                      50%{
                          background-color: green;
                      }
                      75%{
                          background-color: blue;
                      }
                      to {
                          background-color: violet;
                      }
                  }
                  ანიმაცია დაიწყება წითელი ფერით. დროის 25 %-ის გასვლის შემდეგ ის შეიცვლება ყვითელით, კიდევ 25 %-ის გასვლის შემდეგ - მწვანით და ა. შ.
                  
                  ასევე შეიძლება ერთ საკვანძო კადრში რამდენიმე თვისების ანიმირება მოხდეს:
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                          opacity: 0.2;
                      }
                      to {
                          background-color: blue;
                          opacity: 0.9;
                      }
                  }
                  ასევე შეიძლება განისაზღვროს რამდენიმე დამოუკიდებელი ანიმაცია, ხოლო მათი გამოყენება მოხდეს ერთად:
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                      }
                      to {
                          background-color: blue;
                      }
                  }
                  @keyframes opacityAnimation {
                      from {
                          opacity: 0.2;
                      }
                      to {
                          opacity: 0.9;
                      }
                  }
                  div{
                      width: 100px;
                      height: 100px;
                      margin: 40px 30px;
                      border: 1px solid #333;
                      background-color: #ccc;
                      
                      animation-name: backgroundColorAnimation, opacityAnimation;
                      animation-duration: 2s, 3s;
                  }
                  ასეთ დროს თვისებაში animation-name ჩამოითვლება მძიმით გამოყოფილი საჭირო ანიმაციების სახელები. იგივე თანმიმდევრობით მიენიჭება დრო ანიმაციებს.
                  
                  ანიმაციის დასრულება
                  
                  ზოგადად ანიმაციისთვის განკუთვნილი დროის გასვლის შემდეგ ანიმაცია სრულდება. თუმცა დამატებითი თვისებებით შეგვიძლია შევცვალოთ ეს წესი.
                  
                  ასე, მაგალითად, animation-iteration-count განსაზღვრავს, რამდენჯერ უნდა განმეორდეს ანიმაცია:
                  
                  animation-iteration-count: 3;
                  თუ გვინდა, რომ ანიმაცია დაუსრულებლად გაგრძელდეს, ამ თვისებას უნდა მივანიჭოთ მნიშვნელობა infinite:
                  
                  animation-iteration-count: infinite;
                  გამეორებისას ანიმაცია იწყება ისევ საწყისი საკვანძო კადრიდან. მაგრამ animation-direction: alternate; თვისების გამოყენებით გამეორებისას ანიმაცია შესრულდება უკუმიმართულებით.
                  
                  animation-name: backgroundColorAnimation, opacityAnimation;
                  animation-duration: 2s, 2s;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  ანიმაციის დასრულების შემდეგ ბრაუზერი ელემენტს ანიჭებს იმ სტილს, რომელიც მას ჰქონდა ანიმაციის დაწყებამდე. მაგრამ animation-fill-mode: forwards თვისების გამოყენებით ელემენტს ანიმაციის დასრულების მერე ენიჭება ის სტილი, რომელიც იყო განსაზღვრული ბოლო საკვანძო კადრით.
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 2s;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  animation-fill-mode: forwards;
                  ანიმაციის დაყოვნება
                  
                  animation-delay თვისების გამოყენებით შეიძლება დავაყოვნოთ ანიმაციის დაწყება:
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 5s;
                  animation-delay: 1s;    /* დაყოვნება 1 წამით */
                  ანიმაციის ფუნქციები
                  
                  ისევე როგორც გადასვლებისთვის, თვისება transition-timing-function საშუალებას იძლევა გაკონტროლდეს ანიმაციის ხანგრძლივობა და შესრულება. ანუ ეს თვისება განსაზღვრავს, როდის აჩქარდეს ან შენელდეს ანიმაცია. იგი იღებს შემდეგ მნიშვნელობებს:
                  
                  linear: წრფივი ფუნქცია, რომლის დროსაც ანიმაცია თანაბრად სრულდება
                  ease: ფუნქცია, რომლის დროსაც ანიმაცია სწრაფდება შუისკენ და ნელდება ბოლოსკენ. იგი უზრუნველყოფს ანიმაციის უფრო ბუნებრივ შესრულებას
                  ease-in: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის დასაწყისში
                  ease-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის ბოლოს
                  ease-in-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება დასაწყისში და ბოლოსკენ
                  cubic-bezier: ანიმაციისთვის გამოიყენება ბესიეს კუბური ფუნქცია
                  თვისება animation
                  
                  თვისება animation საშუალებას იძლევა ყველა ზემოთჩამოთვლილი თვისება გაერთიანდეს და შემოკლებულად ჩაიწეროს:
                  
                  animation: animation-name animation-duration animation-timing-function animation-iteration-count animation-direction animation-delay animation-fill-mode;
                  ამასთან სავალდებულოა მხოლოდ პირველი ორი პარამეტრი: დასახელება და ხანგრძლივობა. დანარჩენი მიეთითება მხოლოდ საჭიროებისამებრ.
                  
                  ავიღოთ თვისებების შემდეგი ერთობლიობა:
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 5s;
                  animation-timing-function: ease-in-out;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  animation-delay: 1s;
                  animation-fill-mode: forwards;
                  იგივე შეიძლება ჩავწეროთ შემოკლებულად:
                  
                  animation: backgroundColorAnimation 5s ease-in-out 3 alternate 1s forwards;
                  ბანერის შექმნა ანიმაციის მეშვეობით
                  
                  მაგალითისთვის ანიმაციის მეშვეობით შეგვიძლია შევქმნათ ბანერი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>CSS3-ბანერი</title>
                      <meta charset="utf-8" />
                      <style type="text/css">
                      @keyframes text1
                      {
                          10%{opacity: 1;}
                          40%{opacity: 0;}
                      } 
                      @keyframes text2
                      {
                          30%{opacity: 0;}
                          60%{opacity:1;}
                      }
                      @keyframes banner
                      {
                          10%{background-color: #008978;}
                          40%{background-color: #34495e;}
                          80%{background-color: green;}
                      }
                      .banner
                      {
                          width: 600px;
                          height: 120px;
                          background-color: #777;
                          margin: 0 auto;
                          position: relative;
                      }
                      .text1,.text2
                      {
                          position: absolute;
                          width: 100%;
                          height: 100%;
                          line-height: 120px;
                          text-align: center;
                          font-size: 40px;
                          color: #fff;
                          opacity: 0;
                      } 
                      .text1
                      {
                          animation : text1 6s infinite;
                      } 
                      .text2
                      {
                          animation : text2 6s infinite;
                      } 
                      .animated
                      {
                          opacity: 0.8;
                          position: absolute;
                          width: 100%;
                          height: 100%; 
                          background-color: #34495e;
                          animation: banner 6s infinite;
                      }
                      </style>
                  </head>
                  <body>
                      <div class="banner">
                          <div class="animated">
                              <div class="text1">მხოლოდ ამ თვეში</div>
                              <div class="text2">ფასდაკლება 20%</div>
                          </div>
                      </div>
                  </body>
                  </html>
                  აქ ერთდროულად მუშაობს სამი ანიმაცია. ანიმაცია banner ცვლის ბანერის ფონს, ხოლო text1 და text2 აჩენენ და მალავენ ტექსტს გამჭვირვალობის თვისების გამოყენებით. როცა ჩანს პირველი ტექსტი, მეორე დამალულია და პირიქით. ამით ჩვენ ვღებულობთ ტექსტის ანიმაციას ბანერში.`
              },
          
            ]
        },
        {
            title:"თავი 9. ადაპტირებული დიზაინი",
            content:[
                {
                    title:"შესავალი ადაპტირებულ დიზაინში",
                    data:`დღეისათვის სულ უფრო და უფრო მეტ გავრცელებას პოულობს სხვადასხვა სახის გაჯეტები - სმარტფონები, პლანშეტები, ჭკვიანი საათები და სხვა მოწყობილობები, რომელთაც აქვთ კავშირი ინტერნეტთან და საიტების დათვალიერების საშუალება. ზოგიერთი გათვლებით მთელი ინტერნეტ-ტრაფიკის თითქმის ნახევარი მოდის ასეთ გაჯეტებზე, რომელთა ეკრანი გარჩევადობა (ეკრანის ზომა) მნიშვნელოვნად განსხვავდება ჩვეულებრივი კომპიუტერის ეკრანის გარჩევადობისგან. მთელი პრობლემა მდგომარეობს იმაში, რომ ვებგვერდი სხვადასხვა გარჩევადობის ეკრანზე სხვადასხვანაირად გამოიყურება. თავდაპირველი გადაწყვეტა ამ პრობლემის იყო მათთვის ცალკე ვერსიების დამზადება.

                    მობილური ტელეფონების განვითარების საწყის ეტაპზე მათ მომხმარებლებს შეეძლოთ WAP პროტოკოლის მეშვეობით მიეღოთ სპეციალური wap-საიტები, რომლებიც შექმნილი იყო wml -ის - xml საფუძველზე შექმნილი html-ის მსგავსი ენის მეშვეობით.
                    
                    თუმცა გაჯეტების განვითარებამ მიგვიყვანა იქამდე, რომ დღეისატვის მობილურ ტელეფონებს აქვთ გაცილებით უფრო მეტი შესაძლებლობები ინფორმაციის ეკრანზე გამოტანისთვის, ვიდრე ადრეულ მოწყობილობებს. ამიტომ ვებ-გვერდები მათთვის იქმნება იგივე HTML5-ის და  CSS3-ის გამოყენებით.
                    
                    გარდა ამისა, დიდი რაოდენობის სხვადასხვა სახის მოწყობილობების გაჩენამ შექმნა აუცილებლობა, რომ ვებგვერდები ადაპტირებული იყოს არა მხოლოდ სმარტფონებისა და პლანშეტებისთვის, არამედ ასევე დიდ ეკრანიანი ტელევიზორებისა და სხვა მოწყობილობებისთვის, რომელთაც აქვთ ინტერნეტთან კავშირის და ვებსაიტების დათვალიერების შესაძლებლობა. 
                    
                    ამ პრობლემის გადასაწყვეტად შეიქმნა ადაპტირებული დიზაინის კონცეფცია. მისი არსი მდგომარეობს ეკრანის სიგანიდან გამომდინარე ელემენტების მასშტაბირებასა და გადაწყობაში.
                    
                    თუმცა ახლაც ვხვდებით შემთხვევებს, როცა მობილური მოწყობილობებისთვის იქმნება ცალკე საიტები, რომელთაც ხშირად პრეფიქსად აქვს m.
                    
                    ადაპტირებული დიზაინის ტესტირება
                    
                    ადაპტირებული დიზაინის მქონე ვებგვერდის შექმნის პროცესში შეიძლება გადავაწყდეთ ტესტირების პრობლემებს, ვინაიდან ვებგვერდის შექმნა, როგორც წესი, ჩვეულებრივ კომპიუტერში ხდება. საბედნიეროდ, თანამედროვე ბრაუზერების უმეტესობას საშუალება აქვს მოახდინოს სხვადასხვა ზომის ეკრანის ემულაცია.
                    
                    მაგალითად, Google Chrome-ში უნდა გადავიდეთ More tools => Developer tools (ან დავაჭიროთ F12 კლავიშს კლავიატურაზე). გაიხსნება დეველოპერის პანელი, სადაც არის მობილურის გამოსახულებიანი ღილაკი, რომელზე დაჭერითაც გადავალთ ადაპტირებული დიზაინის ტესტირების რეჟიმში სხვადასხვა მოწყობილობებისთვის:
                    
                    HTML5-ის დოკუმენტი
                    
                    შესაძლებელია ავირჩიოთ კონკრეტული მოწყობილობა (სურათზე არჩეულია iPhone5) ან ავირჩიოთ Responsive და ხელით დავაყენოთ სასურველი ეკრანის ზომები.
                    
                    ადაპტირებული დიზაინის ტესტირების რეჟიმი აქვს სხვა ბრაუზერებსაც. მაგალითად, Mozilla Firefox-ში უნდა შევიდეთ Developer=>Responsive Design Mode.
                    
                    `
                },
                {
                  title:"მეტატეგი Viewport",
                  data:`პირველ რიგში განვიხილოთ ადაპტირებული დიზაინის საკვანძო მომენტი - მეტატეგი Viewport. პრაქტიკულად ამ ტეგიდან იწყება ადაპტირებული დიზაინი. ვთქვათ გვაქვს ასეთი ვებგვერდი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ჩვეულებრივი ვებგვერდი</title>
                      </head>
                      <body>
                          <h2>ჩვეულებრივი ვებგვერდი</h2>
                      </body>
                  </html>
                  ეს სტანდარტული ვებგვერდია, რომელიც ბრაუზერში ჩანს ასეთნაირად:
                  
                  HTML5-ის დოკუმენტი
                  
                  მაგრამ თუ იგივე გვერდს გავუშვებთ მობილურში ან ბრაუზერის მობილური მოწყობილობის ემულატორში, გაჭირვებით შევძლებთ წაკითხვას, თუ რა წერია:
                  
                  HTML5-ის დოკუმენტი
                  
                  მასშტაბირების გამოყენებით მომხმარებელი შეძლებს წაიკითხოს, თუ რა წერია, მაგრამ ჯერ ერთი, ეს არც ისე მოხერხებულია, მეორეც - ვებგვერდზე ბევრი ცარიელი ადგილი იქნება, რაც არც ისე ლამაზია.
                  
                  რატომ ხდება ასე? საქმე იმაშია, რომ მობილური ბრაუზერი გვერდს თავიდანვე აძლევს რაღაც ზომებს და შემდეგ ცდილობს მისი შიგთავსი ჩაატიოს ამ ზომებში. 
                  
                  ბრაუზერი მთელი ხილვადი არე  ეკრანზე აღიწერება ცნებით Viewport. არსებითად Viewport წარმოადგენს არეს, რომელსიც ბრაუზერი ცდილობს მოათავსოს მთელი ვებგვერდი. მაგალითად, ბრაუზერი Safari iPhone-ზე და iPod-ზე მიუთითებლობისას Viewport-ის სიგანეს განსაზღვრავს 980 პიქსელით. როცა ბრაუზერი მიიღებს ვებგვერდს და ჩასვამს 980 პიქსელ სიგანეში, შემდეგ ახდენს ყველაფრის მასშტაბირებას (შემცირებას) ისე, რომ ჩაეტიოს მობილურის ეკრანის სიგანეში.მაგალითად, ტუ სმარტფონის სიგანე 320 პიქსელია, ბრაუზერი ახდენს ვებგვერდის მასშტაბირებას 320/980 კოეფიციენტით, რის გამოც ყველაფერი დაახლოებით სამჯერ მცირდება.
                  
                  რატომ იღებს Viewport-ის სიგანედ 980 პიქსელს და არა ეკრანის რეალურ ზომას? საქმე იმაშია, რომ ბრაუზერი თვლის, რომ ვებგვერდი განკუთვნილია ჩვეულებრივი დესკტოპ კომპიუტერებისთვის, ხოლო მათთვის სტანდარტულ სიგანედ შეიძლება ჩაითვალოს 980 პიქსელი.
                  
                  სხვა ბრაუზერებში Viewport-ის სიგანე მიუთითებლობისას შეიძლება სხვა იყოს, მაგრამ თითოეული მათგანი ახდენს მასშტაბირებას.
                  
                  ამ პრობლემის თავიდან ასაცილებლად იყენებენ მეტატეგს viewport. იგი განისაზღვრება შემდეგნაირად:
                  
                  <meta name="viewport" content="მეტატეგის_პარამეტრები">
                  content ატრიბუტში შეიძლება განისაზღვროს შემდეგი ატრიბუტები:
                  
                  პარამეტრი	მნიშვნელობა	აღწერა
                  width	იღებს მნიშვნელობად მთელ რიცხვებს პიქსელებში ან მნიშვნელობას device-width	განსაზღვრავს viewport-ის სიგანეს
                  height	იღებს მნიშვნელობად მთელ რიცხვებს პიქსელებში ან მნიშვნელობას device-width	
                  განსაზღვრავს viewport-ის სიგანეს
                  
                  initial-scale	ათწილადი 0.1 -დან ზევით	განსაზღვრავს მასშტაბირების კოეფიციენტს. მნიშვნელობა 1.0-ს შემთხვევაში მასშტაბირება არ ხდება
                  user-scalable	no/yes	განსაზღვრავს, შეუძლია თუ არა მომხმარებელს მასშტაბირება თავისი სურვილით
                  minimum-scale	ათწილადი 0.1 -დან ზევით	განსაზღვრავს viewport-ის მინიმალურ მასშტაბს
                  maximum-scale	ათწილადი 0.1 -დან ზევით	
                  განსაზღვრავს viewport-ის მაქსიმალურ მასშტაბს
                  
                  მოდით, შევცვალოთ ჩვენი ვებგვერდი მეტატეგის გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>           
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width">
                          <title>ჩვეულებრივი ვებგვერდი</title>
                      </head>
                      <body>
                          <h2>ჩვეულებრივი ვებგვერდი</h2>
                      </body>
                  </html>
                  HTML5-ის დოკუმენტი
                  
                  ვებგვერდი მობილურის ეკრანზე გაცილებით უკეთ გამოიყურება. პარამეტრის width=device-width გამოყენებითჩვენ ვეუბნებით ბრაუზერს, რომ Viewport-ის სიგანედ ჩათვალოს არა 980 პიქსელი ან სხვა რაღაც ზომა, არამედ უშუალოდ მობილური მოწყობილობის სიგანე, შესაბამისად არ მოხდება მასშტაბირება.
                  
                  შეგვიძლია გამოვიყენოთ სხვა პარამეტრებიც, მაგალითად, ავუკრძალოთ მომხმარებელს მასშტაბირება:
                  
                  <meta name="viewport" content="width=device-width, maximum-scale=1.0, minimum-scale=1.0">`
              },
              {
                  title:"Media Query CSS-ში",
                  data:`მეორე მნიშვნელოვანი ელემენტი ადაპტირებული დიზაინის შესაზმნელად არის Media Query, რომელიც განსაზღვრავს სტილს ბრაუზერის ზომების მიხედვით.

                  მაგალითად, ზოგიერთი ელემენტისთვის შეიძლება განისაზღვროს ცალკე სტილი მობილური მოწყობილობებისთვის. CSS2-ში უკვე იყო სტილების გამიჯვნის საშუალება media-ს სახით, რომელშიც ეთითებოდა, თუ რომელი მოწყობილობისთვისაა ესა თუ ის სტილი:
                  
                  <html>
                   <head>
                    <title>Адаптивная веб-страница</title>
                    <link media="handheld" rel="stylesheet" href="mobile.css">
                    <link media="screen" rel="stylesheet" href="desktop.css">
                   </head>
                   <body>
                  ......................
                  წესი media="handheld" მიუთითებს, რომ ეს სტილი გამოიყენება მობილური მოწყობილობებისათვის, ხოლო media="screen" მიუთითებს, რომ ეს სტილი ჩვეულებრივი დესკტოპ კომპიუტერებისთვისაა.
                  
                  თუმცა თანამედროვე ბრაუზერების უმეტესობა თვლის, რომ იგი განკუთვნილია ჩვეულებრივი კომპიუტერებისთვის, ამიტომ ამ წესზე დაყრდნობა არაა მიზანშეწონილი.
                  
                  ამ პრობლემის გადასაწყვეტად CSS3-ში შემოვიდა მექანიზმი Media Query. მობილურებისთვის განკუთვნილი სტილი შეგვიძლია მივუთითოთ შემდეგნაირად:
                  
                  <html>
                   <head>
                    <title>Адаптивная веб-страница</title>
                    <meta name="viewport" content="width=device-width">
                    <link rel="stylesheet" type="text/css" href="desctop.css" />
                    <link rel="stylesheet" type="text/css" media="(max-device-width:480px)" href="mobile.css" />
                   </head>
                   <body>
                  ................................
                  ატრიბუტის მნიშვნელობა media (max-device-width:480px) ნიშნავს იმას, რომ ეს სტილი განკუთვნილია მოწყობილობებისთვის, რომელთა ეკრანის მაქსიმალური სიგანე არის 480 პიქსელი. რეალურად სწორედ ესაა მობილური მოწყობილობები.
                  
                  and საკვანძო სიტყვის გამოყენებით შეგვიძლია მოვახდინოთ პირობების კომპინირება:
                  
                  <link rel="stylesheet" type="text/css" media="(min-width:481px) and (max-width:768px)" href="mobile.css" />
                  ეს სტილი გამოიყენება იმ მოწყობილობებისთვის, რომელთა სიგანე 481-დან 780 პიქსელამდეა.
                  
                  შესაძლოა განვსაზღვროთ ერთი css ფაილი და მასში დავაიმპორტოთ @import  დირექტივის მეშვეობით სხვა css ფაილები:
                  
                  @import url(desctop.css);
                  @import url(tablet.css) (min-device-width:481px) and (max-device-width:768);
                  @import url(mobile.css) (max-device-width:480px);
                  ასევე შეიძლება, რომ სტილები არ დაიყოს ფაილებად და იგივე ფაილში განისაზღვროს CSS3 Media Query წესები:
                  
                  body {
                      background-color: red;
                  }
                  /* და ა. შ.  სხვა სტილები */
                  @media (max-device-width:480px){
                      body {
                          background-color: blue;
                      }
                      /* და ა. შ. სხვა სტილები */
                  }
                  CSS3 Media Query-ში გამოიყენება შემდეგი ფუნქციები:
                  
                  aspect-ratio: ბრაუზერის გამოსახვის ნაწილის სიგანის შეფარდება სიმაღლესთან
                  device-aspect-ratio: მოწყობილობის ეკრანის სიგანის შეფარდება სიმაღლესთან
                  max-width/min-width и max-height/min-height: ბრაუზერის გამოსახვის არის მაქსიმალური/მინიმალური სიგანე და სიმაღლე
                  max-device-width/min-device-width и max-device-height/min-device-height: მოწყობილობის ეკრანის მაქსიმალური/მინიმალური სიგანე და სიმაღლე
                  orientation: ორიენტაცია (პორტრეტული ან ალბომური)
                  მაგალითად, ჩვენ შეგვიძლია განვსაზღვროთ სტილი ეკრანის ორიენტაციის მიხედვით:
                  
                  /* სტილი პორტრეტული ორიენტაციისთვის */
                  @media only screen and (orientation: portrait){   
                     }
                     /* სტილი ალბომური ორიენტაციისთვის */
                     @media only screen and (orientation: landscape){   
                     }
                  ამგვარად, ჩვენ ვცვლით სტილებს მოწყობილობების მიხედვით, ხოლო თვითონ სტილების შექმნის მექანიზმი იგივეა, რაც ჩვეულებრივი საიტებისთვის.
                  
                  როგორც წესი, სტილების განსაზღვრის დროს, უპირატესობა ენიჭება სტილებს მცირე ზომის ეკრანებისთვის, ე. წ. მიდგომა Mobile First, თუმცა ეს არაა აუცილებელი. მაგალითად შევქმნათ შემდეგი სახის ვებგვერდი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width">
                          <title>ადაპტირებული ვებგვერდი</title>
                          
                          <style>
                          body {
                              background-color: red;
                          }
                          /* პლანშეტებისა და ტბლეტებისთვის */
                          @media (min-width: 481px) and (max-width:768px) {
                              body {
                                  background-color: green;
                              }
                          }
                          /* ჩვეულებრივი დესკტოპ კომპიუტერებისთვის */
                          @media (min-width:769px) {
                              body {
                                  background-color: blue;
                              }
                          }
                  </style>
                      </head>
                      <body>
                          <h2>ადაპტირებული ვებგვერდი</h2>
                      </body>
                  </html>
                  ჯერ მოდის ჩვეულებრივი სტილი, რომელიც აქტუალურია მობილურებისთვის, ანუ მცირე ზომის ეკრანებისთვის 480 პიქსელამდე სიგანით, შემდეგ მოდის საშუალო ზომის მოწყობილობებისთვის (481-დან 768 პიქსელამდე სიგანით) და ბოლოს დესკტოპ კომპიუტერებისთვის (რომელთა სიგანე 768 პიქსელზე მეტია). 
                  
                  480 პიქსელი სიგანის მოწყობილობაზე გვერდი შემდეგნაირად გამოჩნდება:
                  
                  HTML5-ის დოკუმენტი
                  
                  ვებგვერდის ფონი არის წითელი. ჩვეულებრივი კომპიუტერის ბრაუზერში კი გვერდს ექნება ლურჯი ფონი, როგორც ეს არის განსაზღვრული შესაბამის სტილში 768 პიქსელზე მეტი სიგანის ბრაუზერებისთვის`
              },
             
            ]
        },
        {
            title:"თავი 10. მულტიმედია",
            content:[
                {
                    title:"ვიდეო",
                    data:`ვიდეოს გამოსატანად ეკრანზე HTML5-ში გამოიყენება ელემენტი video. მის დასაკონფიგურირებლად გამოიყენება შემდეგი ატრიბუტები:

                    src: ვიდეოს წყარო, ის შეიძლება იყოს რაიმე ტიპის ვიდეოფაილი
                    width: ელემენტის სიგანე
                    height: ელემენტის სიმაღლე
                    controls: ვიდეოს მართვის ელემენტები
                    autoplay: განსაზღვრავს ავტომატურ ჩვენებას
                    loop: განსაზღვრავს ვიდეოს განმეორებას
                    muted: თიშავს ხმას მიუთითებლობისას
                    სიგანისა და სიმაღლის მითითება ვიდეოს ასპექტურ ფარდობას (სიგანისა და სიმაღლის შეფარდებას) არ ცვლის. თუ ვიდეოს ფორმატია 375X240, ხოლო ჩვენ მივუთითებთ ზომებს width="375" height="280", ეს არ ნიშნავს, რომ ვიდეო ამ ზომებს მიიღებს: ის დაიკავებს ამ 280 პიქსელ სიმაღლის ცენტრში 240 პიქსელს. ეს თვიდან გვაცილებს ვიდეოს დამახინჯებას მისი გაწელვის გამო.
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Видео в HTML5</title>
                        </head>
                        <body>
                            <video src="Tom_and_Jerry.mp4" width="400" height="300" controls></video>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გამოვიყენოთ ატრიბუტები autoplay და loop.
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls autoplay loop></video>
                    ახლა ვიდეო ავტომატურად ჩაირთვება და უსასრულოდ განმეორდება.
                    
                    თუ გვინდა, რომ ვიდეო ჩაირთოს უხმოდ, უნდა გამოვიყენოთ ატრიბუტო muted:
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls muted></video>
                    ატრიბუტი preload
                    
                    კიდევ ერთი ატრიბუტი reload განსაზღვრავს ვიდეოს ჩატვირთვის რეჟიმს. ის ღებულობს შემდეგ მნიშვნელობებს:
                    
                    auto:ვიდეო და მასთან დაკავშირებული მეტადატა ჩამოიტვირთება ვიდეოს გაშვებამდე
                    none: ვიდეო არ ჩამოიტვირთება ფონურად, სანამ მომხმარებელი არ დააჭერს გაშვების ღილაკს
                    metadata: ფონურ რეჟიმში ჩამოიტვირთება მხოლოდ მეტამონაცემები (ფაილის ფორმატი, ხანგრძლივობა და ა. შ.). თვითონ ფაილი ფონურად არ ჩამოიტვირთება
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls preload="auto"></video>
                     
                    
                    ატრიბუტი poster
                    
                    ატრიბუტი poster განსაზღვრავს გამოსახულებას, რომელიც გამოჩნდება ბრაუზერში ვიდეოს გაშვებამდე. მნიშვნელობის სახით მას გადაეცემა გამოსახულების ფაილის მისამართი:
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls poster="Tom_and_Jerry.jpg"></video>
                    ვიდეოს ფორმატების მხარდაჭერა
                    
                    მთავარი პრობლემა video ელემენტის გამოყენებისას არის სხვადასხვა ბრაუზერების მიერ ვიდეოს ფორმატების მხარდაჭერა. ჩასმული ელემენტის source მეშვეობით შეიძლება ვიდეოს გადავცეთ რამდენიმე წყარო:
                    
                    <video width="400" height="300" controls>
                       <source src="Tom_and_Jerry.mp4" type="video/mp4">
                       <source src="Tom_and_Jerry.webm" type="video/webm">
                       <source src="Tom_and_Jerry.ogv" type="video/ogg">
                    </video>
                    ელემენტი source იყენებს ორ ატრიბუტს:
                    
                    src: ფაილის მისამართი
                    type: ვიდეოს ტიპი (MIME Type)
                    თუ ბრაუზერს არა აქვს პირველი ტიპის ვიდეოს მხარდაჭერა, ის იყენებს მეორეს, თუ არა აქვს არც ამ ტიპის მხარდაჭერა - მესამეს და ა. შ.`
                },
                {
                  title:"აუდიო",
                  data:`გამოსახულების გარეშე ხმის ასაჟღერებლად HTML5-ში გამოიყენება ელემენტი audio. მისი კონფიგურაციისთვის შესაძლებელია შემდეგი ატრიბუტების გამოყენება:

                  src: აუდიო ფაილის მისამართი
                  controls: მართვის ელემენტები
                  autoplay: ავტოგაშვება
                  loop: აუდიო ფაილის განმეორება
                  muted: ხმის გამორთვა
                  preload: ფაილის ჩატვირთვის რეჟიმი
                  ყველა ამ ატრიბუტის მოქმედება video ელემენტისტვის მათი მოქმედების ანალოგიურია.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>აუდიო HTML5<-ში/title>
                      </head>
                      <body>
                          <audio src="mobile_phone.mp3" controls></audio>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სხვადასხვა ბრაუზერში ელემენტის იერსახე შეიძლება იყოს განსხვავებული.
                  
                  აუდიო ფორმატების მხარდაჭერა
                  
                  ვიდეოფაილების მსგავსად, აქაც აქტუალურია სხვადასხვა ბრაუზერის მიერ აუდიო ფორმატების მხარდაჭერის საკითხი. დღესდღეობით, თანამედროვე ბრაუზერების უმეტესობას აქვს mp3 ფორმატის მხარდაჭერა. თუმცა ყოველი შემთხვევისთვის აქაც შეგვიძლია გამოვიყენოთ ჩასმული ელემენტი source რამდენიმე აუდიო ფაილის მისათითებლად:
                  
                  <audio width="400" height="300" controls>
                     <source src="mobile_phone.mp3" type="audio/mpeg">
                     <source src="mobile_phone.m4a" type="audio/aac">
                     <source src="mobile_phone.ogg" type="audio/ogg">
                  </audio>`
              },
              {
                  title:"Media API. ვიდეოს მართვა JavaScript-დან",
                  data:`HTML5-ში ახალ audio და videoელემენტებთან ერთად დაემატა ახალი API JavaScript-ში ამ ელემენტების სამართავად. JavaScript-ის კოდის მეშვეობით შეგვიძლია მივიღოთ ელემენტების audio da video (ისევე როგორც ნებისმიერი სხვა ელემენტი) და გამოვიყენოთ მათი თვისებები. JavaScript-ში ეს ელემენტები წარმოდგენილია როგორც HTMLMediaElement, რომელიც თვისებების, მეთოდების და მოვლენების მეშვეობით მართავს ამ ელემენტების მოქმედებებს.ვნახოთ რამდენიმე ყველაზე მნიშვნელოვანი თვისება ამ ელემენტების კონფიგურაციისთვის:

                  playbackRate: სიჩქარე. მიუთითებლობისას ტოლია -ის
                  src: აბრუნებს რესურსის მისამართს, თუ ის მითითებულია ელემენტის html კოდში
                  duration: ფაილის ხანგრძლივობა წამებში
                  buffered: აბრუნებს ფაილის იმ ნაწილის ზომას, რომელიც უკვე ბუფერშია და მზად არის გამოსატანად
                  controls: აბრუნებს controls ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  loop: აბრუნებს loop ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  muted: აბრუნებს muted ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  preload: ბრუნებს preloadატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  volume: ხმის დონე 0.0-დან 1.0-მდე
                  currentTime: აბრუნებს აუდიოს ან ვიდეოს მიმდინარე დროს
                  მხოლოდ ელემენტისთვის video დამატებით შეიძლება გამოვიყენოთ შემდეგი თვისებები:
                  
                  poster: ატრიბუტ poster-ის მნიშვნელობა
                  height: ატრიბუტ height-ის მნიშვნელობა
                  width: ატრიბუტ width-ის მნიშვნელობა
                  videoWidth, videoHeight: აბრუნებს ვიდეოს სიგანეს და სიმაღლეს
                  აქვე აღსანიშნავია მეთოდები, რომლებითაც შეიძლება ვმართოთ მედია ფაილების გაშვება-შეჩერება:
                  
                  play(): გაშვება
                  pause(): შეჩერება
                  video და audio ელემენტების ძირითადი მოვლენებია:
                  
                  canplaythrough: ეს მოვლენა წარმოიშვება გვერდის ჩატვირთვისას, მას შემდეგ, რაც ბრაუზერი დაადგენს, რომ შეუძლია ამ ვიდეო/აუდიო ფაილის გაშვება
                  pause: ეს მოვლენა წარმოიშვება შეჩერებისას (დაპაუზებისას)
                  play: ეს მოვლენა წარმოიშვება ფაილის გაშვებისას
                  volumechange: წარმოიშვება ხმის აწევა-დაწევისას
                  ended: წარმოიშვება ფაილის დასრულებისას
                  timeupdate: წარმოიშვება ხანგრძლივობის შეცვლისას
                  error: გენერირდება შეცდომის დროს
                  loadeddata: წარმოიშვება ფაილის პირველი ფრეიმის ჩატვირთვისას
                  loadedmetadata: წარმოიშვება მეტამონაცემების (ფაილის ტიპი, ხანგრძლივობა და ა. შ.) ჩატვირთვისას
                  seeking: წარმოიშვება აუდიო/ვიდეო ფაილის მიმდინარეობის ადგილის შეცვლამდე
                  seeked: წარმოიშვება აუდიო/ვიდეო ფაილის მიმდინარეობის ადგილის შეცვლის შემდეგ
                  ახლა გამოვიყენოთ ზოგიერთი თვისება, მეთოდი და მოვლენა:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ვიდეო HTML5-ში</title>
                      <style>
                          .hidden {
                              display: none;
                          }
                          #playBtn {
                              border: solid 1px #333;
                              padding: 5px;
                              cursor: pointer;
                          }
                      </style>
                  </head>
                  <body>
                      <video width="400" height="300">
                          <source src="Tom_and_Jerry.mp4" type="video/mp4">
                          <source src="Tom_and_Jerry.webm" type="video/webm">
                          <source src="Tom_and_Jerry.ogv" type="video/ogg">
                      </video>
                      <div id="controls" class="hidden">
                          <a id="playBtn">Play</a>
                          <span id="timer">00:00</span>
                          <input type="range" step="0.1" min="0" max="1" value="0" id="volume" />
                      </div>
                      <script>
                          // ელემენტების მიღება
                          var videoEl = document.getElementsByTagName('video')[0],
                              playBtn = document.getElementById('playBtn'),
                              vidControls = document.getElementById('controls'),
                              volumeControl = document.getElementById('volume'),
                              timePicker = document.getElementById('timer');
                   
                          // თუ ბრაუზერს შეუძლია ვიდეოს გაშვება, ვაშორებთ კლასს hidden
                          videoEl.addEventListener('canplaythrough', function () {
                              vidControls.classList.remove('hidden');
                              videoEl.volume = volumeControl.value;
                          }, false);
                         
                          // ვიდეოს გაშვება-დაპაუზება
                          playBtn.addEventListener('click', function () {
                              if (videoEl.paused) {
                                  videoEl.play();
                              } else {
                                  videoEl.pause();
                              }
                          }, false);
                          videoEl.addEventListener('play', function () {
                              playBtn.innerText = "Pause";
                          }, false);
                          videoEl.addEventListener('pause', function () {
                   
                              playBtn.innerText = "Play";
                          }, false);
                          volumeControl.addEventListener('input', function () {
                   
                              videoEl.volume = volumeControl.value;
                          }, false);
                          videoEl.addEventListener('ended', function () {
                              videoEl.currentTime = 0;
                          }, false);
                          videoEl.addEventListener('timeupdate', function () {
                              timePicker.innerHTML = secondsToTime(videoEl.currentTime);
                          }, false);
                          // დროის ასახვა
                          function secondsToTime(time) {
                   
                              var h = Math.floor(time / (60 * 60)),
                                  dm = time % (60 * 60),
                                  m = Math.floor(dm / 60),
                                  ds = dm % 60,
                                  s = Math.ceil(ds);
                              if (s === 60) {
                                  s = 0;
                                  m = m + 1;
                              }
                              if (s < 10) {
                                  s = '0' + s;
                              }
                              if (m === 60) {
                                  m = 0;
                                  h = h + 1;
                              }
                              if (m < 10) {
                                  m = '0' + m;
                              }
                              if (h === 0) {
                                  fulltime = m + ':' + s;
                              } else {
                                  fulltime = h + ':' + m + ':' + s;
                              }
                              return fulltime;
                          }
                      </script>
                  </body>
                  </html>
                  JavaScript-ის კოდში თავიდან ხდება ელემენტების დადგენა. შემდეგ ხდება მოვლენის canplaythrough დამუშავება და თუ ბრაუზერს შეუძლია ვიდეოს გაშვება, შორდება კლასი hidden და დგინდება ხმის სიმაღლე:
                  
                  videoEl.addEventListener('canplaythrough', function () {
                      vidControls.classList.remove('hidden');
                      videoEl.volume = volumeControl.value;
                  }, false);
                  ფაილის გასაშვებად საჭიროა Play ბმულზე დაჭერა:
                  
                  playBtn.addEventListener('click', function () {
                      if (videoEl.paused) {
                          videoEl.play();
                      } else {
                          videoEl.pause();
                      }
                  }, false);
                  გაშვებისა და დაპაუზების მოვლენების დამუშავებით შეგვიძლია წარწერის შეცვლა ბმულზე:
                  
                  videoEl.addEventListener('play', function () {
                      playBtn.innerText = "Pause";
                  }, false);
                  videoEl.addEventListener('pause', function () {
                      playBtn.innerText = "Play";
                  }, false);
                  ელემენტის input მოვლენის დამუშავებით, რომელიც წარმოიშვება მცოცავის გადაადგილებისას, შეგვიძლია მცოცავის მნიშვნელობის სინქრონიზაცია და ხმის რეგულირება:
                  
                  volumeControl.addEventListener('input', function () {
                      videoEl.volume = volumeControl.value;
                  }, false);
                   `
              },
              
            ]
        },
        {
            title:"თავი 11. Flexbox",
            content:[
                {
                    title:"რა არის Flexbox. Flex Container",
                    data:`Flexbox - ეს არის CSS3-ში არსებული Flexible Box Layout მოდულის მოკლე დასახელება. ეს მოდული განსაზღვრავს ვებგვერდის აწყობის განსაკუთრებულ რეჟიმს, რომელსაც ეწოდება flex layout. ამ მხრივ Flexbox  წარმოადგენს მომხმარებლის ინტერფეისის სხვა ცხრილისებური და ბლოკისებური აწყობისგან განსხვავებულ მიდგომას. მოდულის გაფართოებული აღწერა შეგიძლიათ ნახოთ მის სპეციფიკაციაში.

                    Flexbox-ის მეშვეობით უფრო ადვილია რთული ინტერფეისების შექმნა, სადაც მარტივად შეიძლება შეიცვალოს ელემენტების თანმიმდევრობა და გასწორებები და შეიქმნას ცხრილისმაგვარი ადაპტირებული გვერდები. ერთადერთი პრობლემა, რაც შეიძლება Flexbox-ის გამოყენებისას წარმოიშვას, ეს არის ბრაუზერების მიერ მისი მხარდაჭერა. მოძველებულ ბრაუზერებში მისი მხარდაჭერა არაა, თუმცა თანამეროვე ბრაუზერების უმრავლესობას ეს მხარდაჭერა გააჩნია.
                    
                    Flexbox-ის ძირითადი ელემენტებია flex-კონტეინერი flex-container და  flex-ელემენტები (flex-items). flex-კონტეინერი ერთგვარი ელემენტია, რომლის შიგნითაც მოთავსებულია flex-ელემენტები.
                    
                    ძირითადი ცნებები
                    
                    სანამ flexbox-ით ვებგვერდების აწყობაზე გადავიდოდოეთ, განვიხილოთ ძირითადი ცნებები.
                    
                    ერთ-ერთ საკვანძო ცნებას წარმოადგენს main axis ანუ ცენტრალური ღერძი. იგი flex-კონტეინერის პირობითი ღერძია, რომლის გასწვრივაც განლაგდება flex-ელემენტები.
                    
                    HTML5-ის დოკუმენტი
                    
                    ელემენტები ჰორიზონტალურად ლაგდება სტრიქონების, ხოლო ვერტიკალურად- - სვეტების სახით. განლაგების ტიპის მიხედვით იცვლება ცენტრალური ღერძიც. თუ განლაგება ხორციელდება სტრიქონების სახით, ღერძი მიმართულია მარცხნიდან მარჯვნივ, ხოლო ტუ ცვეტების სახით - მაშინ ზემოდან ქვემოთ.
                    
                    ტერმინები main start და main end აღნიშნავენ ცენტრალური ღერძის დასაწყისსა და დასასრულს, ხოლო ტერმინი main size განსაზღვრავს მათ შორის მანძილს.
                    
                    გარდა ძირითადი ღერძისა არის ასევე მისი მართობული ღერძი cross axis. როცა ელემენტები შტრიქონებადაა მოთავსებული, იგი მიმართულია ვერტიკალურად ზევიდან ქვევით, ხოლო როცა ელემენტები სვეტებშია - მარცხნიდან მარჯვნივ. cross axis ღერძის დასაწყისი და დასასრული აღინიშნება შესაბამისად cross start და cross end ტერმინებით, ხოლო მანძილი მათ შორის არის cross size.
                    
                    flex-კონტეინერის შექმნა
                    
                    flex-კონტეინერის შესაქმნელად საჭიროა ელემენტის display თვისებას მივანიჭოთ ერთ-ერთი ამ მნიშვნელობებიდან: flex ან inline-flex.
                    
                    შევქმნათ მარტივი ვებგვერდი, რომელიც იყენებს flexbox-ს:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Flexbox CSS3-ში</title>
                            <style>
                                .flex-container {
                                    display: flex;
                                }
                                .flex-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                }
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                            </style>
                        </head>
                        <body>
                            <div class="flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                        </body>
                    </html>
                    კონტეინერისთვის flex-container მინიჭებულია თვისება display:flex. შიგნით არის სამი flex-ელემენტი.
                    
                    HTML5-ის დოკუმენტი
                    
                    თუ flex მნიშვნელობა, განსაზღვრავს კონტეინერს, როგორც ბლოკურ ელემენტს, inline-flex განსაზღვრავს როგორც სტრიქონულ ელემენტს. ვნახოთ ორივე შემდეგ მაგალითზე:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Flexbox CSS3-ში</title>
                            <style>
                                .flex-container {
                                    display: flex;
                                    border:2px solid #ccc;
                                }
                                .inline-flex-container {
                                    display: inline-flex;
                                    border:2px solid #ccc;
                                    margin-top:10px;
                                }
                                .flex-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                }
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                            </style>
                        </head>
                        <body>
                            <div class="flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                            
                            <div class="inline-flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    პირველ შემთხვევაში კონტეინერი გაწელილია ბრაუზერის მთელ სიგანეზე, ხოლო მეორე შემთხვევაში იკავებს ზუსტად იმ ადგილს, რაც სჭირდება.`
                },
                {
                  title:"მიმართულება - flex-direction",
                  data:`flex-ელემენტებს  flex-კონტეინერში გააჩნიათ გარკვეული მიმართულება. ისინი განლაგდებიან სტრიქონებად ან სვეტებად. მიმართულების მისანიჭებლად CSS-ში გამოიყენება თვისება flex-direction. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  row: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც ელემენტები განლაგდება სტრიქონებად მარცხნიდან მარჯვნივ
                  row-reverse: ელემენტები ასევე განლაგდება სტრიქონებად, ოღონდ საპირისპირო მიმართულებით, მარჯვნიდან მარცხნივ
                  column: ელემენტები განლაგდება სვეტებად ზემოდან ქვემოთ
                  column-reverse: ელემენტები განლაგდება სვეტებად საპირისპირო მიმართულებით, ქვემოდან ზემოთ
                  მაგალითად, განლაგება სტრიქონებად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border:1px solid #ccc;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად ხდება სვეტებად განლაგებაც:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border:1px solid #ccc;
                              }
                              .column {
                                  flex-direction: column;
                              }
                              .column-reverse {
                                  flex-direction: column-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                          </style>
                      </head>
                      <body>
                          <h3>Column</h3>
                          <div class="flex-container column">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                          
                          <h3>Column-reverse</h3>
                          <div class="flex-container column-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                      </body>
                  </html>`
              },
              {
                  title:"flex-wrap",
                  data:`თვისება flex-wrap განსაზღვრავს, იქნება თუ არა flex-კონტეინერში რამდენიმე რიგი (სტრიქონი ან სვეტი), როცა ელემენტები ერთ რიგში არ ეტევა. იგი ღებულობს შემდეგ მნიშვნელობებს:

 

                  nowrap: მნიშვნელობა მიუთითებლობისას, რომელიც განსაზღვრავს, რომ ელემენტები განლაგდება ერთ რიგში (სტრიქონში ან სვეტში)
                  wrap: თუ ელემენტები არ ეტევა კონტეინერში, ჩნდება დამატებითი რიგები (სტრიქონები ან სვეტები)
                  wrap-reverse: იგივეა, რაც wrap, ოღონდ ელემენტები განლაგდება საპირისპირო მიმართულებით
                  მაგალითად, ვნახოთ მნიშვნელობა nowrap:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.25em;
                                  flex-wrap:nowrap;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                  აქ თითოეულ კონტეინერში ხუთი ელემენტია, მაგრამ კონტეინერის სიგანეში ხუთივე არ ეტევა და ისინი გამოდიან კონტეინერის გარეთ:
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ დავამატებთ თვისებას კონტეინერზე flex-wrap:wrap, კონტეინერში გაჩნდება მეორე რიგი და ელემენტები მოთავსდება შიგნით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.25em;
                                  
                                  flex-wrap:wrap;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სვეტებად განლაგების შემთხვევაში ჩნდება დამატებითი სვეტი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.5em;
                                  flex-wrap:wrap;
                              }
                              .column {
                                  flex-direction: column;
                              }
                              .column-reverse {
                                  flex-direction: column-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Column</h3>
                          <div class="flex-container column">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Column-reverse</h3>
                          <div class="flex-container column-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>`
              },
              {
                  title:"flex-flow. ელემენტების წესრიგი",
                  data:`თვისება flex-flow საშუალებას გვაძლევს ერთდროულად მივანიჭოთ ელემენტს ორი მნიშვნელობა flex-direction და flex-wrap. მას აქვს შემდეგი სინტაქსი:

                  flex-flow: [flex-direction] [flex-wrap]
                  მეორე თვისება შეიძლება გამოვტოვოთ, რადგან მას მიუთითებლობისას აქვს მნიშვნელობა nowrap.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  height:8.25em;
                                  flex-flow: row wrap;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  თვისება order
                  
                  თვისება order საშუალებას გვაძლევს შევქმნათ ჯგუფები და ამით კონტეინერში ელემენტების განლაგების თანმიმდევრობა შევცვალოთ. მაგალითდ, ჯგუფი რომლის order თვისების მნიშვნელობაა 0 განლაგდება 1-ის ტოლი მნიშვნელობის ჯგუფის წინ, 1 მნიშვნელობის მქონე, 2-ის მნიშვნელობის მქონე ჯგუფის წინ და ა. შ.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  flex-flow: row wrap;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .group1{
                                  order:-1;
                              }
                              .group2{
                                  order:1;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2 group2">Flex Item 2</div>
                              <div class="flex-item color3 group2">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5 group1">Flex Item 5</div>
                          </div>
                  </html>
                  მოცემულ შემთხვევაში განსაზღვრულია სამი ჯგუფი. პირველი გამოისახება ბოლო ელემენტი, ვინაიდან მას orderთვისების მნიშვნელობა აქვს -1. თუ ელემენტს პირდაპირ არა აქვს მითითებული order თვისების მნიშვნელობა ჯგუფის მეშვეობით, იგულისხმება რომ ეს მნიშვნელობა არის 0-ის ტოლი. ამიტომაც მომდევნო ადგილს იკავებს პირველი და მეოთხე ელემენტი. მეორე და მესამე ელემენტი ბოლოშია, რადგან მათ ჯგუფს order-ის მნიშვნელობა აქვს 1.`
              },
              {
                  title:"ელემენტების გასწორება. justify-content",
                  data:`ხშირად არის შემთხვევა, როდესაც კონტეინერის ზომები განსხვავდება ელემენტებისთვის საჭირო ზომებისგან. შეიძლება ადგილი ჰქონდეს ორ შემთხვევას:

                  ელემენტები ვერ ავსებენ კონტეინერის სივრცეს
                  ელემენტები ვერ ეტევიან კონტეინერის შიგნით
                  ამ სიტუაციების სამართავად გამოიყენება თვისება justify-content. ის ასწორებს ელემენტებს მთვარი ღერძის main axis გასწვრივ და ღებულეობს შემდეგ მნიშვნელობებს:
                  
                  flex-start: მნიშვნელობა მიუთითებლობისას. პირველი ელემენტი თავსდება კონტეინერის დასაწყისში (მარცხნივ ან ზევით იმის მიხედვით, ელემენტები მოთავსებულია სტრიქონში თუ სვეტში), მას მოსდევს მეორე ელემენტი და ასე შემდეგ.
                  flex-end: პირველი ელემენტი თავსდება კონტეინერის ბოლოს(მარჯვნივ ან ქვევით იმის მიხედვით, ელემენტები მოთავსებულია სტრიქონში თუ სვეტში), მას მოსდევს მეორე ელემენტი და ასე შემდეგ.
                  center: ელემენტები სწორდება ცენტრში
                  space-between: თუ კონტეინერი შეიცავს მხოლოდ ერთ ელემენტს ან ელემენტები ვერ ეტევიან კონტეინერის შიგნით, მუშაობს როგორც  flex-start. სხვა შემთხვევაში პირველი ელემენტი სწორდება კონტეინერის დასაწყისში, ბოლო ელემენტი კონტეინერის ბოლოში, ხოლო დანარჩენი ელემენტები თანაბრად ნაწილდებიან მათ შორის თანაბარი ინტერვალებით.
                  space-around: თუ კონტეინერი შეიცავს მხოლოდ ერთ ელემენტს ან ელემენტები ვერ ეტევიან კონტეინერის შიგნით, მუშაობს როგორც center. სხვა შემთხვევაში ელემენტები თანაბრად ნაწილდებიან კონტეინერის მთელ სიგრძეზე თანაბარი ინტერვალებით, ამასთან პირველი და ბოლო ელემენტის დაშორება კონტეინერის საზღვრიდან ელემენტებს შორის დაშორების ნახევრის ტოლია.
                  ელემენტების გასწორება სტრიქონში განლაგების შემთხვევაში:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-start{
                                  justify-content: flex-start;
                              }
                              .flex-end{
                                  justify-content: flex-end;
                              }
                              .center{
                                  justify-content: center;
                              }
                              .space-between{
                                  justify-content: space-between;
                              }
                              .space-around{
                                  justify-content: space-around;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                              <h3>Flex-start</h3>
                              <div class="flex-container flex-start">
                                  <div class="flex-item color1">Flex Item 1</div>
                                  <div class="flex-item color2">Flex Item 2</div>
                                  <div class="flex-item color3">Flex Item 3</div>
                                  <div class="flex-item color4">Flex Item 4</div>
                              </div>
                          <h3>Flex-end</h3>
                          <div class="flex-container flex-end">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Center</h3>
                          <div class="flex-container center">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Space-between</h3>
                          <div class="flex-container space-between">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Space-around</h3>
                          <div class="flex-container space-around">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ელემენტების გასწორება სვეტში განლაგების შემთხვევაში:`
              },
              {
                  title:"ელემენტების გასწორება. align-items და align-self",
                  data:`თვისება align-items ასევე ემსახურება ელემენტების გასწორებას, მაგრამ ახლა უკვე არა მთავარი ღერძის (main axis), არამედ მისი მართობული ღერძის (cross axis) მიმართ. iის ღებულობს შემდეგ მნიშვნელობებს:

                  stretch: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც flex-ელემენტები ავსებს flex-კონტეინერის მთელ სიმაღლეს (სტრიქონში განლაგებისას) ან მთელ სიგანეს (სვეტში განლაგებისას)
                  flex-start: flex-ელემენტები სწორდება flex-კონტეინერის ზედა კიდეზე (სტრიქონში განლაგებისას) ან მარცხენა კიდეზე (სვეტში განლაგებისას)
                  flex-end: flex-ელემენტები სწორდება flex-კონტეინერის ქვედა კიდეზე (სტრიქონში განლაგებისას) ან მარჯვენა კიდეზე (სვეტში განლაგებისას)
                  center: flex-ელემენტები სწორდება flex-კონტეინერის ცენტრში
                  baseline: ელემენტები სწორდება საკუთარი საბაზისო ღერძის მიხედვით
                  ვნახოთ გასწორება სტრიქონში განლაგებისას:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>            
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  height:5em;
                              }
                              .flex-start{
                                  align-items: flex-start;
                              }
                              .flex-end{
                                  align-items: flex-end;
                              }
                              .center{
                                  align-items: center;
                              }
                              .baseline{
                                  align-items: baseline;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;                
                              }
                              .largest-item{
                                  padding-top:2em;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <h3>Flex-start</h3>
                          <div class="flex-container flex-start">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Flex-end</h3>
                          <div class="flex-container flex-end">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Center</h3>
                          <div class="flex-container center">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Baseline</h3>
                          <div class="flex-container baseline">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2 largest-item">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად მუშაობს სვეტში განლაგების დროსაც.
                  
                  თვისება align-self
                  
                  თვისება align-self საშუალებას იძლევა შევცვალოთ align-items თვისებით მიღებული გასწორების წესი ერთი ელემენტისთვის. ის ღბულობს იგივე მნიშვნელობებს, რასაც align-items და დამატებით მნიშვნელობას auto. auto არის მნიშვნელობა მიუთითებლობისას. ამ დროს ელემენტი სწორდება align-items--ისგან მემკვიდრეობით მიღებული წესით.
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  justify-content: space-between;
                                  align-items: stretch;
                                  height:12em;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; align-self: center; }
                              .item2 {background-color: #9BC850; align-self: flex-start;}
                              .item3 {background-color: #A62E5C; align-self: flex-end;}
                              .item4 {background-color: #2A9FBC; align-self: center;}
                          </style>
                      </head>
                      <body>
                          <h3>Align-self</h3>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                  </html>
                   `
              },
              {
                  title:"სტრიქონებისა და სვეტების გასწორება. align-content",
                  data:`თვისება align-content მართავს რიგების გასწორებას (სტრიქონების და სვეტების) და გამოიყენება იმ შემთხვევაში, თუ flex-wrap თვისების მნიშვნელობაა wrap ან wrap-reverse. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  stretch: მნიშვნელობა მიუთითებლობისას, რომლის დროცას სტრიქონები (სვეტები) იწელება და იკავებს მთელ თავისუფალ სივრცეს
                  flex-start: სტრიქონები (სვეტები) სწორდება კონტეინერის დასაწყისში
                  flex-end: სტრიქონები (სვეტები) სწორდება კონტეინერის ბოლოში
                  center: სტრიქონები (სვეტები) სწორდება კონტეინერის ცენტრში
                  space-between: სტრიქონები (სვეტები) თანაბრად ნაწილდება მთელ კონტეინერში და ქმნის თანაბარ ინტერვალებს მათ შორის. თუ კონტეინერში ადგილი არასაკმარისია, მუშაობს როგორც fex-start მნიშვნელობის დროს
                  space-around: სტრიქონები (სვეტები) თანაბრად ნაწილდება კონტეინერში და ქმნის თანაბარ ინტერვალებს მათ შორის, ამასთან პირველი და ბოლო სტრიქონის (სვეტის) დაშორება საზღვრებიდან მეზობელ სტრიქონებს (სვეტებს) შორის დაშორების ნახევრის ტოლია
                  გასათვალისწინებელია, რომ ამ თვისებას მაშინ აქვს აზრი, როცა კონტეინერში ორი ან მეტი სტრიქონია (სვეტია).
                  
                  მაგალითად, სტრიქონების განლაგება კონტეინერის დასაწყისში:
                  
                  <!DOCTYPE html>
                  <html>
                   
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  flex-wrap: wrap;
                                  height:200px;
                                  align-content: flex-start;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 16px;
                                  padding: 10px;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7;}
                              .item2 {background-color: #9BC850;}
                              .item3 {background-color: #A62E5C;}
                              .item4 {background-color: #2A9FBC;}
                              .item5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                              <div class="flex-item item5">Flex Item 5</div>
                              <div class="flex-item item1">Flex Item 6</div>
                              <div class="flex-item item2">Flex Item 7</div>
                              <div class="flex-item item3">Flex Item 8</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  შევცვალოთ კონტეინერის სტილი:
                  
                  .flex-container {
                      display: flex;
                      border:1px #ccc solid;
                      flex-wrap: wrap;
                      height:200px;
                      align-content: space-between;
                      flex-direction: column;
                  }
                  ამ შემთხვევაში მივიღებთ ერთმანეთისგან დაშორებული სვეტების ორ რიგს.`
              },
              {
                  title:"ელემენტების მართვა. flex-basis, flex-shrink და flex-grow",
                  data:` გარდა თვისებებისა, რომლებიც ემსახურება ელემენტების გასწორებას, არის კიდევ სამი თვისება, რომლებიც ელემენტების მართვისთვისაა განკუთვნილი:

                  flex-basis: განსაზღვრავს flex-ელემენტის საწყის ზომებს
                  flex-shrink: განსაზღვრავს, თუ როგორ უნდა შემცირდეს flex-ელემენტი სხვა flex-ელემენტების მიმართ flex-კონტეინერში
                  flex-grow: განსაზღვრავს, თუ როგორ უნდა გაიზარდოს flex-ელემენტი სხვა flex-ელემენტების მიმართ flex-კონტეინერში
                  flex-basis
                  
                  flex-კონტეინერი შეიძლება შემცირდეს ან გაიზარდოს მთავარი ღერძის გასწვრივ ბრაუზერის ზომების ცვლილებისას, თუ კონტეინერს არ გააჩნია ფიქსირებული ზომები. კონტეინერთან ერთად შეიძლება შემცირდეს ან გაიზარდოს მასში შემავალი flex-ელემენტებიც. თვისება flex-basis განსაზღვრავს flex-ელემენტის საწყის ზომებს, სანამ იგი დაიწყებს ზომების შეცვლას კონტეინერის ზომების ცვლილების კვალდაკვალ. ეს თვისება იღებს შემდეგ მნიშვნელობებს:
                  
                  auto: flex-ელემენტის საწყისი ზომა დგინდება ავტომატურად
                  content: flex-ელემენტის ზომა განისაზღვრება მისი შიგთავსის მოცულობიდან გამომდინარე
                  რიცხვითი მნიშვნელობა: ჩვენ შეგვიძლია მივუთითოთ კონტეინერის ზომები რიცხვითი მნიშვნელობების სახით
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-basis: auto; width:150px;}
                              .item2 {background-color: #9BC850; flex-basis: auto; width:auto;}
                              .item3 {background-color: #A62E5C; flex-basis: 200px;width:150px;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველ ელემენტს flex-basis თვისების მნიშვნელობა აქვს auto, ამიტომ ეს ელემენტი სიგანეს მიიღებს width თვისების მნიშვნელობიდან გამომდინარე. მეორე ელემენტს flex-basis თვისების მნიშვნელობა ასევე აქვს auto, width თვისების მნიშვნელობაც არის auto, ამიტომ ეს ელემენტი სიგანეს მიიღებს შიგთავსიდან გამომდინარე. მესამე ელემენტის flex-basis თვისებას აქვს კონკრეტული რიცხვითი მნიშვნელობა, შესაბამისად ელემენტი სიგანეს მიიღებს ამ მნიშვნელობიდან გამომდინარე და width  თვისების მნიშვნელობას არავითარი აზრი არა აქვს.
                  
                  flex-shrink
                  
                  თუ flex-კონტეინერს არა აქვს საკმარისი ადგილი მასში მოთავსებული ელემენტებისთვის, ამ ელემენტების შემდგომ ქცევას განსაზღვრავს თვისება flex-shrink.ის უჩვენებს, თუ რამდენად შემცირდება ეს ელემენტი სხვა ელემენტებთან შედარებით. 
                  
                  იგი ღებულობს რიცხვით მნიშვნელობებს. მიუთითებლობისას მისი მნიშვნელობა არის 1-ის ტოლი.
                  
                  ვნახოთ ამ თვისების მოქმედება შემდეგ მაგალითზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width:400px;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-basis: 200px; flex-shrink:1;}
                              .item2 {background-color: #9BC850; flex-basis: 200px; flex-shrink:2;}
                              .item3 {background-color: #A62E5C; flex-basis: 200px; flex-shrink:3;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში თიტოეული ელემენტის სიგანე (გამომდინარე flex-basis მნიშვნელობიდან) არის 200 პიქსელი, ანუ სამივე ელემენტის სიგანე ჯამში არის 600 პიქსელი. მაგრამ თვითონ კონტეინერის სიგანე მხოლოდ 400 პიქსელია. ამიტომ მოქმედებას იწყებს თვისება flex-shrink, რომელიც განსაზღვრული აქვს თიტოეულ ელემენტს.
                  
                  ზომების შესამცირებლად ბრაუზერი იყენებს შემცირების კოეფიციენტს (shrinkage factor). იგი გამოითვლება flex-basis და flex-shrink მნიშვნელობების გადამრავლებით:
                  
                  პირველი ელემენტი: 200*1=200
                  მეორე ელემენტი: 200*2=400
                  მესამე ელემენტი: 200*3=600
                  როგორც ვხედავთ, შემცირების კოეფიციენტი მეორე ელემენტს აქვს 2-ჯერ მეტი, ვიდრე პირველს, ხოლო მესამეს 3-ჯერ მეტი, ვიდრე პირველს. ამიტომაც შემცირების შემდეგ პირველი ელემენტი ორჯერ მეტი იქნება მეორეზე და სამჯერ მეტი მესამეზე.
                  
                  flex-grow
                  
                  თვისება flex-grow განსაზღვრავს ელემენტის გაფართოების წესს, თუ კონტეინერში არის დამატებითი ადგილი. მისი მოქმედება გარკვეულწილად ჰგავს flex-shrink თვისების მოქმედებას, ოღონდ ის მოქმედებს გაფართოების დროს.
                  
                  მნიშვნელობად იღებს არაუარყოფით რიცხვს, რომელიც განსაზღვრავს რამდენჯერ გაიზრდება ელემენტი გაფართოებისას სხვა ელემენტებთან შედარებით. მიუთითებლობისას ამ თვისების მნიშვნელობა არის 0-ის ტოლი.
                  
                  გამოვიყენოთ თვისება flex-grow:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.3em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-grow:0;}
                              .item2 {background-color: #9BC850; flex-grow:1;}
                              .item3 {background-color: #A62E5C; flex-grow:2;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  თითოეულ ელემენტს გააჩნია საწყისი საბაზისო ზომა. აქ ზომები არაა მითითებული, შესაბამისად ზომა განისაზღვრება შიგთავსიდან გამომდინარე, რასაც ემატება შიდა დაშორებები.
                  
                  HTML5-ის დოკუმენტი
                  
                  კონტეინერის გაფართოებასთან ერთად ელემენტები იწყებენ გაფართოებას flex-grow თვისების შესაბამისად, რომელიც მითითებული აქვს თითოეულ ელემენტს. სივრცეს, რომლითაც იზრდება კონტეინერის ზომა, ეწოდება დამატებითი სივრცე. 
                  
                  HTML5-ის დოკუმენტი
                  
                  რადგანაც პირველი ელემენტის flex-grow თვისების მნიშვნელობა 0-ის ტოლია, მისი ზომა არ შეიცვლება. მეორე ელემენტის flex-grow-ის მნიშვნელობა 1-ის ტოლია, მესამისა - 3-ის. 0+1+2=3. შესაბამისად, მეორე ელემენტი გაიზრდება ზომაში დამატებითი სიფრცის 1/3-ით, ხოლო მესამე ელემენტი - დამატებითი სივრცის 2/3-ით.
                  
                  თვისება flex
                  
                  თვისება flex წარმოადგენს flex-basis, flex-shrink და flex-grow თვისებების გაერთიანებას. მას აქვს შემდეგი ფორმალური სინტაქსი:
                  
                  flex: [flex-grow] [flex-shrink] [flex-basis]
                  მიუთითებლობისას მას აქვს მნიშვნელობა 0 1 auto:
                  
                  flex: 0 1 auto;
                  კონკრეტული მნიშვნელობების გარდა flex თვისებას შეიძლება ჰქონდეს ერთ-ერთი შემდეგი მნიშვნელობებიდან:
                  
                  flex: none: ეკვივალენტურია მნიშვნელობისა 0 0 auto, ამ დროს ელემენტი არ მცირდება და არ იზრდება კონტეინერის ზომების შეცვლისას
                  flex: auto: ეკვივალენტურია მნიშვნელობისა 1 1 auto
                  flex: initial: ეკვივალენტურია მნიშვნელობისა 0 1 auto
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container1 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 600px;
                              }
                              .flex-container2 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 500px;
                              }
                              .flex-container3 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 700px;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 16px;
                                  padding: 10px 0;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; width: 150px; flex: 0 0 auto }
                              .item2 {background-color: #9BC850; width: 150px; flex: 1 0 auto;}
                              .item3 {background-color: #A62E5C; width: 150px; flex: 0 1 auto;}
                              .item4 {background-color: #2A9FBC; width: 150px; flex: 1 1 auto;}
                          </style>
                      </head>
                      <body>
                          <h1>width: 600</h1>       
                          <div class="flex-container1">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                          <h1>width: 500</h1> 
                          <div class="flex-container2">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                          <h1>width: 700</h1> 
                          <div class="flex-container3">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                  </html>
                   `
              },
              {
                title:"მრავალსვეტიანი დიზაინი Flexbox-ის მეშვეობით",
                data:`ახლა ვნახოთ, როგორ შეიძლება მარტივი მრავალსვეტიანი დიზაინის შექმნა Flexbox-ის მეშვეობით.

                ორსვეტიანი დიზაინი
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Flexbox CSS3-ში</title>
                    <style>
                            *{
                                box-sizing: border-box;
                            }
                            html,
                            body {
                                padding: 0;
                                margin: 0;
                                font-family: verdana, arial, sans-serif;
                            } 
                            body {
                                display: flex;
                                padding: 1em;
                                flex-direction: column;
                            } 
                            .item {
                                background-color: #455a64;
                                color: #fff;
                                font-size: 1.1em;
                                padding: 1em;
                            }
                 
                            .item:nth-child(even) {
                                background-color: #607d8b;
                            }
                            @media screen and (min-width: 600px) {
                    
                                body {
                                    flex-direction: row;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <div class="item">
                            <h2>What is Lorem Ipsum?</h2>
                            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum
                                has been the industry's standard dummy text ever since the 1500s, when an unknown printer
                                took a galley of type and scrambled it to make a type specimen book. It has survived not only
                                five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.
                                It was popularised in the 1960s with the release of Letraset
                                sheets containing Lorem Ipsum passages, and more recently with desktop publishing software
                                like Aldus PageMaker including versions of Lorem Ipsum.</p>
                        </div>
                            
                        <div class="item">
                            <h2>Where does it come from?</h2>
                            <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a
                                piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard
                                McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of
                                the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through
                                the cites of the word in classical literature, discovered the undoubtable source.
                                Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum"
                                (The Extremes of Good and Evil) by Cicero, written in 45 BC. </p>
                        </div>
                    </body>
                </html>
                აქ flex-კონტეინერს წარმოადგენს body. რადგანაც მობილურ მოწყობილობებში (სმარტფონებში) ეკრანის ზომა არც ისე დიდია, მიუთითებლობისას ელემენტების განლაგება იყოს სვეტში. მაგრამ 600 პიქსელზე მეტი სიგანისთვის მოქმედებს წესი media-query, რომელიც განალაგებს ელემენტებს სტრიქონში. შესაბამისად მცირე ზომის ეკრანზე გამოჩნდება ასე:
                
                HTML5-ის დოკუმენტი 
                
                ხოლო 600 პიქსელის ზემოთ სიგანის ეკრანზე ასე:
                
                HTML5-ის დოკუმენტი
                
                სამსვეტიანი რეჟიმი
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Flexbox CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html,
                        body {
                            padding: 0;
                            margin: 0;
                            font-family: verdana, arial, sans-serif;
                        }
                        body {
                            display: flex;
                            padding: 1em;
                            flex-direction: column;
                        }
                        .item {
                            background-color: #455a64;
                            color: #fff;
                            font-size: 1.1em;
                            padding: 1em;
                            flex: 1;
                        }
                 
                        .item:nth-child(1) {
                            background-color: #607d8b;
                        }
                        @media screen and (min-width: 600px) {
                 
                            body {
                                flex-direction: row;
                            }
                            .item:nth-child(2) {
                                order: -1;
                            }
                        }
                    </style>
                </head>
                <body>    
                    <div class="item">
                        <h2>What is Lorem Ipsum?</h2>
                        <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum
                            has been the industry's standard dummy text ever since the 1500s, when an unknown printer
                            took a galley of type and scrambled it to make a type specimen book...</p>
                    </div>           
                    <div class="item">
                        <h2>Where does it come from?</h2>
                        <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a
                            piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard
                            McClintock, a Latin professor at Hampden-Sydney College in Virginia,... </p>
                    </div>
                    <div class="item">
                        <h3>Why do we use it?</h3>
                        <p>It is a long established fact that a reader will be distracted by the readable content
                            of a page when looking at its layout. The point of using Lorem Ipsum is that it has a
                            more-or-less normal distribution of letters, as opposed to using 'Content here, content here'...</p>
                    </div>
                </body>
                </html>
                წინა მაგალითისგან განსხვავებით, აქ დამატებულია კიდევ ერთი ელემენტი. გარდა ამისა, სვეტებს აქვთ ერთი და იგივე სიგანე, რისთვისაც სამივე სვეტს მინიჭებული აქვს თვისება flex:1. შესაბამისად, ზომების შეცვლისას სამივე სვეტი თანაბრად მასშტაბირდება. გარდა ამისა, 600 პიქსელზე ზევით სიგანისთვის მეორე ელემენტს მინიჭებული აქვს მნიშვნელობა order:-1, რის გამოც ეს ელემენტი თავსდება პირველი:
                
                HTML5-ის დოკუმენტი
                
                ასეთი სახით ჩვენ შეგვიძლია დავამატოთ სვეტების ნებისმიერი რაოდენობა. მაგრამ მოცემულ შემთხვევაში ყველა სვეტს აქვს ერთიდაიგივე სიგანე. თუ გვსურს, რომ რომელიმე სვეტი იყოს სხვა ზომის, სტილებში დავამატოთ ასეთი ჩანაწერი:
                
                 
                
                .item:first-child {
                    flex: 0 0 50%;
                }
                ახლა უკვე პირველი ელემენტი ყოველთვის დაიკავებს მთელი სივრცის 50 %-ს.`
            },
            {
                title:"ვებგვერდის მაკეტი Flexbox-ზე",
                data:`ახლა ვნახოთ ვებგვერდის სტანდარტული მაკეტის შექმნა, რომელიც შედგება ქუდის, ფუტერის და ცენტრალური ნაწილისაგან, რომელიც შედგება სამი სვეტისაგან: მთავარი შიგთავსი და ორი საიდბარი.

                ამისათვის განვსაზღვროთ შემდეგი ვებგვერდი:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Flexbox CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body {
                                padding: 0;
                                margin: 0;
                                font-family: verdana, arial, sans-serif;
                            }
                            body {
                                color: #fff;
                                font-size: 1.1em;
                                padding: 1em;
                                display: flex;
                                flex-direction: column;
                            }
                            main {
                                display: flex;
                                flex-direction: column;
                            }
                            article {
                                background-color: #546e7a;
                                flex: 2 2 12em;
                                padding: 1em;
                            }
                            nav, aside {
                                flex: 1;
                                background-color: #455a64;
                            }
                            nav {
                                order: -1;
                            }            
                            header, footer {
                                flex: 0 0 5em;
                                background-color: #37474f;
                            }            
                            @media screen and (min-width: 600px) {
                                
                                body{
                                    min-height: 100vh;
                                }
                                main {
                                    flex-direction: row;
                                    min-height: 100%;
                                    flex: 1 1 auto;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <header>
                            <p>Header</p>
                        </header>
                        <main>
                            <article>
                                <h1>What is Lorem Ipsum?</h1>
                                <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has
                                    been the industry's standard dummy text ever since the 1500s, when an unknown printer
                                    took a galley of type and scrambled it to make a type specimen book. It has survived not
                                    only five centuries, but also the leap into electronic typesetting, remaining essentially
                                    unchanged...</p>
                            </article>
                            <nav>
                                <p>Navigation</p>
                            </nav>
                            <aside>
                                <p>Sidebar</p>
                            </aside>
                        </main>
                        <footer>
                            <p>Footer</p>
                        </footer>
                    </body>
                </html>
                 
                
                . HTML5-ის დოკუმენტი
                
                ზედა დონის flex-კონტეინერი ამ მაგალითში არის ელემენტი body. მისი flex-ელემენტებია header, main და footer. body-ში ელემენტები განლაგებულია სვეტში ზემოდან ქვემოთ. აღსანიშნავია, რომ როცა გვერდის სიგანე 600px და მეტია, body-ს სიმაღლე არის 100vh. (vh არის ზომის ერთეული, 1 vh არის viewport-ის სიმაღლის 1%, შესაბამისად 100vh არის viewport-ის სიმაღლის ტოლი. ანალოგიურად, 1vw არის viewport-ის სიგანის 1 %).
                
                ელემენტები header და footer ერთმანეთის ანალოგიურია. მათ აქვთ მნიშვნელობა 0 0 5em; .რაც იმას ნიშნავს, რომ კონტეინერის ზომების ნებისმიერი ცვლილებისას ისინი არ გნიცდიან მასშტაბირებას და მათი ზომა ყოველთვის 5em-ის ტოლია. ანუ, მათ აქვთ სტატიკური ზომა.
                
                უფრო რთულია ელემენტი main, რომელშიც მოქცეულია გვერდის ძირითადი შიგთავსი. იგი ერთდროულად flex-ელემენტიცაა და ამასთანავე flex-კონტეინერიც მასში მოქცეული ელემენტებისათვის. 600px-მდე სიგანის დროს მასში მოთავსებული flex-ელემენტები განლაგებულია სვეტში, რაც მოხერხებულია მობილურ მოწყობილობებზე.
                
                600px და მეტ სიგანეზე ელემენტები nav, article და aside განლაგდება სტრიქონში. რადგანაც ასეთი სიგანის დროს მშობელი ელემენტი body იკავებს ბრაუზერის მთელ სიმაღლეს, body კონტეინერის მთელი სიმაღლის შესავსებად მისი ცვლილებისას ელემენტს main მინიჭებული აქვს მნიშვნელობა flex:1 1 auto;
                
                main ელემენტში შემავალი flex-ელემენტებისთვის აღსანიშნავია, რომ კონტეინერის მასშტაბირებისას ნავიგაციის პანელისა და საიდბარის ზომები იქნება ერთნაირი, ხოლო article ელემენტის ზომა იქნება უფრო მეტი, რადგან ის შეიცავს ძირითად შინაარსს. მიუხედავად იმისა, რომ ელემენტი article უფრო ადრეა განსაზღვრული, ვიდრე ნავიგაციის პანელი, ეს უკანასკნელი იქნება ყოველთვის უფრო წინ თვისების order:-1 გამო.`
            },
          
            ]
        },
        {
            title:"თავი 12. Grid Layout",
            content:[
                {
                    title:"რა არის Grid Layout. Grid Container",
                    data:`Grid Layout არის CSS3-ის სპეციალური მოდული, რომელიც საშუალებას იძლევა განვალაგოთ ელემენტები ცხრილის სახით. ისევე, როგორც Flexbox, Grid Layout წარმოადგენს ელემენტების დალაგების მოქნილ სისტემას, ოღონდ თუ Flexbox-ში ელემენტები განთავსდებოდა ერთი მიმართულებით - სტრიქონში ან სვეტში, Grid Layout საშუალებას იძლევა ელემენტების მდებარეობა განვსაზღვროთ ორივე მიმართულებით, რაც წარმოქმნის ცხრილს.

                    Grid Layout მოდულის სრული სპეციფიკაცია შეგიძლია ნახოთ ამ მისამართზე https://www.w3.org/TR/css-grid-1.
                    
                    Grid Layout-ის გამოყენებისას უნდა გავითვალისწინოთ, რომ მისი მხარდაჭერა ბრაუზერებმა შედარებით გვიან დაიწყეს, შესაბამისად ადრინდელ ვერსიებში მისი მხარდაჭერა არ არსებობდა.
                    
                    grid-კონტეინერის შექმნა
                    
                    Grid Layout-ში განლაგების მთავარი ელემენტია grid-კონტეინერი, რომლის შიგნითაც არის მოთავსებული ელემენტები. მის შესაქმნელად საჭიროა ელემენტის display თვისებას მივანიჭოთ მნიშვნელობა grid ან grid-inline.
                    
                    შევქმნათ მარტივი ვებგვერდი Grid Layout-ის გამოყენებით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <meta name="viewport" content="width=device-width" />
                            <title>Grid Layout CSS3-ში</title>
                            <style>
                                .grid-container {
                                    border: solid 2px #000;
                                    display: grid;
                                }
                                .grid-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                } 
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                                .color4 {background-color: #2A9FBC;}
                            </style>
                        </head>
                        <body>
                            <div class="grid-container">
                                <div class="grid-item color1">Grid Item 1</div>
                                <div class="grid-item color2">Grid Item 2</div>
                                <div class="grid-item color3">Grid Item 3</div>
                                <div class="grid-item color4">Grid Item 4</div>
                                <div class="grid-item color1">Grid Item 5</div>
                            </div>
                        </body>
                    </html>
                     
                    
                    კონტეინერისთვის grid-container განსაზღვრულია თვისება display:grid. მასში არის ხუთი ელემენტი:
                    
                    . HTML5-ის დოკუმენტი
                    
                    თუ მნიშვნელობა grid კონტეინერს განსაზღვრავს როგორც ბლოკისებურ ელემენტს, grid-inline განსაზღვრავს სტრიქონულს:
                    
                     
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <meta name="viewport" content="width=device-width" />
                            <title>Grid Layout CSS3-ში</title>
                            <style>
                                .grid-container {
                                    border: solid 2px #000;
                                    display: inline-grid;
                                } 
                                .grid-item {
                                    box-sizing: border-box;
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                } 
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                                .color4 {background-color: #2A9FBC;}
                            </style>
                        </head>
                        <body>
                            <div class="grid-container">
                                <div class="grid-item color1">Grid Item 1</div>
                                <div class="grid-item color2">Grid Item 2</div>
                                <div class="grid-item color3">Grid Item 3</div>
                                <div class="grid-item color4">Grid Item 4</div>
                                <div class="grid-item color1">Grid Item 5</div>
                            </div>
                        </body>
                    </html>
                     
                    
                     
                    
                    ამ შემთხვევაში grid-კონტეინერი იკავებს მხოლოდ იმ ადგილს, რაც ელემენტების დასატევად არის საჭირო.`
                },
                {
                  title:"სტრიქონები და სვეტები",
                  data:`გრიდი სტრიქონებისა და სვეტებისგან წარმოქმნის ბადეს, ხოლო მათ გადაკვეთაზე უჯრებს. სტრიქონებისა და სვეტების შესაქმნელად Grid Layout იყენებს CSS3-ის შემდეგ თვისებებს:

                  grid-template-columns: განსაზღვრავს სვეტებს
                  grid-template-rows: განსაზღვრავს სტრიქონებს
                  სვეტები
                  
                  სვეტების განსაზღვრისთვის Grid Layout იყენებს თვისებას grid-template-columns. მაგალითად, შევქმნათ გრიდი ორი სვეტით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em 8em;
                              }
                              .grid-item {
                                  box-sizing: border-box;
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                          </div>
                      </body>
                  </html>
                  grid-template-columns თვისებას მნიშვნელობად გადაეცემა სვეტების სიგანე. რამდენი სვეტიც გვჭირდება, იმდენი მნიშვნელობა უნდა გადავცეთ. 
                  
                  HTML5-ის დოკუმენტი
                  
                  შესაბამისად, თუ ჩვენ გვინდა, რომ გრიდს ჰქონდეს სამი სვეტი, უნდა გადავცეთ სამი მნიშვნელობა:
                  
                  grid-template-columns: 8em 7em 8em;
                  თუ ელემენტები უფრო მეტია, ვიდრე სვეტები, მათი განთავსებისთვის მიუთითებლობისას ჩნდება ახალი სტრიქონები.
                  
                  სტრიქონები
                  
                  სტრიქონების განსაზღვრა სვეტების ანალოგიურია. ამისათვის გამოიყენება თვისება grid-template-rows. მას მნიშვნელობად გადაეცემა სტრიქონების სიმაღლეები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns:30% 40% 30%;
                                  grid-template-rows: 4em 5em;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color3">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ ელემენტების რაოდენობა მეტია უჯრების რაოდენობაზე, ჩნდება დამატებითი სტრიქონი. ამიტომაც, ჩვენს მაგალითში, მიუხედავად იმისა, რომ განსაზღვრული იყო ორი სტრიქონი, რეალურად გვაქვს სამი.ამასთან, მესამე სტრიქონის სიმაღლე გამოითვლება ავტომატურად.
                  
                  დავამატოთ გრიდში კიდევ ორი სტრიქონი:
                  
                  .grid-container {
                       border: solid 2px #000;
                       display: grid;
                       grid-template-columns:30% 40% 30%;
                       grid-template-rows: 4em 5em 5em 5em;
                   }
                  ახლა განსაზღვრულია სამი სვეტი და ოთხი სტრიქონი. მაგრამ ვინაიდან უჯრების რაოდენობა უფრო მეტია, ვიდრე გრიდში ელემენტების რაოდენობა, მეოთხე სტრიქონი იქნება ცარიელი.`
              },
              {
                  title:"ფუნქცია repeat და თვისება grid",
                  data:`სტრიქონებისა და სვეტების გამეორება

                  თუ გვაქვს რამდენიმე სტრიქონი ან სვეტი, რომელთა ზომები ერთნაირია, აქვს აზრი გამოვიყენოთ ფუნქცია repeat(). მაგალითად, თუ გვაქვს განსაზღვრული შემდეგი გრიდი:
                  
                  .grid-container {
                      grid-template-columns: 8em 8em 8em;
                      grid-template-rows: 5em 5em 5em 5em;
                  }
                  repeat() ფუნქციის გამოყენებით შეგვიძლია ჩავწეროთ შემოკლებულად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(3, 8em);
                      grid-template-rows: repeat(4, 5em);
                  }
                  repeat() ფუნქციის პირველი პარამეტრი უჩვენებს გამეორებათა რაოდენობას, მეორე სვეტის ან სტრიქონის ზომას. შეიძლება ერთდროულად რამდენიმე სვეტის ან სტრიქონის განმეორების განსაზღვრაც:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(2, 7em 8em);
                      grid-template-rows: 6em repeat(3, 5em);
                  }
                  მოცემულ შემთხვევაში შეიქმნება ოთხი სვეტი: ორი სვეტი სიგანით 7em და 8em გამეორდება ორჯერ. სვეტების შემთხვევაში, შეიქმნება ოთხი სტრიქონი: ერთი სიმაღლით 6em და დანარჩენი სამი სიმაღლით 5em.
                  
                  თვისება grid
                  
                  თვისება grid აერთიანებს თვისებებს grid-template-columns და grid-template-rows და იძლევა სტრიქონებისა და სვეტების კონფიგურაციისშესაძლებლობას შემდეგი ფორმატით:
                  
                  grid: grid-template-rows / grid-template-columns;
                  მაგალითად, ვთქვათ, გვაქვს grid-კონტეინერი შემდეგი სტილით:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: 8em 8em 8em;
                      grid-template-rows: 5em 5em 5em 5em;
                  }
                  შეგვიძლია შევამოკლოთ შემდეგნაირად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid: 5em 5em 5em 5em / 8em 8em 8em;
                  }
                  ან repeat() ფუნქციის გამოყენებით კიდევ უფრო შევამოკლოთ:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid: repeat(4, 5em) / repeat(3, 8em);
                  }`
              },
              {
                  title:"სტრიქონებისა და სვეტების ზომა",
                  data:`ფიქსირებული ზომები

                  წინა სტატიებში განხილულ მაგალითებში სვეტების და სტრიქონების ზომების დასადგენად გამოიყენებოდა თვისებები grid-template-columns და grid-template-rows. ზომების მისათითებლად შესაძლოა გამოვიყენოთ სხვადასხვა ზომის ერთეულები (px, em, rem, pt, %). მაგალითად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(3, 200px);
                      grid-template-rows: repeat(3, 4.5em);
                  }
                   
                  
                  ავტომატური ზომები
                  
                  გარდა ზუსტი ზომებისა შეიძლება მიენიჭოს ავტომატური ზომა auto.ამ შემთხვევაში სვეტების სიგანე და სტრიქონების სიმაღლე ენიჭება შიგთავსიდან გამომდინარე:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em auto auto;
                                  grid-template-rows: auto 4.5em auto;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color2">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  აქ განსაზღვრულია სამი სვეტი და სამი სტრიქონი. პირველ სვეტს აქვს ფიქსირებული სიგანე, სოლო მეორეს და მესამეს - ავტომატური. ასევე, პირველ და მესამე სტრიქონს აქვს ავტომატური სიმაღლე, ხოლო მეორეს - ფიქსირებული.
                  
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პროპორციული ზომები
                  
                  პროპორციული ზომების მისანიჭებლად გამოიყენება სპეციალური ზომის ერთეული fr. ის წარმოადგენს სივრცის ნაწილს (fraction), რომელიც განესაზღვრება მოცემულ სვეტს ან სტრიქონს. fr-ს მნიშვნელობას უწოდებენ flex-ფაქტორს (flex-factor).
                  
                  პროპორციული ზომები გამოითვლება ფორმულით:
                  
                  flex-factor *  ხელმისაწვდომი სივრცე / ყველა flex-factor-ის ჯამი.
                  ამასთან, ხელმისაწვდომ სივრცეს წარმოადგენს კონტეინერის მთლიან ზომას გამოკლებული ფიქსირებული ზომის სვეტების (სტრიქონების) ზომები.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em 2fr 1fr;
                                  grid-template-rows: 1fr 4.5em 1fr;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color2">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველი სვეტის სიგანე ფიქსირებულია, ხოლო მეორე და მესამე სვეტისა - პროპორციული 2fr და 1fr. შესაბამისად, მეორე სვეტის სიგანე იქნება მთელი დარჩენილი სივრცის 2/(1+2) = 2/3 , ხოლო მესამე სვეტისა - 1/(1+2) = 1/3.
                  
                  ანალოგიურად, მეორე სტრიქონის სიმაღლე ფიქსირებულია, ხოლო პირველი და მესამე სტრიქონის სიმაღლე დარჩენილი სივრცის ნახევარი იქნება თითოეულისთვის 1/(1+1) = 1/2.
                  
                   `
              },
              {
                  title:"დაშორებები სვეტებსა და სტრიქონებს შორის",
                  data:`სვეტებსა და სტრიქონებს შორის დაშორებების შესაქმნელად გამოიყენება თვისებები grid-column-gap და grid-row-gap.

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-column-gap: 10px;
                                  grid-row-gap: 10px;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ grid-column-gap და grid-row-gap თვისებების მნიშვნელობები ერთმანეთს ემთხვევა, შეიძლება განისაზღვროს ერთი თვისება grid-gap, რომელიც განსაზღვრავს ორივე დაშორებას (როგორც სვეტებს შორის, ასევე სტრიქონებს შორის):
                  
                  .grid-container {
                      height: 100vh;
                      display: grid;
                      grid-template-columns: repeat(3, 1fr);
                      grid-template-rows: repeat(3, 1fr);
                      grid-gap: 10px;
                  }`
              },
              {
                  title:"ელემენტების განლაგება",
                  data:`გრიდი წარმოადგენს უჯრების ერთობლიობას, რომლებიც წარმოიქმნებიან სვეტებისა და სტრიქონების გადაკვეთისას. მაგრამ თვითონ სვეტები და სტრიქონები წარმოიქმნება grid-ხაზების მეშვეობით, რომლებიც ყოფენ გრიდს ვერტიკალურად და ჰორიზონტალურად:

                  HTML5-ის დოკუმენტი
                  
                  მიუთითებლობისას ყოველი ელემენტი გრიდში თავსდება ერთ უჯრაში რიგის მიხედვით, მაგრამ ელემენტების გრიდში ჩვენი სურვილის მიხედვით განლაგებისთვის გამოიყენება შემდეგი თვისებები:
                  
                  grid-row-start: განსაზღვრავს საწყის ჰორიზონტალურ grid-ხაზს, საიდანაც იწყება ელემენტი
                  grid-row-end: განსაზღვრავს, თუ რომელ ჰორიზონტალურ grid-ხაზამდე გრძელდება ელემენტი
                  grid-column-start: განსაზღვრავს საწყის ვერტიკალურ grid-ხაზს, საიდანაც იწყება ელემენტი
                  grid-column-end: განსაზღვრავს, თუ რომელ ვერტიკალურ grid-ხაზამდე გრძელდება ელემენტი
                  მაგალითად, მოვათავსოთ ელემენტი რამდენიმე სვეტში:
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: repeat(4, 1fr);
                                  grid-template-rows: repeat(3, 5em);
                              }
                              .special-item{
                                  grid-column-start:2;
                                  grid-column-end: 5;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2 special-item">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color4">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ განსაზღვრულია ოთხი სვეტი, ამასთან მე-2 ელემენტს მინიჭებული აქვს სპეციალური კლასი special-item, რომელიც თავსდება მე-2 grid-ხაზიდან ანუ მეორე სვეტიდან მე-5  grid-ხაზამდე ანუ მეოთხე სვეტის ბოლომდე.
                  
                  აუცილებელი არაა, რომ მე-2 ელემენტი იწყებოდეს მეორე სვეტიდან, ეს შეიძლება იყოს ნებისმიერი სვეტი: 1-ლი, მე-3, მე-4. მაგალითად, თუ მე-2 ელემენტს მოვათავსებთ მე-3 სვეტიდან (grid-column-start: 3;), მე-2 სვეტის ადგილას პირველ სტრიქონში დარჩება სიცარიელე:
                  
                  .special-item{
                      grid-column-start: 3;
                      grid-column-end: 5;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ მეორე ელემენტს მოვუთითებთ, რომ უნდა დაიწყოს პირველი სვეტიდან, მაშინ სი გადავა მე-2 სტრიქონში და დაიწყება პირველი სვეტიდან და დაიკავებს მთლიან სტრიქონს.
                  
                  .special-item{
                      grid-column-start: 1;
                      grid-column-end: 5;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  grid-column-start და grid-column-end თვისებების ნაცვლად შეიძლება გამოვიყენოთ ერთი - grid-column. ამ შემთხვევაში მნიშვნელობები მიეთითება სლეშით:
                  
                  grid-column: grid-column-start / grid-column-end;
                  მაგალითად, ჩვენ შეგვიძლია შევამოკლოთ special-item კლასის სტილი წინა მაგალითიდან შემდეგნაირად:
                  
                  grid-column: 1 / 5;
                  ზუსტად ანალოგიურად grid-row-start და grid-row-end თვისებების მეშვეობით შეგვიძლია ელემენტი მოვათავსოთ რამდენიმე სტრიქონში:
                  
                  .special-item{
                      grid-column-start:2;
                      grid-row-start: 1;
                      grid-row-end: 3;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩანაწერის შესამოკლებლად აქაც შეგვიძლია გამოვიყენოთ თვისება grid-row ნაცვლად grid-row-start და grid-row-end-სა:
                  
                  .special-item{
                      grid-column-start:2;
                      grid-row-start: 1 / 3;
                  }
                   
                  
                  span
                  
                  სპეციალური სიტყვის span მეშვეობით შეგვიძლია ელემენტს მივუთითოთ უჯრების რაოდენობა, რომელსაც ის დაიკავებს. მაგალითად:
                  
                  .special-item{
                      grid-row: 1 / span 2;
                      grid-column: 2 / span 2;
                  }
                   
                  
                  ელემენტი დაიწყება პირველი სტრიქონისა და მეორე სვეტის გადაკვეთის ადგილში და დაიკავებს ორ უჯრას ჰორიზონტალურად და ორს ვერტიკალურად:
                  
                  HTML5-ის დოკუმენტი
                  
                  grid-area
                  
                  თვისება grid-area აერთიანებს თვისებებს grid-row და grid-column და ამოკლებს ჩანაწერს:
                  
                  grid-area: row-start / column-start / row-end / column-end
                  მაგალითად:
                  
                  .special-item{
                      grid-row: 1 / span 2;
                      grid-column: 2 / span 2;               
                      grid-area: 1 / 2 / 3 / 4;
                  }`
              },
              {
                  title:"ელემენტების გადაფარვა",
                  data:`ელემენტების განლაგების მანიპულირებით ადვილად შეიძლება გრიდის ერთი ელემენტები გადავფაროთ სხვა ელემენტებით, ანუ მოვათავსოთ ელემენტები ფენებად. მაგალითად, განვსაზღვროთ შემდეგი გრიდი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-gap: 10px;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                                  z-index: 1;
                              }
                              .item1{
                                  grid-area: 1 / 1 / 3 / 4;
                                  opacity: 0.8;
                              }
                              .item2{
                                  grid-area: 1 / 1 / 2 / 2;
                              }
                              .item3{
                                  grid-area: 1 / 3 / 2 / 4;
                              }
                              .item4{
                                  grid-area: 2 / 1 / 3 / 2;
                              }
                              .item5{
                                  grid-area: 2 / 2 / 3 / 3;
                              }
                              .item6{
                                  grid-area: 2 / 3 / 3 / 4;
                              }
                              .item7{
                                  grid-area: 3 / 1 / 4 / 2;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item item1 color2">Grid Item 2</div>
                              <div class="grid-item item2 color1">Grid Item 1</div>
                              <div class="grid-item item3 color3">Grid Item 3</div>
                              <div class="grid-item item4 color4">Grid Item 4</div>
                              <div class="grid-item item5 color1">Grid Item 5</div>
                              <div class="grid-item item6 color4">Grid Item 6</div>
                              <div class="grid-item item7 color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                  აქ პირველი ელემენტი იკავებს იგივე ადგილს, რასაც მისი მომდევნო ხუთი ელემენტი. რადგან ყველა ელემენტს აქვს თვისება z-index: 1, ამიტომ პირველი ელემენტი დანარჩენი ელემენტებისთვის გამოცნდება როგორც ფონი:
                  
                  HTML5-ის დოკუმენტი
                  
                  საჭიროებისას შეგვიძლია პირველი ელემენტის ფენა გადმოვიტანოთ უფრო ახლოს და მისი მეშვეობით გადავფაროთ სხვა ელემენტები. ამისათვის საკმარისია გავუზარდოთ მას z-index:
                  
                  .item1{
                      grid-area: 1 / 1 / 3 / 4;
                      opacity: 0.8;
                      z-index: 10;
                  }`
              },
              {
                  title:"ელემენტების მიმართულება და თანმიმდევრობა",
                  data:`თვისება grid-auto-flow

                  მიუთითებლობისას ელემენტები გრიდში განლაგდება თანმიმდევრობით პირველ სტრიქონსი მარცხნიდან მარჯვნივ, როცა პირველ სტრიქონსი უჯრები გამოილევა, გადავა მეორე სტრიქონზე და ა. შ. მაგრამ grid-auto-flow თვისების მეშვეობით შეგვიძლია შევცვალოთ ეს თანმიმდევრობა. იგი ღებულობს შემდეგ მნიშვნელობებს:
                  
                  row: მნიშვნელობა მიუთითებლობისას. ელემენტები განლაგდება სტრიქონში თანმიმდევრობით, როცა მეტი ადგილი არ არის, გადავა მომდევნო სტრიქონზე
                  column: ელემენტები განლაგდება სვეტებში, როცა მეტი ადგილი არ არის, გადავა მომდევნო სვეტზე
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-auto-flow: row;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება grid-auto-flow აქვს მნიშვნელობა row, ამიტომ ელემენტები განლაგებულია სტრიქონებად. თუ შევცვლით მნიშვნელობაზე column, ელემენტები განლაგდება სვეტებში.
                  
                  grid-auto-flow: column;
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება order
                  
                  თვისება order გვაძლევს საშუალებას, შევცვალოთ ელემენტების თანმიმდევრობა. მიუთითებლობისას ყველა ელემენტისთვის მისი მნიშვნელობა 0-ის ტოლია. ამიტომ ელემენტები განლაგდება იმ თანმიმდევრობით, რა თანმიმდევრობითაც მოდიან html კოდში. მაგრამ თვისება order-ის მნიშვნელობის შეცვლით შეგვიძლია შევცვალოთ ეს თანმიმდევრობა:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .last-item{
                                  order: 1;
                              }
                              .first-item{
                                  order: -1;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2 last-item">Grid Item 2</div>
                              <div class="grid-item color3 last-item">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5 first-item">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ელემენტებს კლასით last-item (მე-2 და მე-3 ელემენტი) გააჩნიათ order:1 მნიშვნელობა და რადგან სხვა ელემენტებს, რომელთაც მითითებული არა აქვთ order-ის მნიშვნელობა მიუტითებლობისას აქვთ 0-ის ტოლი, ამიტომ მე-2 და მე-3 ელემენტი განთავსდება ყველაზე ბოლოს. ელემენტს კლასით first-item (მე-7 ელემენტი) order-ის მნიშვნელობა აქვს -1-ის ტოლი, ანუ ყველაზე ნაკლები, შესაბამისად ის განთავსდება გრიდში პირველი.
                  
                   
                  
                  
                  
                  `
              },
              {
            title:"grid-ხაზებისთვის სახელის მიცემა",
            data:`Grid Layout-ში ჩვენ შეგვიძლია გრიდის თითოეულ ხაზს მივცეთ სახელი, რომელიც ეთითება კვადრატულ ფრჩხილებში, შემდგომსი ამ სახელის გამოყენება შეიძლება ელემენტების პოზიციის განსაზღვრისთვის. მაგალითად:

            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width" />
                    <title>Grid Layout CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html, body{
                            margin:0;
                            padding:0;
                        }
                        .grid-container {
                            height:100vh;
                            display: grid;
                            grid-template-columns: [col1start] 1fr [col1end] 10px
                                                    [col2start] 1fr [col2end] 10px
                                                    [col3start] 1fr [col3end];
                            grid-template-rows: [row1start] 1fr [row1end] 10px [row2start] 1fr [row2end];
                        }
                         
                        .grid-item {
                            background-color: #ddd;
                        }
                        
                        .special-item{
                            grid-column: col1start / col2end;
                            grid-row: row1start;
                            background-color: #bbb;
                        }
                        .item1{
                            grid-column: col3start / col3end;
                            grid-row: row1start;
                        }
                        .item2{
                            grid-column: col1start / col1end;
                            grid-row: row2start;
                        }
                        .item3{
                            grid-column: col2start / col2end;
                            grid-row: row2start;
                        }
                        .item4{
                            grid-column: col3start / col3end;
                            grid-row: row2start;
                        }
                    </style>
                </head>
                <body>
                    <div class="grid-container">
                        <div class="grid-item special-item"></div>
                        <div class="grid-item item1"></div>
                        <div class="grid-item item2"></div>
                        <div class="grid-item item3"></div>
                        <div class="grid-item item4"></div>
                    </div>
                </body>
            </html>
            თითოეული ხაზის დასახელება მოქცეულია კვადრატულ ფრჩხილებში, ხოლო მათ შორის წერია ამ ხაზებით შემოსაზღვრული სვეტის ან სტრიქონის სიგანე ან სიმაღლე:
            
            grid-template-columns: [col1start] 1fr [col1end] 10px
                                   [col2start] 1fr [col2end] 10px
                                   [col3start] 1fr [col3end];
            grid-template-rows: [row1start] 1fr [row1end] 10px [row2start] 1fr [row2end];
            ამის შემდეგ გრიდის ხაზების გამოყენებით განისაზღვრება ელემენტების მდებარეობა:
            
            .special-item{
                grid-column: col1start / col2end;
                grid-row: row1start;
                background-color: #bbb;
            }
             
            
            HTML5-ის დოკუმენტი
            
            ვნახოთ მეორე მაგალითი გვერდის მაკეტის შექმნით:
            
            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width" />
                    <title>Grid Layout CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html, body {
                            padding: 0;
                            margin: 0;
                        } 
                        .grid-container {
                            display: grid;
                            height: 100vh;
                            grid-template-rows: 6em 10px 1fr;
                            grid-template-columns: [mainstart] 1fr [mainend] 10px [sidebarestart] 25% [sidebarend];
                        } 
                        .grid-item-content {
                            background-color: #455a64;
                            grid-row: 3 / 4;
                            grid-column: mainstart / mainend;
                        } 
                        .grid-item-sidebar {
                            background-color: #37474f;
                            grid-row: 3 / 4;
                            grid-column: sidebarestart / sidebarend;
                        } 
                        .grid-item-header{
                            background-color: #263238;
                            grid-row: 1 / 2;
                            grid-column: mainstart / sidebarend;
                        } 
                        .grid-item {
                            color: #fff;
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                    <main class="grid-container">
                        <header class="grid-item grid-item-header">
                            <h1>Header</h1>
                        </header>                
                        <article class="grid-item grid-item-content">
                            <h1>Main Content</h1>
                        </article>            
                        <aside class="grid-item grid-item-sidebar">
                            <h1>Sidebar</h1>
                        </aside>
                    </main>
                </body>
            </html>`
              },
              {
                title:"სახელდებული grid-ხაზები და ფუნქცია repeat",
                data:`ადრე განხილული ფუნქციის repeat მეშვეობით შესაძლებელია იმ სვეტებისა და სტრიქონების ტირაჟირება, რომლებიც მოქცეულია სახელდებულ გრიდის ხაზებს შორის:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px);
                                grid-template-rows: 10px repeat(2, [row] 1fr [rowgutter] 10px);
                            }
                            
                            .grid-item {
                                background-color: #ddd;
                            }
                            
                            .special-item{
                                grid-column: column 2;
                                grid-row: row 1;
                                background-color: #bbb;
                            }
                            .item1{
                                grid-column: column 1;
                                grid-row: row 1;
                            }
                            .item2{
                                grid-column: column 3;
                                grid-row: row 1;
                            }
                            .item3{
                                grid-column: column 1;
                                grid-row: row 2;
                            }
                            .item4{
                                grid-column: column 2;
                                grid-row: row 2;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="grid-item special-item"></div>
                            <div class="grid-item item1"></div>
                            <div class="grid-item item2"></div>
                            <div class="grid-item item3"></div>
                            <div class="grid-item item4"></div>
                        </div>
                    </body>
                </html>
                ავიღოთ მოცემული მაგალითიდან სვეტების განსაზღვრა:
                
                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px);
                 
                
                პირველ სვეტს ექნება 10 პიქსელი სიგანე. შემდეგ მოდის repeat ფუნქციით ტირაჟირებული სვეტები. ის ქმნის მიმდევრობით ორი სვეტის სამ ასლს. პირველი სვეტის სიგანეა 1fr, ანუ მას აქვს პროპორციული ზომა და მოთავსებულია grid-ხაზებს "column" და "colgutter" შორის. შემდეგ მოდის 10 პიქსელი სიგანის სვეტი. ეს ორი სვეტი გამეორდება სამჯერ. საბოლოოდ, გრიდს ექნება შვიდი სვეტი.
                
                ანალოგიურად არის სტრიქონების შემთხვევაშიც. იქმნება 5 სტრიქონი.
                
                ელემენტების სტილის განსაზღვრის დროს გამოიყენება grid-ხაზის სახელი და რიგითი ნომერი. ჩვენ შეგვიძლია პირდაპირ მივუთითოთ, ტუ სად იქნება მოთავსებული ესა თუ ის ელემენტი grid-column და grid-row თვისებების მეშვეობით:
                
                .special-item{   
                   grid-column: column 2; /* მე-2 სვეტი სახელით column */
                   grid-row: row 1;       /* 1-ლი სტრიქონი სახელით row */
                }
                თვისება grid-column: column 2 უთითებს სვეტზე, რომელიც მოსდევს მე-2 grid-ხაზს სახელით "column". 
                
                ვღებულობთ ასეთ შედეგს:
                
                HTML5-ის დოკუმენტი
                
                შესაძლოა ასეთი მიდგომა ინტუიტიურად ბევრისთვის უფრო გასაგები იყოს.
                
                ჩვენ შეგვიძლია სახელდებული სვეტების და სრტიქონების განსაზღვრა repeat ფუნქციის გარეთაც:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px)
                                                       [sidebarstart] 150px [sidebarend] 10px;
                                grid-template-rows: 10px repeat(2, [row] 1fr [rowgutter] 10px);
                            }
                             
                            .grid-item {
                                background-color: #ddd;
                            }
                            
                            .special-item{
                                grid-column: column 2;
                                grid-row: row 1;
                                background-color: #bbb;
                            }
                            .item1{
                                grid-column: column 1;
                                grid-row: row 1;
                            }
                            .item2{
                                grid-column: column 3;
                                grid-row: row 1;
                            }
                            .item3{
                                grid-column: column 1;
                                grid-row: row 2;
                            }
                            .item4{
                                grid-column: column 2;
                                grid-row: row 2;
                            }
                            .sidebar{
                                grid-column: sidebarstart / sidebarend;
                                grid-row: 2 / 5;
                                background-color: #ccc;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="grid-item special-item"></div>
                            <div class="grid-item item1"></div>
                            <div class="grid-item item2"></div>
                            <div class="grid-item item3"></div>
                            <div class="grid-item item4"></div>
                            <div class="grid-item sidebar"></div>
                        </div>
                    </body>
                </html> 
                აქვე უნდა აღინიშნოს, რომ მიუხედავად იმისა, სახელდებულია grid-ხაზები თუ არა, მათზე მიმართვა რიგითი ნომრით ყოველთვის შესაძლებელია:
                
                .sidebar{
                       grid-column: sidebarstart / sidebarend;
                       grid-row: 2 / 5;
                       background-color: #ccc;
                 }`
                  },
            {
               title:"გრიდის არეები",
                data:`გრიდის შიგნით შესაძლებელია არეების (grid area) განსაზღვრა. არე განისაზღვრება ორი ვერტიკალური და ორი ჰორიზონტალური ხაზით. არაა აუცილებელი, რომ არე მოიცავდეს ერთ უჯრას, ის შეიძლება შეიცავდეს ვერტიკალური და ჰორიზონტალური ხაზებით შემოსაზღვრულ ბევრ უჯრას. არეების განსაზღვრა მოხერხებულია გვერდის სემანტიკური სტრუქტურის ასაგებად.

                არის განსაზღვრისთვის გამოიყენება თვისება grid-template-areas. მაგალითად, განვსაზღვროთ სამი არე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-areas: "header header"
                                                     "sidebar content"
                                                     "sidebar content";
                                grid-template-columns: 150px 1fr;
                                grid-template-rows: 100px 1fr 100px;
                            }
                            .header { grid-area: header; background-color: #bbb; }
                            .sidebar { grid-area: sidebar; background-color: #ccc; }
                            .content { grid-area: content; background-color: #eee; }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="header"></div>
                            <div class="sidebar"></div>
                            <div class="content"></div>
                        </div>
                    </body>
                </html>
                grid-კონტეინერს განსაზღვრული აქვს ორი სვეტი და სამი სტრიქონი:
                
                grid-template-columns: 150px 1fr;
                grid-template-rows: 100px 1fr 100px;
                 
                
                შესაბამისად გრიდს ექნება 3*2=6 უჯრა. html კოდში განსაზღვრულია სამი ელემენტი, რომელთაც აქვთ იგივე სახელი, რაც გრიდის არეებს: header, sidebar, content. თვისება grid-template-areas განსაზღვრავს, როგორ იქნება ეს არეები განლაგებული გრიდში:
                
                grid-template-areas: "header header"
                                                                 "sidebar content"
                                                                "sidebar content";
                 
                
                გამოსახულება "header header"  მიუთითებს, რომ header არე იკავებს პირველი სტრიქონის ორ უჯრას. შემდეგი სტრიქონი "sidebar content" განსაზღვრავს მეორე სტრიქონის უჯრებს, ანუ sidebar იკავებს მეორე სტრიქონის პირველ უჯრას, ხოლო content მეორე სტრიქონის მეორე უჯრას. მესამე სტრიქონი იმეორებს მეორეს. თუ შევხედავთ, გრიდში უჯრები იქნება შემდეგნაირად:
                
                header
                
                header
                
                sidebar
                
                content
                
                sidebar
                
                content
                
                 
                
                ელემენტებისათვის არის მისათითებლად გამოიყენება თვისება grid-area:
                
                .header {
                      grid-area: header; background-color: #bbb;
                }
                შედეგად ვღებულობთ ასეთ ვებგვერდს:
                
                HTML5-ის დოკუმენტი
                
                ვნახოთ მეორე, ცოტა უფრო რთული მაგალითი:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-areas: "header header header header header"
                                                     ". . . . ."
                                                     "menu . content . sidebar"
                                                     ". . . . ."
                                                     "footer footer footer footer footer";
                                grid-template-columns: 130px 5px 1fr 5px 130px;
                                grid-template-rows: 90px 5px 1fr 5px 90px;
                            }
                            .header { grid-area: header; background-color: #bbb; }
                            .menu { grid-area: menu; background-color: #ccc; }
                            .sidebar { grid-area: sidebar; background-color: #ccc; }
                            .content { grid-area: content; background-color: #eee; }
                            .footer { grid-area: footer; background-color: #bbb; }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="header"></div>
                            <div class="content"></div>
                            <div class="menu"></div>
                            <div class="sidebar"></div>
                            <div class="footer"></div>
                        </div>
                    </body>
                </html>
                 
                
                ახლა გრიდი შეიცავს 5 სვეტს და 5 სტრიქონს, ანუ სულ 25 უჯრას, რომლებშიც განლაგებულია 5 არე: header, menu, sidebar, content და footer.
                
                თვისება grid-template-areas განსაზღვრავს, თუ როგორაა განაწილებული ეს არეები უჯრების მიხედვით. მაგალითდ, პირველი სტრიქონი "header header header header header" მიუთითებს, რომ გრიდის პირველი სტრიქონის ხუთივე უჯრას იკავებს header ელემენტი. მეორე სტრიქონის, რომლის სიმაღლე 5 პიქსელია, განსაზღვრა განსხვავდება ჩვეულებრივისგან: ". . . . .".  წერტილი ნიშნავს, რომ ეს უჯრა არ ეკუთვნის არცერთ არეს და ცარიელია. თუ გვინდა 5 შეუვსებელი უჯრის განსაზღვრა, უნდა დავსვათ 5 წერტილი მათ შორის ადგილის გამოტოვებით. შედეგად ჩვენ მივიღებთ ხუთ არეს, რომელთა შორის ცარიელი სივრცეა:`
            
            },
             {
             title:"გვერდის მაკეტი Grid Layout-ის მეშვეობით",
              data:`შევქმნათ სტანდარტული ადაპტირებული ვებგვერდის მაკეტი Grid Layout-ის მეშვეობით, რომელსაც ექნება ქუდი (header), დაბოლოება (footer), ნავიგაციის პანელი (menu), ძირითადი ნაწილი (content) და გვერდითა პანელი (sidebar): 

              <!DOCTYPE html>
              <html>
                  <head>
                      <meta charset="utf-8">
                      <meta name="viewport" content="width=device-width" />
                      <title>Grid Layout CSS3-ში</title>
                      <style>
                          *{
                              box-sizing: border-box;
                          }
                          html, body{
                              margin:0;
                              padding:0;
                          }
                          .grid-container {
                              height:100vh;
                              display: grid;
                              grid-template-areas: "header"
                                                   "."
                                                   "menu"
                                                   "."
                                                   "content"
                                                   "."
                                                   "sidebar"
                                                   "."
                                                   "footer";
                              grid-template-columns: 1fr;
                              grid-template-rows: 80px 5px 80px 5px 1fr 5px 80px 5px 80px;
                          }
                          .header { grid-area: header; background-color: #bbb; }
                          .menu { grid-area: menu; background-color: #ccc; }
                          .sidebar { grid-area: sidebar; background-color: #ccc; }
                          .content { grid-area: content; background-color: #eee; }
                          .footer { grid-area: footer; background-color: #bbb; }
                          h3{
                              text-align:center;
                          }
                          @media screen and (min-width: 468px) {
                              
                              .grid-container {
                                  height:100vh;
                                  display: grid;
                                  grid-template-areas: "header header header header header"
                                                       ". . . . ."
                                                       "menu . content . sidebar"
                                                       ". . . . ."
                                                       "footer footer footer footer footer";
                                  grid-template-columns: 130px 5px 1fr 5px 130px;
                                  grid-template-rows: 90px 5px 1fr 5px 90px;
                              }
                          }
                      </style>
                  </head>
                  <body>
                      <div class="grid-container">
                          <div class="header"><h3>Header</h3></div>
                          <div class="content"><h3>Content</h3></div>
                          <div class="menu"><h3>Menu</h3></div>
                          <div class="sidebar"><h3>Sidebar</h3></div>
                          <div class="footer"><h3>Footer</h3></div>
                      </div>
                  </body>
              </html>
              აქ გამოიყენება წინა თემაში განხილული გრიდის არეები, რაც მეტად მოხერხებულია ვებგვერდის სემანტიკური მაკეტის შესაქმნელად.
              
              რადგანაც ვებგვერდი შეიძლება დათვალიერებული იყოს მობილური მოწყობილობის ეკრანზე, რომელსაც მცირე სიგანე გააჩნია, ამიტომ გრიდის არეები განისაზღვრება ორნაირად: 468 პიქსელის და მეტი სიგანის მქონე ეკრანებისთვის ელემენტები განლაგებულია ხუთ სვეტში, ხოლო ნაკლები სიგანის მქონე მოწყობილობებისთვის (მობილური მოწყობილობებისთვის) - ერთ სვეტში. შედეგად მობილურში გვერდი გამოიყურება შემდეგნაირად`
              },
                          
            ]
        }
    ]
},

javascript:{
    chapters:[
        {
            title:"თავი 1. შესავალი Javascript-ში",
            content:[
                {
                    title:"რას წარმოადგენს Javascript",
                    data:`დღეისათვის ვებსაიტების სამყაროს წარმოდგენა Javascript-ის გარეშე პრაქტიკულად წარმოუდგენელია. Javascript - ეს არის ის, რაც აცოცხლებს ვებსაიტებს, რომელთაც ყოველდღიურად ვათვალიერებთ ჩვენს ბრაუზერებში.

                    Javascript შეიქმნა 1995 წელს კომპანია Netscape-ს მიერ, როგორც სცენარების ენა ბრაუზერისთვის Netscape Navigator 2. თავდაპირველად ენას ერქვა LiveScript, მაგრამ იმ დროისათვის პოპულარული სხვა ენის Java LiveScript ტალღაზე გადაერქვა სახელი და დაერქვა JavaScript. ეს მომენტი გარკვეულ გაუგებრობას იწვევს : ზოგიერთ დამწყებ დეველოპერს Java და JavaScript ლამის ერთი ენა ჰგონია. სინამდვილეში ეს ორი აბსოლუტურად განსხვავებული ენაა, რომლებიც ერთმანეთთან მხოლოდ დასახელების მსგავსებითაა დაკავშირებული.
                    
                    თავდაპირველად JavaScript-ს გააჩნდა შეზღუდული შესაძლებლობები. მისი მიზანი იყო, დაემატებინა ვებგვერდისთვის მცირეოდენი ქცევა, რაც გამოიხატებოდა ღილაკზე დაჭერის დამუშავებაში, ასევე შეესრულებინა რაღაც ქმედებები, დაკავშირებული ძირითადად მართვის ელემენტებთან.
                    
                    მაგრამ ვებგარემოს განვითარებამ, HTML5-ის და Nide.js ტექნოლოგიების გამოჩენამ JavaScript-ს გადაუშალა უფრაო ფართო ასპარეზი. დღეს JavaScript ისევ გამოიყენება ვებგვერდების შესაქმნელად, მაგრამ მას ახლა გაცილებით უფრო მეტი შესაძლებლობები გააჩნია.
                    
                    JavaScript  ასევე გამოიყენება, როგორც პროგრამირების ენა სერვერის მხარეზე. თუ ადრე JavaScript გამოიყენებოდა მხოლოდ ვებგვერდებისთვის და სერვერის მხარეს უნდა გამოგვეყენებინა ისეთი ტექნოლოგიები, როგორიცაა PHP, ASP.NET, Ruby, Java, ამჟამად Nide.js-ის დამსახურებით სერვერზე მოსული მიმართვების დამუშავება ასევე შესაძლებელია Node.js-ის მეშვეობით.
                    
                    HTML5-ის სტანდარტების ფართო გავრცელებამ შესაძლებლობა მოგვცა რომ JavaScript გამოყენებული იქნეს ასევე მობილური მოწყობილობებისთვის აპლიკაციების შექმნის პროცესშიც. უფრო მეტიც, Windows 8/8.1/10 ოპერაციული სისტემების გამოჩენასთან ერთად JavaScript -ის გამოყენებით ამ ოპერაციული სისტემებისთვის პროგრამული უზრუნველყოფის შექმნაც გახდა შესაძლებელი. ამდენად, JavaScript -მა გადააბიჯა ვებბრაუზერის საზღვრებს, რაც მისთვის იყო შემოხაზული შექმნის დროს.
                    
                    ამდენად, JavaScript-ის გამოყენებას შეიძლება შევხდეთ პრაქტიკულად ყველგან და მისი გამოყენების სფერო უფრო და უფრო იზრდება.
                    
                    საჭირო ინსტრუმენტები
                    JavaScript-თან სამუშაოდ პირველ რიგში ფდაგვჭირდება რომელიმე ტექსტური რედაქტორი. ამ დროისათვის ერთ-ერთი ტექსტური რედაქტორი, რომელიც ფართოდ გამოიყენება არის Notepad++, მისი ნახვა და გადმოწერა შეიძლება შემდეგი მისამართიდან: http://notepad-plus-plus.org. მისი უპირატესობა მდგომარეობს იმაში რომ არის უფასო და გააჩნია კოდის შემოწმების ინსტრუმენტები.
                    
                    ასევე ფართოდ გამოიყენება კროსპლატფორმული ტექსტური რედაქტორი Visual Studio Code. მას გააჩნია უფრო მეტი შესაძლებლობები, ვიდრე Notepad++-ს და ასევე არის უფასო, გარდა ამისა, მისი გამოყენება შეიძლება როგორც Windows-ში, ასევე MacOS-ში და Linux-ის ბაზაზე არსებულ ოპერაციულ სისტემებში. ამ სახელმძღვანელოს შექმნის პროცესში გამოყენებულ იქნა Visual Studio Code.
                    
                    `
                },
                {
                    title:"პირველი პროგრამა JavaScript-ზე",
                    data:`შევქმნათ პირველი პროგრამა JavaScript-ზე. პირველ რიგში შევქმნათ საქაღალდე და ამ საქაღალდეში ფაილი index.html. ეს ფაილი წარმოადგენს ვებგვერდს.

                    გავხსნათ ეს ფაილი ტექსტურ რედაქტორში და ჩავწეროთ მასში შემდეგი კოდი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        alert('გამარჯობა, სამყაროვ!');
                        </script>   
                    </body>
                    </html>
                    აქ განსაზღვრულია სტანდარტული html ელემენტები. ელემენტში head განსაზღვრულია ვებგვერდის კოდირება utf-8 და გვერდის სათაური (title). body ელემენტში მოცემულია ვებგვერდის ტანი, რომელიც შედგება სათაურის ელემენტისაგან (h2) და ელემენტისაგან script.
                    
                    JavaScript-ის კოდის ჩართვა ვებგვერდზე ხორციელდება ტეგის <script> მეშვეობით. ეს ტეგი უნდა მოთავსდეს ან ვებგვერდის თავში (<head> და </head> ტეგებს შორის), ან ტანში (<body> და </body>). ხშირად ვებგვერდის ჩატვირთვის ოპტიმიზაციისთვის სკრიპტს ათავსებენ </body> დამხურავი ტეგის წინ.
                    
                    ადრე ტეგში <script> აუცილებელი იყო სკრიპტის ტიპის მითითება, რადგან ეს ტეგი სხვა ინსტრუქციების ჩატვირთვისთვისაც გამოიყენება. ზოგჯერ ახლაც შეიძლება ვებგვერდებზე შეგვხვდეს სკრიპტის ტიპის მითითება:
                    
                    <script type="text/javascript">
                    თუმცა დღეისათვის მიღებულია type ატრიბუტის გამოტოვება, რადგან მიუთითებლობისას ბრაუზერი თვლის, რომ ეს არის JavaScript-ის კოდი.
                    
                    ჩვენს მიერ გამოყენებული JavaScript-ის კოდი შეიცავს ერთ ინსტრუქციას:
                    
                    alert('გამარჯობა, სამყაროვ!');
                    JavaScript-ის კოდი შეიძლება შეიცავდეს ბევრ ინსტრუქციას და თითოეული მათგანი მთავრდება წერტილმძიმით. ჩვენი ინსტრუქცია იძახებს მეთოდს alert(), რომელსაც გამოაქვს შეტყობინება: 'გამარჯობა, სამყაროვ!'.
                    
                    როცა გავხსნით ვებგვერდს ბრაუზერში, გამოვა შეტყობინება:`
                },
                {
                    title:"JavaScript-ის კოდის შესრულება",
                    data:`როცა ბრაუზერი იღებს ვებგვერდს html-ისა და  JavaScript-ის კოდებით, ის ახდენს მის ინტერპრეტაციას. ინტერპრეტაციის შედეგი სხვადასხვა ელემენტების სახით - ღილაკები, შეყვანის ველები, ბლოკები, გამოისახება ბრაუზერში. ვებგვერდის ინტერპრეტაცია ხდება თანმიმდევრობით ზემოდან ქვემოთ.

                    როცა ბრაუზერი ხედავს JavaScript-ის კოდს, მოქმედებას იწყებს JavaScript-ის ინტერპრეტატორი. სანამ ის არ დაასრულებს მოქმედებას, ვებგვერდის შემდგომი ინტერპრეტაცია ჩერდება. 
                    
                    ვნახოთ შემდეგი მაგალითი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                        <script>
                            alert("სექცია head");
                        </script>
                    </head>
                    <body>
                        <h2>პირველი სათაური</h2>   
                        <script>
                            alert("პირველი სათაური");
                        </script>
                        <h2>მეორე სათაური</h2>
                        <script>
                            alert("მეორე სათაური");
                        </script>
                    </body>
                    </html>
                    აქ არის სამი ჩანართი JavaScript-ის კოდით: ერთი სექცია <head>-ში, და თითო თითოეული სათურის შემდეგ.
                    
                    გავსხნათ ვებგვერდი ბრაუზერში:
                    
                    JavaScript
                    
                    მიუხედავად იმისა, რომ ვებგვერდში არის ორი სათაური, ბრაუზერში ისინი არ ჩანს, რადგან სრულდება ჯავასკრიპტის კოდი <head>-დან. სანამ შეტყობინებას არ დავხურავთ, ვებგვერდის შემდგომი ინტერპრეტაცია შეჩერებულია.
                    
                    შეტყობინების დახურვის შემდეგ ბრაუზერში გამოჩნდება პირველი სათაური და შესრულდება ჯავასკრიპტის შემდეგი კოდი, რომელიც გამოიტანს შეტყობინებას და ვებგვერდის ინტერპრეტაცია ისევ შეჩერდება შეტყობინების დახურვამდე:
                    
                    JavaScript
                    
                    შეტყობინების დახურვის შემდეგ გამოჩნდება მეორე სათაური და შეჩერდება მესამე ჯავასკრიპტის კოდზე:
                    
                    JavaScript
                    
                    მესამე შეტყობინების შემდეგ ბრაუზერი დაასრულებს ვებგვერდის ინტერპრეტაციას და ჩატვირთვა დასრულდება. ეს მომენტი მნიშვნელოვანიამ რადგან მოქმედებს ვებგვერდის წარმადობაზე, ამიტომ ხშირად ჯავასკრიპტის კოდს ათავსებენ </body> დამხურავი ტეგის წინ, როცა ვებგვერდის ძირითადი ნაწილი უკვე ჩატვირთულია.
                    
                    ჩვენს შემთხვევაში შეგვეძლო დაგვეწერა ასე:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი სათაური</h2>   
                        <h2>მეორე სათაური</h2>
                        <script>
                       alert("სექცია head");
                       alert("პირველი სათაური");
                           alert("მეორე სათაური");
                        </script>
                    </body>
                    </html>
                    javascript-ის სინტაქსის საფუძვლები
                    
                    სანამ გავაგრძელებთ პროგრამირების ენა javascript-ის შესწავლას, განვიხილოთ მისი სინტაქსის რამდენიმე ძირითადი მომენტი.
                    
                    javascript-ის კოდი შედგება ცალკეული ინსტრუქციებისაგან, რომლების ბოლოვდება წერტილმძიმით:
                    
                    alert("გამოსახულების გამოთვლა"); var a = 5 + 8; alert(a);
                    თუმცა თანამედროვე ბრაუზერების უმრავლესობას შეუძლია ჯავასკრიპტის ინსტრუქციების შესრულება იმ შემთხვევაში, თუ ისინი მოთავსებულია ცალ-ცალკე სტრიქონებზე წერტილმძიმის გარეშე:
                    
                    alert("გამოსახულების გამოთვლა")
                    var a = 5 + 8 
                    alert(a)
                    თუმცა კოდის გარჩევადობის ასამაღლებლად და შეცდომების თავიდან ასაცილებლად უმჯობესია თითოეული ინსტრუქცია მოთავსდეს ცალკე სტრიქონზე და დასრულდეს წერტილმძიმით:
                    
                    alert("გამოსახულების გამოთვლა");
                    var a = 5 + 8;
                    alert(a);
                    ჯავასკრიპტის კოდში შესაძლებელია კომენტარების გამოყენება. კომენტარს ინტერპრეტატორი არანაირად არ ითვალისწინებს და იგი არანაირ გავლენას არ ახდენს პროგრამის მუშაობაზე. ის განკუთვნილია კოდში ორიენტაციისთვის, იმის მისათითებლად, თუ რას აკეთებს მისი ესა თუ ის ნაწილი.
                    
                    კომენტარი შეიძლება იყოს ერთსტრიქონიანი, ამისთვის გამოიყენება ორმაგი სლეში:
                    
                    //შეტყობინების გამოტანა
                    alert("გამოსახულების გამოთვლა");
                    //არითმეტიკული ოპერაცია
                    var a = 5 + 8;
                    alert(a);
                    გარდა ერთსტრიქონიანისა, გამოიყენება მრავალსტრიქონიანი კომენტარებიც. ამისთვის გამოიყენება სიმბოლოები: /* კომენტარის ტექსტი */ . მაგალითად:
                    
                    /* შეტყობინების გამოტანა და
                        არითმეტიკული ოპერაცია */
                    alert("გამოსახულების გამოთვლა");
                    var a = 5 + 8;
                    alert(a);`
                    
                },
                {
                    title:"გარე ფაილის ჩართვა",
                    data:`ვებგვერდზე JavaScript-ის ჩართვის კიდევ ერთი საშუალებაა JavaScript-ის კოდის გატანა გარე ფაილში და ამ ფაილის ჩართვა ვებგვერდზე ტეგით <script>.

                    index.html ფაილთან იგივე საქაღალდეში შევქმნათ საქაღალდე js. იგი იქნება განკუთვნილი ჯავასკრიპტის ფაილების შესანახად. ამ საქაღალდის შიგნით შვქმნათ ფაილი myscript.js. ჯავასკრიპტის ფაილებს უნდა ჰქონდეს გაფართოება .js. გავხსნათ შექმნილი ფაილი და ჩავწეროთ შიგნით შემდეგი კოდი:
                    
                    var date = new Date(); // მიმდინარე თარიღის მიღება
                    var time = date.getHours(); // მიმდინარე დრო საათებში
                    if(time < 13) // შევადაროთ რიცხვს 13
                        alert('დილა მშვიდობისა!'); // მიმდინარე დრო ნაკლებია 13 საათზე
                    else
                        alert('საღამო მშვიდობისა!'); // მიმდინარე დრო მეტია 13 საათზე
                    ახლა ჩავრთოთ ჯავასკრიპტის ფაილი ვებგვერდზე:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script src="js/myscript.js"></script>
                    </body>
                    </html>
                     
                    
                    ვებგვერდზე ჯავასკრიპტის ფაილის ჩასართავად  გამოიყენება ტეგი <script>, რომელსაც აქვს ატრიბუტი src. ეს ატრიბუტი უჩვენებს ფაილის მისამართს. ვებგვერდის გაშვებისას გამოვა შეტყობინება:
                    
                    JavaScript
                    
                    ჯავასკრიპტის კოდის გარე ფაილში გატანას აქვს მთელი რიგი უპირატესობები:
                    
                    ერთი და იგივე კოდის გამოყენება შეგვიძლია სხვადასხვა ვებგვერდზე;
                    ბრაუზერი ახდენს ჯავასკრიპტის გარე ფაილების კეშირებას, შესაბამისად მომდევნო მიმართვებისას არ უწევს სერვერზე მიმართვა, რითაც მცირდება სერვერზე დატვირთვა და ბრაუზერს უწევს ნაკლები ინფორმაციის ჩამოტვირთვა;
                    ვებგვერდის კოდი არის უფრო "სუფთა". ის შეიცავს მხოლოდ html-კოდს, ხოლო ჯავასკრიპტის კოდი ინახება ცალკე ფაილებში. ამავდროულად შეიძლება html-კოდს და JavaScript-ის კოდზე მუშაობა დავაცალკევოთ.
                    ამიტომაც, ჯავასკრიპტის კოდისთვის ძირითადად გამოიყენება გარე ფაილები.
                    
                     `
                    
                },
                {
                    title:"ბრაუზერის კონსოლი. console.log და document.write",
                    data:`ჯავასკრიპტთან მუშაობისას შეუცვლელ ინსტრუმენტს წარმოადგენს ბრაუზერის კონსოლი, რომელიც გვეხმარება პროგრამის დახვეწის პროცესში. თანამედროვე ბრაუზერების უმეტესობას გააჩნია ასეთი კონსოლი. მაგალითად, Google Chrome-ში უნდა გავხსნათ More tools=>Developer tools და გახსნილ ჩანართში ავირჩიოთ Console:

 

                    JavaScript
                    
                    JavaScript
                    
                    კონსოლში შეგვიძლია პირდაპირ შევიყვანოთ ჯავასკრიპტის კოდი და Enter კლავიშზე დაჭერით კოდი შესრულდება. მაგალითად, ჩავწეროთ კონსოლში შემდეგი კოდი:
                    
                    alert("გამარჯობა, სამყაროვ");
                    Enter-ზე დაჭერის შემდეგ ჯავასკრიპტის კოდი შესრულდება და გამოვა შეტყობინება:
                    
                    JavaScript
                    
                    ბრაუზერის კონსოლში სხვადასხვა ინფორმაციის გამოსატანად გამოიყენება ფუნქცია console.log(). მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        var a = 5 + 8;
                        console.log("ოპერაციის შედეგი:");
                        console.log(a);
                        </script>
                    </body>
                    </html>
                    ჯავასკრიპტის კოდში საკვანძო სიტყვის var მეშვეობით გამოცხადებულია ცვლადი a, რომელსაც ენიჭება მნიშვნელობად 5-სა და 8-ის ჯამი: var a=5+8. console.log() ფუნქციის მეშვეობით გამოგვაქვს a-ს მნიშვნელობა ეკრანზე. ვებგვერდის გაშვებისას ბრაუზერის კონსოლში ვხედავთ კოდის შესრულების შედეგს:
                    
                    JavaScript
                    
                    მეთოდი document.write
                    
                    საწყის ეტაპზე ასევე სასარგებლოა მეთოდის document.write გამოყენება, რომელიც წერს ინფორმაციას ვებგვერდზე. წინა მაგალითში შევცვალოთ ფუნქცია console.log() ფუნქციით document.write():
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        var a = 5 + 8;
                        document.write("ოპერაციის შედეგი:");
                        document.write(a);
                        </script>
                    </body>
                    </html>
                    ამ შემთხვევაში ინფორმაცია გამოდის უშუალოდ ვებგვერდზე.`
                    
                }
            ]
        },
        {
            title:"თავი 2. JavaScript-ის საფუძვლები",
            content:[
                {
                    title:"ცვლადები",
                    data:`პროგრამაში მონაცემების შესანახად გამოიყენება ცვლადები. ცვლადები გამოიყენება რაიმე დროებითი ინფორმაციის შესანახად ან ისეთი მონაცემებისთვის, რომლებიც პროგრამის შესრულებისას შეიძლება შეიცვალონ. ცვლადის შესაქმნელად (გამოსაცხადებლად) გამოიყენება საკვანძო სიტყვა var. მაგალითად, გამოვაცხადოთ ცვლადი myIncome:

                    var myIncome;
                    ყველა ცვლადს გააჩნია სახელი, რომელიც წარმოადგენს ალფავიტურ-ციფრული სიმბოლოების, გახაზვის სიმბოლოს (_) და დოლარის ნიშნის ($) თავისუფალ კომბინაციას, ამასთან ცვლადის სახელი არ შეიძლება იწყებოდეს ციფრით. ყველა სხვა სიმბოლოს გამოყენება აკრძალულია.
                    
                    მაგალითდ, ცვლადების დასაშვები სახელებია:
                    
                    $commision
                    someVariable
                    product_Store
                    income2
                    myIncome_from_deposit
                    ხოლო შემდეგი სახელები არასწორია:
                    
                    222lol
                    @someVariable
                    my%percent
                    ასევე არ შეიძლება ცვლადს მივცეთ ისეთი სახელი, რომელიც ემთხვევა დარეზერვებულ სიტყვებს. ჯავასკრიპტში არც ისე ბევრი დარეზერვებული სიტყვაა, ამიტომ ამ წესის დაცვა რთული არაა. მაგალითად, შემდეგი ცვლადის სახელი არასწორია, ვინაიდან სიტყვა for დარეზერვებული სიტყვაა:
                    
                    var for;
                    ჯავასკრიპტში დარეზერვებულია შემდეგი სიტყვები:
                    
                    abstract, boolean, break, byte, case, catch, char, class, const, continue, debugger, default, delete, do, double, else, enum, export, extends, false, final, finally, float, for, function, goto, if, implements, import, in, instanceof, int, inteface, long, native, new, null, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, true, try, typeof, var, volatile, void, while, with.
                    
                    უნდა გავითვალისწინოთ, რომ ჯავასკრიპტის კოდი მგრძნობიარეა რეგისტრის მიმართ, შესაბამისად ქვემოთ მოცემულ მაგალითში გამოცხადებულია ორი სხვადასხვა ცვლადი:
                    
                    var myIncome;
                    var MyIncome;
                    შეგვიძლია ერთდროულად რამდენიმე ცვლადის გამოცხადება, ამ შემთხვევაში ისინი ერთმანეთისგან გამოიყოფა მძიმით:
                    
                    var myIncome, procent, sum;
                    ტოლობის ნიშნის მეშვეობით (რომელსაც მეორენაირად მინიჭების ოპერატორს ეძახიან), შეიძლება ცვლადს მივანიჭოთ რამე მნიშვნელობა:
                    
                    var income = 300;
                    ცვლადისთვის საწყისი მნიშვნელობის მინიჭების პროცესს ინიციალიზაცია ეწოდება.
                    
                    პროგრამის შესრულების პროცესში შესაძლებელია ცვლადის მნიშვნელობის შეცვლა:
                    
                    var income = 300;
                    income = 400;`
                },
                {
                  title:"მნიშვნელობათა ტიპები",
                  data:`ჯავასკრიპტში გამოყენებულ ნებისმიერ მონაცემს გააჩნია განსაზღვრული ტიპი. ჯავასკრიპტში გვაქვს 5 პრიმიტიული მონაცემთა ტიპი:

                  string: წარმოადგენს სტრიქონს (ტექსტს)
                  number: წარმოადგენს რიცხვით მნიშვნელობას
                  Boolean: წარმოადგენს ლოგიკურ მნიშვნელობას true ან false
                  undefined: მიუთითებს, რომ მნიშვნელობა არ აქვს მინიჭებული
                  null: მიუთითებს განუსაზღვრელ მნიშვნელობას
                  ნებისმიერი სხვა მონაცემი, რომელიც არ განეკუთვნება ჩამოთვლილ ტიპებს, მიეკუთვნება ტიპს object.
                  
                  რიცხვითი მონაცემები
                  
                  JavaScript-ში რიცხვებს შეიძლება ჰქონდეთ ორი ფორმა:
                  
                  მთელი რიცხვები, მაგალითქად, 35. შეგვიძლია გამოვიყენოთ როგორც დადებითი, ასევე უარყოფითი რიცხვები. გამოყენებული რიცხვების დიაპაზონია -253 -დან 253-მდე.
                  ათწილადები (რიცხვები მცურავი წერტილით), მაგალითად 3.5575. აქაც შეგვიძლია გამოვიყენოთ როგორც დადებითი, ასევე უარყოფითი რიცხვები იგივე დიაპაზონსი:  -253 -დან 253-მდე.
                  მაგალითად:
                  
                  var x = 45;
                  var y = 23.897;
                  მთელი და წილადი ნაწილის გამოსაყოფად, ისევე როგორც პროგრამირების სხვა ენებში, JavaScript-შიც გამოიყენება წერტილი.
                  
                  სტრიქონები
                  
                  ტიპი string წარმოადგენს სტრიქონს, ანუ ისეთ მონაცემებს, რომლებიც იწერება ბრჭყალებში. მაგალითად, "გამარჯობა, სამყაროვ". ამასთან, შეგვიძლია გამოვიყენოთ როგორც ორმაგი, ასევე ერთმაგი ბრჭყალები: "გამარჯობა, სამყაროვ" და 'გამარჯობა, სამყაროვ'. ერთადერთი, რაც უნდა გავითვალისწინოთ ისაა, რომ გამხსნელი და დამხურავი ბრჭყალები უნდა იყოს ერთნაირი. 
                  
                  თუ სტრიქონის შიგნით გვხვდება ბრჭყალები, საჭიროა მათი ეკრანირება. მაგალითად, ტექსტი "ბიურო "რქები და ჩლიქები"" უნდა ჩაიწეროს შემდეგი სახით:
                  
                  var companyName =  "ბიურო \"რქები და ჩლიქები\"";
                  ასევე, სტრიქონის შიგნით შეიძლება მეორე ტიპის ბრჭყალების გამოყენება:
                  
                  var companyName1 = "ბიურო 'რქები და ჩლიქები'";
                  var companyName2 = 'ბიურო "რქები და ჩლიქები"';
                  ტიპი Boolean
                  
                  ტიპი Boolean წარმოადგენს ლოგიკურ ტიპს. მას აქვს ორი მნიშვნელობა true(ჭეშმარიტია) და  false(მცდარია):
                  
                  var isAlive = true;
                  var isDead = false;
                  null და undefined
                  
                  ხშირად null-ს და undefined-ს ურევენ ერთმანეთში. როცა ცვლადი მხოლოდ გამოცხადებულია და მასზე არაა მინიჭებული საწყისი მნიშვნელობა, ის წარმოადგენს ტიპს undefined:
                  
                  var isAlive;
                  console.log(isAlive); // კონსოლში გამოიტანს undefined-ს
                  null მნიშვნელობის მინიჭება ნიშნავს, რომ ცვლადს აქვს რაღაც განუსაზღვრელი (არა რიცხვი, არა სტრიქონი, არა ლოგიკური ტიპი), მაგრამ მაინც მნიშვნელობა, განსხვავებით undefined-საგან, როცა ცვლადს მნიშვნელობა არა აქვს:
                  
                  var isAlive;
                  console.log(isAlive); // undefined
                  isAlive = null;
                  console.log(isAlive); // null
                  isAlive = undefined;  // ისევ მივანიჭოთ ტიპი undefined
                  console.log(isAlive); // undefined
                  სუსტი ტიპიზაცია
                  
                  JavaScript წარმოადგენს პროგრამირების ენას სუსტი ტიპიზაციით. ეს იმას ნიშნავს, რომ ცვლადმა შეიძლება დინამიურად შეიცვალოს ტიპი. მაგალითად:
                  
                  var xNumber;  // ტიპი undefined
                  console.log(xNumber);
                  xNumber = 45;  // ტიპი number
                  console.log(xNumber);
                  xNumber = "45"; // ტიპი string
                  console.log(xNumber);
                  მიუხედავად იმისა, რომ მე-2 და მე-3 შემთხვევაში კონსოლში გამოიტანს 45-ს, მე-2 შემთხვევაში ეს იქნება რიცხვი 45, ხოლო მე-3 შემთხვევაში - სტრიქონი "45". ამას ძალიან დიდი მნიშვნელობა აქვს, რადგან ამაზეა დამოკიდებული ცვლადის ქცევა პროგრამაში:
                  
                  var xNumber = 45;  // ტიპი number
                  var yNumber = xNumber + 5;
                  console.log(yNumber); // კონსოლში გამოიტანს 50-ს
                      
                  xNumber = "45"; // ტიპი string
                  var zNumber = xNumber + 5
                  console.log(zNumber); //კონსოლში გამოიტანს 455-ს
                  პირველ შემთხვევაში ცვლად xNumber-ს აქვს რიცხვითი მნიშვნელობა, შეკრების ოპერაციის (+) შედეგად ვღებულობთ ჯამს (45+5=50), რაც გამოდის კონსოლში.
                  
                  მეორე შემთხვევაში ცვლად xNumber-ს აქვს სტრიქონული მნიშვნელობა. რადგან სტრიქონზე რიცხვის მიმატება შეუძლებელია, რიცხვი 5 გადაიქცევა სტრიქონად და მოხდება ორის ტრიქონის გაერთიანება ("45"+"5"="455").
                  
                  ოპერატორი typeof
                  
                  typeof ოპერატორის მეშვეობით შესაძლებელია ცვლადის ტიპის მიღება:
                  
                  var name = "Tom";
                  console.log(typeof name); // string
                   
                  var income = 45.8;
                  console.log(typeof income); // number
                      
                  var isEnabled = true;
                  console.log(typeof isEnabled); // boolean
                   
                  var undefVariable;
                  console.log(typeof undefVariable); // undefined`
              },
              {
                  title:"ოპერაციები ცვლადებზე",
                  data:`მათმატიკური ოპერაციები

                  JavaScript-ს გააჩნია ყველა საბაზისო მათემატიკური ოპერაციის მხარდაჭერა:
                  
                  შეკრება:
                  
                  var x = 10;
                  var y = x + 50;
                  გამოკლება:
                  
                  var x = 10;
                  var y = x - 50;
                  გამრავლება:
                  
                  var x = 10;
                  var y = x * 50;
                  გაყოფა:
                  
                  var x = 10;
                  var y = x / 50;
                  ნაშთი გაყოფისას (ოპერატორი %):
                  
                  var x = 41;
                  var y = 7;
                  var z = x % y;
                  console.log(z); // 6
                  აბრუნებს 6-ს, რადგან 41 ზე ნაკლები ან ტოლი უდიდესი რიცხვი, რომელიც იყოფა 5-ზე არის 35, 41-35=6.
                  
                  ინკრემენტი:
                  
                  var x = 5;
                  x++; // x = 6
                  ინკრემენტის ოპერატორი ზრდის ცვლადს 1 ერთეულით. არსებობს პრეფიქსული ინკრემენტი, რომელიც ჯერ ზრდის ცვლადს და მერე აბრუნებს მის მნიშვნელობას, და პოსტფიქსური ინკრემენტი, რომელიც ჯერ მნიშვნელობას აბრუნებს და მერე ცვლის ცვლადს:
                  
                  // პრეფიქსული ინკრემენტი
                  var x = 5;
                  var z = ++x;
                  console.log(x); // 6
                  console.log(z); // 6
                      
                  // პოსტფიქსური ინკრემენტი
                  var a = 5;
                  var b = a++;
                  console.log(a); // 6
                  console.log(b); // 5
                  პოსტფიქსური ინკრემენტი შემდეგი ოპერაციის ანალოგიურია:
                  
                  a = a + 1; // a++
                  დეკრემენტი
                  
                  დეკრემენტი  ამცირებს ცვლადის მნიშვნელობას 1 ერთეულით. ინკრემენტის ანალოგიურად, არსებობს პრეფიქსული და პოსტფიქსური დეკრემენტი:
                  
                  // პრეფიქსული დეკრემენტი
                  var x = 5;
                  var z = --x;
                  console.log(x); // 4
                  console.log(z); // 4
                      
                  // პოსტფიქსური დეკრემენტი
                  var a = 5;
                  var b = a--;
                  console.log(a); // 4
                  console.log(b); // 5
                  როგორც მიღბულია მათემატიკაში, ყველა ოპერაცია სრულდება მარცხნიდან მარჯვნივ და განსხვავდება პრიორიტეტით: ჯერ სრულდება ინკრემენტი და დეკრემენტი, შემდეგ გამრავლება და გაყოფა, შემდეგ მიმატება და გამოკლება. ოპერაციების თანმიმდევრობის შესაცვლელად გამოიყენება ფრჩხილები:
                  
                  var x = 10;
                  var y = 5 + (6 - 2) * --x;
                  console.log(y); //41
                  მინიჭების ოპერაციები
                  
                  = : ანიჭებს ცვლადს გარკვეულ მნიშვნელობას:
                  var x = 10;
                  += : შეკრება მნიშვნელობის შემდგომი მინიჭებით:
                   
                  
                  var a = 23;
                  a += 5; // იგივეა რაც a = a + 5
                  console.log(a); // 28
                   
                  
                  += : გამოკლება მნიშვნელობის შემდგომი მინიჭებით:
                  var a = 23;
                  a -= 5; // იგივეა რაც a = a - 5
                  console.log(a); // 18
                  *= : გამრავლება მნიშვნელობის შემდგომი მინიჭებით:
                  var a = 20;
                  a *= 5; // იგივეა რაც a = a * 5
                  console.log(a); // 100
                  /= : გაყოფა მნიშვნელობის შემდგომი მინიჭებით:
                  var a = 20;
                  a /= 5; // იგივეა რაც a = a / 5
                  console.log(a); // 4
                  %= : გაყოფის ნაშთი მნიშვნელობის შემდგომი მინიჭებით:
                  var a = 23;
                  a % = 5; // იგივეა რაც a = a % 5
                  console.log(a); // 3
                   
                  
                  შედარების ოპერატორები
                  
                  როგორც წესი, პირობის შესამოწმებლად გამოიყენება შედარების ოპერატორები. ისინი ადარებენ ორ მნიშვნელობას და აბრუნებენ true ან false-ს.:
                  
                  == : ტოლობის ოპერატორი ადარებს ორ მნიშვნელობას და თუ ისინი ტოლია, აბრუნებს true-ს, თუ არა და - false-ს: x == 5.
                  === : იგივეობის ოპერატორი ადარებს ორ მნიშვნელობას და მათ ტიპს, და თუ ისინი ტოლია და ერთი და იგივე ტიპი აქვთ, აბრუნებს true-ს, თუ არა და - false-ს: x === 5.
                  != : ადარებს ორ მნიშვნელობას და თუ ისინი განსხვავდებიან, აბრუნებს true-ს, თუ არა და - false-ს x != 5.
                  !== : ადარებს ორ მნიშვნელობას და მათ ტიპს თუ ისინი განსხვავდებიან მნიშვნელობით ან ტიპით, აბრუნებს true-ს, თუ არა და - false-ს x !== 5.
                  > : ადარებს ორ მნიშვნელობას და თუ პირველი მეტია მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს: x > 5.
                  < : ადარებს ორ მნიშვნელობას და თუ პირველი ნაკლებია მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს: x < 5.
                  >= : ადარებს ორ მნიშვნელობას და თუ პირველი მეტია ან ტოლი მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს: x >= 5.
                  <= : ადარებს ორ მნიშვნელობას და თუ პირველი ნაკლებია ან ტოლი მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს: x <= 5.
                  ყველა ეს ოპერატორი საკმაოდ მარტივია, გარდა ტოლობის და იგივეობის ოპერატორებისა. ისინი ორივე ადარებენ მნიშვნელობას, მაგრამ მეორე მწედველობაში იღებს ასევე მნიშვნელობის ტიპს. მაგალითად:
                  
                  var income = 100;
                  var strIncome = "100";
                  var result1 = income == strIncome;
                  var result2 = income === strIncome;
                  console.log(result1); //true
                  console.log(result2); //false
                  ორივე შემთხვევაში ხდება ორი ცვლადის შედარება, პირველ შემთხვევაში ტოლობის, მეორე შემთხვევაში - იგივეობის ოპერატორით. პირველ შემთხვევაში ვღებულობთ true-ს, რადგან მათი მნიშვნელობები ტოლია, ხოლო მეორე შემთხვევაში false-ს, რადგან მიუხედავად მნიშვნელობების ტოლობისა, მათ გააჩნიათ სხვადასხვა ტიპი (ერთი რიცხვია, მეორე - სტრიქონი).
                  
                  ანალოგიურად მუშაობს უტოლობის ოპერატორები != და !==.
                  
                  ლოგიკური ოპერაციები
                  
                  ლოგიკური ოპერაციები გამოიყენება ორი შედარების ოპერაციის შედეგის გასაერთიანებლად. ჯავასკრიპტში არის შემდეგი შედარების ოპერაციები:
                  
                  &&: აბრუნებს true-ს, თუ შედარების ორივე ოპერაცია აბრუნებს true-ს, წინააღმდეგ შემთხვევაში აბრუნებს false-ს:
                  var income = 100;
                  var percent = 10;
                  var result = income > 50 && percent < 12;
                  console.log(result); //true
                  ||: აბრუნებს true-ს, თუ შედარების ერთ-ერთი ოპერაცია მაინც აბრუნებს true-ს, წინააღმდეგ შემთხვევაში აბრუნებს false-ს:
                  var income = 100;
                  var isDeposit = true;
                  var result = income > 50 || isDeposit == true;
                  console.log(result); //true
                  ! : აბრუნებს true-ს, თუ შედარების ეოპერაცია აბრუნებს false-ს, წინააღმდეგ შემთხვევაშია ბრუნებს false-ს:
                  var income = 100;
                  var result1 = !(income > 50);
                  console.log(result1); // false, რადგანაც income > 50 აბრუნებს true
                   
                  var isDeposit = false;
                  var result2 = !isDeposit;
                  console.log(result2); // true
                  ოპერაციები სტრიქონებზე
                  
                  სტრიქონებს შეუძლიათ გამოიყენონ ოპერატორი + სტრიქონების გასაერთიანებლად. მაგალითად:
                  
                  var name = "ტომ";
                  var surname = "სოიერი"
                  var fullname = name + " " + surname;
                  console.log(fullname); //ტომ სოიერი
                  თუ ერთი გამოსახულება სტრიქონია, ხოლო მეორე რიცხვი, რიცხვი გარდაიქმნება სტრიქონად და მოხდება მათი გაერთიანება:
                  
                  var name = "ტომ";
                  var fullname = name + 256;
                  console.log(fullname); //ტომ256
                  გავაკეთოთ პატარა პროგრმა, რომელიც მოახდენს ცვლადებზე ოპერაციების მუშაობის დემონსტრირებას:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <title>JavaScript</title>
                  </head>
                  <body>
                  <script>
                      var sum = 500; // ანაბრის თანხა
                      var percent = 10;  // პროცენტი ანაბარზე
                      var income = sum * percent / 100;  //შემოსავალი ანაბრის მიხედვით
                      sum = sum + income; // განვსაზღვროთ ახალი თანხა
                      console.log("შემოსავალი ანაბარზე: " + income);
                      console.log("ანაბრის თანხა პირველი წლის შემდეგ: " + sum);
                  </script>
                  </body>
                  </html>`
              },
              {
                  title:"მონაცემების გარდაქმნა",
                  data:`ხშირად ჩნდება საჭიროება, რომ ერთი ტიპის მონაცემები გარდავქმნათ მეორე ტიპში. მაგალითად:

                  var number1 = "46";
                  var number2 = "4";
                  var result = number1 + number2;
                  console.log(result); //464
                  
                  ორივე ცვლადი წარმოადგენს სტრიქონს, უფრო სწორად, რიცხვის სტრიქონულ წარმოდგენას. შეკრების შედეგად ვღებულობთ არა 50-ს, არამედ სტრიქონს 464. ხანდახან რიცხვების სტრიქონულ წარმოდგენაზე საჭიროა რიცხვითი ოპერაციების წარმოება. ასეთ შემთხვევებში იყენებენ გარდაქმნის ოპერაციებს. გამოვიყენოთ ფუნქცია parseInt():
                  
                  var number1 = "46";
                  var number2 = "4";
                  var result = parseInt(number1) + parseInt(number2);
                  console.log(result); // 50
                  სტრიქონების ათწილადად გარდაქმნისთვის გამოიყენება ფუნქცია parseFloat():
                  
                  var number1 = "46.07";
                  var number2 = "4.98";
                  var result = parseFloat(number1) + parseFloat(number2);
                  console.log(result); //51.05
                  სტრიქონს შეიძლება ჰქონდეს შერეული მნიშვნელობა, მაგალითად „123hello“, სადაც ციფრების გარდა სხვა სიმბოლოებიცაა. მეთოდი parseInt() მაინც შეეცდება მოახდინოს გარდაქმნა:
                  
                  var num1 = "123hello";
                  var num2 = parseInt(num1);
                  console.log(num2); // 123
                  თუ მეთოდი ვერ შეძლებს გარდაქმნის შესრულებას ,აბრუნებს მნიშვნელობას NaN (Not a Number), რაც მიუთითებს იმაზე, რომ მოცემული სტრიქონის გარდაქმნა რიცხვად შეუძლებელია.
                  
                  სპეციალური ფუნქციის isNaN() მეშვეობით შეიძლება შემოწმება, წარმოადგენს თუ არა სტრიქონი რიცხვს. თუ სტრიქონი არ წარმოადგენს რიცხვს, ფუნქცია აბრუნებს true-ს, თუ არა და -  false-ს.
                  
                  var num1 = "javascript";
                  var num2 = "22";
                  var result = isNaN(num1);
                  console.log(result); // true - num1 არაა რიცხვი
                      
                  result = isNaN(num2);
                  console.log(result); //  false - num2 - რიცხვია
                  ზემოთ მოცემულ მაგალითებში ჩვენ განვიხილეთ სტრიქონის გარდაქმნა ათობითი სისტემის რიცხვად. თუმცა შესაძლებელია ნებისმიერი სისტემის რიცხვად გარდაქმნა. მიუთითებლობისას რიცხვი გადადის როგორც ათობითი სისტემის რიცხვი, მაგრამ დამატებითი პარამეტრის მეშვეობით შეგვიძლია მივუთითოთ, თუ ათვლის რომელი სისტემით გვინდა სტრიქონის გადაყვანა რიცხვში:
                  
                  var num1 = "110";
                  var num2 = parseInt(num1, 2);
                  console.log(num2); // 6
                  შედეგი იქნება 6, რადგან ორობითი სისტემის ჩანაწერი 110 ნიშნავს ათობითი სისტემის 6-ს.
                  
                  დავწეროთ პატარა პროგრამა, სადაც გამოვიყენებთ ოპერაციებს ცვლადებზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <title>JavaScript</title>
                  </head>
                  <body>
                  <script>
                      var strSum = prompt("შეიყვანეთ ანაბრის თნხა", 1000);
                      var strPercent = prompt("შეიყვანეთ საპროცენტო განაკვეთი", 10);
                      var sum = parseInt(strSum);
                      var procent = parseInt(strPercent);
                      sum = sum + sum * procent / 100;
                      alert("პროცენტების დარიცხვის შემდეგ ანაბრის თანხა იქნება: " + sum);
                  </script>
                  </body>
                  </html>
                  prompt() ფუნქციის მეშვეობით ბრაუზერში გამოდის დიალოგური ფანჯარა, სადაც შესაძლებელია მნიშვნელობის შეყვანა. მეორე არგუმენტი წარმოადგენს მნიშვნელობას მიუთითებლობისას. მაგრამ prompt() ფუნქცია აბრუნებს სტრიქონს, რომელიც უნდა გარდავქმნათ რიცხვად. პროგრამის გაშვების შემდეგ ბრაუზერში გამოვა ფანჯარა:
                  
                  JavaScript
                  
                  JavaScript
                  
                  მონაცემების შემდეგ გამოდის ფანჯარა დათვლილი თანხით.`
              },
              {
                  title:"მასივები",
                  data:`მონაცემთა ნაკრებისთვის გამოიყენება მასივები. მასივის შესაქმნელად გამოიყენება ფუნქცია new Array():

                  var myArray = new Array();
                  არსებობს მასივის ინიციალიზაციის უფრო მოკლე ხერხიც:
                  
                  var myArray = [];
                  მოცემულ შემთხვევაში ჩვენ ვქმნით ცარიელ მასივს. თუმცა შეიძლება დავამატოთ საწყისი მონაცემები:
                  
                  var people = ["Tom", "Alice", "Sam"];
                  console.log(people);
                  ამ შემთხვევაში მასივში myArray იქნება სამი ელემენტი. გრაფიკულად შეიძლება გამოვსახოთ ასე:
                  
                  ინდექსი	ელემენტი
                  0	Tom
                  1	Alice
                  2	Sam
                  მასივის ცალკეულ ელემენტებთან მიმართვისთვის გამოიყენება ინდექსი. ათვლა იწყება ნულიდან, შესაბამისად პირველი ელემენტის ინდექსი არის 0, ხოლო ბოლო ელემენტისა - 2:
                  
                   
                  
                  var people = ["Tom", "Alice", "Sam"];
                  console.log(people[0]); // Tom
                  var person3 = people[2]; // Sam
                  console.log(person3); // Sam
                   
                  
                  თუ მოვინდომებთ მივმართოთ მასივის ელემენტს ინდექსით, რომელიც მასივის ზომაზე (სიგრძეზე) მეტია, მივიღებთ undefined-ს:
                  
                  var people = ["Tom", "Alice", "Sam"];
                  console.log(people[7]); // undefined
                  ინდექსის მეშვეობით ასევე შესაძლებელია ელემენტისთვის მნიშვნელობის მინიჭება:
                  
                   
                  
                  var people = ["Tom", "Alice", "Sam"];
                  console.log(people[0]); // Tom
                  people[0] = "Bob";
                  console.log(people[0]); // Bob
                   
                  
                  ამასთან განსხვავებით პროგრამირების სხვა ენებისგან, როგორიცაა მაგალითად C#, Java, მნიშვნელობა შეიძლება მივანიჭოთ ელემენტს, რომელიც მანამდე არ იყო განსაზღვრული:
                  
                  var people = ["Tom", "Alice", "Sam"];
                  console.log(people[7]); // undefined - მასივში მხოლოდ სამი ელემენტია
                  people[7] = "Bob";
                  console.log(people[7]); // Bob
                   
                  
                   
                  
                  მრავალგანზომილებიანი მასივები
                  
                  მასივი შეიძლება იყოს ერთგანზომილებიანი და მრავალგანზომილებიანი. მრავალგანზომილებიანი მასივის თითოეული ელემენტი წარმოადგენს მასივს. შევქმნათ მრავალგანზომილებიანი მასივი:
                  
                   
                  
                  var numbers1 = [0, 1, 2, 3, 4, 5 ]; // ერთგანზომილებიანი მასივი
                  var numbers2 = [[0, 1, 2], [3, 4, 5] ]; // ორგანზომილებიანი მასივი
                   
                  
                  ვიზუალურად ორივე მასივი შეიძლება გამოვსახოთ შემდეგი სახით:
                  
                  ერთგანზომილებიანი მასივი: 
                  
                  0	1	2	3	4	5
                  მრავალგანზომილებიანიმასივი: 
                  
                  0	1	2
                  3	4	5
                  რადგანაც მასივი numbers2 არის ორგანზომილებიანი, ის წარმოადგენს მარტივ ცხრილს. მისი თითოეული ელემენტი წარმოადგენს მასივს. 
                  
                  განვიხილოთ კიდევ ერთი ორგანზომილებიანი მასივი:
                  
                  var people = [
                      ["Tom", 25, false],
                      ["Bill", 38, true],
                      ["Alice", 21, false]
                  ];
                   
                  console.log(people[0]); // ["Tom", 25, false]
                  console.log(people[1]); // ["Bill", 38, true]
                  people მასივი შეიძლება წარმოვადგინოთ შემდეგი ცხრილის სახით:
                  
                  Tom	25	false
                  Bill	38	true
                  Alice	21	false
                  მასივის ცალკეული ელემენტის მისაღებად ასევე გამოიყენება ინდექსი:
                  
                  var tomInfo = people[0];
                  ელემენტი tomInfo თვითონაც მასივია, მისი ელემენტის მისაღებად ისევ უნდა გამოვიყენოთ ინდექსი:
                  
                   
                  
                  console.log("სახელი: " + people[0][0]); // Tom
                  console.log("ასაკი: " + people[0][1]); // 25
                   
                  
                  ასევე შესაძლებელია ელემენტებისთვის მნიშვნელობების მინიჭებაც:
                  
                  var people = [
                      ["Tom", 25, false],
                      ["Bill", 38, true],
                      ["Alice", 21, false]
                  ];
                  people[0][1] = 56; // მივანიჭოთ ცალკეული მნიშვნელობა
                  console.log(people[0][1]); // 56
                   
                  people[1] = ["Bob", 29, false]; // მივანიჭოთ მასივი
                  console.log(people[1][0]); // Bob
                   
                  
                  მრავალგანზომილებიანი მასივების შექმნისას არა ვართ შემოფარგლული მხოლოდ ორგანზომილებიანი მასივებით. შესაძლებელია მეტი განზომილების მქონე მასივების შექმნაც:
                  
                   
                  
                  var numbers = [];
                  numbers[0] = []; // ახლა numbers -ორგანზომილებიანი მასივია
                  numbers[0][0]=[]; // ახლა numbers - სამგანზომილებიანი მასივია
                  numbers[0][0][0] = 5; // სამგანზომილებიანი მასივის პირველი ელემენტია 5
                  console.log(numbers[0][0][0]);
                   `
              },
              {
                  title:"პირობითი კონსტრუქციები",
                  data:`პირობითი კონსტრუქციები საშუალებას გვაძლევს შევასრულოთ ესა თუ ის მოქმედება პირობიდან გამომდინარე.

                  ოპერატორი if
                  
                  ოპერატორი if ამოწმებს გარკვეულ პირობას და თუ ეს პირობა ჭეშმარიტია, ასრულებს გარკვეულ მოქმედებას. if კონსტრუქციას აქვს შემდეგი სახე:
                  
                  if(პირობა) მოქმედება;
                  მაგალითად:
                  
                  var income = 100;
                  if(income > 50) alert("შემოსავალი მეტია 50-ზე");
                  თუ საჭიროა ერთზე მეტი ინსტრუქციის შესრულება, ეს ინსტრუქციები თავსდება ფიგურული ფრჩხილებით შექმნილ ბლოკში:
                  
                  var income = 100;
                  if(income > 50){ 
                      var message = "შემოსავალი მეტია 50-ზე";
                      alert(message);
                  }
                  პირობა შეიძლება იყოს რთული:
                  
                  var income = 100;
                  var age = 19;
                  if(income < 150 && age > 18){ 
                      var message = "შემოსავალი მეტია 50-ზე";
                      alert(message);
                  }
                  კონსტრუქცია  if შესაძლებლობას გვაძლევს შევამოწმოთ მნიშვნელობის არსებობა:
                  
                  var myVar = 89;
                  if(myVar){
                      // მოქმედება
                  }
                  თუ ცვლადს myVar აქვს მნიშვნელობა, ბრუნდება true და სრულდება მოქმედება.
                  
                  ხშირად მნიშვნელობის არსებობა მოწმდება მეორენაირად - ამოწმებენ ცვლადის ტიპს, არის თუ არა undefined:
                  
                  if (typeof myVar != "undefined") {
                      // მოქმედება
                  }
                  if კონსტრუქციაში შესაძლებელია გამოვიყენოთ ბლოკი else. ეს ბლოკი შეიცავს ინსტრუქციებს, რომლებიც სრულდება იმ შემთხვევაში, როცა პირობის შემოწმებისას ბრუნდება false:
                  
                  var age = 17;
                  if(age >= 18){ 
                      alert("თქვენ დაშვებული ხართ დაკრედიტების პროგრამაში");
                  }
                  else{
                      alert("თქვენ არ შეგიძლიათ დაკრედიტების პროგრამაში მონაწილეობა, რადგან თქვენი ასაკი ნაკლებია 18 წელზე");
                  }
                  კოსტრუქციის else if მეშვეობით ჩვენ შეგვიძლია დავამატოთ ალტერნატიული პირობა if ბლოკზე:
                  
                  var income = 300;
                  if(income < 200){ 
                      alert("საშუალოზე დაბალი შემოსავალი");
                  }
                  else if(income >= 200 && income <= 400){    
                      alert("საშუალო შემოსავალი");
                  }
                  else{    
                      alert("საშუალოზე მაღალი შემოსავალი");
                  }
                  მოცემულ შემთხვევაში შესრულდება ბლოკი  else if. საჭიროებისას შეგვიძლია დავამატოთ რამდენიმე ბლოკი  else if სხვადასხვა პირობით:
                  
                  if (income < 200) {
                      alert("საშუალოზე დაბალი შემოსავალი");
                  }
                  else if (income >= 200 && income < 300) {
                      alert("საშუალოზე ოდნავ დაბალი შემოსავალი");
                  }
                  else if (income >= 300 && income < 400) {
                      alert("საშუალო შემოსავალი");
                  }
                  else {
                      alert("საშუალოზე მაღალი შემოსავალი");
                  }
                   
                  
                  true ან false
                  
                  ჯავასკრიპტში ნებისმიერი ცვლადი შეიძლება გამოვიყენოთ პირობად, ამასთან ყველა ცვლადს არ გააჩნია ტიპი boolean. ჩნდება კითხვა, რას დააბრუნებს ესა თუ ის ცვლადი - true თუ false? ყველაფერი დამოკიდებულია ცვლადის ტიპზე:
                  
                  undefined: აბრუნებს false-ს
                  null: აბრუნებს false-ს
                  Boolean: თუ ცვლადის მნიშვნელობაა false, აბრუნებს false-ს. შესაბამისად, თუ ცვლადის მნიშვნელობაა true, აბრუნებს true-ს
                  Number: აბრუნებს false-ს, თუ რიცხვი ტოლია0-ის ან NaN (Not a Number), სხვა ყველა შემთხვევაში ბრუნდება true
                  მაგალითად, შემდეგი პირობა დააბრუნებს false-ს:
                  
                  var x = NaN;
                  if(x){  // false
                   
                  }
                  String: აბრუნებს false-ს, თუ ცვლადის მნიშვნელობა ცარიელი სტრიქონია, ანუ მისი სიგრძე ტოლია 0-ის, სხვა ყველა შემთხვევაში ბრუნდება true
                   
                  
                  var y = ""; // false - ცარიელი სტრიქონი
                  var z = "javascript";   // true - არაცარიელი სტრიქონი
                   
                  
                    Object: ყოველთვის ბრუნდება true
                  var user = {name:"Tom"};    // true
                  var isEnabled = new Boolean(false)  // true
                  var car = {}    // true
                  ბოლოს განვიხილოთ ასეთი შემთხვევა:
                  
                  console.log(undefined==null); // true
                  ბრუნდება true, რადგან შედარების ოპერაცია მიიყვანს შესადარებელ ცვლადებს boolean მნიშვნელობამდე და ვინაიდან ორივე მათგანი არის false, false==false შედარების ოპერაცია დააბრუნებს true-ს.
                  
                  თუ ტოლობას შევცვლით იგივეობით:
                  
                  console.log(undefined===null); // false
                  ახლა უკვე ხდება არა მხოლოდ მნიშვნელობის, არამედ ტიპის შედარებაც, ვინაიდან მათ გააჩნია სხვადასხვა ტიპი, ბრუნდება false.
                  
                  კონსტრუქცია switch..case
                  
                  კონსტრუქცია switch..case წარმოადგენს if..else if..else კონსტრუქციის ალტერნატივას და ასევე შეუძლია ბევრი პირობის შემოწმება:
                  
                  var income = 300;
                  switch(income){ 
                      case 100 :
                          console.log("შემოსავალი 100-ის ტოლია");
                          break;
                      case 200 :
                          console.log("შემოსავალი 200-ის ტოლია");
                          break;
                      case 300 :
                          console.log("შემოსავალი 300-ის ტოლია");
                          break;
                  }
                  საკვანძო სიტყვა swith-ის მერე მოდის შესადარებელი გამოსახულება. ამ გამოსახულების მნიშვნელობა თანმიმდევრულად შედარდება მნიშვნელობებს, რომლებიც case საკვანძო სიტყვის შემდეგ მოდის. თუ თანხვედრა მოხდება, შესრულდება შესაბამისი case ბლოკი. თითოეული case ბლოკი სრულდება ოპერატორით break, რათა არ მოხდეს სხვა ბლოკების შესრულება.
                  
                  თუ გვინდა დავამუშავოთ ის სიტუაციაც, როცა თანხვედრა არ მოიძებნა, შეგვიძლია დავამატოთ ბლოკი default:
                  
                  var income = 300;
                  switch (income) {
                      case 100:
                          console.log("შემოსავალი 100-ის ტოლია");
                          break;
                      case 200:
                          console.log("შემოსავალი 200-ის ტოლია");
                          break;
                      case 300:
                          console.log("შემოსავალი 300-ის ტოლია");
                          break;
                      default:
                          console.log("დაუდგენელი შემოსავალი");
                          break;
                  }
                  ტერნარული ოპერაცია
                  
                  ტერნარული ოპერაცია შედგება სამი ოპერანდისაგან და გააჩნია შემდეგი სახე: [პირველი გამოსახულება - პირობა] ? [მეორე გამოსახულება] : [მესამე გამოსახულება]. პირობიდან გამომდინარე, ტერნარული ოპერაცია აბრუნებს მეორე ან მესამე გამოსახულებას: თუ პირობა ჭეშმარიტია (true), ბრუნდება მეორე გამოსახულება, თუ არა და - მესამე გამოსახულება. მაგალითად:
                  
                  var a = 1;
                  var b = 2;
                  var result = a < b ? a + b : a - b;
                  console.log(result); // 3
                  რადგანაც a ნაკლებია b-ზე, ბრუნდება მეორე გამოსახულების მნიშვნელობა. წინააღმდეგ შემთხვევაში დაბრუნდებოდა მესამე გამოსახულების მნიშვნელობა.`
              },
              {
                  title:"ციკლები",
                  data:`ციკლები საშუალებას იძლევა გარკვეული პირობების მიხედვით შესრულდეს რაღაც მოქმედებები მრავალჯერ. ჯავასკრიპტში გამოიყენება ციკლის შემდეგი სახეები:

                  for
                  for..in
                  while
                  do..while
                  ციკლი for
                  
                  ციკლს for აქვს შემდეგი სახე:
                  
                  for ([მრიცხველის ინიციალიზაცია]; [პირობა]; [მრიცხველის შეცვლა]) {
                      // მოქმედებები
                  }
                  მაგალითად, გამოვიყენოთ ციკლი მასივის ელემენტების გადასარჩევად:
                  
                  var people = ["Tom", "Alice", "Bob", "Sam"];
                  for(var i = 0; i<people.length; i++){    
                      document.write(people[i] + "</br>");
                  }
                  ციკლის პირველი ნაწილი - var i = 0; ახდენს მრიცხველის (ცვლადი i) ინიციალიზაციას. ციკლის დაწყების წინ მისი მნიშვნელობა იქნება 0. მეორე ნაწილი წარმოადგენს პირობას, რომლის შესრულებისას სრულდება ციკლი. მოცემულ შემთხვევაში, ციკლი შესრულდება მანამ, სანამ i-ს მნიშვნელობა არ მიარჭევს მასივის სიგრძეს. მასივის სიგრძეს ვღებულობთ length თვისების მეშვეობით: people.length. ციკლის მესამე ნაწილში ხდება მრიცხველის გაზრდა ერთი ერთეულით.
                  
                  რადგანაც მასივში 4 ელემენტია, ციკლი შესრულდება 4-ჯერ. თითოეული შესრულების შემდეგ მრიცხველის მნიშვნელობა გაიზრდება 1-ით და როცა მიაღწევს 4-ს, ციკლი დამთავრდება. ციკლის თითოეულ შესრულებას იტერაცია ეწოდება. მოცემულ ციკლში გვექნება 4 იტერაცია.
                  
                  people[i] გამოსახულების მეშვეობით ჩვენ ვღებულობთ მასივის ელემენტს ბრაუზერში მისი  შემდგომი გამოტანისთვის. 
                  
                  აუცილებელი არაა მრიცხველი აუცილებლად გავზარდოთ ერთი ერთეულით. შესაძლებელია მასზე სხვა მოქმედებების შესრულება. მაგალითად, შემდეგ მაგალითში ციკლში მრიცხველს საწყის მნიშვნელობად მივანიჭოთ მასივის სიგრძეს მინუს ერთი, ხოლო მრიცხველი ყოველი იტერაციის შემდეგ შევამციროთ 1-ით, სანამ არ გახდება 0-ის ტოლი:
                  
                  var people = ["Tom", "Alice", "Bob", "Sam"];
                  for(var i = people.length - 1; i >= 0; i--){    
                      document.write(people[i] + "</br>");
                  }
                  ამ მაგალითში მასივის ელემენტები გამოვა საწინააღმდეგო თნმიმდევრობით - ბოლო ელემენტიდან პირველამდე.
                  
                  ციკლი for..in
                  
                  ციკლი for..in განკუთვნილია მასივის ელემენტების გადასარჩევად. იგი განისაზღვრება შემდეგნაირად:
                  
                  for (ინდექსი in მასივი) {
                      // მოქმედებები
                  }
                  მაგალითად:
                  
                  var people = ["Tom", "Alice", "Bob", "Sam"];
                  for(var index in people){    
                      document.write(people[index] + "</br>");
                  }
                  ციკლი while
                  
                  ციკლი while სრულდება მანამ, სანამ რაღაც პირობა სრულდება.მას აქვს შემდეგი სახე:
                  
                  while(პირობა){   
                     // მოქმედებები
                  }
                  გამოვიტანოთ ისევ მასივის ელემენტები:
                  
                  var people = ["Tom", "Alice", "Bob", "Sam"];
                  var index = 0;
                  while(index < people.length){    
                      document.write(people[index] + "</br>");
                      index++;
                  }
                  ციკლი შესრულდება მანამ, სანამ ცვლადი index არ გახდება მასივის სიგრძის ტოლი.
                  
                  do..while
                  
                  ციკლში do ჯერ სრულდება რაღაც მოქმედებები და შემდეგ მოწმდება პირობა while და სანამ ეს გამოსახულება ჭეშმარიტია, ციკლი გრძელდება. მაგალითად:
                  
                  var x = 1;
                  do{
                      document.write(x * x + "</br>");
                      x++;
                  }while(x < 10)
                  აქ ციკლი შესრულდება 9-ჯერ, სანამ x არ გახდება 10-ის ტოლი. ამასთან, ციკლი do..while-ის დროს ციკლი ერთხელ მაინც შესრულდება აუცილებლად, თუნდაც პირველივე ჯერზე პირობა while იყოს მცდარი.
                  
                  ოპერატორები continue და break
                  
                  ხანდახან საჭიროა ციკლიდან გამოსვლა მის დასრულებამდე. ამისთვის გამოიყენება ოპერატორი break:
                  
                  var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
                  for (var i = 0; i < array.length; i++)
                  {
                      if (array[i] > 10)
                          break;
                      document.write(array[i] + "</br>");
                  }
                  მოცემულ მაგალითში ციკლი სრულდება მანამ, სანამ არ შეხვდება ელემენტი, რომლის მნიშვნელობა მეტია 10-ზე:
                  
                  JavaScript
                  
                  თუ ჩვენ გვინდა უბრალოდ იტერაციის გამოტოვება და არა ციკლიდან გამოსვლა, უნდა გამოვიყენოთ ოპერატორი continue:
                  
                   
                  
                  var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
                  for (var i = 0; i < array.length; i++)
                  {
                      if (array[i] > 10)
                          continue;
                      document.write(array[i] + "</br>");
                  }
                   
                  
                  ამ შემთხვევაში, მასივის ის ელემენტი, რომლის მნიშვნელობაც მეტია 10-ზე, არ გამოვა ეკრანზე`
              },
              
            ]
        },
        {
            title:"თავი 3. ფუნქციონალური პროგრამირება",
            content:[
                {
                    title:"ფუნქციები",
                    data:`ფუნქცია წარმოადგენს ინსტრუქციების ერთობლიობას, რომლებიც ასრულებენ გარკვეულ მოქმედებას ან ითვლიან გარკვეულ მნიშვნელობას. ფუნქციის სინტაქსს აქვს შემდეგი სახე:

                    function ფუნქციის_სახელი([პარამეტრი [, ...]]) {
                        // ინსტრუქციები
                    }
                    ფუნქციის განსაზღვრა იწყება საკვანძო სიტყვით function, რასაც მოსდევს ფუნქციის სახელი. ფუნქციის დასახელება ექვემდებარება იგივე წესებს, რასაც ცვლადების სახელები. შესაბამისად, ფუნქციის სახელი უნდა შედგებოდეს ასოებისგან, ციფრებისგან და სიმბოლოებისგან "_" და "$". ამასთან, ფუნქციის სახელი არ უნდა იწყებოდეს ციფრით.
                    
                    ფუნქციის სახელის შემდეგ მოდის პარამეტრების ჩამონათვალი. ფუნქციას თუნდაც არ ჰქონდეს პარამეტრი, მაინც უნდა დავსვათ ცარიელი ფრჩხილები. შემდეგ ფიგურულ ფრჩხილებში მოდის ფუნქციის ტანი, რომელიც შეიცავს ინსტრუქციების ერთობლიობას.
                    
                    შევქმნათ უმარტივესი ფუნქცია:
                    
                    function display() {
                        document.write("JavaScript-ის ფუნქციები");
                    }
                    მოცემული ფუნქციის სახელია display. მას არ გააჩნია პარამეტრები და ერთადერთი, რასაც აკეთებს, არის ის, რომ ბრაუზერში წერს სტრიქონს. მაგრამ მხოლოდ ფუნქციის განსაზღვრა საკმარისი არ არის. იმისათვის, რომ ფუნქცია შესრულდეს, საჭიროა ის გამოვიძახოთ:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                    <script>
                    function display(){
                        document.write("JavaScript-ის ფუნქციები");
                    }
                    display();
                    </script>
                    </body>
                    </html>
                    არაა აუცილებელი ფუნქციისთვის სახელის მიცემა - შეიძლება გამოვიყენოთ ანონიმური ფუნქციები:
                    
                    var display = function () {  // ფუნქციის განსაზღვრა   
                        document.write("JavaScript-ის ფუნქციები");
                    }
                    display();
                    პრაქტიკულად, ჩვენ განვსაზღვრეთ ცვლადი display და მივანიჭეთ მას მიმართვა ფუნქციაზე. ხოლო შემდეგ ცვლადის სახელით ხდება ფუნქციის გამოძახება.
                    
                    ასევე შესაძლებელია ცვლადს დინამიურად მივანიჭოთ ფუნქციაზე მიმართვა:
                    
                    function goodMorning() {
                        document.write("დილა მშვიდობისა!");
                    }
                    function goodEvening() {
                        document.write("საღამო მშვიდობისა!");
                    }
                    var message = goodMorning;
                    message(); // დილა მშვიდობისა!
                    message = goodEvening;
                    message(); // საღამო მშვიდობისა!
                    ფუნქციის პარამეტრები
                    
                    ვნახოთ პარამეტრების გადაცემა:
                    
                    function display(x) {  // ფუნქციის განსაზღვრა
                        var z = x * x;
                        document.write(x + " კვადრატში ტოლია " + z);
                    }
                    display(5); // ფუნქციის გამოძახება
                    ფუნქცია ღებულობს ერთ პარამეტრს - x. გამოძახებისას მას გადაეცემა პარამეტრის მნიშვნელობა - 5. 
                    
                    ფუნქციას შეიძლება ჰქონდეს ბევრი პარამეტრი, ამასთან პარამეტრების ნაწილი შეიძლება იყოს არა აუცილებელი:
                    
                    function display(x, y) {
                        if (y === undefined) y = x;
                        var z = x * y;
                        document.write(x + " გამრავლებული " + y + "-ზე უდრის " + z + "<br/>");
                    }
                    display(6); // 36
                    display(6, 4) // 24
                    ამ ფუნქცით თუ მეორე პარამეტრს არ გადავცემთ, იგი პირველი პარამეტრის ტოლი იქნება. 
                    
                    საჭიროებისას, ფუნქციის ყველა პარამეტრი შეიძლება მივიღოთ გლობალურად წვდომადი მასივის - arguments მეშვეობით:
                    
                    function display() {
                        var z = 1;
                        for (var i = 0; i < arguments.length; i++)
                            z *= arguments[i];
                        console.log(z);
                    }
                    display(6); // 6
                    display(6, 4) // 24
                    display(6, 4, 5) // 120
                    ამასთან, არა აქვს მნიშვნელობა, რომ ფუნქციის განსაზღვრისას საერთოდ არ მიგვითითებია პარამეტრები, მათი მიღება მაინც შესაძლებელია გლობალური მასივის - arguments მეშვეობით. 
                    
                    ფუნქციის შედეგი
                    
                    ფუნქცია შეიძლება აბრუნებდეს შედეგს. ამისთვის გამოიყენება ოპერატორი return:
                    
                    var y = 5;
                    var z = square(y);
                    document.write(y + " კვადრატში უდრის " + z);
                    function square(x) {
                        return x * x;
                    }
                    return ოპერატორის შემდეგ მოდის მნიშვნელობა, რაც უნდა დააბრუნოს ფუნქციამ. მოცემულ შემთხვევაში x-ის კვადრატი.
                    
                    ფუნქციის მიერ დაბრუნებული მნიშვნელობა შეიძლება მივანიჭოთ რამე ცვლადს:
                    
                    var z = square(y);
                    ფუნქცია პარამეტრად
                    
                    ფუნქცია შეიძლება გამოვიყენოთ სხვა ფუნქციის პარამეტრად:
                    
                    function display(x, func) {
                        var message = func(x);
                        document.write(message);
                    }
                    function welcomeMessage(time) {
                        if (time < 12)
                            return "დილა მშვიდობისა!";
                        else
                            return "დღე მშვიდობისა!";
                    }
                    display(13, welcomeMessage);
                    ფუნქცია display ღებულობს ორ პარამეტრს: x და func. func წარმოადგენს ფუნქციას, ამასთან display ფუნქციის განსაზღვრის დროს არა აქვს მნიშვნელობა, თუ რა ფუნქციაა ეს. ერთადერთი, რაც ცნობილია,ისაა, რომ ის იღებს პარამეტრს და აბრუნებს მნიშვნელობას, რომელიც შემდეგ გამოისახება ბრაუზერში.
                    
                    კოდში ასევე განსაზღვრულია ფუნქცია welcomeMessage., რომელიც პარამეტრად ღებულობს მიმდინარე საათს და მისი მნიშვნელობიდან გამომდინარე აბრუნებს შეტყობინებას. ფუნქცია display-ს გამოძახებისას იგი მეორე პარამეტრად იღებს ფუნქციას welcomeMessage.`
                },
                {
                  title:"ცვლადების ხედვის არე",
                  data:`ჯავასკრიპტში ყველა პარამეტრს აქვს გარკვეული ხედვის არე, რომლის ფარგლებშიც ისინი მოქმედებენ.

                  გლობალური ცვლადები
                  
                  ყველა ცვლადი, რომელიც გამოცხადებულია ფუნქციის გარეთ, არის გლობალური:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <script>
                          var x = 5;
                          function displaySquare() {
                              var z = x * x;
                              console.log(z);
                          }
                      </script>
                  </body>
                  </html>
                  აქ ცვლადი x არის გლობალური, მასზე მიმართვა შეიძლება პროგრამის ნებისმიერი ადგილიდან. ხოლო ცვლადი z არაა გლობალური, რადგანაც გამოცხადებულია ფუნქციის შიგნით.
                  
                  ლოკალური ცვლადები
                  
                  ცვლადი, რომელიც გამოცხადებულია ფუნქციის შიგნით, წარმოადგენს ლოკალურ ცვლადს:
                  
                  function displaySquare() {
                      var z = 10;
                      console.log(z);
                  }
                  ცვლადი z ლოკალურია და ის არსებობს მხოლოდ ფუნქციის შიგნით. ფუნქციის გარეთ მისი გამოყენება არ შეიძლება:
                  
                  function displaySquare() {
                      var z = 10;
                      console.log(z);
                  }
                  console.log(z);  // შეცდომაა, რადგან z არ არსებობს
                  როცა ფუნქცია ასრულებს მუშაობას, ყველა ცვლადი, შექმნილი ფუნქციის სიგნით, ნადგურდება.
                  
                  საჭიროა გავითვალისწინთ, რომ სიტყვა var განუსაზღვრავს ცვლადს ლოკალურ არეს. მის გარეშე მივიღებთ გლობალურ ცვლადს. მაგალითად:
                  
                  function bar(){
                      foo = "25";}
                  bar();
                  console.log(foo);   // 25
                  მიუხედავად იმისა, რომ foo ცვლადი ფუნქციის გარეთ არსად არ გვხვდება, იგი გლობალურია და მისი გამოყენებაფუნქციის გარეთ შესაძლებელია. თუ გამოვიყენებთ სიტყვას var (ანუ გამოვაცხადებთ ცვლადს), მაშინ იგი იქნება ლოკალური და მისი გამოყენება ფუნქციის გარეთ იქნება შეუძლებელი:
                  
                  function bar(){
                      var foo = "25";}
                  bar();
                  console.log(foo);   // შეცდომა
                  strict mode
                  
                  ფუნქციის შიგნით გლობალური ცვლადების განსაზღვრამ შეიძლება გაზარდოს შეცდომის რისკი. ამის თავიდან ასაცილებლად გამოიყენება მკაცრი რეჟიმი, ანუ strict mode:
                  
                  "use strict";
                  function bar() {
                      foo = "25";
                  }
                  bar();
                  console.log(foo);
                  ამ შემთხვევაში ჩვენ მივიღებთ შეცდომას: SyntaxError: Unexpected identifier, რაც იმაზე მიუთითებს, რომ ცვლადი foo არაა განსაზღვრული. 
                  
                  strict mode შეიძლება დავაყენოთ ორი ხერხით:
                  
                  დავამატოთ გამოსახულება "strict mode" ჯავასკრიპტის კოდის დასაწყისში;
                  დავამატოთ გამოსახულება "strict mode" ფუნქციის ტანის დასაწყისში. ამ შემთხვევაში, მკაცრი რეჟიმი იქნება გამოყენებული მხოლოდ ამ ფუნქციაში.
                  ცვლადების გადაფარვა
                  
                  რა მოხდება, თუ გვაქვს ორი ცვლადი - ერთი გლობალური, ხოლო მეორე - ლოკალური, რომელთაც გააჩნიათ ერთი და იგივე სახელი:
                  
                  var z = 89;
                  function displaySquare() {
                      var z = 10;
                      console.log(z); // 10
                  }
                  displaySquare(); // 10
                  ამ შემთხვევაში ფუნქციის შიგნით ლოკალური ცვლადი გადაფარავს გლობალურს და ფუნქციის შიგნით გამოიყენებს ლოკალურ ცვლადს.
                  
                  თვითშესრულებადი ფუნქციები (IIFE)
                  
                  როგორც წესი, ფუნქციის განსაზღვრა და მისი გამოძახება ერთმანეთისგან გამოყოფილია. ჯერ განისაზღვრება ფუნქცია, ხოლო შემდეგ ხდება მისი გამოძახება საჭირო ადგილას. მაგრამ ეს აუცილებელი არ არის. ჩვენ ასევე შეგვიძლია შევქმნათ ფუნქციებიუ, რომლებიც განსაზღვრისთანავე ამუშავდებიან. ასეთ ფუნქციებს მეორენაირად უწოდებენ Immediately Invoked Function Expression (IIFE).
                  
                   
                  
                  (function () {
                      console.log("გამარჯობა, სამყაროვ!");
                  }());
                   
                  (function (n) {
                      var result = 1;
                      for (var i = 1; i <= n; i++)
                          result *= i;
                      console.log(n + " -ის ფაქტორიალი არის " + result);
                  }(4));
                  ასეთი ფუნქციები მოთავსებულია ფრჩხილებში და ფუნქციის განსაზღვრის შემდეგ მაშინვე მოდის ფრჩხილებში პარამეტრების გადაცემა.`
              },
              {
                  title:"რეკურსიული ფუნქციები",
                  data:`ფუნქციებს შორის შეიძლება ცალკე გამოვყოთ რეკურსიული ფუნქციები. მათი არსი მდგომარეობს იმაში, რომ ფუნქცია იძახებს თავის თავს. მაგალითისთვის ვნახოთ ფუნქცია, რომელიც ითვლის რიცხვის ფაქტორიალს:

                  function getFactorial(n) {
                      if (n === 1) {
                          return 1;
                      }
                      else {
                          return n * getFactorial(n - 1);
                      }
                  }
                  var result = getFactorial(4);
                  console.log(result); // 24
                  ფუნქცია getFactorial() აბრუნებს 1-ს, თუ n პარამეტრის მნიშვნელობაა 1, თუ არა და აბრუნებს ისევ getFactorial() ფუნქციის მნიშვნელობას პარამეტრით n-1, გამრავლებულს n-ზე.მაგალითად, პარამეტრად 4-ის გადაცემისას ვღებულობთ შემდეგ ჯაჭვს:
                  
                  var result = 4 * getFactorial(3);
                  var result = 4 * 3 * getFactorial(2);
                  var result = 4 * 3 * 2 * getFactorial(1);
                  var result = 4 * 3 * 2 * 1; // 24
                  ვნახოთ მეორე მაგალითი - ფიბონაჩის რიცხვების გამოთვლა:
                  
                  function getFibonachi(n) {
                      if (n == 0) {
                          return 0;
                      }
                      if (n == 1) {
                          return 1;
                      }
                      else {
                          return getFibonachi(n - 1) + getFibonachi(n - 2);
                      }
                  }
                  var result = getFibonachi(8); //21
                  console.log(result); // 21`
              },
              {
                  title:"ფუნქციის ხელახალი განსაზღვრა",
                  data:`ფუნქციას გააჩნია შესაძლებლობა, მოხდეს მისი ხელახალი განსაზღვრა. ხელახალი განსაზღვრა ხდება ფუნქციის სახელის მქონე ცვლადისთვის ანონიმური ფუნქციის მინიჭებით. მაგალითად:

                  function display(){
                      console.log("დილა მშვიდობისა");
                      display = function(){
                          console.log("დღე მშვიდობისა");
                      }
                  }
                   
                  display(); // დილა მშვიდობისა
                  display(); // დღე მშვიდობისა
                  პირველი გამოძახებისას მუშაობს ფუნქციის ძირითადი ბლოკი და გამოდის შეტყობინება "დილა მშვიდობისა". შემდგომი გამოძახებისას ფუნქცია უკვე ხელახლაა განსაზღვრული, შესაბამისად უკვე მუშაობს ის ანონიმური ფუნქცია, რაც მივანიჭეთ თავდაპირველ ფუნქციას ხელახალი განსაზღვრისას, შესაბამისად გამოვა შეტყობინება "დღე მშვიდობისა".
                  
                  ფუნქციის ხელახალი განსაზღვრისას საჭიროა ზოგიერთი ნიუანსის გათვალისწინება. კერზოდ, შევეცადოთ ცვლადს მივანიჭოთ მიმართვა ფუნქციაზე:
                  
                  function display(){
                      console.log("დილა მშვიდობისა");
                      display = function(){
                          console.log("დღე მშვიდობისა");
                      }
                  }
                   
                  // ცვლადისთვის ფუნქციაზე მიმართვის მინიჭება ფუნქციის ხელახალ განსაზღვრამდე
                  var displayMessage = display;
                  display(); // დილა მშვიდობისა
                  display(); // დღე მშვიდობისა
                  displayMessage(); // დილა მშვიდობისა
                  displayMessage(); // დილა მშვიდობისა
                  ცვლადისთვის ფუნქციაზე მიმართვის მინიჭება ხდება მის ხელახლა განსაზღვრამდე, შესაბამისად ის ყოველთვის მიმართავს თავდაპირველად განსაზღვრულ ფუნქციას, შესაბამისად ყოველთვის გამოაქვს შეტყობინება "დილა მშვიდობისა". თუ ცვლადისთვის ფუნქციაზე მიმართვის მინიჭება მოხდება ფუნქციის ხელახალი განსაზღვრის შემდეგ, ის უკვე მიმართავს ხელახლა განსაზღვრულ ფუნქციას და ყოველთვის გამოიტანს შეტყობინებას "დღე მშვიდობისა":
                  
                  function display(){
                      console.log("დილა მშვიდობისა");
                      display = function(){
                          console.log("დღე მშვიდობისა");
                      }
                  }
                   
                  // ცვლადისთვის ფუნქციაზე მიმართვის მინიჭება ფუნქციის ხელახალ განსაზღვრამდე
                  display(); // დილა მშვიდობისა
                  display(); // დღე მშვიდობისა
                  var displayMessage = display;
                  displayMessage(); // დღე მშვიდობისა
                  displayMessage(); // დღე მშვიდობისა`
              },
              {
                  title:"Hoisting",
                  data:` Hoisting წარმოადგენს ცვლადზე მიმართვის პროცესს მის განსაზღვრამდე. შეიძლება ეს კონცეფცია ცოტა უცნაურად მოგეჩვენოთ, მაგრამ ის დაკავშირებულია JavaScript-ის კომპილატორის მუშაობასთან. კოდის კომპილაცია ხდება ორ ჯერზე. პირველ ჯერზე კომპილატორი ღებულობს ყველა ცვლადის გამოცხადებას, ყველა იდენტიფიკატორს. ამ დროს არანაირი კოდი არ სრულდება, მეთოდების გამოძახება არ ხდება. მეორე ჯერზე ხდება კოდის შესრულება. შესაბამისად, შეცდომას არა აქვს ადგილი იმ შემთხვევაში, როცა ცვლადის გამოცხადება ხდება მისი გამოყენების შემდეგ, რადგანაც კომპილატორმა უკვე იცის ცვლადის არსებობის შესახებ. ამ პროცესს ეწოდება hoisting, რაც ინგლისურიდან ითარგმნება, როგორც აწევა. ამ დროს თითქოს ხდება ცვლადის გამოცხადების ადგილის აწევა. ცვლადი, რომელიც ხვდება hoisting-ში, ღებულობს მნიშვნელობას undefined.

                  ვნახოთ უმარტივესი მაგალითი:
                  
                  console.log(foo);
                  ამ კოდის შესრულება გამოიწვევს შეცდომას ReferenceError: foo is not defined.
                  
                  დავამატოთ ცვლადის განსაზღვრა:
                  
                  console.log(foo);   // undefined
                  var foo = "Tom";
                  ახლა უკვე შეცდომას ადგილი არა აქვს, რადგანაც კომპილატორი პირველ ჯერზე იგებს ცვლადის არსებობის შესახებ და ანიჭებს მას undefined მნიშვნელობას.
                  
                  ვნახოთ მეორე მაგალითი:
                  
                  var c = a * b;
                  var a = 7;
                  var b = 3;
                  console.log(c); // NaN
                  აქაც იგივე სიტუაციაა. ცვლადები a და b გამოიყენება მათ განსაზღვრამდე. შესაბამისად, პირველ ჯერზე კომპილატორი მათ ანიჭებს მნიშვნელობას  undefined, ხოლო undefined გამრავლებული undefined-ზე გვაძლევს Not a Number (NaN).
                  
                  იგივე ეხება ფუნქციებსაც. ჩვენ შეგვიძლია გამოვიძახოთ ფუნქცია მის განსაზღვრამდე:
                  
                  display();
                   
                  function display(){
                     console.log("Hello Hoisting");
                  }
                  აქ ფუნქციის გამოძახება უპრობლემოდ შესრულდება, მიუხედავად იმისა, რომ იგი გამოძახების მერეა განსაზღვრული.
                  
                  უნდა განვასხვავოთ შემთხვევა, როცა ფუნქცია განისაზღვრება ცვლადის სახით:
                  
                  display();
                   
                  var display = function (){
                     console.log("Hello Hoisting");
                  }
                  პირველ ჯერზე კომპილატორი გაიგებს display ცვლადის შესახებ და მიანიჭებს მას მნიშვნელობას undefined. მეორე ჯერზე კომპილატორი შეეცდება გამოიძახოს ფუნქცია, რომელსაც მიმართავს ცვლადი, მაგრამ  ნახავს, რომ ცვლადი ჯერ ისევ არის undefined, შესაბამისად მივიღებთ შეცდომას: display is not a function.
                  
                  `
              },
            
            ]
        },{
            title:"თავი 4. ობიექტზე ორიენტირებული პროგრამირება",
            content:[
                {
                    title:"ობიექტები",
                    data:`დღისათვის ობიექტზე ორიენტირებული პროგრამირება წარმოადგენს გაბატონებულ პარადიგმას პროგრამული უზრუნველყოფის შექმნის პროცესში. JavaScript-ში ჩვენ შეგვიძლია გამოვიყენოთ ყველა ის უპირატესობა, რასაც გვაძლევს OOP (Object-oriented programming). მაგრამ ჯავასკრიპტისთვის ობიექტზე ორიენტირებულ პროგრამირებას გააჩნია თავისი ნიუანსები.

                    პროგრამირების ობიექტზე ორიენტირებულ კლასიკურ ენებში, როგორიცაა C++, Java, C#, OOP-is მთელი კონცეფცია კლასისა და ობიექტის ცნებების ირგვლივ ტრიალებს. კლასი წარმოადგენს ობიექტის ერთგვარ იდეალურ გეგმას, ხოლო ობიექტი - ამ გეგმის კონკრეტულ განხორციელებას. მაგალითად, ყველას აქვს წარმოდგენა სახლზე, როგორც საგანზე, რომელსაც აქვს კედლები და სახურავი. ანუ ეს წარმოდგენა არის რაღაც იდეალური გეგმა, რომელიც შეიძლება წარმოვიდგინოთ, როგორც კლასი. ამავდროულად არსებობს კონკრეტული სახლები, რომლებიც ერთმანეთისგან განსხვავდება მასალით, რისგანაც არიან აგებულნი, სართულების რაოდენობით, ფანჯრებით, ფორმით და ასე შემდეგ. ანუ სახლი გამოდის კლასის როლსი, სოლო კონკრეტული სახლები ამ კლასის ობიექტებია.
                    
                    JavaScript-ში ECMAScript 6 სტანდარტამდე არ არსებობდა კლასის ცნება, მის ნაცვლად გამოიყენებოდა ობიექტის პროტოტიპი. რადგანაც ECMAScript 6 სტანდარტი ჯერ კიდევ შორსაა ბრაუზერულ JavaScript-ში სრული დანერგვისაგან, ჩვენ განვიხილავთ პროტოტიპების გამოყენებას.
                    
                    ობიექტები
                    
                    წინა თემებში ჩვენ ვმუშაობდით პრმიტიულ მონაცემებთან - რიცხვებთან, სტრიქონებთან, მაგრამ მონაცემები ყოველთვის არაა წარმოდგენილი მხოლოდ პრიმიტიულ ტიპებში. მაგალითად, თუ ჩვენს პროგრამაში გვჭირდება ადამიანის არსის აღწერა, რომელსაც აქვს სახელი, ასაკი, სქესი და ასე შემდეგ, მისი აღწერისთვის პრიმიტიული ტიპები საკმარისი არაა - ადამიანის არსს ვერ აღვწერთ მარტო რიცხვით ან მარტო სტრიქონით, საჭიროა ბევრი რიცხვი და სტრიქონი. ამდენად, ადამიანი წარმოადგენს კომპლექსურ სტრუქტურას, რომელსაც გააჩნია თვისებები: სახელი, გვარი, ასაკი, სქესი, პროფესია და ასე შემდეგ.
                    
                    ასეთ სტრუქტურებთან სამუშაოდ JavaScript-ში გამოიყენება ობიექტები. თითოეული  ობიექტი შეიძლება შეიცავდეს თვისებებს, რომლებიც აღწერს მის მდგომარეობას და მეთოდებს, რომლებიც აღწერენ მის ქცევას.
                    
                    ახალი ობიექტის შექმნა
                    
                    არსებობს ახალი ობიექტის შექმნის რამდენიმე ხერხი.
                    
                    პირველი ხერხი მდგომარეობს object-ის კონსტრუქტორის გამოყენებაში:
                    
                    var user = new Object();
                    ამ შემთხვევაში ობიექტს ჰქვის user. ის განისაზღვრება ისევე, როგორც სხვა ცვლადები საკვანძო var სიტყვის მეშვეობით. 
                    
                    გამოსახულება new Object() წარმოადგენს კონსტრუქტორის გამოძახებას, ანუ გამოძახებას ფუნქციისა, რომელიც ქმნის ახალ ობიექტს. კონსტრუქტორის გამოსაძახებლად გამოიყენება ოპერატორი new. 
                    
                    ობიექტის შექმნის მეორე მეთოდია ფიგურული ფრჩხილების გამოყენება:
                    
                    var user = {};
                    დღეისათვის უფრო გავრცელებულია მეორე ხერხი.
                    
                    ობიექტის თვისებები
                    
                    ობიექტის შექმნის შემდეგ შეგვიძლია განვსაზღვროთ მისი თვისებები. ამისათვის ობიექტის სახელის შემდეგ უნდა დავსვათ წერტილი, მივუთითოთ თვისების სახელი და მივანიჭოთ მნიშვნელობა:
                    
                    var user = {};
                    user.name = "Tom";
                    user.age = 26;
                    მოცემულ შემთხვევაში გამოცხადებულია ორი თვისება name და age, რომელთაც მინიჭებული აქვთ შესაბამისი მნიშვნელობები. ამის შემდეგ ჩვენ შეგვიძლია გამოვიყენოთ ეს თვისებები, მაგალითად გამოვიტანოთ კონსოლში:
                    
                    console.log(user.name);
                    console.log(user.age);
                    ობიექტის მეთოდები
                    
                    ობიექტის მეთოდები განსაზღვრავენ მის ქცევას ან მოქმედებას. მეთოდები თავისი არსით წარმოადგენენ ფუნქციებს. მაგალითად, განვსაზღვროთ მეთოდი, რომელიც კონსოლსი გამოიტანს ადამიანის სახელს და ასაკს:
                    
                    var user = {};
                    user.name = "Tom";
                    user.age = 26;
                    user.display = function(){    
                        console.log(user.name);
                        console.log(user.age);
                    };
                     
                    // მეთოდის გამოძახება
                    user.display();
                    როგორც ფუნქციის შემთხვევაში, მეთოდი ჯერ განისაზღვრება, ხოლო შემდეგ ხდება მისი გამოძახება.
                    
                    მასივის სინტაქსი
                    
                    არსებობს თვისებების და მეთოდების განსაზღვრის ალტერნატიული გზაც მასივის სინტაქსის მეშვეობით:
                    
                    var user = {};
                    user["name"] = "Tom";
                    user["age"] = 26;
                    user["display"] = function(){     
                        console.log(user.name);
                        console.log(user.age);
                    };
                     
                    // მეთოდის გამოძახება
                    user["display"]();
                    თითოეული თვისების და მეთოდის დასახელება ექცევა ბრჭყალებში და კვადრატულ ფრჩხილებში, შემდეგ ასევე ენიჭება მნიშვნელობა. მაგალითად: user["age"] = 26. 
                    
                    ამ თვისებებისა და მეთოდებისადმი მიმართვის უნდა გამოვიყენოთ წერტილის ნოტაცია  (user.name) ან მივმართოთ ასე:user["name"].
                    
                    ობიექტის შექმნის გამარტივებული სინტაქსი
                    
                    ობიექტის თვისებებისა და მეთოდების ცალ-ცალკე განსაზღვრის ნაცვლად შეგვიძლია ისინი განვსაზღვროთ ერთდროულად:
                    
                    var user = {
                        name: "Tom",
                        age: 26,
                        display: function () {
                            console.log(this.name);
                            console.log(this.age);
                        }
                    };
                    // მეთოდის გამოძახება
                    user.display();
                    ობიექტის განსაზღვრის ასეთი მეთოდის დროს მინიჭებბის ოპერატორად გამოიყენება არა ტოლობის ნიშანი, არამედ ორწერტილი. მაგალითად, name:"Tom" გამოსახულება თვისება name-ს ანიჭებს მნიშვნელობას "Tom". თითოეული თვისების ან მეთოდის განსაზღვრის შემდეგ მოდის არა წერტილმძიმე, არამედ მძიმე.
                    
                    იმისათვის, რომ მივმართოთ ობიექტის თვისებას ან მეთოდს ამ ობიექტის შიგნით, გამოიყენება საკვაძო სიტყვა this. ის ნიშნავს მიმართვას მიმდინარე ობიექტისადმი.
                    
                    აქვე უნდა აღინიშნოს, რომ ობიექტის თვისებებისა და მეთოდების სახელები წარმოადგენენ სტრიქონებს. ანუ ობიექტის წინა განსაზღვრა შეგვიძლია შევცვალოთ ასეთნაირად:
                    
                    var user = {
                        "name": "Tom",
                        "age": 26,
                        "display": function () {
                            console.log(user.name);
                            console.log(user.age);
                        }
                    };
                    // მეთოდის გამოძახება
                    user.display();
                    ერთის მხრივ, ამ ორ განსაზღვრას შორის არანაირი განსხვავება არ არის. მეორეს მხრივ, არის შემთხვევები, როცა სახელების სტრიქონებში ჩასმამ შეიძლება გვიშველოს. მაგალითად იმ შემთხვევაში, როცა თვისების ან მეთოდის სახელი შედგება ცარიელი ადგილით გაყოფილი ორი სიტყვისგან:
                    
                    var user = {
                        name: "Tom",
                        age: 26,
                        "full name": "Tom Johns",
                        "display info": function () {
                            console.log(user.name);
                            console.log(user.age);
                        }
                    };
                    console.log(user["full name"]);
                    user["display info"]();
                    ოღონდ ასეთ შემთხვევაში თვისების ან მეთოდისადმი მიმართვისთვის უნდა გამოვიყენოთ მასივის სინტაქსი.
                    
                    თვისებების და მეთოდების წაშლა
                    
                    ზემოთ ჩვენ ვნახეთ, როგორ შეიძლება ობიექტს დინამიურად დავამატოთ მეთოდები და თვისებები. ასევე ჩვენ შეგვიძლია მათი წაშლაც. ამისთვის გამოიყენება ოპერატორი delete:
                    
                    var user = {};
                    user.name = "Tom";
                    user.age = 26;
                    user.display = function () {
                        console.log(user.name);
                        console.log(user.age);
                    };
                     
                    console.log(user.name); // Tom
                    delete user.name; // წავშალოთ თვისება
                    console.log(user.name); // undefined
                    წაშლის შემდეგ ობიექტის ეს თვისება არ იქნება განსაზღვრული და მასზე მიმართვისას დაბრუნდება undefined.`
                },
                {
                  title:"ჩასმული ობიექტები და მასივები ობიექტებში",
                  data:`ერთი ობიექტი თვისების სახით შეიძლება შეიცავდეს სხვა ობიექტს. მაგალითად, ავიღოთ ობიექტი country (ქვეყანა). მას შეიძლება ჰქონდეს სხვადასხვა თვისება. ერთ-ერთი თვისება შეიძლება იყოს დედაქალაქი. მაგრამ დედაქალაქს თავის მხრივ შეიძლება ჰქონდეს თვისებები, მაგალითად დასახელება, მოსახლეობის რაოდენობა, დაარსების წელი:

                  var country = {
                      name: "გერმანია",
                      language: "გერმანული",
                      capital: {
                          name: "ბერლინი",
                          population: 3375000,
                          year: 1237
                      }
                  };
                  console.log("დედაქალაქი: " + country.capital.name); // Берлин
                  console.log("მოსახლეობა: " + country["capital"]["population"]); // 3375000
                  console.log("დაარსების წელი: " + country.capital["year"]); // 1237
                  ჩასმული ობიექტის თვისებისადმი მიმართვისთვის შეგვიძლია გამოვიყენოთ სტანდარტული წერტილის ნოტაცია:
                  
                  country.capital.name
                  ან მიმვმართოთ მასივის სინტაქსით:
                  
                  country["capital"]["population"]
                  დასაშვებია მიმართვის შერეული სახეც:
                  
                  country.capital["year"]
                  თვისებად ასევე შეიძლება მასივების გამოყენებაც, მათ შორის ობიექტების მასივებისაც:
                  
                  var country = {
                      name: "შვეიცარია",
                      languages: ["გერმანული", "ფრანგული", "იტალიური"],
                      capital: {
                          name: "ბერნი",
                          population: 126598
                      },
                      cities: [
                          { name: "ციურიხი", population: 378884 },
                          { name: "ჟენევა", population: 188634 },
                          { name: "ბაზელი", population: 164937 }
                      ]
                  };
                   
                  // country.languages ყველა ელემენტის გამოტანა
                  document.write("<h3>შვეიცარიის ოფიციალური ენებია</h3>");
                  for (var i = 0; i < country.languages.length; i++)
                      document.write(country.languages[i] + "<br/>");
                   
                  // country.cities ყველა ელემენტის გამოტანა
                  document.write("<h3>შვეიცარიის ქალაქებია</h3>");
                  for (var i = 0; i < country.cities.length; i++)
                      document.write(country.cities[i].name + "<br/>");
                  country ობიექტში გვაქვს თვისება languages, რომელიც შეიცავს სტრიქონების მასივს, ასევე თვისება cities, რომელიც შეიცავს ერთი ტიპის ობიექტების მასივს. ამ მასივებთან შეგვიძლია ვიმუშაოთ ისევე, როგორც სხვა მსივებთან, მაგალითად გადავარჩიოთ for ციკლის მეშვეობით. მასივის ობიექტების გადარჩევისას თითოეული ელემენტი წარმოადგენს ობიექტს და შეგვიძლია მივმართოთ მის თვისებებს:
                  
                  country.cities[i].name
                  შედეგად ბრაუზერი გამოიტანს ამ მასივების შიგთავსს`
              },
              {
                  title:"მეთოდებისა და თვისებების არსებობის შემოწმება და გადარჩევა",
                  data:`ობიექტში ახალი თვისებებისა და მეთოდების დინამიურად დამატების დროს მნიშვნელოვანია შემოწმდეს, ხომ არა აქვს ასეთი თვისება ან მეთოდი ობიექტს უკვე. ამისათვის ჯავასკრიპტში გამოიყენება ოპერატორი in:

                  var user = {};
                  user.name = "Tom";
                  user.age = 26;
                  user.display = function () {
                      console.log(user.name);
                      console.log(user.age);
                  };
                  var hasNameProp = "name" in user;
                  console.log(hasNameProp); // true - თვისება name უკვე არსებობს user ობიექტში
                  var hasWeightProp = "weight" in user;
                  console.log(hasWeightProp); // false - user ობიექტში არაა თვისება ან მეთოდი weight
                  in ოპერატორს გააჩნია შემდეგი სინტაქსი: "თვისება|მეთოდი" in ობიექტი - ბრჭყალებში მოდის მეთოდის ან თვისების სახელი, ხოლო in ოპერატორის მერე ობიექტის სახელი. თუ თვისება ან მეთოდი ამ სახელით მოიძებნება ობიექტში, ფრუნდება true, წინააღმდეგ შემთხვევაში - false.
                  
                  ალტერნატიული ხერხი მდგომარეობს შემდეგში: თუ ობიექტის თვისება ან მეთოდი არის undefined, ესე იგი, ეს თვისება ან მეთოდი ობიექტს არ გააჩნია:
                  
                  var hasNameProp = user.name!==undefined;
                  console.log(hasNameProp); // true
                  var hasWeightProp = user.weight!==undefined;
                  console.log(hasWeightProp); // false
                  რადგანაც ობიექტს გააჩნია ტიპი Object, მას ასევე აქვს Object ტიპის ყველა თვისება და მეთოდი. შეგვიძლია გამოვიყენოთ მეტოდი hasOwnProperty(), რომელიც განსაზღვრულია Object ტიპში:
                  
                  var hasNameProp = user.hasOwnProperty('name');
                  console.log(hasNameProp); // true
                  var hasDisplayProp = user.hasOwnProperty('display');
                  console.log(hasDisplayProp); // true
                  var hasWeightProp = user.hasOwnProperty('weight');
                  console.log(hasWeightProp); // false
                  თვისებებისა და მეთოდების გადარჩევა
                  
                  for ციკლის მეშვეობით შესაძლებელია ობიექტის გადარჩევა, როგორც ჩვეულებრივი მასივისა და მისი ყველა თვისებისა და მეთოდის მიღება მათი მნიშვნელობებით:
                  
                  var user = {};
                  user.name = "Tom";
                  user.age = 26;
                  user.display = function () {
                      console.log(user.name);
                      console.log(user.age);
                  };
                  for (var key in user) {
                      console.log(key + " : " + user[key]);
                  }
                  გაშვებისას ბრაუზერის კონსოლი გამოიტანს შემდეგს:
                  
                  name : Tom
                  age : 26
                  display : function (){
                      
                      console.log(user.name);
                      console.log(user.age);
                  }`
              },
              {
                  title:"ობიექტები ფუნქციებში",
                  data:`ფუნქცია შეიძლება აბრუნებდეს მნიშვნელობას. არაა აუცილებელი, რომ ეს იყოს პრიმიტიული მონაცემები - რიცხვები, სტრიქონები, ასევე შეიძლება იყოს რთული ობიექტები.

                  მაგალითად, გავიტანოთ User ობიექტის შექმნა ფუნქციაში:
                  
                  function createUser(pName, pAge) {
                      return {
                          name: pName,
                          age: pAge,
                          displayInfo: function() {
                              document.write("სახელი: " + this.name + " ასაკი: " + this.age + "<br/>");
                          }
                      };
                  };
                  var tom = createUser("Tom", 26);
                  tom.displayInfo();
                  var alice = createUser("Alice", 24);
                  alice.displayInfo();
                  აქ ფუნქცია createUser() პარამეტრებად იღებს pName-ს და pAge-ს და მათ მიხედვით ქმნის ახალ ობიექტს, რაც წარმოადგენს დასაბრუნებელ მნიშვნელობას. ობიექტის შექმნის პროცესის ფუნქციაში გატანას ის უპირატესობა აქვს, რომ მისი მეშვეობით შესაძლებელია ერთი ტიპის ბევრი ობიექტის შექმნა სხვადასხვა მნიშვნელობებით.
                  
                  ასევე, ობიექტი შეიძლება იყოს პარამეტრად ფუნქციაში:
                  
                  function createUser(pName, pAge) {
                      return {
                          name: pName,
                          age: pAge,
                          displayInfo: function () {
                              document.write("სახელი: " + this.name + ", ასაკი: " + this.age + "<br/>");
                          },
                          driveCar: function (car) {
                              document.write(this.name + " ატარებს მანქანას მარკით " + car.name + "<br/>");
                          }
                      };
                  };
                   
                  function createCar(mName, mYear) {
                      return {
                          name: mName,
                          year: mYear
                      };
                  };
                  var tom = createUser("ტომი", 26);
                  tom.displayInfo();
                  var bently = createCar("ბენტლი", 2004);
                  tom.driveCar(bently);
                  აქ განსაზღვრულია ორი ფუნქცია: ერთი მომხმარებელთა დასამატებლად, მეორე მანქანის ობიექტის შესაქმნელად. user ობიექტის driveCar() მეთოდს პარამეტრად გადაეცემა ობიექტი car. შედეგად, ბრაუზერსი გამოვა შემდეგი:`
              },
              {
                  title:"ობიექტის კონსტრუქტორი",
                  data:`ახალი ობიექტების შექმნის გარდა ჯავასკრიპტი საშუალებას გვაძლევს შევქმნათ ობიექტის ახალი ტიპები კონსტრუქტორის მეშვეობით. ობიექტის შექმნის ერთ-ერთი ხერხია მისი შექმნა Object-ის კონსტრუქტორის მეშვეობით:

                  var tom = new Object();
                შექმნის შემდეგ ის იქცევა, როგორც Object ტიპის ობიექტი.
                
                კონსტრუქტორი გვაძლევს ახალი ტიპის ობიექტის შექმნის შესაძლებლობას. ტიპი წარმოადგენს აბსტრაქტულ აღწერას ანუ ობიექტის შაბლონს. შეიძლება ასეთი ანალოგიის მოყვანაც. ყველას გვაქვს წარმოდგენა ადამიანზე - მას უნდა ჰქონდეს ორი ხელი, ორი ფეხი, თავი, ტანი, სისხლის მიმოქცევის სისტემა, ნერვული სისტემა და ა. შ. ეს ერის ერთგვარი შაბლონი - ეს შაბლონი შეიძლება განვიხილოთ როგორც ობიექტის ტიპი. რეალურად არსებული ადამიანი კი არის ამ ტიპის კონკრეტული ობიექტი.
                
                ტიპის განსაზღვრა შეიძლება შედგებოდეს კონსტრუქტორის ფუნქციისგან, მეთოდებისა და თვისებებისგან.
                
                პირველ რიგში განვსაზღვროთ კონსტრუქტორი:
                
                function User(pName, pAge) {
                    this.name = pName;
                    this.age = pAge;
                    this.displayInfo = function(){
                        document.write("სახელი: " + this.name + "; ასაკი: " + this.age + "<br/>");
                    };
                }
                კონსტრუქტორი - ეს ჩვეულებრივი ფუნქციაა, იმ განსხვავებით, რომ მას აქვს თვისებები და მეთოდები. თვისების და მეთოდის განსაზღვრისთვის გამოიყენება საკვანძო სიტყვა this:
                
                 this.name = pName;
                მოცემულ შემთხვევაში განსაზღვრულია ორი თვისება - name და age, და ერთი მეთოდი - displayInfo.
                
                როგორც წესი, კონსტრუქტორის სახელი იწყება დიდი ასოთი, განსხვავებით ფუნქციის სახელებისგან. ამის შემდეგ ამ კონსტრუქტორის მეშვეობით შეგვიძლია შევქმნათ ახალი User ტიპის ობიექტები და გამოვიყენოთ მისი თვისებები და  მეთოდები:
                
                 var tom = new User("Том", 26);
                console.log(tom.name); // Том
                tom.displayInfo();
                კონსტრუქტორის გამოსაძახებლად, ანუ ახალი User ობიექტის შესაქმნელად უნდა გამოვიყენოთ საკვანძო სიტყვა new.
                
                ანალოგიურად შეგვიძლია განვსაზღვროთ სხვა ტიპებიც და გამოვიყენოთ ისინი ერთად:
                
                // Car ტიპის კონსტრუქტორი
                function Car(mName, mYear){
                    this.name = mName;
                    this.year = mYear;
                    this.getCarInfo = function(){
                        document.write("მოდელი: " + this.name + "  გამოშვების წელი: " + this.year + "<br/>");
                    };
                };
                // User ტიპის კონსტრუქტორი
                function User(pName, pAge) {
                    this.name = pName;
                    this.age = pAge;
                    this.driveCar = function(car){
                        document.write(this.name + " ატარებს მანქანას მარკით " + car.name + "<br/>");
                    };
                    this.displayInfo = function(){
                        document.write("სახელი: " + this.name + "; ასაკი: " + this.age + "<br/>");
                    };
                };
                 
                var tom = new User("ტომი", 26);
                tom.displayInfo();
                var bently = new Car("ბენტლი", 2004);
                tom.driveCar(bently);`
              },
              {
                  title:"ობიექტების გაფართოება. Prototype",
                  data:`გარდა თვისებებისა და მეთოდების განსაზღვრისა, კონსტრუქტორში ასევე შეიძლება გამოვიყენოთ თვისება prototype. ყველა ფუნქციას გააჩნია თვისება prototype, რომელიც წარმოადგენს ფუნქციის პროტოტიპს. ანუ თვისება User.prototype წარმოადგენს User ობიექტების პროტოტიპს. ყველა თვისება და მეთოდი, რომელიც განსაზღვრულია User.prototype-ში, იქნება საერთო ყველა User ობიექტისთვის.

                  მაგალითად:
                  
                  function User(pName, pAge) {
                      this.name = pName;
                      this.age = pAge;
                      this.displayInfo = function(){
                          document.write("სახელი: " + this.name + "; ასაკი: " + this.age + "<br/>");
                      };
                  };
                   
                  User.prototype.hello = function(){
                      document.write(this.name + " ამბობს: 'გამარჯობა!'<br/>");
                  };
                  User.prototype.maxAge = 110;
                   
                  var tom = new User("ტომი", 26);
                  tom.hello();
                  var john = new User("ჯონი", 28);
                  john.hello();
                  console.log(tom.maxAge); // 110
                  console.log(john.maxAge); // 110
                  აქ დამატებულია მეთოდი hello და თვისება maxAge და ნებისმიერი ობიექტი User იყენებს მათ. მნიშვნელოვანია აღვნიშნოთ, რომ ეს თვისება ერთი და იგივე იქნება ყველა User ობიექტისთვის, იგი არის სტატიკური თვისება, განსხვავებით სხვა თვისებებისგან, მაგალითად this.name, რომელიც ყველა ობიექტს თავისი აქვს.
                  
                  ამავდროულად, ჩვენ შეგვიძლია თვითონ ობიექტში განვსაზღვროთ თვისება, რომელსაც ექნება იგივე სახელი, რაც პროტოტიპის თვისებას. ამ შემთხვევაში ობიექტის საკუთარ თვისებას ექნება პრიორიტეტი პროტოტიპის თვისებასთან შედარებით:
                  
                  User.prototype.maxAge = 110;
                  var tom = new User("ტომი", 26);
                  var john = new User("ჯონი", 28);
                  tom.maxAge = 99;
                  console.log(tom.maxAge); // 99
                  console.log(john.maxAge); // 110
                  maxAge თვისებასთან მიმართვის დროს ჯავასკრიპტი ჯერ ეძებს თვიტონ ობიექტის თვისებებში და თუ ვერ იპოვის, მხოლოდ შემდეგ ეძებს პროტოტიპის თვისებებში. იგივე ეხება მეთოდებსაც.
                  
                   `
              },
              {
                  title:"ინკაფსულაცია",
                  data:`ინკაფსულაცია წარმოადგენს ობიექტზე ორიენტირებული პროგრამირების ერთ-ერთ საკვანძო ცნებას და წარმოადგენს ობიექტის მდგომარეობის დაფარვას გარე ზემოქმედებისაგან. მიუთითებლობისას ობიექტის ყველა თვისება წარმოადგენს საჯაროს და მათზე მიმართვა შესაძლებელია პროგრამის ნებისმიერი ადგილიდან.

                  function User(pName, pAge) {
                      this.name = pName;
                      this.age = pAge;
                      this.displayInfo = function(){
                          document.write("სახელი: " + this.name + "; ასაკი: " + this.age);
                      };
                  };
                  var tom = new User("ტომი", 26);
                  tom.name=34;
                  console.log(tom.name);
                  მაგრამ ჩვენ შეგვიძლია გავხადოთ ისინი გარედან მიუწვდომელნი თვისებების ლოკალურ ცვლადებად გარდაქმნის გზით:
                  
                  function User (name, age) {
                      this.name = name;
                      var _age = age;
                      this.displayInfo = function(){
                          document.write("სახელი: " + this.name + "; ასაკი: " + _age + "<br>");
                      };
                      this.getAge = function() {
                          return _age;
                      }
                      this.setAge = function(age) {
                          if(typeof age === "number" && age >0 && age<110){
                              return _age = age;
                          } else {
                              console.log("არასწორი მნიშვნელობა");
                          }
                      }
                  }
                   
                  var tom = new User("Том", 26);
                  console.log(tom._age); // undefined - _age - ლოკალური ცვლადი
                  console.log(tom.getAge()); // 26
                  tom.setAge(32);
                  console.log(tom.getAge()); // 32
                  tom.setAge("54"); // არასწორი მნიშვნელობა
                  კონსტრუქტორში თვისების age ნაცვლად გამოცხადებულია ლოკალური ცვლადი _age. როგორც წესი, ლოკალური ცვლადების სახელები კონსტრუქტორში იწყება "_" სიმბოლოთი. 
                  
                  კონსტრუქტორის გარედან მომხმარებლის ასაკთან სამუშაოდ კონსტრუქტორში განსაზღვრულია ორი მეთოდი. მეთოდი getAge()  განკუთვნილია ლოკალური ცვლადის _age მნიშვნელობის მისაღებად. ასეთ მეთოდს ეძახიან გეტერს (getter). მეორე მეთოდი - setAge რომელსაც სეტერს (setter) უწოდებენ, განკუთვნილია _age ცვლადისთვის მნიშვნელობის მისანიჭებლად;
                  
                  ასეტი მიდგომის პლუსი მდგომარეობს იმაში, რომ ჩვენ შეგვიძლია ვაკონტროლოთ _age-სთვის მნიშვნელობის მინიჭების პროცესი, ჩვენ შეგვიძლია შევამოწმოთ მისანიჭებელი მნიშვნელობები, როგორც მოცემულ მაგალითში, სადაც მოწმდება, რომ ასაკი უნდა იყოს 0-ზე მეტი და 110-ზე ნაკლები რიცხვი.
                  
                   `
              },
              {
                  title:"ფუნქცია, როგორც ობიექტი. მეთოდები call და apply",
                  data:`ჯავასკრიპტში ფუნქციებიც წარმოადგენენ ობიექტებს - ობექტებს Function. მათ ასევე აქვთ პროტოტიპი, თვისებები და მეთოდები. ყველა ფუნქცია, რომელიც გამოიყენება პროგრამაში, წარმოადგენს Function-ის ობიექტებს და აქვთ მისი ყველა თვისება და მეთოდი.

                  მაგალითად, ჩვენ შეგვიძლია ფუნქციის შექმნა Function-ის კონსტრუქტორის მეშვეობით:
                  
                  var square = new Function('n', 'return n * n;');
                  console.log(square(5));
                  Function-ის კონსტრუქტორში შეიძლება გადაეცეს რამდენიმე პარამეტრი.ბოლო პარამეტრი წარმოადგენს ფუნქციის ტანს სტრიქონის სახით. ფაქტიურად, ეს სტრიქონი შეიცავს ჯავასკრიპტის კოდს. წინა არგუმენტები შეიცავენ ფუნქციის პარამეტრების სახელებს. მოცემულ მაგალითში განსაზღვრულია რიცხვის კვადრატში აყვანის ფუნქცია და მას გააჩნია ერთი პარამეტრი n.
                  
                  Function ობიექტის თვისებებს შორის შეიძლება გამოვყოთ:
                  
                  arguments: პარამეტრების მასივი
                  length: პარამეტრების რაოდენობა, რასაც ელოდება ფუნქცია
                  caller: განსაზღვრავს ფუნქციას, რომელმაც წამოიწყო ფუნქციის მიმდინარე შესრულება
                  name: ფუნქციის სახელი
                  prototype: ფუნქციის პროტოტიპი
                  პროტოტიპის მეშვეობით ჩვენ შეგვიძლია განვსაზღვროთ დამატებითი თვისებები:
                  
                  function display(){   
                     console.log("გამარჯობა, სამყაროვ!");
                  }
                  Function.prototype.program ="Hello";
                   
                  console.log(display.program); // Hello
                  მეთოდებს შორის აღსანიშნავია call() და apply(). 
                  
                  მეთოდი call() იძახებს ფუნქციას მითითებული მნიშვნელობით this და პარამეტრებით:
                  
                  function add(x, y){   
                     return x + y;
                  }
                  var result = add.call(this, 3, 8);
                   
                  console.log(result); // 11
                  this უთითებს ობიექტზე, რომლისთვისაც ხდება ფუნქციის გამოძახება - მოცემულ შემთხვევაში გლობალური ობიექტი window. შემდეგ მოდის პარამეტრების მნიშვნელობები.
                  
                  პირველი პარამეტრის მეშვეობით ობიექტის გადაცემისას მასზე მიმართვა შეიძლება საკვანძო სიტყვის - this მეშვეობით:
                  
                  function User (name, age) {
                      this.name = name;
                      this.age = age;
                  }
                  var tom = new User("ტომი", 26);
                  function display(){
                      console.log("მისი სახელია " + this.name);
                  }
                  display.call(tom); // მისი სახელია ტომი
                  მოცემულ შემთხვევაში გადაეცემა მხოლოდ ერთი მნიშვნელობა, ვინაიდან ფუნქციას პარამეტრები არ გააჩნია. ანუ ფუნქციის გამოძახება ხდება ობიექტისთვის tom.
                  
                  თუ არა აქვს მნიშვნელობა ობიექტს, გადაეცემა null:
                  
                  function add(x, y){   
                     return x + y;
                  }
                  var result = add.call(null, 3, 8);
                   
                  console.log(result); // 11
                  მეთოდი apply() მეთოდი call()-ის მსგავსია. აქაც პირველ პარამეტრად გადაეცემა ობიექტი, რომლისთვისაც ხდება ფუნქციის გამოძახება. ხოლო მეორე პარამეტრად გადაეცემა არგუმენტების მასივი:
                  
                  function add(x, y){   
                     return x + y;
                  }
                  var result = add.apply(null, [3, 8]);
                   
                  console.log(result); // 11`
              },
              {
                title:"მემკვიდრეობითობა",
                data:`JavaScript-ს გააჩნია მემკვიდრეობითობა, რაც საშუალებას იძლევა ობიექტების ახალი ტიპების შექმნისას, საჭიროებისას, შევინარჩუნოთ არსებული ტიპებისგან მემკვიდრეობით მიღებული ფუნქციონალი. მაგალითად, ვთქვათ გვაქვს ობიექტი User , რომელიც წარმოადგენსმომხმარებელს. ვთქვათ, ასევე გვაქვს ობიექტი Employee, რომელიც წარმოადგენს მომუშავეს. მაგრამ მომუშავე ამავე დროს მომხმარებელიცაა, შესაბამისად, მას უნდა ჰქონდეს ასევე User ობიექტის ყველა თვისება და მეთოდი. მაგალითად:

                // მომხმარებლის კონსტრუქტორი
                function User (name, age) {
                    this.name = name;
                    this.age = age;
                    this.go = function(){document.write(this.name + " მიდის <br/>");}
                    this.displayInfo = function(){
                        document.write("სახელი: " + this.name + "; ასაკი: " + this.age + "<br/>");
                    };
                }
                User.prototype.maxage = 110;
                 
                // მომუშავის კონსტრუქტორი
                function Employee(name, age, comp){
                    User.call(this, name, age);
                    this.company = comp;
                    this.displayInfo = function(){
                        document.write("სახელი: " + this.name + "; ასაკი: " + this.age + "; კომპანია: " + this.company + "<br/>");
                    };
                }
                Employee.prototype = Object.create(User.prototype);
                 
                var tom = new User("ტომი", 26);
                var bill = new Employee("ბილი", 32, "Google");
                tom.go();
                bill.go();
                tom.displayInfo();
                bill.displayInfo();
                console.log(bill.maxage);
                აქ დასაწყისში განსაზღვრულია ტიპი User და მის პროტოტიპში დამატებულია თვისება maxage. შემდეგ მოდის Employee ტიპის განსაზღვრა. მის კონსტრუქტორში ხდება User-ის კონსტრუქტორის გამოძახება:
                
                User.call(this, name, age);
                პირველი პარამეტრის (this) გადაცემა შესაძლებლობას გვაძლევს გამოვიძახოთ User-ის კონსტრუქტორი შესაქმნელი Employee ობიექტისთვის. ამის შედეგად ყველა მეთოდი და თვისება, რაც გააჩნია User-ს ასევე გადადის Employee ობიექტზე.
                
                გარდა ამისა საჭიროა პროტოტიპის გადაცემა მემკვიდრეობით. ამისთვის გამოიყენება შემდეგი სტრიქონი:
                
                Employee.prototype = Object.create(User.prototype);
                მეთოდი Object.create() საშუალებას გვაძლევს შევქმნათ User-ის პროტოტიპის ობიექტი, რომელიც ენიჭება Employee-ს პროტოტიპს. ამასთან, Employee-ს პროტოტიპში, აუცილებლობისას, ჩვენ შეგვიძლია დამატებითი თვისებებისა და მეთოდების შექმნაც. 
                
                მემკვიდრეობითობისას შესაძლებელია მემკვიდრეობით მიღებული ფუნქციონალის ხელახალი განსაზღვრაც (შეცვლა). მაგალითად, Employee ობიექტში შეცვლილია მეთოდი displayinfo() და მასში დამატებულია მომუშავის კომპანიის გამოტანა.
                
                ამ ყველაფრის შედეგად ბრაუზერში გამოვა შემდეგი ინფორმაცია`
            },
            {
                title:"საკვანძო სიტყვა",
                data:`this საკვანძი სიტყვის მნიშვნელობა დამოკიდებულია იმ კონტექსტზე, რომელშიც ხდება მისი გამოყენება, ასევე კოდის რეჟიმზე (strict mode) - მკაცრია იგი თუ არა.

                გლობალური კონტექსტი
                
                გლობალურ კონტექსტში this მიმართავს გლობალურ ობიექტს. ასეთ შემთხვევაში არა აქვს მნიშვნელობა, თუ რომელ რეჟიმში (მკაცრში თუ არამკაცრში) ხდება მისი გამოყენება.
                
                this.alert("global alert");
                this.console.log("global console");
                 
                var currentDocument = this.document;
                მოცემულ შემთხვევაში this საკვანძო სიტყვის გამოყენება პრაქტიკულად ზედმეტია.
                
                ფუნქციის კონტექსტი
                
                თუ სკრიპტის გაშვება ხდება მკაცრ რეჟიმში (დირეტივა "use strict"), this მიმართავს უშუალოდ ფუნქციის კონტექსტს, წინააღმდეგ შემთხვევაში - გარე კონტექსტს. მაგალითად:
                
                function foo(){
                    var bar = "bar2";
                    console.log(this.bar);
                }
                 
                var bar = "bar1";
                 
                foo();  // bar1
                მკაცრი რეჟიმის შემთხვევაში მივიღებდით შეცდომას undefined:
                
                "use strict";
                function foo(){
                    var bar = "bar2";
                    console.log(this.bar);
                }
                 
                var bar = "bar1";
                 
                foo();  // შეცდომა - this - undefined
                ობიექტის კონტექსტი
                
                ობიექტის კონტექსტში, მათ შორის მეთოდებშიც, საკვანძო სიტყვა this მიმართავს თვითონ ამ ობიექტს:
                
                var o = {
                    bar: "bar3",
                    foo: function(){
                        console.log(this.bar);
                    }
                }
                var bar = "bar1";
                o.foo();    // bar3
                მაგალითები
                
                განვიხილოთ ცოტა უფრო რთული მაგალითი:
                
                function foo(){
                    var bar = "bar2";
                    console.log(this.bar);
                }
                 
                var o3 = {bar:"bar3", foo: foo};
                var o4 = {bar:"bar4", foo: foo};
                 
                var bar = "bar1";
                 
                foo();      // bar1
                o3.foo();   // bar3
                o4.foo();   // bar4
                აქ განსაზღვრულია გლობალური ცვლადი bar. ასევე, ფუნქციაში foo()  გამოცხადებულია ლოკალური ცვლადი bar. რომელი ცვლადის მნიშვნელობას გამოიტანს ფუნქცია foo? ფუნქცია გამოიტანს გლობალურ ცვლადს, ვინაიდან სკრიპტი გაშვებულია რამკაცრ რეჟიმში, შესაბამისად საკვანძო სიტყვა this მიუთითებს გარე კონტექსტზე.
                
                სხვანაირადაა საქმე ობიექტებთან მიმართებაში. თითოეულ ობიექტში განსაზღვრულია თავისი თვისება bar. foo მეთოდის გამოძახებისას ის მიმართავს ფუნქციის გარე კონტექსტს, რაც ამ შემთხვევაში არის შესაბამისი ობიექტის კონტექსტი.
                
                ასეთმა ქცევამ ხანდახან შეიძლება გარკვეულ გაუგებრობამდე მიგვიყვანოს. განვიხილოთ ასეთი სიტუაცია:
                
                var o1 = {
                    bar: "bar1",
                    foo: function () {
                        console.log(this.bar);
                    }
                }
                var o2 = { bar: "bar2", foo: o1.foo };
                 
                var bar = "bar3";
                var foo = o1.foo;
                 
                o1.foo();   // bar1
                o2.foo();   // bar2
                foo();      // bar3
                მიუხედავად იმისა, რომ ობიექტი o2 იყენებს foo მეთოდს o1 ობიექტიდან, o1.foo ფუნქცია this მნიშვნელობის ძებნას იწყებს გარე კონტექსტში, ანუ o2 ობიექტის კონტექსტში. შესაბამისად ის აბრუნებს მნიშვნელობას "bar2". 
                
                იგივე ეხება გლობალურ ცვლადს foo. this.bar მნიშვნელობის ძებნას იწყებს გარე კონტექსტში, ანუ გლობალურ კონტექსტში და შესაბამისად მნიშვნელობად იღებს "bar3"-ს.
                
                თუმცა, თუ გამოვიძახებთ ფუნქციას მეორე ფუნქციიდან, გამოძახებული ფუნქცია ასევე მიმართავს გარე კონტექსტს:
                
                var bar = "bar2";
                 
                function daz(){
                   var bar = "bar5";
                   function maz(){       
                       console.log(this.bar);
                   }
                   maz();
                }
                daz();  // bar2
                აქ ფუნქცია maz-სთვის this.bar მიმართავს გარე კონტექსტს, ანუ daz ფუნქციის this.bar, თავის მხრივ, daz ფუნქციისთვის this მიმართავს გარე კონტექსტს, ანუ გლობალურ კონტექსტს, შესაბამისად საბოლოოდ ვღებულობთ "bar2" -ს და არა "bar5"-ს.
                
                ცხადი მიბმა
                
                call() და apply() მეთოდების მეშვეობით შეიძლება ფუნქცია მივაბათ განსაზღვრულ კონტექსტს:
                
                function foo(){
                    console.log(this.bar);
                }
                 
                var o3 = {bar: "bar3"}
                var bar = "bar1";
                foo();  // bar1
                foo.apply(o3);  // bar3
                // ან
                // foo.call(o3);
                მეორე შემთხვევაში ფუნქცია foo მიბმულია o3 ობიექტზე. ამიტომაც, ამ შემთხვევაში კონსოლში გამოიტანს "bar3"-ს.
                
                მეთოდი bind
                
                მეთოდი f.bind(o) საშუალებას გვაძლევს შევქმნათ ახალი ფუნქცია იგივე შიგთავსით და ხედვის იგივე არეალით, რაც აქვს f ფუნქციას, ოღონდ o ობიექტზე მიბმით:
                
                function foo(){
                    console.log(this.bar);
                }
                 
                var o3 = {bar: "bar3"}
                var bar = "bar1";
                foo();  // bar1
                var func = foo.bind(o3);
                func(); // bar3`
            },
         
            ]
        },{
            title:"თავი 5. ჩაშენებული ობიექტები",
            content:[
                {
                    title:"ობიექტი Date. თარიღებთან მუშაობა",
                    data:`ობიექტი Date ჯავასკრიპტში თარიღებთან მუშაობის საშუალებას გვაძლევს.

                    არსებობს Date ობიექტის შექმნის რამდენიმე ხერხი. პირველი მათგანი არის ცარიელი კონსტრუქტორის გამოყენება პარამეტრების გარეშე:
                    
                    var currentDate = new Date();
                    document.write(currentDate);
                    ამ დროს Date ობიექტი ღებულობს კომპიუტერის მიმდინარე თაღიღის და დროის მნიშვნელობას:
                    
                    JavaScript
                    
                    მეორე ხერხი მდგომარეობს კონსტრუქტორში პარამეტრად Unix ეპოქის დაწყებიდან, ანუ 1970 წლის 1 იანვრიდან (GMT 00:00:00) გასული მილიწამების გადაცემა:
                    
                    var myDate = new Date(1509825600000);
                    document.write(myDate); // Sun Nov 05 2017 00:00:00 GMT+0400 (Georgian Standard Time)
                    მესამე ხერხი მდგომარეობს კონსტრუქტორში პარამეტრად დღის, თვისა და წლის გადაცემაში:
                    
                    var myDate = new Date("27 October 2017");
                    // ან
                    // var myDate = new Date("27 Oct 2017");
                    // ან
                    // var myDate = new Date("10/27/2017");
                    // ან
                    // var myDate = new Date("10.27.2017");
                    // ან
                    // var myDate=new Date("2017-10-27");
                    document.write(myDate); // Fri Oct 27 2017 00:00:00 GMT+0400 (Georgian Standard Time)
                    თუ თვის დასახელება იწერება ტექსტურად, ის უნდა დაიწეროს ინგლისურად (სრულად ან შემოკლებით). ციფრებით ჩაწერის შემთხვევაში იწერება ფორმატით თვე/რიცხვი/წელი, ან წელი-თვე-რიცხვი.
                    
                    მეოთხე ხერხი მდგომარეობს თარიღის და დროის ყველა პარამეტრის გადაცემაში:
                    
                    var myDate = new Date(2016,11,25,18,30,20,10); // Sun Dec 25 2016 18:30:20 GMT+0400 (Georgian Standard Time)
                    ამ შემთხვევაში კონსტრუქტორში გადაეცემა პარამეტრები შემდეგი თანმიმდევრობით: new Date(წელი, თვე, რიცხვი, საათი, წუთი, წამი, მილიწამი). გასათვალისწინებელია, რომ თვეების ათვლა იწყება ნულიდან, ანუ იანვარი არის 0, დეკემბერი - 11.
                    
                    თარიღის და დროის კომპონენტების მიღება
                    
                    თარიღის და დროის კომპონენტების მისაღებად გამოიყენება შემდეგი მეთოდები:
                    
                    getDate(): აბრუნებს თვის რიცხვს;
                    getDay(): აბრუნებს კვირის დღეს (ათვლა იწყება 0-დან: 0 - კვირა, 6 - შაბათი);
                    getMonth(): აბრუნებს თვის ნომერს (ათვლა იწყება 0-დან: 0 - იანვარი, 11 - დეკემბერი);
                    getFullYear(): აბრუნებს წელს;
                    toDateString(): აბრუნებს სრულ თარიღს სტრიქონის სახით;
                    getHours(): აბრუნებს სასთს (0-დან 23-ის ჩათვლით);
                    getMinutes(): აბრუნებს წუთებს (0-დან 59-ის ჩათვლით);
                    getSeconds(): აბრუნებს წამებს(0-დან 59-ის ჩათვლით);
                    getMilliseconds(): აბრუნებს მილიწამებს (0-დან 999-ის ჩათვლით);
                    toTimeString(): აბრუნებს სრულ დროს სტრიქონის სახით.
                    მაგალითად:
                    
                    var days = ["კვირა","ორშაბათი","სამშაბათი","ოთხშაბათი","ხუთშაბათი","პარასკევი","შაბათი"];
                    var months = ["იანვარი","თებერვალი","მარტი","აპრილი","მაისი","ივნისი",
                                    "ივლისი","აგვისტო","სექტემბერი","ოქტომბერი","ნოემბერი","დეკემბერი"];
                                
                    var myDate = new Date();
                    var fullDate = "დღეს " + myDate.getFullYear() + " წლის " + myDate.getDate() + " " + months[myDate.getMonth()] + "ა" + ", " + days[myDate.getDay()];
                    document.write(fullDate); // დღეს 2017 წლის 10 ნოემბერია, პარასკევი
                    თვის და კვირის დღის რიცხვებიდან უფრო ჩვეულ ტექსტურ ფორმაში გადასაყვანად გამოიყენება მასივები. myDate.getDay() და myDate.getMonth() მეთოდების მეშვეობით ვღებულობთ შესაბამისად კვირის დღის და თვის ინდექსს, რომლის მიხედვითაც მასივებიდან ამოგვაქვს შესაბამისი მნიშვნელობები.
                    
                    ახლა მივიღოთ მიმდინარე დრო:
                    
                    var welcome;
                    var myDate = new Date();
                    var hour = myDate.getHours();
                    var minute = myDate.getMinutes();
                    var second = myDate.getSeconds();
                    if (minute < 10) {
                        minute = "0" + minute;
                    }
                    if (second < 10) {
                        second = "0" + second;
                    }
                    if (hour < 12) {
                        welcome = "დილა მშვიდობისა";
                    } else if (hour < 17) {
                        welcome = "დღე მშვიდობისა";
                    } else {
                        welcome = "საღამო მშვიდობისა";
                    }
                    document.write(welcome + ", მიმდინარე დროა: " + hour +
                                    ":" + minute + ":" + second); // საღამო მშვიდობისა, მიმდინარე დროა: 22:03:03
                    დროისა და თარიღის მინიჭება
                    
                    კონსტრუქტორში თარიღის და დროის პარამეტრების მითითების გარდა საჭირო თარიღის და დროის მისაღებად გამოიყენება ასევე Date ობიექტის დამატებითი მეთოდები:
                    
                    setDate(): რიცხვის მინიჭება თარიღისთვის;
                    setMonth(): თვის მინიჭება (ათვლა იწყება 0-დან);
                    setFullYear(): ანიჭებს წელს;
                    setHours(): ანიჭებს საათს;
                    setMinutes(): ანიჭებს წუთებს;
                    setSeconds(): ანიჭებს წამებს;
                    setMilliseconds(): ანიჭებს მილიწამებს.
                    მაგალითად:
                    
                    var days = ["კვირა","ორშაბათი","სამშაბათი","ოთხშაბათი","ხუთშაბათი","პარასკევი","შაბათი"];
                    var months = ["იანვარი","თებერვალი","მარტი","აპრილი","მაისი","ივნისი",
                                    "ივლისი","აგვისტო","სექტემბერი","ოქტომბერი","ნოემბერი","დეკემბერი"];
                                
                    var myDate = new Date();
                    myDate.setDate(15);
                    myDate.setMonth(6);
                    myDate.setYear(2017);
                     
                    var fullDate = myDate.getDate() + " " + months[myDate.getMonth()] +
                                    " " + myDate.getFullYear() + ", " + days[myDate.getDay()];
                    document.write(fullDate); // 15 ივლისი 2017, შაბათი
                    სიდიდის მინიჭების დროს ჩვენ შეგვიძლია გადავცეთ ისეთი მნიშვნელობა, რომელიც მაქსიმალურად დასაშვებს აღემატება. მაგალითად, თუ მივანიჭებთ საათების მნიშვნელობას 54 საათს myDate.setHour(54), მაშინ საათის მნიშვნელობა იქნება 54-2*24=6, ანუ 6 საათი, ხოლო დანარჩენი საათები შეადგენს 2 დღეს (2*24) და ეს ორი დღე დაემატება დღეებს. იგივე პრინციპი გამოიყენება თვეების, დღეების, წუთების, წამების და მილიწამებისთვის.`
                },
                {
                  title:"ობიექტი Math. მათემატიკური ოპერაციები",
                  data:`ობიექტი Math წარმოადგენს მათემატიკური ფუნქციების რიგს, რომლებიც შეიძლება გამოვიყენოთ გამოთვლებში. განვიხილოთ ძირითადი მათემატიკური ფუნქციები.

                  abs()
                  
                  ფუნქცია abs() აბრუნებს რიცხვის აბსოლუტურ მნიშვნელობას:
                  
                  var x = -25;
                  document.write(Math.abs(x)); // 25
                  var y = 34;
                  document.write(Math.abs(y)); // 34
                   
                  
                  min() და max()
                  
                  ფუნქციები min() და max() აბრუნებენ რიცხვების ერთობლიობიდან შესაბამისად მინიმალურ და მაქსიმალურ მნიშვნელობებს:
                  
                  var max = Math.max(19, 45); // 45
                  var min = Math.min(33, 24); // 24
                  არაა აუცილებელი, რომ ჩამონათვალში იყოს ორი რიცხვი, შესაძლებელია მეტიც:
                  
                  var max = Math.max(1, 2, 3, -9, 46, -23); // 46
                  ceil()
                  
                  ფუნქცია ceil() აბრუნებს რიცხვის უახლოეს მთელ რიცხვს, რომელიც მეტია ან ტოლი ამ რიცხვზე:
                  
                  var x = Math.ceil(9.2); // 10
                  var y = Math.ceil(-5.9); // -5
                  floor()
                  
                  ფუნქცია floor() აბრუნებს რიცხვის უახლოეს მთელ რიცხვს, რომელიც ნაკლებია ან ტოლი ამ რიცხვზე:
                  
                  var x = Math.floor(9.2); // 9
                  var y = Math.floor(-5.9); // -6
                  round()
                  
                  ფუნქცია round() ამრგვალებს რიცხვს უახლოეს მთელ რიცხვამდე, რომელიც მეტია ამ რიცხვზე, თუ რიცხვის ათწილადი ნაწილი მეტია ან ტოლი 0.5-ზე, წინააღმდეგ შემთხვევაში - ამრგვალებს უახლოეს მთელ რიცხვამდე, რომელიც ნაკლებია ან ტოლი ამ რიცხვზე:
                  
                  var x = Math.round(5.539); // 6
                  var y = Math.round(5.4); // 5
                  var z = Math.round(-5.4); // -5
                  var n = Math.round(-5.5); // -5
                  var m = Math.round(-5.6); // -6
                  console.log(x);
                  console.log(y);
                  console.log(z);
                  console.log(n);
                  random()
                  ფუნქცია random() აბრუნებს შემთხვევით რიცხვს 0-დან 1-მდე დიაპაზონში:
                  
                  var x = Math.random();
                  pow()
                  pow() ფუნქციას აჰყავს რიცხვი ხარისხში, მაგალითად ავიყვანოთ რიცხვი 2 მე-3 ხარისხში:
                  
                  var x = Math.pow(2, 3); // 8
                  sqrt()
                  
                  ფუნქცია sqrt() აბრუნებს კვადრატულ ფესვს მოცემული რიცხვიდან:
                  
                  var x = Math.sqrt(121); // 11
                  var y = Math.sqrt(9); // 3
                  var z = Math.sqrt(20); // 4.47213595499958
                  log()
                  
                  ფუნქცია log() აბრუნებს რიცხვის ნატურალურ ლოგარითმს:
                  
                  var x = Math.log(1); // 0
                  var z = Math.log(10); // 2.302585092994046
                  ტრიგონომეტრიული ფუნქციები
                  
                  ობიექტი Math შეიცავს რამდენიმე ტრიგონომეტრიულ ფუნქციას. ესენია:
                  
                  sin: ითვლის კუთხის სინუსს;
                  cos: ითვლის კუთხის კოსინუსს;
                  tan: ითვლის კუთხის ტანგენსს;
                  asin: ითვლის კუთხის არკსინუსს;
                  acos: ითვლის კუთხის არკკოსინუსს;
                  atan: ითვლის კუთხის არკტანგენსს.
                  გასათვალისწინებელია, რომ კუთხე იზომება რადიანებში და არა გრადუსებში. მაგალითად:
                  
                  var x = Math.sin(90); // 0.8939966636005579
                  var y = Math.cos(0); // 1
                  var z = Math.tan(45); // 1.6197751905438615
                  var x = Math.asin(0.9); // 1.1197695149986342
                  var y = Math.acos(1); // 1
                  var z = Math.atan(1); // 0.7853981633974483
                  კონსტანტები
                  
                  ფუქციების გარდა Math ობიექტი შეიცავს ასევე კონსტანტებს, რომლებიც შეიძლება გამოვიყენოთ გამოთვლებში:
                  
                  Math.PI (რიცხვი PI - წრეწირის სიგრძის შეფარდება დიამეტრთან): 3.141592653589793
                  Math.SQRT2 (კვადრატული ფესვი 2-დან): 1.4142135623730951
                  Math.SQRT1_2 (ნახევარი რიცხვისა კვადრატული ფესვი 2-დან): 0.7071067811865476
                  Math.E (რიცხვი e ანუ ეილერის რიცხვი): 2.718281828459045
                  Math.LN2 (2-ის ნატურალური ლოგარითმი): 0.6931471805599453
                  Math.LN10 (10-ის ნატურალური ლოგარითმი): 2.302585092994046
                  Math.LOG2E (e რიცხვის ლოგარითმო 2-ის ფუძით): 1.4426950408889634
                  Math.LOG10E (e რიცხვის ლოგარითმი 10-ის ფუძით): 0.4342944819032518
                  გამოვიყენოთ კონსტანტები გამოთვლებში:
                  
                  var x = Math.log(Math.E); // 1
                  var z = Math.tan(Math.PI/4); // 0.9999999999999999`
              },
              {
                  title:"ობიექტი Array. მასივებთან მუშაობა",
                  data:`ობიექტი Array წარმოადგენს მასივს და მას აქვს მეთოდები და თვისებები, რომელთა მეშვეობითაც შეიძლება მასივის მართვა.

                  მასივის ინიციალიზაცია
                  
                  ცარიელი მასივის შექმნა შესაძლებელია კვადრატული ფრჩხილების ან Array-ს კონსტრუქტორის გამოყენებით:
                  
                  var users = new Array();
                  var people = [];
                   
                  console.log(users); // Array[0]
                  console.log(people); // Array[0]
                  შეიძლება მასივის ინიციალიზაცია გარკვეული რაოდენობის ელემენტების შემცველობით:
                  
                  var users = new Array("Tom", "Bill", "Alice");
                  var people = ["Sam", "John", "Kate"];
                   
                  console.log(users); // ["Tom", "Bill", "Alice"]
                  console.log(people); // ["Sam", "John", "Kate"]
                  შეიძლება განვსაზღვროთ მასივი და შემდეგ შევავსოთ ელემენტებით:
                  
                  var users = new Array();
                  users[1] = "Tom";
                  users[2] = "Kate";
                  console.log(users[1]); // "Tom"
                  console.log(users[0]); // undefined
                  ამასთან არა აქვს მნიშვნელობა, რომ თავიდან მასივი შეიქმნა ნულოვანი სიგრძით. ინდექსების მეშვეობით შესაძლებელია ნებისმიერი ინდექსის მქონე ელემენტის დამატება. 
                  
                  მასივის სიგრძე. თვისება length()
                  
                  მასივის სიგრძის გასაგებად გამოიყენება თვისება length:
                  
                  var fruit = new Array();
                  fruit[0] = "ვაშლი";
                  fruit[1] = "მსხალი";
                  fruit[2] = "ქლიავი";
                   
                  document.write("fruit მასივში " + fruit.length + " ელემენტია: <br/>");
                  for(var i=0; i < fruit.length; i++)
                      document.write(fruit[i] + "<br/>");
                  ფაქტობრივად, მასივის სიგრძე არის მასივის ბოლო ელემენტის ინდექსს მიმატებული ერთი. მაგალითად:
                  
                  var users = new Array(); // მასივში 0 ელემენტია
                  users[0] = "Tom";
                  users[1] = "Kate";
                  users[4] = "Sam";
                  for(var i=0; i<users.length;i++)
                      console.log(users[i]);
                  შედეგად ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  მიუხედავად იმისა, რომ ჩვენ არ დაგვიმატებია მასივში ელემენტები ინდექსით 2 და 3, მასივის სიგრძე იქნება 5-ის ტოლი, უბრალოდ ელემენტებს ინდექსით 2 და 3 ექნებათ მნიშვნელობა undefined.
                  
                  ელემენტის დამატება მასივის ბოლოსი. მეთოდი push()
                  
                  მეთოდი push() ამატებს ელემენტს (ან ელემენტებს) მასივის ბოლოში:
                  
                  var fruit = [];
                  fruit.push("ვაშლი");
                  fruit.push("მსხალი");
                  fruit.push("ქლიავი");
                  fruit.push("ალუბალი", "ატამი");
                   
                  document.write("fruit მასივში " + fruit.length + " ელემენტია: <br/>");
                  document.write(fruit); // ვაშლი,მსხალი,ქლიავი,ალუბალი,ატამი
                  მასივის ბოლო ელემენტის წაშლა. მეთოდი pop()
                  
                  მეთოდი pop() აბრუნებს მასივის ბოლო ელემენტს და შლის მას:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი"];
                   
                  var lastFruit = fruit.pop(); // წავშალოთ მასივის ბოლო ელემენტი
                  document.write(lastFruit + "<br/>");
                  document.write("fruit მასივში " + fruit.length + " ელემენტია: <br/>");
                  document.write(fruit);
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  მასივის პირველი ელემენტის წაშლა. მეთოდი shift()
                  
                  მეთოდი shift() აბრუნებს მასივის პირველ ელემენტს და შლის მას:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი"];
                   
                  var firstFruit = fruit.shift(); // წავშალოთ მასივის პირველი ელემენტი
                  document.write(firstFruit + "<br/>");
                  document.write("fruit მასივში " + fruit.length + " ელემენტია: <br/>");
                  document.write(fruit);
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  ელემენტის დამატება მასივის დასაწყისში. მეთოდი unshift()
                  
                  მეთოდი unshift() ამატებს ელემენტს მასივის დასაწყისში:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი"];
                  var firstFruit = fruit.unshift("ატამი");
                  document.write(fruit);
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  ელემენტის წაშლა ინდექსის მიხედვით. მეთოდი splice()
                  
                  მეთოდი splice() შლის ელემენტს ინდექსის მიხედვით:
                  
                  fruit.splice(2);
                  დამატებითი პარამეტრის მეშვეობით შესაძლებელია მითითებული რაოდენობის ელემენტის წაშლა, დაწყებული რომელიღაც ელემენტიდან:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი","ალუბალი","ატამი"];
                  fruit.splice(1,2); // წავშალოთ 2 ელემენტი, დაწყებული ელემენტიდან ინდექსით 1
                  console.log(fruit); // ["ვაშლი","ალუბალი","ატამი"];
                  მეთოდის კიდევ ერთი ვერსია საშუალებას გვაძლევს წაშლილი ელემენტების ადგილას ჩავსვათ ახალი ელემენტები:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი","ალუბალი","ატამი"];
                  fruit.splice(1,2,"ყურძენი","მანგო","ბანანი");
                  console.log(fruit); // ["ვაშლი","ყურძენი","მანგო","ბანანი","ალუბალი","ატამი"];
                  მასივების გაერთიანება. მეთოდი concat()
                  
                  concat() მეთოდის დანიშნულებაა ორი მასივის გაერთიანება:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი"];
                  var vegetables = ["პომიდორი","კიტრი","კარტოფილი"];
                  var products = fruit.concat(vegetables);
                   
                  for(var i=0; i < products.length; i++)
                      document.write(products[i] + "<br/>");
                  ამასთან არაა აუცილებელი, რომ ეს მასივები იყოს ერთი ტიპის. შესაძლებელია სხვადასხვა ტიპის მასივების გაერთიანებაც:
                  
                  var fruit = ["ვაშლი","მსხალი","ქლიავი"];
                  var prices = [20, 30, 80];
                  var products = fruit.concat(prices);
                  მასივის ელემენტების კოპირება. მეთოდი slice()
                  
                  მეთოდი slice() აკოპირებს მასივის ნაწილს:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ალუბალი", "ატამი"];
                  var selectedFruit = fruit.slice(1, 4);
                   
                  document.write(selectedFruit); // მსხალი,ქლიავი,ალუბალი
                  მეთოდს გადაეცემა საწყისი და ბოლო ელემენტის ინდექსი, რომლის მიხედვითაც ხდება ელემენტების კოპირება მასივიდან. ამასთან, პირველი ელემენტი კოპირებულში შედის, ხოლო ბოლო ელემენტი - არა. მოცემულ შემთხვევაში კოპირებით მიღებულ მასივში იქნება 3 ელემენტი, რომელთა ინდექსიებია 1,2 და 3.
                  
                  მეთოდი join()
                  
                  მეთოდი join() აერთიანებს მასივის ყველა ელემენტს ერთ სტრიქონში:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ალუბალი", "ატამი"];
                  var fruitString = fruit.join(", ");
                  document.write(fruitString);  // ვაშლი, მსხალი, ქლიავი, ალუბალი, ატამი
                  მეთოდში პარამეტრად გადაეცემა სტრიქონში ელემენტების გამყოფი. მოცემულ შემთხვევაში მასივის ელემენტები სტრიქონში ერთმანეთისგან გამოიყოფა მძიმით და ცარიელი ადგილით (", ").
                  
                  ელემენტების სორტირება. მეთოდი sort()
                  
                  მეთოდი sort() ახდენს მასივის ელემენტების სორტირებას ზრდადობით:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ალუბალი", "ატამი"];
                  fruit.sort();
                   
                  for(var i=0; i < fruit.length; i++)
                     document.write(fruit[i] + "<br/>");
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  reverse()
                  
                  მეთოდი reverse() ატრიალებს მასივს უკუმიმართულებით:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ალუბალი", "ატამი"];
                  fruit.reverse();
                   
                  for(var i=0; i < fruit.length; i++)
                     document.write(fruit[i] + "<br/>");
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  sort() მეთოდთან კომბინაციაში მივიღებთ სორტირებას კლებადობით:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ალუბალი", "ატამი"];
                  fruit.sort().reverse();
                   
                  for(var i=0; i < fruit.length; i++)
                     document.write(fruit[i] + "<br/>");
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  ელემენტის ინდექსის ძებნა
                  
                  მეთოდები indexOf() და lastIndexOf() აბრუნებენ შესაბამისად მასივში ელემენტის პირველი და ბოლო ჩართვის ინდექსს:
                  
                  var fruit = ["ვაშლი", "მსხალი", "ქლიავი", "ვაშლი", "ატამი"];
                  var firstIndex = fruit.indexOf("ვაშლი");
                  var lastIndex = fruit.lastIndexOf("ვაშლი");
                  var otherIndex = fruit.indexOf("ალუბალი");
                  document.write(firstIndex); // 0
                  document.write(lastIndex);  // 3
                  document.write(otherIndex); // -1
                  firstIndex-ს აქვს მნიშვნელობა 0, რადგან "ვაშლი" ელემენტის მასივში პირველი ჩართვის ინდექსია 0, ხოლო ამ ელემენტის ბოლო ჩართვის ინდექსია 3. თუ ელემენტი მასივში არ მოიძებნება, ორივე მეთოდი აბრუნებს -1-ს.
                  
                  every()
                  
                  მეთოდი every() ამოწმებს, მასივის ყველა ელემენტი აკმაყოფილებს თუ არა გარკვეულ პირობას:
                  
                  var numbers = [ 1, -12, 8, -4, 25, 42 ];
                  function condition(value, index, array) {
                      var result = false;
                      if (value > 0) {
                          result = true;
                      }
                      return result;
                  };
                  var passed = numbers.every(condition);
                  document.write(passed); // false
                   every() მეთოდს პარამეტრად გადაეცემა ფუნქცია (condition), რომელიც ამოწმებს პირობას. ამ ფუნქციას გააჩნია 3 პარამეტრი: პარამეტრი value წარმოადგენს მასივის მიმდინარე ელემენტს, index - ამ ელემენტის ინდექსს, ხოლო პარამეტრი array წარმოადგენს მასივს.
                  
                  ამ ფუნქციით მოწმდება, აკმაყოფილებს თუ არა მასივის ელემენტი გარკვეულ პირობას. მოცემულ შემთხვევაში მოწმდება, მასივის ელემენტი მეტია თუ არა 0-ზე. თუ პირობა სრულდება, ბრუნდება true, წინააღმდეგ შემთხვევაში -  false.
                  
                  საბოლოოდ, numbers.every(condition)  მეთოდის გამოძახებისას ხდება numbers მასივის გადარჩევა, რომლის დროსაც მასივის ტიტოეული ელემენტი გადაეცემა ფუნქციას condition. თუ მასივის ერთი ელემენტი მაინც არ აკმაყოფილებს პირობას, მეთოდი აბრუნებს false-ს, ხოლო თუ ყველა ელემენტი აკმაყოფილებს - აბრუნებს true-ს.
                  
                  some()
                  
                  მეთოდი some() მეთოდის every() მსგავსია, ორონდ ის ამოწმებს, მასივის ერთი ელემენტი მაინც თუ აკმაყოფილებს პირობას. თუ ერთი მაინც აკმაყოფილებს, მეთოდი some() აბრუნებს true-ს, თუ არა და - false-ს:
                  
                  var numbers = [ 1, -12, 8, -4, 25, 42 ];
                  function condition(value, index, array) {
                      var result = false;
                      if (value === 8) {
                          result = true;
                      }
                      return result;
                  };
                  var passed = numbers.some(condition); // true
                  filter()
                  
                  მეთოდი filter(), ისევე როგორც some() და every(), პარამეტრად იღებს ფუნქციას, მაგრამ აბრუნებს იმ ელემენტების მასივს, რომლებიც აკმაყოფილებენ ფუნქციით განსაზღვრულ პირობას:
                  
                  var numbers = [ 1, -12, 8, -4, 25, 42 ];
                  function condition(value, index, array) {
                      var result = false;
                      if (value > 0) {
                          result = true;
                      }
                      return result;
                  };
                  var filteredNumbers = numbers.filter(condition);
                   
                  for(var i=0; i < filteredNumbers.length; i++)
                      document.write(filteredNumbers[i] + "<br/>");
                  ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  forEach() და map()
                  
                  მეთოდები forEach() და map() ახდენენ მასივის ელემენტების გადარჩევას და ასრულებენ მათზე გარკვეულ მოქმედებებს. მაგალითად, მასივში შემავალი რიცხვების კვადრატების გამოსათვლელად შეიძლება გამოვიყენოთ შემდეგი კოდი:
                  
                  var numbers = [ 1, 2, 3, 4, 5, 6];
                  for(var i = 0; i<numbers.length; i++){
                      
                      var result = numbers[i] * numbers[i];
                      
                      document.write("რიცხვი " + numbers[i] + " კვადრატში ტოლია " + result + "<br/>");
                  }
                  forEach() მეთოდის დახმარებით შესაძლოა ამ კოდის გამარტივება:
                  
                  var numbers = [ 1, 2, 3, 4, 5, 6];
                   
                  function square(value, index, array) {
                   
                     var result = value * value;
                     document.write("რიცხვი " + value + " კვადრატში ტოლია " + result + "<br/>");
                  };
                   
                  numbers.forEach(square);
                  მეთოდი forEach() პარამეტრად ღებულობს ფუქციას, რომელსაც გადარჩევის დროს გადაეცემა მიმდინარე ელემენტი და ხდება ამ ელემენტზე ფუნქციით განსაზღვრული მოქმედებების შესრულება.
                  
                  მეთოდი  map() მეთოდის forEach() მსგავსია. მასაც გადაეცემა ფუნქცია, რომელსაც გადარჩევის დროს გადაეცემა მიმდინარე ელემენტი და ხდება ამ ელემენტზე ფუნქციით განსაზღვრული მოქმედებების შესრულება, მაგრამ განსხვავებით forEach()-ისგან, მეთოდი map() აბრუნებს ფუნქციით განსაზღვრული მოქმედებების შედეგად მიღებული ელემენტების ახალ მასივს:
                  
                  var numbers = [ 1, 2, 3, 4, 5, 6];
                   
                  function square(value, index, array) {   
                     return result = value * value;
                  };
                   
                  var squareArray = numbers.map(square);
                  document.write(squareArray);`
              },
              {
                  title:"ობიექტი Number",
                  data:`ობიექტი Number წარმოადგენს რიცხვებს. რიცხვის შესაქმნელად კონსტრუქტორში უნდა გადავცეთ რიცხვი ან სტრიქონი, რომელიც წარმოადგენს რიცხვს:

                  var x = new Number(34);
                  var y = new Number('42');
                  document.write(x+y); // 76
                  თუმცა Number ობიექტის შექმნა შესაძლებელია უფრო მარტივადაც, ცვლადზე რიცხვითი მნიშვნელობის მინიჭებით:
                  
                  var z = 34;
                  Number ობიექტს გააჩნია თვისებები და მეთოდები. ვნახოთ ზოგიერთი მისი თვისება:
                  
                  Number.MAX_VALUE: უდიდესი შესაძლო დადებითი რიცხვი, დაახლოებით ტოლია 1.79E+308. ამ ამნიშვნელობაზე დიდი რიცხვები განიხილება როგორც Infinity
                  Number.MIN_VALUE: უმცირესი შესაძლო დადებითი რიცხვი - 5e-324 (პრაქტიკულად ნულის ტოლია)
                  Number.NaN: სპეციალური მნიშვნელობა, რომელიც მიუთითებს, რომ ობიექტი არ წარმოადგენს რიცხვს
                  Number.NEGATIVE_INFINITY: მნიშვნელობა, რომელიც აღნიშნავს უარყოფით განუსაზღვრელობას და რომელიც წარმოიშვება გადავსებისას. მაგალითად, ორი უარყოფითი რიცხვის შეკრებისას, რომელთა მოდულიც ტოლია Number.MAX_VALUE. მაგალითად:
                  var x = -1 * Number.MAX_VALUE
                  var y = -1 * Number.MAX_VALUE
                  var z = x + y;
                  if(z===Number.NEGATIVE_INFINITY)
                      document.write("უარყოფითი განუსაზღვრელობა");
                  else
                      document.write(z);
                  Number.POSITIVE_INFINITY: დადებითი განუსაზღვრელობა. ისევე, როგორც უარყოფითი განუსაზღვრელობა, მიიღება გადავსებისას. მაგალითად:
                  var x = Number.MAX_VALUE
                  var y = Number.MAX_VALUE
                  var z = x * y;
                  if(z===Number.POSITIVE_INFINITY)
                      document.write("უარყოფითი განუსაზღვრელობა");
                  else
                      document.write(z);
                  ზოგიერთი ძირითადი მეთოდი:
                  
                  isNaN(): განსაზღვრავს, არის თუ არა ობიექტი რიცხვი. თუ ობიექტი რიცხვია, აბრუნებს false-ს, თუ არა და - true-ს:
                  var a = Number.isNaN(Number.NaN); // true
                  var b = Number.isNaN(true); // false - new Number(true) = 1
                  var c = Number.isNaN(null);  // false - new Number(null) = 0
                  var d = Number.isNaN(25);  // false
                  var e = Number.isNaN("54"); // false
                  მაგრამ შემდეგი გამოსახულება აბრუნებს false-ს, Tუმცა ობიექტი არაა რიცხვი:
                  
                  var f = Number.isNaN("hello"); // false
                  მსგავსი სიტუაციის თავიდან ასაცილებლად, უმჯობესია გამოვიყენოთ გლობალური ფუნქცია isNaN:
                  
                  var f = isNaN("hello"); // true
                  parseFloat(): გარდაქმნის სტრიქონს ათწილადად:
                  var a = Number.parseFloat("34.90"); // 34.9
                  document.write(a);
                  var b = Number.parseFloat("hello"); // NaN
                  document.write(b);
                  var c = Number.parseFloat("34hello"); // 34
                  document.write(c);
                  parseInt: გარდაქმნის სტრიქონს მთელ რიცხვად. მაგალითად:
                  var a = Number.parseInt("34.90"); // 34
                  document.write(a);
                  var b = Number.parseInt("hello"); // NaN
                  document.write(b);
                  var c = Number.parseInt("25hello"); // 25
                  document.write(c);
                  toFixed(): ტოვებს ათწილადის წილად ნაწილში ციფრების მითითებულ რაოდენობას. მაგალითად:
                  
                  var a =  10 / 1.44;
                  document.write("toFixed() მეთოდამდე: " + a + "<br/>");
                  a = a.toFixed(2); // დავტოვოთ ორი ციფრი წილად ნაწილში
                  document.write("toFixed() მეთოდის შემდეგ: " + a + "<br/>");`
              },
            
            ]
        },{
            title:"თავი 6. სტრიქონები",
            content:[
                {
                    title:"ობიექტი String",
                    data:`სტრიქონებთან სამუშაოდ განკუთვნილია ობიექტი String. სტრიქონის შექმნა შესაძლებელია ცვლადზე სტრიქონის მინიჭებით:

                    var name = "Tom";
                    ასევე შესაძლებელია კონსტრუქტორის გამოყენება:
                    
                    var name = new String("Tom");
                    თუმცა, როგორც წესი, გამოიყენება პირველი, უფრო მოკლე ვარიანტი.ამ დროს. საჭიროებისას, ჯავასკრიპტი თვიტონ გარდაქმნის პრიმიტიული ტიპის ცვლადს სტრიქონად:
                    
                    String ობიექტს გააჩნია დიდი რაოდენობის თვისება და მეთოდი, რომელთა მეშვეობითაც შეიძლება სტრიქონებზე მანიპულირება.
                    
                    თვისება length წარმოადგენს სტრიქონის სიგრძეს:
                    
                    var hello = "გამარჯობა, სამყაროვ!";
                    document.write("სტრიქონში '" + hello + "' " + hello.length + " სიმბოლოა");
                    ძებნა სტრიქონში
                    
                    სტრიქონსი ქვესტრიქონის მოსაძებნად გამოიყენება მეთოდები indexOf() (პირველი ჩართვის ინდექსის მოსაძებნად) და  lastIndexOf() (ბოლო ჩართვის ინდექსის მოსაძებნად). ეს მეთოდები იღებენ 2 პარამეტრს:
                    
                    ქვესტრიქონი, რომელსაც ვეძებთ
                    არააუცილებელი პარამეტრი, რომელიც მიუთითებს, ტუ რომელი სიმბოლოდან იწყება ძებნა
                    ორივე მეთოდი აბრუნებს იმ სიმბოლოს ინდექსს, რომლითაც იწყება ქვესტრიქონი. თუ ქვესტრიქონი არ მოიძებნა, ბრუნდება რიცხვი -1.
                    
                    var hello = "გამარჯობა, სამყაროვ! ნახვამდის, სამყაროვ!";
                    var key = "სამყარო";
                    var firstPos = hello.indexOf(key);
                    var lastPos = hello.lastIndexOf(key);
                    document.write("პირველი ჩართვა: " + firstPos + "<br />");
                    document.write("ბოლო ჩართვა: " + lastPos + "<br />");
                    ბრაუზერში გამოვა:
                    
                    JavaScript
                    
                    ქვესტრიქონის ამოჭრა
                    
                    ქვესტრიქონის ამოსაჭრელად გამოიყენება მეთოდები substring(). და substr().
                    
                    მეთოდი substring() ღებულობს ორ პარამეტრს:
                    
                    სტრიქონში იმ სიმბოლოს ინდექსი, საიდანაც უნდა დაიწყოს ამოსაჭრელი ქვესტრიქონი
                    იმ სიმბოლოს ინდექსი, სადამდეც გრძელდება ქვესტრიქონი
                    var hello = "გამარჯობა, სამყაროვ! ნახვამდის, სამყაროვ!";
                    var world = hello.substring(11, 18); // მე-11-დან მე-18-მდე
                    document.write(world); // სამყარო
                    მეთოდი  substr() პირველ პარამეტრად ასევე იღებს იმ სიმბოლოს ინდექსს, საიდანაც უნდა დაიწყოს ამოსაჭრელი ქვესტრიქონი, ხოლო მეორე პარამეტრი მიუთითებს ამოსაჭრელი ქვეტექსტის სიგრძეს:
                    
                    var hello = "გამარჯობა, სამყაროვ! ნახვამდის, სამყაროვ!";
                    var world = hello.substr(11, 7); // მე-11-დან 7 სიმბოლო
                    document.write(world); // სამყარო
                    თუ მე-2 პარამეტრი არ ეთითება, ამოიჭრება ქვესტრიქონი ბოლომდე:
                    
                    var hello = "გამარჯობა, სამყაროვ! ნახვამდის, სამყაროვ!";
                    var bye = hello.substr(21); // მე-21-დან 
                    document.write(bye); // ნახვამდის, სამყაროვ!
                    სიმბოლოების რეგისტრის მართვა
                    
                    სიმბოლოების რეგისტრის შესაცვლელად გამოიყენება მეთოდები toLowerCase() (დაბალ რეგისტრში გადასაყვანად) და toUpperCase()  (მაღალ რეგისტრში გადასაყვანად):
                    
                    var hello = "Hello, Tom";
                    document.write(hello.toLowerCase() + "<br/>"); // hello, tom
                    document.write(hello.toUpperCase() + "<br/>"); // HELLO, TOM
                    ინდექსის მიხედვით სიმბოლოს მიღება
                    
                    რომ მივიროთ განსაზღვრული სიმბოლო სტრიქონიდან ინდექსის მიხედვით, გამოიყენება მეთოდები charAt() და charCodeAt(). ორივე მეთოდი პარამეტრად იღებს სიმბოლოს ინდექსს, მაგრამ თუ პირველი აბრუნებს თვითონ ამ სიმბოლოს, მეორე მეტოდი აბრუნებს ამ სიმბოლოს კოდს:
                    
                    var hello = "გამარჯობა, სამყაროვ!";
                    document.write(hello.charAt(2) + "<br/>"); // მ
                    document.write(hello.charCodeAt(2) + "<br/>"); // 4315
                    სტრიქონის თავში და ბოლოში ცარიელი ადგილების მოშორება
                    
                    სტრიქონის თავში და ბოლოში ცარიელი ადგილების მოსაშორებლად გამოიყენება მეთოდი trim():
                    
                    var hello = "   გამარჯობა, სამყაროვ!  ";
                    var beforeLength = hello.length;
                    hello = hello.trim();
                    var afterLength = hello.length;
                    document.write("სიგრძე მოშორებამდე: " + beforeLength +  "<br/>"); // 25
                    document.write("სიგრძე მოშორების შემდეგ: " + afterLength +  "<br/>"); // 20
                    სტრიქონების გაერთიანება
                    
                    მეთოდი concat() აერთიანებს ორ სტრიქონს:
                    
                    var hello = "გამარჯობა, ";
                    var world = "სამყაროვ!";
                    hello = hello.concat(world);
                    document.write(hello); // გამარჯობა, სამყაროვ!
                    ქვესტრიქონის ამოცვლა
                    
                    მეთოდი replace() ახდენს პირველად შეხვედრილი ერთი ქვესტრიქონის ამოცვლას მეორით:
                    
                    var hello = "დილა მშვიდობის!";
                    hello = hello.replace("დილა", "საღამო");
                    document.write(hello); // საღამო მშვიდობის!
                    პირველი პარამეტრი მიუთითებს, თუ რომელი ქვესტრიქონი უნდა ამოიცვალოს, ხოლო მეორე - რით უნდა ამოიცვალოს.
                    
                    სტრიქონის დაყოფა
                    
                    მეთოდი split() ახდენს სტრიქონის დაყოფას და მასივად გარდაქმნას განსაზღვრული გამყოფით. გამყოფად გამოიყენება ქვესტრიქონი, რომელიც გადაეცემა მეთოდს პარამეტრად:
                    
                    var message = "დღეს მშვენიერი ამინდია";
                    var stringArray = message.split(" ");
                    for(var str in stringArray)
                        document.write(stringArray[str] + "<br/>");`
                },
                {
                  title:"ობიექტი RegExp. რეგულარული გამოსახულებები",
                  data:`რეგულარული გამოსახუება წარმოადგენს შაბლონს, რომელიც გამოიყენება სტრიქონის მოსაძებნად ან მოდიფიკაციისთვის. რეგულარულ გამოსახულებებტან სამუშაოდ ჯავასკრიპტში გამოიყენება ობიექტი RegExp.

                  რეგულარული გამოსახულების განსაზღვრა შესაძლებელია ორი ხერხით:
                  
                  var myExp = /hello/;
                  var myExp = new RegExp("hello");
                  პირველ შემთხვევაში სიტყვა hello მოთავსებულია ორ დახრილ ხაზს შორის, მეორე შემთხვევაში გამოიყენება კონსტრუქტორი. ორივე მათგანი განსაზღვრავს ერთი და იგივე რეგულარულ გამოსახულებას, რომელიც ერთი სიტყვისგან შედგება.
                  
                  RegExp ობიექტის მეთოდები
                  
                  იმის გასაგებად, შეესაბამება თუ არა სტრიქონი რეგულარულ გამოსახულებას, გამოიყენება მეთოდი test(). ეს მეთოდი აბრუნებს true-ს, თუ სტრიქონი შეესაბამება რეგულარულ გამოსახულებას, წინააღმდეგ შემთხვევაში ბრუნდება false.
                  
                  var initialText = "hello world!";
                  var exp = /hello/;
                  var result = exp.test(initialText);
                  document.write(result + "<br/>"); // true
                   
                  initialText = "beautifull wheather";
                  result = exp.test(initialText);
                  document.write(result); // false - სტრიქონში initialText არაა "hello"
                  ანალოგიურად მოქმედებს მეთოდი exec(), ის ასევე ამოწმებს, შეესაბამება ტუ არა სტრიქონი რეგულარულ გამოსახულებას, ოღონდ ეს მეთოდი აბრუნებს სტრიქონის იმ ნაწილს, რომელიც შეესაბამება რეგულარულ გამოსახულებას. თუ შესაბამისობა არაა, ბრუნდება null.
                  
                  var initialText = "hello world!";
                  var exp = /hello/;
                  var result = exp.exec(initialText);
                  document.write(result + "<br/>"); // hello
                   
                  initialText = "beautifull wheather";
                  result = exp.exec(initialText);
                  document.write(result); // null
                  სიმბოლოთა ჯგუფები
                  
                  არაა აუცილებელი, რომ რეგულარული გამოსახულება შედგებოდეს ჩვეულებრივი სტრიქონისაგან. ის შეიძლება შედგებოდეს რეგულარული გამოსახულების სპეციალური სინტაქსით შედგენილი ელემენტებისაგან. ერთ-ერთ ასეთ ელემენტს წარმოადგენს კვადრატულ ფრჩხილებში ჩასმული სიმბოლოების ჯგუფი. მაგალითად:
                  
                  var initialText = "თავდაცვისუნარიანობა";
                  var exp = /[აბგ]/;
                  var result = exp.test(initialText);
                  document.write(result + "<br/>"); // true
                   
                  initialText = "სოფელი";
                  result = exp.test(initialText);
                  document.write(result); // false
                  გამოსახულება [აბგ] მიუთითებს, რომ სტრიქონი უნდა შეიცავდეს კვადრატულ ფრჩხილებში ჩასმული სიმბოლოებიდან ერთ-ერთს მაინც.
                  
                  თუ გვინდა განვსაზღვროთ, შეიცავს თუ არა სტრიქონი სიმბოლოს მოცემული დიაპაზონიდან, შეიძლება მივუთითოთ დიაპაზონი:
                  
                  var initialText = "თავდაცვისუნარიანობა";
                  var exp = /[ა-ჰ]/;
                  var result = exp.test(initialText);
                  document.write(result + "<br/>"); // true
                   
                  initialText = "3d9tiR12";
                  result = exp.test(initialText);
                  document.write(result); // false
                  მოცემულ შემთხვევაში სტრიქონი უნდა შეიცავდეს სიმბოლოს ა-ჰ დიაპაზონიდან.
                  
                  თუ, პირიქით, არ გვინდა, რომ სტრიქონი შედგებოდეს მხოლოდ არჩეული დიაპაზონის სიმბოლოებისაგან, სიმბოლოთა ჩამონათვალის წინ უნდა იყოს ნიშანი ^":
                  
                  var initialText = "თავდაცვისუნარიანობა";
                  var exp = /[^ა-ჰ]/;
                  var result = exp.test(initialText);
                  document.write(result + "<br/>"); // false
                   
                  initialText = "3d9tiR12";
                  result = exp.test(initialText);
                  document.write(result); // true
                  პირველ შემთხვევაში სტრიქონი არ უნდა შეიცავდეს სიმბოლოებს მხოლოდ ა-ჰ დიაპაზონიდან, მაგრამ ვინაიდან სტრიქონი "თავდაცვისუნარიანობა" მხოლოდ ამ დიაპაზონის სიმბოლოებისგან შედგებამ მეტოდი test() აბრუნებს false-ს.
                  
                  მეორე შემთხვევაში სტრიქონი "3d9tiR12" გარდა 0-9 დიაპაზონის სიმბოლოებისა შეიცავს სხვა სიმბოლოებსაც, მეთოდი test() აბრუნებს true-ს.
                  
                  საჭიროებისას, შესაძლოა გამოსახულებების კომბინაციის გამოყენება:
                  
                  var initialText = "ბალი";
                  var exp = /[ბგ]ა[ნლ]/;
                  var result = exp.test(initialText);
                  document.write(result); // true
                  გამოსახულება [ბგ]ა[ნლ] მიუთითებს, რომ სტრიქონი უნდა შეიცავდეს "ბან", "ბალ", "გან", "გალ" ქვესტრიქონებიდან ერთ-ერთს.
                  
                  რეგულარული გამოსახულების თვისებები
                  
                  global: ეს თვისება საშუალებას იძლევა მოვძებნოთ ყველა ქვესტრიქონი, რომელიც შეესაბამება რეგულარულ გამოსახულებას. მიუთითებლობისას, ქვესტრიქონის ძებნისას რეგულარული გამოსახულება ირჩევს პირველივე შემხვედრ შესაბსამისობას, თუმცა სტრიქონში შეიძლება იყოს რამდენიმე შესაბამისობა. ამისათვის გამოიყენება ეს თვისება g სიმბოლოს სახით რეგულარულ გამოსახულებაში;
                  ignoreCase: ეს თვისება საშუალებას იძლევა მოვძებნოთ შესაბამისობა რეგისტრის მიუხედავად. ამისათვის გამოიყენება სიმბოლო i რეგულარულ გამოსახულებაში;
                  multiline: ეს თვისება საშუალებას იძლევა მოვძებნოთ შესაბამისობები მრავალსტრიქონიან ტექსტში. ამისათვის რეგულარულ გამოსახულებაში გამოიყენება სიმბოლო m.
                  მაგალითად:
                  
                  var initialText = "Hello, World!";
                  var exp = /world/;
                  var result = exp.test(initialText); // false
                  აქ არაა სტრიქონის შესაბამისობა გამოსახულებასთან, რადგან სიტყვა "World" განსხვავდება "world"-ისაგან პირველი სიმბოლოს რეგისტრის გამო. თუ გამოვიყენებთ თვისებას ignoreCase, მაშინ ადგილი ექნება შესაბამისობას:
                  
                  var exp = /world/i;
                  შეიძლება ერთდროულად რამდენიმე თვისების გამოყენებაც:
                  
                  var exp = /world/ig;`
              },
              {
                  title:"რეგულარული გამოსახულება String ობიექტის მეთოდებში",
                  data:`String ობიექტის ზოგიერთ მეთოდში შესაძლებელია რეგულარული გამოსახულების გამოყენება.

                  სტრიქონის დაყოფა. მეთოდი split
                  
                  split მეთოდში შესაძლებელია რეგულარული გამოსახულების გამოყენება. მაგალითად, დავყოთ წინადადება სიტყვებად:
                  
                  var initialText = "დღეს ძალიან კარგი ამინდია";
                  var exp = /\s/;
                  var result = initialText.split(exp);
                  result.forEach(function(value, index, array){    
                      document.write(value + "<br/>");
                  });
                  \s რეგულარულ გამოსახულებაში ნიშნავს ცარიელ ადგილს (space).შესაბამისად, წინადადება დაიყოფა სიტყვებად და ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  მეთოდი match
                  
                  სტრიქონში ყველა შესაბამისობის მოსაძებნად გამოიყენება მეთოდი match():
                  
                  var initialText = "ის შევიდა კლასში და დაიწყო საკლასო დავალების წერა";
                  var exp = /[ა-ჰ]*კლას[ა-ჰ]*/gi;
                  var result = initialText.match(exp);
                  result.forEach(function(value, index, array){    
                      document.write(value + "<br/>");
                  });
                  [ა-ჰ ]დიაპაზონის შემდეგ სიმბოლო * უთითებს, რომ შეიძლება გამოყენებული იყოს ნებისმიერი რაოდენობის სიმბოლო ა-დან ჰ-მდე. შესაბამისად, მოიძებნება ყველა ის სიტყვა, რომელსაც "კლას"-ის წინდ და შემდეგ ექნება ნებისმიერი რაოდენობის ქართული ანბანის ასოები. შესაბამისად, მასივში result აღმოჩნდება სიტყვები "კლასში" და "საკლასო".
                  
                  ძებნა სტრიქონში. მეთოდი search
                  
                  მეთოდი search ეძებს საძებნი შესაბამისობის პირველ ჩართვას სტრიქონში:
                  
                  var initialText = "hello world";
                  var exp = /wor/;
                  var result = initialText.search(exp);
                  document.write(result); // 6
                  ამოცვლა. მეთოდი replace
                  
                  მეთოდი replace საშუალებას გვაძლევს რეგულარული გამოსახულების ყველა შესაბამისობა ამოვცვალოთ განსაზღვრული სტრიქონით:
                  
                  var menu = "საუზმე: ფაფა, ჩაი. სადილი: სუპი, ჩაი. ვახშამი: სალათა, ჩაი.";
                  var exp = /ჩაი/gi;
                  menu = menu.replace(exp, "კოფე");
                  document.write(menu);`
              },
              {
                  title:"რეგულარული გამოსახულების სინტაქსი",
                  data:`განვიხილოთ რეგულარული გამოსახულების სინტაქსის ძირითადი მომენტები.

                  მეტასიმბოლოები
                  
                  რეგულარულ გამოსახულებებსი გამოიყენება მეტასიმბოლოები - სიმბოლოები, რომელთაც აქვთ განსაზღვრული აზრი:
                  
                  \d: შეესაბამება ნებისმიერ ციფრს 0-დან 9-ის ჩათვლით;
                  \D: შეესაბამება ნებისმიერ სიმბოლოს, რომელიც არაა ციფრი;
                  \w: შეესაბამება ლათინური ანბანის ნებისმიერ ასოს, ციფრს (დიაპაზონი A–Z, a–z, 0–9) ან გახაზვის სიმბოლოს;
                  \W: შეესაბამება ნებისმიერ სიმბოლოს, გარდა ლათინური ანბანის ასოებისა, ციფრებისა (დიაპაზონი A–Z, a–z, 0–9) და გახაზვის სიმბოლოსი;
                  \s: შეესაბამება ცარიელ ადგილს (space);
                  \S: შეესაბამება ნებისმიერ სიმბოლოს, გარდა ცარიელი ადგილისა (space);
                  .: შეესაბამება ნებისმიერ სიმბოლოს.
                  გასათვალისწინებელია, რომ \w გამოიყენება მხოლოდ ლათინური ანბანის ასოებისთვის, უნიკოდის სიმბოლოებისთვის მას ვერ გამოვიყენებთ.
                  
                  სტანდარტული ტელეფონის ნომრის +1-234-567-8901 შესაბამის რეგულარულ გამოსახულებას ექნება შემდეგი სახე: /\d-\d\d\d-\d\d\d-\d\d\d\d/. მაგალითად, ამოვცვალოთ ტელეფონის ნომერი:
                  
                  var phoneNumber = "+1-234-567-8901";
                  var myExp = /\d-\d\d\d-\d\d\d-\d\d\d\d/;
                  phoneNumber = phoneNumber.replace(myExp, "00000000000");
                  document.write(phoneNumber);
                  მოდიფიკატორები
                  
                  რეგულარული გამოსახულების ზემოთ განხილული ელემენტების გარდა არის კიდევ ერთი ჯგუფი, რომელიც მიუთითებს, თუ როგორ უნდა მეორდებოდეს სიმბოლოები სტრიქონში. ასეთ კომბინაციებს უწოდებენ მოდიფიკატორებს:
                  
                  {n}: მიუთითებს, რომ წინა სიმბოლო მეორდება n-ჯერ. მაგალითად, h{3} შეესაბამება ქვესტრიქონს "hhh".
                  {n,}: მიუთითებს, რომ წინა სიმბოლო მეორდება n-ჯერ ან მეტჯერ. მაგალითად, h{3,} შეესაბამება ქვესტრიქონებს "hhh", "hhhh", "hhhhh" და ა. შ.
                  {n,m}: შეესაბამება წინა სიმბოლოს n-დან m-მდე განმეორებას. მაგალითად, h{2, 4} შეესაბამება ქვესტრიქონებს "hh", "hhh", "hhhh".
                  ?: შეესაბამება ერთ წინა სიმბოლოს ან მის არარსებობას სტრიქონში. მაგალითად, /h?ome/ შეესაბამება ქვესტრიქონებს "home" და "ome".
                  +: შეესაბამება წინა სიმბოლოს ერთ ან მეტ განმეორებას.
                  *: შეესაბამება წინა სიმბოლოს ნებისმიერი რაოდენობის განმეორებას ან მის არარსებობას.
                  ^: შეესაბამება სტრიქონის დასაწყისს. მაგალითად, ^h შეესაბამება სტრიქონს "home", მაგრამ არ შეესაბამება "ohma"-ს, რადგან h უნდა იყოს დასაწყისში.
                  $: შეესაბამება სტრიქონის დასასრულს, ი$ შეესაბამება სტრიქონს "სახლი", რადგანაც სტრიქონი ბოლოვდება "ი" ასოთი.
                  მაგალითად, ავიღოთ ისევ ტელეფონის ნომერი, რომელსაც შეესაბამება რეგულარული გამოსახულება \d-\d\d\d-\d\d\d-\d\d\d\d. თუმცა, მოდიფიკატორების მეშვეობით შეიძლება იგი გავამარტივოთ: \d-\d{3}-\d{3}-\d{4}.
                  
                  აქვე უნდა აღინიშნოს, რომ სიმბოლოებს ?, +, * აქვთ განსაკუთრებული აზრი რეგულარულ გამოსახულებებში. თუ გვინდა მათი გამოყენება ჩვეულებრივი მნიშვნელობით (მაგალითად, ნიშანი მინუსის შესაცვლელად პლუსით), უნდა მოხდეს მათი ეკრანირება სლეშის (\) მეშვეობით: 
                  
                  var phoneNumber = "+1-234-567-8901";
                  var myExp = /\+\d-\d{3}-\d{3}-\d{4}/;
                  phoneNumber = phoneNumber.replace(myExp, "80000000000");
                  document.write(phoneNumber);
                  ცალკე განვიხილოთ '\b' კომბინაციის გამოყენება, რომელიც მიუთითებს შესაბამისობაზე სიტყვის ფარგლებში. მაგალითად, ვთქვათ გვაქვს სტრიქონი: "პროგრამირების ენები:  Java, JavaScript, C++" და გვინდა, რომ Java შევცვალოთ C#-ით. თუ პირდაპირ ამოვცვლით, შეიცვლება სიტყვა "JavaScript" -ც და მივიღებთ "C#Script"-ს. ამ შემთხვევაში ამოცვლა უნდა მოხდეს მხოლოდ იმ შემთხვევაში, როცა სიტყვა მთლიანად შეესაბამება რეგულარულ გამოსახულებას:
                  
                  var initialText = "პროგრამირების ენები:  Java, JavaScript, C++";
                  var exp = /Java\b/g;
                  var result = initialText.replace(exp, "C#");
                  document.write(result); // პროგრამირების ენები:  C#, JavaScript, C++
                  '\b'-ს გამოყენებისას უნდა გავითვალისწინოთ, რომ ჯავასკრიპტს არ გააცნია უნიკოდის სრულყოფილი მხარდაჭერა, ამიტომ '\b'-ს გამოყენება შეიძლება მხოლოდ ინგლისურენოვანი სიტყვების მიმართ.
                  
                  ჯგუფების გამოყენება რეგულარულ გამოსახულებებში
                  
                  სტრიქონში ძებნისას უფრო რთული შესაბამისობებისთვის გამოიყენება ჯგუფები. რეგულარულ გამოსახულებაში ჯგუფი თავსდება ფრჩხილებში. მაგალითად, გვაქვს კოდი, რომელიც შეიცავს სურათის ტეგს: '<img src="picture.png" />'. ვთქვათ, გვინდა კოდიდან ამოვკრიფოთ სურათების მისამართები:
                  
                  var initialText = '<img src= "picture.png" />';
                  var exp = /[a-z]+\.(png|jpg)/i;
                  var result = initialText.match(exp);
                  result.forEach(function(value, index, array){    
                      document.write(value + "<br/>");
                  });
                  პირველი ნაწილი ფრჩხილებამდე ([a-z]+\.) მიუთითებს, რომ სტრიქონი იწყება 1 ან მეტი ლათინური ანბანის სიმბოლოებით, რომლებიც ბოლოვდება წერტილით. რადგანაც წერტილი წარმოადგენს სპეციალურ სიმბოლოს, საჭიროა მისი ეკრანირება სლეშით. შემდეგ მოდის ჯგუფი: (png|jpg). ეს ჯგუფი მიუთითებს, რომ წერტილის მერე შეიძლება იყოს როგორც "png", ისე "jpg".`
              },
              
            ]
        },{
            title:"თავი 7. მუშაობა ბრაუზერთან და BOM (Browser Object Model)",
            content:[
                {
                    title:"Browser Object Model და ობიექტი window",
                    data:`ჯავასკრიპტში დიდი მნიშვნელობა აქვს ვებბრაუზერთან და იმ ობიექტებთან მუშაობა, რომელთაც ის წარმოადგენს. მაგალითად, ბრაუზერის ობიექტების გამოყენება html-ის ელემენტებით მანიპულირების საშუალებას გვაძლევს,ასევე მომხმარებელთან ურთიერთობის საშუალებას იძლევა.

                    ყველე ობიექტს, რომელთა მეშვეობითაც ხდება ჯავასკრიპტის ურთიერთქმედება ბრაუზერთან, აღწერენ ცნებით Browser Object Model (ბრაუზერის ობიექტური მოდელი).
                    
                    Browser Object Model შეიძლება წარმოვადგინოთ შემდეგი სქემის სახით:
                    
                    JavaScript
                    
                    სათავეში იმყოფება მთვარი ობიექტი - window, რომელიც წარმოადგენს ბრაუზერს. ის შეიცავს სხვა ობიექტებს, მათ შორის ობიექტს document, რომელიც წარმოადგენს ცალკეულ ვებგვერდს, რომელიც გამოისახება ბრაუზერში.
                    
                    ობიექტი window
                    
                    ობიექტი window წარმოადგენს ვებბრაუზერს, რომელშიც არის მოთავსებული ვებგვერდები. window წარმოადგენს გლობალურ ობიექტს, ამიტომ მასზე მიმართვისთვის არაა აუცილებელი მისი სახელის გამოყენება. მაგალითად, window ობიექტს გააჩნია მეთოდი alert(), რომელსაც გამოაქვს შეტყობინება. მაგრამ არაა აუცილებელი დავწეროთ:
                    
                        window.alert("გამარჯობა, სამყაროვ!");
                    window შეგვიძლია არ მივუთითოთ და დავწეროთ მოკლედ:
                    
                        alert("გამარჯობა, სამყაროვ!");
                    ვინაიდან window წარმოადგენს გლობალურ ობიექტს, ეს გარკვეულ შეზღუდვებსიწვევს. მაგალითად:
                    
                      var alert = function (message) {
                        document.write("შეტყობინება: " + message);
                    };
                    window.alert("გამარჯობა, სამყაროვ!");
                    პროგრამაში გამოცხადებული ყველა გლობალური ცვლადი და ფუნქცია ავტომატურად ემატება window ობიექტს. ვინაიდან ჩვენი ფუნქციის სახელი ემთხვევა alert() მეთოდის სახელს, მოხდება ამ მეთოდის ხელახალი განსაზღვრა. შესაბამისად, alert() მეთოდის ნაცვლად შესრულდება ჩვენს მიერ შექმნილი ფუნქცია.
                    
                    ასევე, თუ ჩვენ გამოვაცხადებთ რამე გლობალურ ცვლადს, იგი ხელმისაწვდომი იქნება როგორც window ობიექტის თვისება:
                    
                    var message = "hello";
                    document.write(window.message);`
                },
                {
                  title:"ფანჯრების მართვა",
                  data:`მომხმარებელთან ურთიერთობისთვის window ობიექტში არის მეთოდები, რომლებიც გვაძლევენ დიალოგური ფანჯრების შექმნის შესაძლებლობას.

                  მეთოდს alert()  გამოაქვს დიალოგური ფანჯარა შეტყობინებით:
                  
                      alert("გამარჯობა, სამყაროვ!");
                  მეთოდს confirm() ასევე გამოაქვს დიალოგური ფანჯარა შეტყობინებით, მაგრამ მას აქვს ორი ღილაკი Ok და Cancel. იმის მიხედვით, თუ რომელ ღილაკს დააჭერს მომხმარებელი, მეთოდი აბრუნებს true-ს (თუ დააჭირა ღილაკს Ok) ან false-ს (თუ დააჭირა ღილაკს Cancel):
                  
                   var result = confirm("დავასრულოთ პროგრამის მუშაობა?");
                  if(result===true)
                      document.write("პროგრამის მუშაობა დასრულებულია");
                  else
                      document.write("პროგრამა აგრძელებს მუშაობას");
                   
                  
                  JavaScript
                  
                  მეთოდი prompt() საშუალებას გვაძლევს მივცეთ მომხმარებელს საჭირო ინფორმაციის შეყვანის საშუალება. ეს მეთოდი აბრუნებს მომხმარებლის მიერ შეყვანილ მონაცემს:
                  
                  var age = prompt("შეიყვანეთ თქვენი ასაკი:");
                  document.write("თქვენ ხართ " + age + " წლის");
                   
                  
                  JavaScript
                  
                  თუ მომხმარებელი დააჭერს Cancel-ს, მეთოდი დააბრუნებს null-ს.
                  
                  ფანჯრის გახსნა, დახურვა და პოზიციის შეცვლა
                  
                  window ობიექტის ასევე გვაძლევს საშუალებას ვმართოთ ბრაუზერის ფანჯრები. 
                  
                  მეთოდი open() ხსნის გარკვეულ რესურსს ბრაუზერის ახალ ფანჯარაში:
                  
                  var popup = window.open('https://microsoft.com', 'Microsoft', 'width=400, height=400, resizable=yes');
                  მეთოდი open() ღებულობს შემდეგ პარამეტრებს: რესურსის მისამართი, ფანჯრის დასახელება და მესამე პარამეტრად - ფანჯრის სტილის მახასიათებლები. მეთოდი აბრუნებს ახალი ფანჯრის ობიექტზე მიმართვას.
                  
                  ჩვენ შეგვიძლია გამოვიყენოთ შემდეგი სტილის მახასიათებლები:
                  
                  width: ფანჯრის სიგანე პიქსელებში. მაგალითად, width=640
                  height: ფანჯრის სიმაღლეპიქსელებში. მაგალითად, height=480
                  left: X კოორდინატი ფანჯრის დასაწყისიდან პიქსელებში. მაგალითად, left=0
                  top: Y კოორდინატი ფანჯრის დასაწყისიდან პიქსელებში. მაგალითად, top=0
                  titlebar: განსაზღვრავს, ექნება თუ არა ფანჯარას სათაურის ზოლი. მაგალითად, titlebar=no
                  menubar: განსაზღვრავს, ექნება თუ არა ფანჯარას მენიუს პანელი. მაგალითად, menubar=yes
                  toolbar: განსაზღვრავს, ექნება თუ არა ფანჯარას ინსტრუმენტების პანელი. მაგალითად, toolbar=yes
                  location: განსაზღვრავს, ექნება თუ არა ფანჯარას მისამართის ზოლი. მაგალითად, location=no
                  scrollbars: განსაზღვრავს, დაშვებულია თუ არა ფანჯარაში გადახვევის ზოლების გაჩენა. მაგალითად, scrollbars=yes
                  status: განსაზღვრავს, ექნება თუ არა ფანჯარას სტატუსის ზოლი. მაგალითად, status=yes
                  resizable: განსაზღვრავს, შეიძლება თუ არა ფანჯრის ზომების შეცვლა. მაგალითად, resizable=no
                  close() მეთოდის მეშვეობით შესაძლებელია ფანჯრის დახურვა. მაგალითად, გავხსნათ ფანჯარა და 10 წამში დავხუროთ:
                  
                  var popup = window.open('https://microsoft.com', 'Microsoft', 'width=400, height=400, resizable=yes');
                  function closeWindow(){
                      popup.close();
                  }
                  setTimeout(closeWindow, 10000);
                  მეთოდი moveTo() გადააადგილებს ფანჯარას ახალ პოზიციაზე:
                  
                  var popup = window.open('https://microsoft.com', 'Microsoft', 'width=400, height=400, resizable=yes');
                  popup.moveTo(50,50);
                  მოცემულ შემთხვევაში ფანჯარა გადაადგილდება პოზიციაზე, რომლის კოორდინატებია x=50, y=50 ეკრანის მარცხენა ზედა კუთხიდან.
                  
                  მეთოდი resizeTo() ცვლის ეკრანის ზომას:
                  
                  var popup = window.open('https://microsoft.com', 'Microsoft', 'width=400, height=400, resizable=yes');
                  popup.resizeTo(500,350); // 500 - სიგანე და 350 - სიმაღლე`
              },
              {
                  title:"ბრაუზერის ისტორია. ობიექტი history",
                  data:`ობიექტი history განკუთვნილია ბრაუზერში ვებგვერდების დათვალიერების ისტორიის შესანახად. ეს ობიექტი წარმოადგენს window-ის ობიექტს.

                  ყველა ინფორმაცია მომხმარებლის მიერ დათვალიერებული ვებგვერდების შესახებ ინახება ცპეციალურ სტეკში (history stack).length თვისების მეშვეობით შეგვიძლია გავიგოთ, თუ რამდენი ვებგვერდის ინფორმაცია ინახება სტეკში:
                  
                  document.write("ისტორიაში " + history.length + " გვერდია.");
                  ისტორიაში გვერდებს შორის გადასაადგილებლად გამოიყენება მეთოდები back() (წინა დათვალიერებულ გვერდზე გადასაადგილებლად) და forward() (მომდევნო დათვალიერებულ გვერდზე გადასასვლელად):
                  
                  history.back(); // გადაადგილება უკან
                  ასევე history ობიექტში არის სპეციალური მეთოდი go(), რომელიც საშუალებას გვაძლევს გადავადგილდეთ ისტორიაში რამდენიმე გვერდით წინ ან უკან. მაგალითად, 2 გვერდით უკან გადასაადგილებლად უნდა დავწეროთ:
                  
                  history.go(-2);
                  ანალოგიურად, წინ გადასაადგილებლად უნდა გადავცეთ დადებითი რიცხვი პარამეტრად. მაგალითად, სამი გვერდით წინ გადასაადგილებლად უნდა დავწეროთ:
                  
                  history.go(3);`
              },
              {
                  title:"ობიექტი location",
                  data:`ობიექტი location შეიცავს ინფორმაციას მიმდინარე ვებგვერდის მდებარეობის შესახებ: URL, ინფორმაცია სერვერზე, პროტის ნომერი, პროტოკოლი. ობიექტის თვისებების მეშვეობით შეგვიძლია ამ ინფორმაციის მიღება:

                  href: რესურსის სრული მოთხოვნის სტრიქონი
                  pathname: გზა რესურსამდე
                  origin: მოთხოვნის საერთო სქემა
                  protocol: პროტოკოლი
                  port: რესურსის მიერ გამოყენებული პორტი
                  host: ჰოსტი
                  hostname: ჰოსტი დასახელება
                  hash: თუ მოთხოვნის სტრიქონი შეიცავს # სიმბოლოს, ეს თვისება აბრუნებს მოთხოვნის იმ ნაწილს, რომელიც ამ სიმბოლოს შემდეგაა
                  search: თუ მოთხოვნა შეიცავს კითხვის ნიშანს (?), ეს თვისება აბრუნებს მოთხოვნის იმ ნაწილს, რომელიც კითხვის ნიშნის შემდეგაა
                  მაგალითად, ვთქვათ გვაქვს ვებგვერდი test.html, რომელიც მოთავსებულია ლოკალურ ვებსერვერზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                  <script>
                  document.write("მოთხოვნის სტრიქონი: " + location.href + "<br />");
                  document.write("გზა რესურსამდე: " + location.pathname + "<br />");
                  document.write("სქემა: " + location.origin + "<br />");
                  document.write("პროტოკოლი: " + location.protocol + "<br />");
                  document.write("პორტი: " + location.port + "<br />");
                  document.write("ჰოსტი: " + location.host + "<br />");
                  document.write("ჰოსტის სახელი: " + location.hostname + "<br />");
                  document.write("ჰეში: " + location.hash + "<br />");
                  document.write("ძებნა: " + location.search + "<br />");
                  </script>
                  </body>
                  </html>
                  JavaScript
                  
                  ასევე ობიექტი location შეიცავს მეთოდებს, რომელთა მეშვეობითაც შესაძლებელია მოთხოვნის მართვა:
                  
                  assign(url): ტვირთავს რესურსს, რომელიც იმყოფება url-სი მითითებულ მისამართზე
                  reload(forcedReload): მიმდინარე ვებგვერდის გადატვირთვა. პარამეტრი forcedReload მიუთითებს, უნდა მოხდეს თუ არა კეში გამოყენება. თუ პარამეტრი არის true, კეში არ გამოიყენება
                  replace(url): ცვლის მიმდინარე ვებგვერდს სხვა რესურსით, რომელიც იმყოფება url მისამართზე.განსხვავებით assign მეთოდისგან, მიმდინარე ვებგვერდი ისტორიის სტეკში არ ინახება და მასზე დაბრუნება history.back() მეთოდით შეუძლებელია.
                  სხვა რესურსზე გადასამისამართებლად შესაძლებელია location ობიექტის როგორც თვისებების, ასევე მეთოდების გამოყენება:
                  
                  location = "http://google.com";
                  // ანალოგიურია
                  // location.href = "http://google.com";
                  // location.assign("http://google.com");
                  სხვა ლოკალურ რესურსზე გადასვლა:
                  
                  location.replace("index.html");`
              },
              {
                  title:"ობიექტი navigator",
                  data:`ობიექტი navigator შეიცავს ინფორმაციას ბრაუზერისა და ოპერაციული სისტემის შესახებ, რომელსიც ბრაუზერია გაშვებული. ის განსაზღვრავს თვისებებსა და მეთოდებს, რომელთა შორის ძირითადს წარმოადგენს თვისება userAgent, რომელიც მიუთითებს მომხმარებლის ბრაუზერს:

                  document.write(navigator.userAgent);
                  მოცემული თვისება ინახავს სრულ სტრიქონს მომხმარებლის ბრაუზერის შესახებ, მაგალითად Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36.
                  
                  უშუალოდ ბრაუზერის გასაგებად უნდა შევეცადოთ მოვძებნოთ ამ სტრიქონში ბრაუზერის დასახელება. მაგალითად:
                  
                  var browser, uAgent = navigator.userAgent;
                   
                  if(uAgent.indexOf("Chrome") > -1) {
                     browser = "Google Chrome";
                  } else if (uAgent.indexOf("Safari") > -1) {
                     browser = "Apple Safari";
                  } else if (uAgent.indexOf("Opera") > -1) {
                     browser = "Opera";
                  } else if (uAgent.indexOf("Firefox") > -1) {
                     browser = "Mozilla Firefox";
                  } else if (uAgent.indexOf("MSIE") > -1) {
                     browser = "Microsoft Internet Explorer";
                  }
                  document.write(browser);
                  ობიექტი geolocation
                  
                  ობიექტი navigator შეიცავს თვისებას geolocation, რომელიც საშუალებას გვაძლევს განვსაზღვროთ მომხმარებლის გეოგრაფიული ადგილმდებარეობა. ამისთვის გამოიყენება მეთოდი getCurrentPosition(). მას პარამეტრებად გადაეცემა ორი ფუნქცია: ფუნქცია, რომელიც ამუშავდება წარმატებული გაშვების შემდეგ და ფუნქცია, რომელიც გაიშვებს გეოგრაფიული მონაცემების მოთხოვნის შეცდომით დასრულებისას:
                  
                  function success(position) {
                      var latitude = position.coords.latitude;
                      var longitude = position.coords.longitude;
                      var altitude = position.coords.altitude;
                      var speed = position.coords.speed;
                      
                      document.write("განედი: " + latitude + "<br/>");
                      document.write("გრძედი: " + longitude + "<br/>");
                      document.write("სიმაღლე ზღვის დონიდან: " + altitude + "<br/>");
                      document.write("გადაადგილების სიჩქარე: " + speed + "<br/>");
                  };
                   
                  function error(obj) {
                      document.write("შეცდომა მდებარეობის განსაზღვრისას");
                  };
                  navigator.geolocation.getCurrentPosition(success, error);
                  ფუნქციას, რომელიც მუშაობს ადგილმდებარეობის წარმატებით განსაზღვრის შემდეგ, პარამეტრად გადაეცემა position. ეს ობიექტი შეიცავს თვისებას coord, საიდანაც ვგებულობთ ადგილის გეოგრაფიულ კოორდინატებს:
                  
                  latitude: გეოგრაფიული განედი
                  longitude: გეოგრაფიული გრძედი
                  altitude: სიმაღლე ზღვის დონიდან
                  speed: სიჩქარე, რომლითაც გადაადგილდება მომხმარებელი (ტრანსპორტით მოძრაობისას)
                  ამასთან გასათვალისწინებელია, რომ ბრაუზერებში მუშაობს უსაფრთხოების პოლიტიკა, რის გამოც geolocation.getCurrentPosition() მეთოდის გამოძახებისას ბრაუზერი მომხმარებელს გამოუტანს შეტყობინებას, რომელშიც მომხმარებელმა უნდა დაადასტუროს კოორდინატების გადაცემა. თუ მომხმარებელი უარს განაცხადებს, ამუშავდება ფუნქცია error().`
              },
              {
                  title:"ტაიმერი",
                  data:`მოქმედებების განსაზღვრული ინტერვალით შესასრულებლად ჯავასკრიპტში გათვალისწინებულია ტაიმერის ფუნქციები. არის ტაიმერის 2 ტიპის ფუნქცია: ერთი, რომელიც სრულდება მხოლოდ ერთხელ და მეორე, რომელიც სრულდება გამუდმებით დროის გარკვეული ინტერვალის შემდეგ.

                  ფუნქცია setTimeout
                  
                  მოქმედების ერთჯერადად დროის გარკვეული ინტერვალის შემდეგ შესასრულებლად გამოიყენება ფუნქცია setTimeout(). მას გადაეცემა ორი პარამეტრი: ფუნქცია, რომელიც უნდა შესრულდეს და დროის ინტერვალი მილიწამებში. მაგალითად:
                  
                  function timerFunction() {
                      document.write("setTimeout ფუნქციის შესრულება");
                  }
                  setTimeout(timerFunction, 3000);
                  მოცემულ შემთხვევაში 3 წამის შემდეგ შესრულდება ფუნქცია timerFunction. ფუნქცია setTimeout() აბრუნებს ტაიმერის იდენტიფიკატორს.
                  
                  ტაიმერის შესაჩერებლად გამოიყენება ფუნქცია clearTimeout().
                  
                  function timerFunction() {
                      document.write("setTimeout ფუნქციის შესრულება");
                  }
                  var timerId = setTimeout(timerFunction, 3000);
                  clearTimeout(timerId);
                  ფუნქცია setInterval
                  
                  ფუნქციები setInterval() და clearInterval() მუშაობენ setTimeout() და clearTimeout() ფუნქციების ანალოგიურად, იმ განსხვავებით, რომ setTimeout() გამუდმებით ასრულებს განსაზღვრულ ფუნქციას დროის გარკვეული ინტერვალებით.
                  
                  მაგალითად, დავწეროთ პატარა პროგრამა მიმდინარე დროის გამოსატანად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                  <div id="time"></div>
                  <script>
                  function updateTime() {
                      document.getElementById("time").innerHTML = new Date().toTimeString();
                  }
                  setInterval(updateTime, 1000);
                  </script>
                  </body>
                  </html>
                  ყოველი 1 წამის (1000 მილიწამი) შემდეგ გამოიძახება ფუნქცია updateTime(), რომელიც აახლებს <div id="time" > ველს და ანიჭებს მას html კოდს მიმდინარე დროის სახით.
                  
                  requestAnimationFrame()
                  
                  მეთოდი requestAnimationFrame() მუშაობს setInterval()-ის ანალოგიურად, იმ განსხვავებით, რომ იგი განკუთვნილია ანიმაციებისათვის და გრაფიკასთან სამუშაოდ. მას გააჩნია მთელი რიგი ოპტიმიზაციები, რაც აუმჯობესებს მის წარმადობას.
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                      #rect {
                          margin: 100px;
                          width: 100px;
                          height: 100px;
                          background: #50c878;
                      }
                      </style>
                  </head>
                  <body>
                  <div id="rect"></div>
                  <script>
                  var square = document.getElementById("rect");
                  var angle = 0;
                  function rotate() {
                      angle = (angle + 2)%360;
                      square.style.transform = "rotate(" + angle + "deg)";
                      window.requestAnimationFrame(rotate);
                  }
                  var id = window.requestAnimationFrame(rotate);
                  </script>
                  </body>
                  </html>
                  window.requestAnimationFrame() მეთოდს გადაეცემა ფუნქცია, რომელიც გამოიძახება გარკვეული პერიოდულობით (როგორც წესი, წამში 60-ჯერ). მოცემულ შემთხვევაში გამოიძახება ფუნქცია rotate(), რომელიც რომელიც ცვლის ბლოკის ბრუნვის კუთხეს და მერე ისევ იძახებს მეთოდს window.requestAnimationFrame(rotate).
                  
                  მეთოდი window.requestAnimationFrame() აბრუნებს უნიკალურ id-ს, რომელიც შემდგომში შეიძლება გამოვიყენოთ ანიმაციის შესაცერებლად:
                  
                  window.cancelAnimationFrame(id);`
              },
       
            ]
        },{
            title:"თავი 8. DOM (Document Object Model)",
            content:[
                {
                    title:"DOM - შესავალი",
                    data:`ჯავასკრიპტის ერთ-ერთი უმნიშვნელოვანესი ამოცანაა ურთიერთქმედება მომხმარებელთან და ვებგვერდის ელემენტებთან. ჯავასკრიპტისთვის ვებგვერდი ხელმისაწვდომია, როგორც დოკუმენტის ობიექტური მოდელი (Document Object Nodel - შემოკლებით DOM). DOM აღწერს ვებგვერდის სტრუქტურას ხისმაგვარი წარმოდგენით და ხელმისაწვდომს ხდის ვებგვერდის ცალკეულ ელემენტებს.

                    მნიშვნელოვანია არ ავურიოთ ერთმანეთში BOM (Browser Object Model - ბრაუზერის ობიექტური მოდელი) и DOM (დოკუმენტის ობიექტური მოდელი). BOM იძლევა ბრაუზერთან და მის თვისებებთან წვდომის საშუალებას, ხოლო DOM იძლევა კონკრეტულ ვებგვერდთან ან html დოკუმენტთან და მის ელემენტებთან წვდომის საშუალებას.
                    
                    მაგალითად, ვნახოთ მარტივი ვებგვერდი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Page Title</title>
                    </head>
                    <body>
                        <h2>Page Header</h2>
                        <div>
                            <h3>Block Header</h3>
                            <p>Text</p>
                        </div>
                    </body>
                    </html>
                    DOM-ის ხე ამ შემთხვევაში იქნება შემდეგი სახის:
                    
                    JavaScript
                    
                    ამგვარად, ყველა კომპონენტი DOM-ში დალაგებულია იერარქიულად, სადაც ყოველი ელემენტი წარმოადგენს ცალკე კვანძს. ტექსტი ელემენტის შიგნით ასევე წარმოადგენს ცალკე კვანძს. არსებობს კვანძების შემდეგი სახეები:
                    
                    Element: html-ელემენტი
                    Attr: html-ელემენტის ატრიბუტი
                    Document: html-დოკუმენტის ძირითადი კვანძი
                    DocumentType: DTD ანუ XML-დოკუმენტის სქემის ტიპი
                    DocumentFragment: დოკუმენტის ფრაგმენტების დროებითი შენახვის ადგილი
                    EntityReference: XML-დოკუმენტზე მიმართვა
                    ProcessingInstruction: ვებგვერდის დამუშავების ინსტრუქცია
                    Comment: კომენტარის ელემენტი
                    Text: ელემენტის ტექსტი
                    CDATASection: CDATA სექცია XML დოკუმენტში
                    Entity: DTD-ს დაუმუშავებელი შინაარსი
                    Notation:DTD-ს გამოცხადების ნოტაცია
                    მიუხედავად კვანძების სიმრავლისა, როგორც წესი, ჩვენ ვიმუშავებთ მხოლოდ რამდენიმე მათგანთან.`
                },
                {
                  title:"ობიექტი document. ელემენტების ძებნა",
                  data:`DOM-ის სტრუქტურასთან სამუშაოდ JavaScript-ში განკუთვნილია ობიექტი document, რომელიც განსაზღვრულია გლობალურ ობიექტში window. document-ს გააჩნია მთელი რიგი თვისებები და მეთოდები ვებგვერდის ელემენტებთან სამუშაოდ. 

                  ელემენტების ძებნა
                  
                  ვებგვერდის ელემენტების ძებნისთვის გამოიყენება შემდეგი მეთოდები:
                  
                  getElementById(value):ეძებს ელემენტს, რომლის ატრიბუტი id უდრის value-ს
                  getElementsByTagName(value): ეძებს ყველა იმ ელემენტს, რომლის ტეგის მნიშვნელობაც არის value
                  getElementsByClassName(value): ეძებს ყველა იმ ელემენტს, რომლის კლასიც არის value
                  querySelector(value): ეძებს პირველ ელემენტს, რომლის css-სელექტორიც არის value
                  querySelectorAll(value): ეძებს ყველა ელემენტს, რომლის css-სელექტორიც არის value
                  მაგალითად, მოვძებნოთ ელემენტი id-ს მიხედვით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div>
                          <h3 id="header">Block Header</h3>
                          <p>Text</p>
                      </div>
                  <script>
                  var headerElement = document.getElementById("header");
                  document.write("სათაურის ტექსტი: " + headerElement.innerText);
                  </script>
                  </body>
                  </html>
                  document.getElementById("header") მეთოდის მეშვეუბით ვპოულობთ ელემენტს, რომლის id არის header. ხოლო თვისების innerText მეშვეობით ვგებულობთ ელემენტის ტექსტს. 
                  
                  ტეგის მიხედვით ძებნა:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div>
                          <h3>სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                  <script>
                  var pElements = document.getElementsByTagName("p");
                   
                  for (var i = 0; i < pElements.length; i++) {
                      document.write("პარაგრაფის ტექსტია: " + pElements[i].innerText + "<br/>");
                  }
                  </script>
                  </body>
                  </html>
                  document.getElementsByTagName("p") მეთოდის მეშვეობით ვეძებთ ყველა პარაგრაფს (ანუ ელემენტებს, რომელთა ტეგია "p"). მეთოდი აბრუნებს ნაპოვნი ელემენტების მასივს, ამიტომ ცალკეული ელემენტების მისაღებად უნდა გამოვიყენოით ციკლი.
                  
                  თუ გვინდა მივიღოთ მხოლოდ პირველი ელემენტი, შეგვიძლია მივმართოთ მიღებული კოლექციის პირველ ელემენტს:
                  
                  var pElement = document.getElementsByTagName("p")[0];
                  document.write("Текст параграфа: " + pElement.innerText);
                  ელემენტების ძებნა კლასის მიხედვით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p class="text">პირველი აბზაცი</p>
                          <p class="text">მეორე აბზაცი</p>
                      </div>
                  <script>
                  var articleDiv = document.getElementsByClassName("article")[0];
                      console.log(articleDiv);
                  var textElems = document.getElementsByClassName("text");
                  for (var i = 0; i < textElems.length; i++) {
                      console.log(textElems[i]);
                  }
                  </script>
                  </body>
                  </html>
                  ძებნა css-ის სელექტორით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="annotation">
                          <p>სტატიის ანოტაცია</p>
                      </div>
                      <div class="text">
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                  <script>
                  var elem = document.querySelector(".annotation p");
                  document.write("სელექტორის ტექსტი: " + elem.innerText);
                  </script>
                  </body>
                  </html>
                  გამოსახულება document.querySelector(".annotation p") ეძებს ელემენტს, რომლის css-სელექტორია .annotation p. თუ ასეთი ელემენტი რამდენიმეა, მეთოდი ირჩევს პირველ მათგანს. შედეგად ბრაუზერში გამოვა:
                  
                  JavaScript
                  
                  თუ გვინდა სელექტორის მიხედვით ყველა ელემენტის მიღება, უნდა გამოვიყენოთ მეთოდი document.querySelectorAll(). იგი აბრუნებს ნაპოვნი ელემენტების მასივს:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="annotation">
                          <p>სტატიის ანოტაცია</p>
                      </div>
                      <div class="text">
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                  <script>
                  var elems = document.querySelectorAll(".text p");
                   
                  for (var i = 0; i < elems.length; i++) {
                     document.write("სელექტორის ტექსტი: " + i + ": " + elems[i].innerText + "<br/>");
                  }
                  </script>
                  </body>
                  </html>`
              },
              {
                  title:"document ობიექტის თვისებები",
                  data:`ადრე განხილული მეთოდების გარდა ობიექტი document საშუალებას გვაძლევს მივმართოთ ვებგვერდის გარკვეულ ელემენტებს თვისებების მეშვეობით:

                  documentElement: მიმართავს  დოკუმენტის საწყის ელემენტს <html>
                  body: მიმართავს ვებგვერდის ელემენტს <body> 
                  images: წარმოადგენს ვებგვერდის ყველა სურათის კოლექციას (ელემენტები img)
                  links: წარმოადგენს ვებგვერდის ბმულების კოლექციას - ელემენტები <a> და <area>, რომელთაც განსაზღვრული აქვთ ატრიბუტი href
                  anchors: წარმოადგენს <a> ელემენტების კოლექციას, რომელთაც განსაზღვრულიაქვთ ატრიბუტი name
                  forms: წარმოადგენს ვებგვერდის ყველა ფორმის კოლექციას
                  ეს თვისებები არ იძლევა ვებგვერდის ყველა ელემენტისადმი მიმართვის საშუალებას, მაგრამ საშუალებას იძლევა მივმართოთ ყველაზე ხშირად გამოყენებულ ელემენტებს. მაგალითად, მივმართოთ ვებგვერდის საწყის ელემენტს:
                  
                  var container = document.documentElement;
                  მივიღოთ ვებგვერდის ყველა სურათი :
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <img src="picure1.png" alt="სურათი 1" />
                      <img src="picure2.png" alt="სურათი 2" />
                      <img src="picure3.png" alt="სურათი 3" />
                  <script>
                  var images = document.images;
                  // შევცვალოთ პირველი სურათი
                  images[0].src="pics/picture_4.jpg";
                  images[0].alt="ახალი სურათი";
                  // გადავარჩიოთ ყველა სურათი
                  for(var i=0; i<images.length;i++){
                   
                      document.write("<br/>" + images[i].src);
                      document.write("<br/>" + images[i].alt);
                  }
                  </script>
                  </body>
                  </html>
                  ისევე, როგორც html კოდში შეგვიძლია მივანიჭოთ img ელემენტს ატრიბუტები, ასევე ჯავასკრიპტის კოდის მეშვეობით შეგვიძლია მივიღოთ ან შევცვალოთ src და altატრიბუტების მნიშვნელობები.
                  
                  მივიღოთ ვებგვერდის ყველა ბმული:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <a href="article1.html">სტატია 1</a>
                      <a href="article2.html">სტატია 2</a>
                      <a href="article3.html">სტატია 3</a>
                  <script>
                  var links = document.links;
                   
                  for(var i=0; i<links.length;i++){
                   
                      document.write("<br/>" + links[i].innerText);
                      document.write("<br/>" + links[i].href);
                  }
                  </script>
                  </body>
                  </html>
                  აქაც, რადგან ბმულს გააჩნია ატრიბუტი href, მისი მნიშვნელობის მიღება და შეცვლა შეგვიძლია ჯავასკრიპტის კოდის მეშვეობით.`
              },
              {
                  title:"ობიექტი Node. ნავიგაცია DOM-ში",
                  data:`ყოველი ცალკეული კვანძი, იქნება ის html-ელემენტი, ატრიბუტი თუ  ტექსტი, DOM-ის სტრუქტურაში წარმოდგენილია Node ობიექტის სახით. მას გააჩნია თვისებები, რომელთა მეშვეობითაც შეგვიძლია მივიღოთ ინფორმაცია ამ კვანძზე:

                  childNodes: შეიცავს შვილი კვანძების კოლექციას
                  firstChild: აბრუნებს მიმდიანრე კვანძის პირველ შვილ კვანძს
                  lastChild:აბრუნებს მიმდიანრე კვანძის ბოლო შვილ კვანძს
                  previousSibling: აბრუნებს წინა ელემენტს, რომელიც მიმდინარე ელემენტთან იგივე დონეზე იმყოფება
                  nextSibling: აბრუნებს მომდევნო ელემენტს, რომელიც მიმდინარე ელემენტთან იგივე დონეზე იმყოფება
                  ownerDocument: აბრუნებს დოკუმენტის საწყის კვანძს
                  parentNode: აბრუნებს ელემენტს, რომელიც წარმოადგენს მიმდინარე ელემენტის მშობელს
                  nodeName: აბრუნებს კვანძის სახელს
                  nodeType: აბრუნებს კვანძის ტიპს რიცხვის სახით
                  nodeValue: აბრუნებს ან ანიჭებს კვანძის მნიშვნელობას ტექსტის სახით
                  გადავარჩიოთ ელემენტის ყველა შვილი კვანძი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                  <script>
                  var articleDiv = document.querySelector("div.article");
                  var nodes = articleDiv.childNodes;
                  for(var i=0; i<nodes.length;i++){
                   
                      var type = "";
                      if(nodes[i].nodeType===1)
                          type="ელემენტი";
                      else if(nodes[i].nodeType===2)
                          type="ატრიბუტი";
                      else if(nodes[i].nodeType===3)
                          type="ტექსტი";
                          
                      console.log(nodes[i].nodeName + ": " + type);
                  }
                  </script>
                  </body>
                  </html>
                  document.querySelector("div.article") მეთოდის მეშვეობით ვირჩევთ div ელემენტს კლასით article და ციკლის მეშვეობით გავივლით მის ყველა შვილ კვანძს. ციკლში თვისებების nodeName და nodeType მეშვეობით გამოგვაქვს კვანძის სახელი და ტიპი. თითოეულ ტიპს შეესაბამება გარკვეული რიცხვი:
                  
                  nodeType	კვანძის ტიპი
                  1	ელემენტი
                  2	ატრიბუტი
                  3	ტექსტი
                   
                  
                   
                  
                   
                  
                   
                  
                   
                  
                  მიუხედავად იმისა, რომ ვებგვერდზე მხოლოდ სამი კვანძია სათური h3 და 2 პარაგრაფი, კონსოლსი გამოცნდება 5 კვანძი:
                  
                  JavaScript
                  
                  საქმე იმაშია, რომ კვანძებს შორის სიცარიელე ასევე ითვლება ცალკე კვანძებად.
                  
                  კვანძებს შორის ნავიგაცია
                  
                  nextSibling და previousSibling თვისებების მეშვეობით შესაძლებელია გადაადგილება კვანძებს შორის პირდაპირი ან უკუმიმართულებით. მაგალითად, წინამაგალითში განხილულ კვანძებს შორის გადაადგილება შესაძლებელია შემდეგი კოდის გამოყენებით:
                  
                  var articleDiv = document.querySelector("div.article");
                   
                  // ვღებულობთ პირველ შვილ ელემენტს
                  var node = articleDiv.firstChild;
                  console.log(node.nodeName);
                  // მივმართავთ მომდევნო კვანძს, სანამ ის არსებობს
                  while((node=node.nextSibling)!==null){
                     console.log(node.nodeName);
                  }
                  ასევე შესაძლებელია კვანძების გადარჩევა უკუმიმართულებით. ამისთვის ჯერ ვიღებთ ბოლო კვანძს, შემდეგ კი მივმართავთ იმავე დონის წინა კვანძს:
                  
                  var articleDiv = document.querySelector("div.article");
                   
                  // ვღებულობთ ბოლო შვილ ელემენტს
                  var node = articleDiv.lastChild;
                  console.log(node.nodeName);
                  // მივმართავთ წინა კვანძს, სანამ ის არსებობს
                  while((node=node.previousSibling)!==null){
                     console.log(node.nodeName);
                  }`
              },
              {
                  title:"ელემენტების შექმნა, დამატება და წაშლა",
                  data:`ელემენტების შესაქმნელად გამოიყენება შემდეგი მეთოდები:

                  createElement(elementName): ქმნის html ელემენტს, რომლის ტეგიც გადაეცემა პარამეტრად. აბრუნებს შექმნილ ელემენტს
                  createTextNode(text): ქმნის ტექსტურ კვანძს. პარამეტრად გადაეცემა ტექსტი.
                  var elem = document.createElement("div");
                  var elemText = document.createTextNode("გამარჯობა, სამყაროვ!");
                  მაგრამ ელემენტების მხოლოდ შექმნა საკმარისი არ არის. საჭიროა ისინი დავამატოთ ვებგვერდზე. 
                  
                  ელემენტების დასამატებლად გამოიყენება მეთოდები:
                  
                  appendChild(newNode): ამატებს ახალ კვანძს newNode შვილი კვანძების კოლექციის ბოლოსი
                  insertBefore(newNode, referenceNode): ამატებს ახალ კვანძს newNodeარსებული referenceNode კვანძის წინ.
                  გამოვიყენოთ მეთოდი appendChild:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                      <script>
                          var articleDiv = document.querySelector("div.article");
                          // ვქმნით ელემენტს
                          var elem = document.createElement("h2");
                          // ვქმნით ტექსტს
                          var elemText = document.createTextNode("გამარჯობა, სამყაროვ!");
                          // ვამატებთ ტექსტს შვილი ელემენტის სახით
                          elem.appendChild(elemText);
                          // ვამატებთ ელემენტს div ბლოკში
                          articleDiv.appendChild(elem);
                      </script>
                  </body>
                  </html>
                  თავიდან ვქმნით ჩვეულებრივ სათაურის ელემენტს h2 და ტექსტურ კვანძს. შემდეგ ტექსტური კვანძი ემატება სათაურის ელემენტში. ამის შემდეგ სათაურის ელემენტი ემატება ვებგვერდის ერთ-ერთ ელემენტს:
                  
                  JavaScript
                  
                  თუმცა არაა აუცილებელი ელემენტის შიგნით შევქმნათ ტექსტური კვანძი, საკმარისია ვისარგებლოთ თვისებით textContent და პირდაპირ მას მივანიჭოთ ტექსტი:
                  
                   
                  
                  var elem = document.createElement("h2");
                  elem.textContent = "გამარჯობა, სამყაროვ!";
                   
                  
                  ამ შემთხვევაში ტექსტური კვანძი იქმნება ტექსტის მინიჭების დროს,
                  
                  ახლა განვიხილოთ, როგორ შეიძლება დავამატოთ ელემენტი div ბლოკის შვილი კვანძების კოლექციის დასაწყისში:
                  
                  var articleDiv = document.querySelector("div.article");
                  // შევქმნათ ელემენტი
                  var elem = document.createElement("h2");
                  // შევქმნათ მისთვის ტექსტი
                  var elemText = document.createTextNode("გამარჯობა, სამყაროვ!");
                  // დავამატოთ ტექსტი ელემენტში
                  elem.appendChild(elemText);
                  // მოვძებნოთ პირველი ელემენტი, რომლის წინაც უნდა ჩავსვათ ახალი
                  var firstElem = articleDiv.firstChild.nextSibling;
                  //დავამატოთ ელემენტი პირველი ელემენტის წინ
                  articleDiv.insertBefore(elem, firstElem);
                  თუ გვინდა ელემენტის ჩასმა სხვა რომელიმე კვანძის წინ, უნდა მოვძებნოთ ეს კვანძი firstChild/lastChild და nextSibling/previousSibling თვისებების კომბინაციით.
                  
                  ელემენტის კოპირება
                  
                  ხანდახან საჭიროა ელემენტის კოპირება. ამისთვის გამოიყენება მეთოდი cloneNode():
                  
                  var articleDiv = document.querySelector("div.article");
                  // დავკლონოთ ელემენტი articleDiv
                  var newArticleDiv = articleDiv.cloneNode(true);
                  // დავამატოთ ახალი ელემენტი body-ს ბოლოში
                  document.body.appendChild(newArticleDiv);
                  მეთოდს პარამეტრად გადაეცემა ლოგიკური მნიშვნელობა: თუ გადაეცემა true, ელემენტი კოპირდება ყველა მისი შვილი კვანძებით, თუ გადაეცემა false - კოპირება ხდება შვილი კვანძების გარეშე. მოცემულ შემთხვევაში ელემენტი კოპირდება ყველა მისი კვანძით და ემატება body ელემენტის ბოლოში:
                  
                  JavaScript
                  
                  ელემენტის წაშლა
                  
                  ელემენტის წასაშლელად გამოიყენება Node ობიექტის მეთოდი removeChild(). ის შლის ერთ არჩეულ შვილ კვანძს:
                  
                  var articleDiv = document.querySelector("div.article");
                  // ვეძებთ კვანძს, რომელიც უნდა წავშალოთ
                  var removableNode = document.querySelectorAll("div.article p")[0];
                  // ვშლით კვანძს
                  articleDiv.removeChild(removableNode);
                  მოცემულ შემთხვევაში იშლება div ბლოკის პირველი პარაგრაფი.
                  
                  ელემენტის შეცვლა
                  
                  ელემენტის შესაცვლელად გამოიყენება Node ობიექტის მეთოდი replaceChild(newNode, oldNode). პირველ პარამეტრად გადაეცემა ახალი კვანძი newNode, რომლითაც შეიცვლება არსებული oldNode, რომელიც გადაეცემა მეორე პარამეტრად:
                  
                  var articleDiv = document.querySelector("div.article");
                  // ვეძებთ კვანძს, რომელიც უნდა ჩავანაცვლოთ ახლით
                  var oldNode = document.querySelectorAll("div.article p")[0];
                  // ვქმნით ახალ ელემენტს
                  var newNode = document.createElement("h2");
                  // ვქმნით მისთვის ტექსტს
                  var elemText = document.createTextNode("გამარჯობა, სამყაროვ!");
                  // ვამატებთ ტექსტს ელემენტში
                  newNode.appendChild(elemText);
                  // ვცვლით ძველ ელემენტს ახლით
                  articleDiv.replaceChild(newNode, oldNode);
                  მოცემულ შემთხვევაში პირველი პარაგრაფი იცვლება სათაურით h2`
              },
              {
                  title:"ობიექტი Element. ელემენტების მართვა",
                  data:`Node ობიექტის თვისებებისა და მეთოდების გარდა ჯავასკრიპტში შესაძლებელია Element ობიექტის თვისებებისა და მეთოდების გამოყენება. მნიშვნელოვანია ერთმანეთში არ ავურიოთ ობიექტები Node და Element. Node წარმოადგენს ვებგვერდის ნებისმიერ კვანძს, მაშინ როდესაც Element წარმოადგენს მხოლოდ უშუალოდ html ელემენტებს. ანუ ობიექტი Element არის ვებგვერდის ის კვანძები - Node ობიექტები, რომელთაც კვანძის ტიპი (nodeType) ტოლია 1-ის.

                  Element ობიექტის ერთ-ერთი უმნიშვნელოვანესი თვისებაა tagName, რომელიც აბრუნებს ელემენტის ტეგს. მაგალითად, მივიღოთ ყველა ელემენტი, რომელიც არის ვებგვერდზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                      <script>
                          function getChildren(elem) {
                   
                              for (var i in elem.childNodes) {
                   
                                  if (elem.childNodes[i].nodeType === 1) {
                   
                                      console.log(elem.childNodes[i].tagName);
                                      getChildren(elem.childNodes[i]);
                                  }
                              }
                          }
                          var root = document.documentElement;
                          console.log(root.tagName);
                          getChildren(root);
                      </script>
                  </body>
                  </html>
                  აქ ჯერ ვღებულობთ საწყისი ელემენტის <html> ტეგს, ხოლო შემდეგ რეკურსიული ფუნქციის getChildren მეშვეობით ვღებულობთ ყველა ჩასმულ ელემენტს:
                  
                  JavaScript
                  
                  თვისებები innerText და innerHTML
                  
                  ელემენტის ტექსტის მისაღებად ან მისანიჭებლად გამოიყენება თვისება innerText, ხოლო ელემენტის html კოდის მისაღებად ან მისანიჭებლად - innerHTML:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                      <script>
                          var articleDiv = document.querySelector("div.article");
                          console.log(articleDiv.innerText);
                          console.log("_______________________");
                          console.log(articleDiv.innerHTML);
                      </script>
                  </body>
                  </html>
                   
                  
                  JavaScript
                  
                  უნდა აღინიშნოს, რომ თვისება innerText პრაქტიკულად ანალოგიურია თვისებისა textContent. შესაბამისად, შემდეგი ბრძანებები ერთი და იგივე შედეგს მოგვცემს:
                  
                  var pElement = document.querySelectorAll("div.article p")[0];
                  pElement.innerText = "hello";
                  pElement.textContent = "hello";
                  ელემენტისთვის html კოდის მინიჭება შესაძლებელია შემდეგნაირად:
                  
                  var articleDiv = document.querySelector("div.article");
                  articleDiv.innerHTML ="<h2>Hello World!!!</h2><p>bla bla bla</p>";
                  Element ობიექტის მეთოდები
                  
                  Element ობიექტის მეთოდებს შორის მნიშვნელოვანია მეთოდები ატრიბუტების სამართავად:
                  
                  getAttribute(attr): აბრუნებს ატრიბუტის attr მნიშვნელობას;
                  setAttribute(attr, value):  attr ატრიბუტს ანიჭებს მნიშვნელობას value. თუ ასეთი ატრიბუტი ელემენტს არა აქვს, ის ემატება;
                  removeAttribute(attr): შლის ატრიბუტს attr და მის მნიშვნელობას.
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div class="article" style="color:red;">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                      <script>
                          var articleDiv = document.querySelector("div.article");
                          // მივიღოთ ატრიბუტი style
                          var styleValue = articleDiv.getAttribute("style");
                          console.log("ატრიბუტი შეცვლამდე: " + styleValue);
                          // წავშალოთ ატრიბუტი
                          articleDiv.removeAttribute("style");
                          // დავამატოთ ატრიბუტი style
                          articleDiv.setAttribute("style", "color:blue;");
                          styleValue = articleDiv.getAttribute("style");
                          console.log("ატრიბუტი შეცვლის შემდეგ: " + styleValue);
                      </script>
                  </body>
                  </html>
                   
                  
                  JavaScript
                  
                  ელემენტის ზომები და პოზიცია
                  
                  ელემენტებს გააჩნიათ თვისებები, რომელთა მეშვეობით შესაძლებელია მათი ზომების დადგენა.
                  
                  თვისებები offsetWidth და offsetHeight განსაზღვრავენ ელემენტის სიგანეს და სიმაღლეს პიქსელებში. ზომებში შედის ელემენტის ჩარჩოს ზომებიც.
                  
                  თვისებები clientWidth და clientHeight ასევე განსაზღვრავენ ელემენტის სიგანეს და სიმაღლეს პიქსელებში. ოღონდ ამ შემთხვევაში ზომები განისაზღვრება ჩარჩოს გარეშე.
                  
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #rect {
                              width: 100px;
                              height: 100px;
                              background: #50c878;
                              border: 3px solid silver;
                          }
                      </style>
                  </head>
                  <body>
                      <div id="rect"></div>
                      <script>
                          var rect = document.getElementById("rect");
                          console.log("offsetHeight: " + rect.offsetHeight);
                          console.log("offsetWidth: " + rect.offsetWidth);
                          console.log("clientHeight: " + rect.clientHeight);
                          console.log("clientWidth: " + rect.clientWidth);
                      </script>
                  </body>
                  </html>
                   
                  
                  JavaScript
                  
                  ვინაიდან div ბლოკს გააჩნია 3 პიქსელის ზომის ჩარჩო, offsetHeight/offsetWidth 6 პიქსელით მეტია clientHeight/clientWidth-ზე.
                  
                  ელემენტის პოზიციის განსაზღვრისთვის ყველაზე ეფექტური მეთოდია getBoundingClientRect(). ეს მეთოდი აბრუნებს ობიექტს თვისებებით top, bottom, left, right, რომლებიც განსაზღვრავენ ელემენტის დაშორებებს ბრაუზერის ზედა მარცხენა კუთხიდან:
                  
                  var rect = document.getElementById("rect");
                  var clientRect  = rect.getBoundingClientRect();
                  console.log("top: " + clientRect.top);
                  console.log("bottom: " + clientRect.bottom);
                  console.log("left: " + clientRect.left);
                  console.log("right: " + clientRect.right);`
              },
              {
                  title:"ელემენტების სტილის შეცვლა",
                  data:`ელემენტების სტილის თვისებების შესაცვლელად ჯავასკრიპტში არის ძირითადად ორი მიდგომა:

                  style თვისების შეცვლა;
                  class  ატრიბუტის შეცვლა
                  თვისება style
                  
                  ელემენტის თვისება style წარმოადგენს რთულ ობიექტს. იგი შეიცავს CSS-ის თვისებების ნაკრებს: element.style.CSSთვისება. მაგალითად, შევცვალოთ შრიფტის ფერი:
                  
                  var root = document.documentElement;
                  root.style.color = "blue";
                  document.write(root.style.color); // blue
                  მოცემულ შემთხვევაში თვისება color ემთხვევა css-ის თვისებას color. ფერის მიცემა შეიძლებოდა css-ის თვისების მეშვეობით:
                  
                  html{
                      color:blue;
                  }
                  მაგრამ css-ის ზოგიერთი თვისება შეიცავს დეფისს, მაგალითად, fint-family. ჯავასკრიპტში შესაბამისი თვისებების აღსანიშნავად დეფისი არ გამოიყენება, მაგრამ დეფისის მომდევნო პირველი ასო იწერება მაღალ რეგისტრში:
                  
                  var root = document.documentElement;
                  root.style.fontFamily = "Verdana";
                  თვისება className 
                  
                  className თვისების მეშვეობით შესაძლებელია html ელემენტის class ატრიბუტის შეცვლა. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          .blueStyle {
                              color: blue;
                              font-family: Verdana;
                          }
                   
                          .article {
                              font-size: 20px;
                          }
                      </style>
                  </head>
                  <body>
                      <div class="article">
                          <h3>სტატიის სათაური</h3>
                          <p>პირველი აბზაცი</p>
                          <p>მეორე აბზაცი</p>
                      </div>
                      <script>
                          var articleDiv = document.querySelector("div.article");
                          // ახალი კლასის მინიჭება
                          articleDiv.className = "blueStyle";
                          // მივიღოთ კლასის სახელი
                          document.write(articleDiv.className);
                      </script>
                  </body>
                  </html>
                  კლასების გამოყენების მეშვეობით არ დაგვჭირდება თითოეული css თვისების სათითაოდ მინიჭება ელემენტისთვის. 
                  
                  მაგრამ უნდა გავითვალისწინოთ, რომ კლასის მინიჭების დროს წინა მნიშვნელობა იშლება. თუ გვინდა. რომ წინა მნიშვნელობაც შევინარცუნოთ და დავამატოთ ახალი მნიშვნელობა, საჭიროა ორი კლასის სახელის გაერთიანება:
                  
                  articleDiv.className = articleDiv.className + " blueStyle";
                  თუ გვინდა საერთოდ წავშალოთ ყველა კლასი, უნდა მივანიჭოთ ცარიელი მნიშვნელობა:
                  
                  articleDiv.className = "";
                  თვისება classList
                  
                  ზემოთ იყო განხილული, ტუ როგორ უნდა დავუმატოთ  ელემენტს კლასი. მაგრამ ერთ ელემენტზე ბევრი კლასის სამართავად უფრო მოხერხებულია გამოვიყენოთ თვისება classList. ეს თვისება წარმოადგენს ობიექტს, რომელსაც გაჩნია შემდეგი მეთოდები:
                  
                  add(className): ამატებს კლასს className
                  remove(className): შლის კლასს className
                  toggle(className): კლასის className-ის ჩართვა-გამორთვა. თუ ეს კლასი (className) ელემენტს გააჩნია, ის წაიშლება, თუ არ გააცნია - დაემატება.
                  მაგალითად:
                  
                  var articleDiv = document.querySelector("div.article");
                  // წავშალოთ კლასი
                  articleDiv.classList.remove("article");
                  // დავამატოთ კლასი
                  articleDiv.classList.add("blueStyle");
                  // ჩავრთოთ (გამოვრთოთ) კლასი
                  articleDiv.classList.toggle("article");`
              },
    
            ]
        },
        {
            title:"თავი 9. მოვლენები",
            content:[
                {
                    title:"შესავალი მოვლენების დამუშავებაში",
                    data:`მომხმარებელთან ურთიერთობისათვის ჯავასკრიპტში განსაზღვრულია მოვლენების მექანიზმი. მაგალითად, როცა მომხმარებელი აჭერს ღილაკს, წარმოიშობა ღილაკზე დაჭერის მოვლენა. ჯავასკრიპტის კოდში ჩვენ შეგვიძლია განვსაზღვროთ მოვლენის წარმოშობა და დავამუშავოთ ეს მოვლენა.

                    ჯავასკრიპტში არის მოვლენების შემდეგი ტიპები:
                    
                    მაუსის მოვლენები (კურსორის გადაადგილება, მაუსის დაჭერა და ა. შ.)
                    კლავიატურის მოვლენები (კლავიატურის კლავიშის დაჭერა ან აშვება)
                    ელემენტების სასიცოცხლო ციკლის მოვლენები (მაგალითად, ვებგვერდის ჩატვირთვის მოვლენა)
                    ფორმის ელემენტების მოვლენები (ფორმის რილაკის დაჭერა, ჩამოსაშლელ სიასი ელემენტის არჩევა და ა. შ.)
                    მოვლენები, რომლებიც წარმოიშობა DOM-ის ელემენტების ცვლილებისას
                    მოვლენები, რომლებიც წარმოისობა სენსორულ ეკრანთან შეხებისას
                    მოვლენები, რომლებიც წარმოიშობა კოდის სსრულების შეცდომების დაშვებისას
                    ვნახოთ მოვლენის დამუშავების უმარტივესი მაგალითი. ვთქვათ, ვებგვერდზე გვაქვს შემდეგი div ელემენტი:
                    
                    <div id="rect" onclick="alert('ღილაკზე დაჭერა')" style="width:50px;height:50px;background-color:blue;"></div>
                    აქ მოცემულია ჩვეულებრივი div ბლოკი, რომელსაც გააცნია ატრიბუტი onClick. ეს ატრიბუტი განსაზღვრავს div ბლოკზე დაჭერის მოვლენის დამუშავებას. მოვლენის დამუშავებისთვის საჭიროა განისაზღვროს მისი დამმუშავებელი, ანუ ჯავასკრიპტის კოდი, რომელიც შესრულდება ამ მოვლენის წარმოშობისას. მოცემულ შემთხვევაში დამმუშავებელი არის მარტივი კოდი:
                    
                    alert('ღილაკზე დაჭერა')
                    ღილაკზე დაჭერისას გამოდის შეტყობინება:
                    
                    JavaScript
                    
                    დამმუშავებლის ყველა მოქმედება შეიძლება გავიტანოთ ცალკე ფუნქციაში:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                    <div id="rect" onclick="displayMessage()" style="width:50px;height:50px;background-color:blue;"></div>
                    <script>
                    function displayMessage(){    
                        alert('ღილაკზე დაჭერა');
                    }
                    </script>
                    </body>
                    </html>
                    ახლა უკვე მოვლენის დამმუშავებლის როლში გამოდის ფუნქცია displayMessage().
                    
                    მოვლენის დამმუშავებელზე პარამეტრების გადაცემა
                    
                    მოვლენის დამმუშავებელს შეიძლება გადაეცეს პარამეტრები. მაგალითად, ჩვენ შეგვიძლია პარამეტრად გადავცეთ მიმდინარე ობიექტი, რომელზეც წარმოიშვა მოვლენა:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <a href="page1.html" onclick="return handler(this)">გვერდი 1</a>
                        <script>
                            function handler(obj) {
                                alert(obj.href);
                                return false;
                            }
                        </script>
                    </body>
                    </html>
                    საკვანძო სიტყვა this მიუთითებს მიმდინარე ბმულის ობიექტზე, რომელზეც ხდება მაუსის დაჭერა. დამმუშავებლის კოდში შეიძლება ამ ობიექტის მიღება და მის თვისებებზე მიმართვა, მაგალითად თვისებაზე href.
                    
                    გარდა ამისა, მოცემულ მაგალითში დამმუშავებელი აბრუნებს რეზულტატს. თუმცა წინა მაგალითში დამმუშავებლისგან არ მოითხოვებოდა შედეგის დაბრუნება. საქმე იმაშია, რომ ზოგიერთ დამმუშავებელში შესაძლებელია მოვლენის დამუშავებაზე თანხმობის მიცემა ან უარყოფა. ჩვენს მაგალითში ბმულზე დაჭერა იწვევს გადამისამართებას. მაგრამ თუ მოვლენის დამმუშავებელი დააბრუნებს false-ს, გადამისამართება არ მოხდება. თუ დამმუშავებელი დააბრუნებს true-ს, გადამისამართება მოხდება ჩვეულებრივ რეჟიმში.
                    
                    თუ საერთოდ მოვაშორებთ რეზულტატის დაბრუნებას, მოვლენა დამუშავდება ისე, თითქოს დაბრუნდა true:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                            <a href="page1.html" onclick="handler(this)">გვერდი 1</a>
                            <script>
                            function handler(obj){            
                                alert(obj.href);
                            }
                            </script>
                    </body>
                    </html>
                    გარდა უშუალოდ მოვლენის წარმომშობი ობიექტისა მოვლენის დამმუშავებელში შეიძლება გადავცეთ ობიექტი event. ეს ობიექტი არის ფუნქციის დამმუშავებლის არგუმენტი, რომელიც ინახავს სრულ ინფორმაციას მოვლენის შესახებ. მაგალითად:
                    
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <style>
                            #rect {
                                width: 50px;
                                height: 50px;
                                background-color: blue;
                            }
                        </style>
                    </head>
                    <body>
                        <div id="rect" onclick="handler(event)"></div>
                        <script>
                            function handler(e) {
                     
                                alert(e.type); // ვიღებთ მოვლენის ტიპს
                            }
                        </script>
                    </body>
                    </html>
                    მოცემულ შემთხვევაში type თვისების მეშვეობით ვიღებთ მოვლენის ტიპს (ამ შემთხვევაში click).`
                },
                {
                  title:"მოვლენების დამმუშავებლები",
                  data:`წინა თემაში განხილული იყო ჩაშენებული დამმუშავებლები (inline event handler), რომლებიც განისაზღვრება ელემენტის კოდში ატრიბუტის სახით:

                  <div id="rect" onclick="handler(event)"></div>
            მიუხედავად იმისა, რომ ეს მეთოდი მშვენივრად მუშაობს, მას აქვს მთელი რიგი ნაკლოვანებები:
            
            html კოდი და ჯავასკრიპტის კოდი ერთმანეთშია არეული, რის გამოც რთულდება პროგრამული უსზრუნველყოფის შექმნა, დამუშავება და მხარდაჭერა;
            მოვლენის დამმუშავებელი შეიძლება განესაზღვროს მხოლოდ ვებგვერდზე თავიდანვე არსებულ ელემენტებს. დინამიურად შექმნილი ელემენტებისთვის ამ სახით მოვლენის დამმუშავებლის განსაზღვრა შეუძლებელია;
            ელემენტის ერთი მოვლენისთვის შეიძლება მხოლოდ ერთი დამმუშავებლის განსაზღვრა;
            შეუძლებელია დამმუშავებლის მოშორება კოდის შეცვლის გარეშე.
            მოვლენების დამმუშავებლის თვისებები
            
            პრობლემები, რომლებიც წარმოიშობა ჩაშენებული დამმუშავებლების შემთხვევაში, შეიძლება გადაიჭრას დამმუშავებლების ტვისებების მეშვეობით. ისევე როგორც  html კოდში გვაქვს ატრიბუტები დამმუშავებლებისთვის, ასევე ჯავასკრიპტის DOM-ის ელემენტებს გააჩნიათ თვისებები დამმუშავებლებისთვის:
            
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8" />
                <style>
                    #rect {
                        width: 50px;
                        height: 50px;
                        background-color: blue;
                    }
                </style>
            </head>
            <body>
                <div id="rect"></div>
                <script>
                    function handler(e) {
             
                        alert(e.type);
                    }
                    document.getElementById("rect").onclick = handler;
                </script>
            </body>
            </html>
            საკმარისია ელემენტის onclick თვისებას მივანიჭოთ ფუნქცია, რომელიც იქნება ამ მოვლენის დამმუშავებელი. შედეგად ჯავასკრიპტის კოდი გაემიჯნება html კოდს. 
            
            ასევე აღსანიშნავია, რომ მოვლენის დამმუშავებელს ბრაუზერი ავტომატურად გადასცემს ობიექტს event, რომელიც ინახავს სრულ ინფორმაციას მოვლენაზე. ამიტომ ჩვენ შეგვიძლია გამოვიყენოთ ეს ობიექტი ფუნქციაში.
            
            მოვლენების მომსმენი
            
            მიუხედავად იმისა, რომ დამმუშავებლის ტვისება ხსნის ბევრ პრობლემას, ეს მაინც არაა ოპტიმალური მიდგომა. მოვლენის დამმუშავებლის განსაზღვრის კიდევ ერთი ხერხია მომსმენების დამატება.
            
            მომსმენებთან სამუშაოდ ჯავასკრიპტში არსებობს ობიექტი EventTarget, რომელიც განსაზღვრავს მეტოდებს addEventListener() (მომსმენის დასამატებლად) და removeEventListener() (მომსმენის მოსაშორებლად). ვინაიდან DOM-ის html ელემენტები ასევე წარმოადგენენ EventTarget ობიექტებს, მათაც გააჩნიათ ეს მეთოდები. ფაქტობრივად მომსმენები წარმოადგენენ იგივე დამმუშავებელ ფუნქციებს.
            
            მეთოდი addEventListener() ღებულობს ორ პარამეტრს: მოვლენის დასახელება on პრეფიქსის გარეშე და ამ მოვლენის დამმუშავებელ ფუნქციას. მაგალითად:
            
                 <!DOCTYPE html><html>
            
            <head>
                <meta charset="utf-8" />
                <style>
                    #rect {
                        width: 50px;
                        height: 50px;
                        background-color: blue;
                    }
                </style>
            </head>
            <body>
                <div id="rect"></div>
                <script>
                    var rect = document.getElementById("rect");
             
                    rect.addEventListener("click", function (e) {
                        alert(e.type);
                    });
                </script>
            </body>
            </html>
            ამ შემთხვევაში ისევ ხდება click მოვლენის დამუშავება. მეთოდში ასევე შესაძლებელია ფუნქციის სახელის გადაცემა:
            
            function handler(e){   
               alert(e.type);
            }
            var rect = document.getElementById("rect");
             
            rect.addEventListener("click", handler);
            მომსმენის წაშლა მისი დამატების ანალოგიურია:
            
            rect.removeEventListener("click", handler);
            მომსმენების გამოყენების უპირატესობა მდგომარეობს იმასი, რომ ერთი ელემენტისთვის შეიძლება რამდენიმე დამმუშავებლის დამატება:
            
            var clicks = 0;
            function handlerOne(e){    
                alert(e.type);
            }
            function handlerTwo(e){    
                clicks++;
                var newNode = document.createElement("p");
                newNode.textContent = "მოხდა დაჭერა " + clicks;
                document.body.appendChild(newNode);
            }
            var rect = document.getElementById("rect");
            // დაემატა პირველი დამმუშავებელი
            rect.addEventListener("click", handlerOne);
            // დაემატა მეორე დამმუშავებელი
            rect.addEventListener("click", handlerTwo);`
              },
              {
                  title:"ობიექტი Event",
                  data:`მოვლენის დამუშავებისას ბრაუზერი დამმუშავებელ ფუნქციას პარამეტრის სახით ავტომატურად გადასცემს ობიექტს Event, რომელიც შეიცავს ყველანაირ ინფორმაციას მოვლენის შესახებ. ამ ობიექტის თვისებების მეშვეობით შეგვიძლია მივიღოთ ეს ინფორმაცია:

                  bubbles: აბრუნებს true-ს, თუ მოვლენა არის აღმავალი. მაგალითად, თუ მოვლენა წარმოიშვა შვილ ელემენტზე, მისი დამუშავება შესაძლებელია მშობელ ელემენტზე
                  cancelable: აბრუნებს true-ს, თუ შესაძლებელია მოვლენის სტანდარტული დამუშავების გაუქმება
                  currentTarget: განსაზღვრავს ელემენტს, რომელზეც მიმაგრებულია მოვლენის დამმუშავებელი
                  defaultPrevented: აბრუნებს true-ს, თუ Event ობიექტზე გამოძახებული იყო მეთოდი preventDefault()
                  eventPhase: განსაზღვრავს მოვლენის დამუშავების სტადიას
                  target: მიუთითებს ელემენტზე, რომელზეც იყო წარმოშობილი მოვლენა
                  timeStamp: ინახავს მოვლენის წარმოშობის დროს
                  type: მიუთითებს მოვლენის ტიპს
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #rect {
                              width: 50px;
                              height: 50px;
                              background-color: blue;
                          }
                      </style>
                  </head>
                  <body>
                      <div id="rect"></div>
                      <script>
                          function handler(event) {
                              console.log("მოვლენის ტიპი: " + event.type);
                              console.log(event.target);
                          }
                          var rect = document.getElementById("rect");
                          rect.addEventListener("click", handler);
                      </script>
                  </body>
                  </html>
                  ამასთან მოცემულ შემთხვევაში თვისება target წარმოადგენს ელემენტს, ამიტომ ჩვენ შეგვიძლია ამ ელემენტით მანიოულირება ისევე, როგორც DOM-ის ნებისმიერი სხვა კვანძით. მაგალითად, შეგვიძლია შევუცვალოთ ფერი:
                  
                  function handler(e){   
                     e.target.style.backgroundColor = "red";
                  }
                  მოვლენის შესრულების შეჩერება
                  
                  Event ობიექტის preventDefault() მეთოდის მეშვეობით შესაძლებელია მოვლენის შესრულების შეჩერება. ზოგიერთ შემთხვევაში ეს მეთოდი შეიძლება იყოს სასარგებლო. მაგალითად, ბმულზე დაჭერისას დამმუშავებელში შეიძლება განვსაზღვროთ, გადავიდეთ ბმულზე თუ არა. ან მეორე მაგალითი: მომხმარებელი აგზავნის ფორმის მონაცემებს. დამუშავებისას აღმოცნდა, რომ მონაცემები არაა სრულად შევსებული და საჭიროა გაგზავნის შეჩერება. 
                  
                  მაგალითად, გადასვლა ბმულზე მხოლოდ 12 საათამდე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #rect {
                              width: 50px;
                              height: 50px;
                              background-color: blue;
                          }
                      </style>
                  </head>
                  <body>
                      <a href="http://google.com" id="link">Поиск</a>
                      <script>
                          function linkHandler(e) {
                   
                              var date = new Date();
                              var hour = date.getHours();
                              console.log(hour);
                              if (hour > 12) {
                                  e.preventDefault();
                                  document.write("12 საათის მერე გადასვლა შეუძლებელია");
                              }
                          }
                          var link = document.getElementById("link");
                          link.addEventListener("click", linkHandler);
                      </script>
                  </body>
                  </html>`
              },
              {
                  title:"მოვლენების გავრცელება",
                  data:`როცა ვაჭერთ რომელიმე ელემენტს ვებგვერდზე და გენერირდება დაჭერის მოვლენა, ეს მოვლენა შეიძლება გავრცელდეს ელემენტიდან ელემენტზე. მაგალითად, როცა ვაჭერთ div ბლოკზე, ჩვენ ასევე ვაჭერთ body ელემენტზე, რომელსიც იმყოფება ეს div ელემენტი. ანუ, ხდება მოვლენის გავრცელება.

                  არსებობს მოვლენის გავრცელების რამდენიმე ფორმა:
                  
                  აღმავალი: მოვლენა ვრცელდება DOM-ის იერარქიული ხეზე ქვემოდან ზემოთ, ანუ შვილი ელემენტიდან მშობელზე
                  დაღმავალი: მოვლენა ვრცელდება DOM-ის იერარქიული ხეზე ზემოდან ქვემოთ, ანუ მშობელი ელემენტიდან შვილზე, სანამ არ მიაღწევს არ მიაღწევს იმ ელემენტს, რომელზეც წარმოიშვა ეს მოვლენა
                  აღმავალი მოვლენები
                  
                  განვიხილოთ აღმავალი (bubbling) მოვლენები, რომლებიც ვრცელდება DOM-ის იერარქიული ხეზე ქვემოდან ზემოთ. ვთქვათ, გვაქვს შემდეგი ვებგვერდი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #blueRect {
                              width: 100px;
                              height: 100px;
                              background-color: blue;
                          }
                   
                          #redRect {
                              width: 50px;
                              height: 50px;
                              background-color: red;
                          }
                      </style>
                  </head>
                   
                  <body>
                      <div id="blueRect">
                          <div id="redRect"></div>
                      </div>
                      <script>
                          var redRect = document.getElementById("redRect");
                          redRect.addEventListener("click", function () {
                              console.log("მოვლენა redRect-ზე");
                          });
                   
                          var blueRect = document.getElementById("blueRect");
                          blueRect.addEventListener("click", function () {
                              console.log("მოვლენა blueRect-ზე");
                          });
                   
                          document.body.addEventListener("click", function () {
                              console.log("მოვლენა body-ზე");
                          });
                      </script>
                  </body>
                  </html>
                  თუ ჩვენ დავაჭერთ მაუსით ჩასმულ ანუ წითელ div-ზე, მოვლენა გავრცელდება მის მშობელ div-ზე და შემდეგ body-ზე:
                  
                  JavaScript
                  
                  მოვლენის ასეთი სახით გავრცელება ყოველთვის არ არის სასურველი. ასეთ შემთხვევაში შეიძლება შევაჩეროთ მოვლენის გავრცელება Event ობიექტის stopPropagation() მეთოდის მეშვეობით:
                  
                  var redRect = document.getElementById("redRect");
                  redRect.addEventListener("click", function (e) {
                      console.log("მოვლენა redRect-ზე");
                      e.stopPropagation();
                  });
                  შედეგად, მოვლენა დამუშავდება მხოლოდ redRect ელემენტში და მისი გავრცელება არ მოხდება.
                  
                  დაღმავალი მოვლენები
                  
                  მოვლენები ასევე შეიძლება იყოს დაღმავალი (capturing). ამისათვის addEventListener() მეთოდს მესამე არასავალდებულო პარამეტრად გადაეცემა ლოგიკური მნიშვნელობა true ან false, რომელიც განსაზღვრავს, იქნება თუ არა მოვლენა დაღმავალი. მიუთითებლობისას ყველა მოვლენა აღმავალია.
                  
                  ავიღოთ იგივე ვებგვერდი, ოღონდ შევცვალოთ მისი ჯავასკრიპტის კოდი:
                  
                  var redRect = document.getElementById("redRect");
                  redRect.addEventListener("click", function (e) {
                      console.log("მოვლენა redRect-ზე");
                  },true);
                   
                  var blueRect = document.getElementById("blueRect");
                  blueRect.addEventListener("click", function () {
                      console.log("მოვლენა blueRect-ზე");
                  },true);
                   
                  document.body.addEventListener("click", function () {
                      console.log("მოვლენა body-ზე");
                  },true);
                  ახლა უკვე მოვლენები გავრცელდება საწინააღმდეგო მიმართულებით - ზემოდან ქვემოთ`
              },
              {
                  title:"მაუსის მოვლენები",
                  data:`მოვლენების ერთ-ერთი ყველაზე გავრცელებული სახეა მაუსის მოვლენები:

                  click: წარმოიშობა მაუსის კურსორის ელემენტზე დაჭერის შედეგად
                  mousedown: წარმოიშობა, როცა მაუსის კურსორი ელემენტის თავზეა, ხოლო მაუსის ღილაკი დაჭერილია
                  mouseup: წარმოიშობა, როცა მაუსის კურსორი ელემენტის თავზეა მაუსის ღილაკის აშვებისას
                  mouseover: წარმოიშობა მაუსის კურსორის ელემენტის საზღვრებში შესვლისას
                  mousemove: წარმოიშობა, როცა მაუსის კურსორი ელემენტის თავზეა
                  mouseout: წარმოიშობა მაუსის კურსორის მიერ ელემენტის საზღვრების დატოვებისას
                  მაგალითად, დავამუშავოთ მოვლენები mouseover და mouseout:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #blueRect {
                              width: 100px;
                              height: 100px;
                              background-color: blue;
                          }
                      </style>
                  </head>
                  <body>
                      <div id="blueRect"></div>
                   
                      <script>
                          function setColor(e) {
                              if (e.type === "mouseover")
                                  e.target.style.backgroundColor = "red";
                              else if (e.type === "mouseout")
                                  e.target.style.backgroundColor = "blue";
                          }
                          var blueRect = document.getElementById("blueRect");
                          blueRect.addEventListener("mouseover", setColor);
                          blueRect.addEventListener("mouseout", setColor);
                      </script>
                  </body>
                  </html>
                  კურსორის blueRect ბლოკზე გადატარებისას ის გაფერადდება წითლად, ხოლო როცა დატოვებს კურსორი ელემენტს, ისევ დაიბრუნებს ლურჯ ფერს.
                  
                  Event ობიექტი არის საერთო ყველა მოვლენისთვის. მაგრამ სხვადასხვა ტიპის მოვლენებისთვის ასევე არსებობს მოვლენის თავისი ობიექტებიც, რომლებიც ამატებენ თავის თვისებებს. მაუსის მოვლენებისთვის განსაზღვრულია ობიექტი MouseEvent, რომელშიც დამატებულია შემდეგი თვისებები:
                  
                  altKey: აბრუნებს true-ს, თუ იყო დაჭერილი Alt კლავიშზე მოვლენის გენერაციის დროს
                  button: მიუთითებს, მაუსის რომელ ღილაკზე მოხდა დაჭერა
                  clientX: განსაზღვრავს ბრაუზერის ფანჯრის Х კოორდინატს, რომელზეც იმყოფებოდა კურსორი მოვლენის გენერაციის დროს
                  clientY: განსაზღვრავს ბრაუზერის ფანჯრის Y კოორდინატს, რომელზეც იმყოფებოდა კურსორი მოვლენის გენერაციის დროს
                  ctrlKey: აბრუნებს true-ს, თუ იყო დაჭერილი Ctrl კლავიშზე მოვლენის გენერაციის დროს
                  metaKey: აბრუნებს true-ს, თუ იყო დაჭერილი მეტაკლავიშზე მოვლენის გენერაციის დროს
                  relatedTarget: განსაზღვრავს მოვლენის წარმოშობის მეორად წყაროს
                  screenX: განსაზღვრავს Х კოორდიანტს მონიტორის მარცხენა ზედა კუთხესთან მიმართებაში, რომელზეც იმყოფებოდა კურსორი მოვლენის გენერაციის დროს
                  screenY: განსაზღვრავს Y კოორდიანტს მონიტორის მარცხენა ზედა კუთხესთან მიმართებაში, რომელზეც იმყოფებოდა კურსორი მოვლენის გენერაციის დროს
                  shiftKey: აბრუნებს true-ს, თუ იყო დაჭერილი Shift კლავიშზე მოვლენის გენერაციის დროს
                  განვსაზღვროთ კურსორის კოორდინატები მაუსის დაჭერის დროს:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          #blueRect {
                              width: 100px;
                              height: 100px;
                              background-color: blue;
                          }
                      </style>
                  </head>
                  <body>
                      <div id="blueRect"></div>
                   
                      <script>
                          function handleClick(e) {
                   
                              console.log("screenX: " + e.screenX);
                              console.log("screenY: " + e.screenY);
                              console.log("clientX: " + e.clientX);
                              console.log("clientY: " + e.clientY);
                          }
                          var blueRect = document.getElementById("blueRect");
                          blueRect.addEventListener("click", handleClick);
                      </script>
                  </body>
                  </html>`
              },
              {
                  title:"კლავიატურის მოვლენები",
                  data:`მოვლენების მეორე, ასევე ხშირად გამოყენებადი სახეა კლავიატურის მოვლენები:

                  keydown: წარმოიშობა კლავიშის დაჭერისას და გრძელდება მანამ, სანამ კლავიში დაჭერილია
                  keyup: წარმოისობა კლავიშის აშვებისას
                  keypress: წარმოისობა კლავიშზე დაჭერისას, მაგრამ keydown მოვლენის შემდეგ keyup მოვლენის დაწყებამდე. გასათვალისწინებელია, რომ ეს მოვლენა წარმოიშობა მხოლოდ იმ კლავიშებზე დაჭერისას, რომელიც აბრუნებს სიმბოლოს. სხვა კლავიშებზე, მაგალითად alt კლავიშზე დაჭერისას ეს მოვლენა არ წარმოიშობა.
                  კლავიატურის მოვლენებთან სამუშაოდ განსაზღვრულია ობიექტი KeyboardEvent, რომელიც ამატებს Event ობიექტს კლავიატურისთვის დამახასიათებელ სპეციფიკურ თვისებებს:
                  
                  altKey: აბრუნებს true-ს, თუ იყო დაჭერილი Alt კლავიშზე მოვლენის გენერაციის დროს
                  charCode: აბრუნებს დაჭერილი კლავიშის შესაბამის უნიკოდის სიმბოლოს (გამოიყენება keypress მოვლენის დროს)
                  keyCode: აბრუნებს დაჭერილი კლავიშის შესაბამისი სიმბოლოს რიცხვით კოდს
                  ctrlKey: აბრუნებს true-ს, თუ იყო დაჭერილი Ctrl კლავიშზე მოვლენის გენერაციის დროს
                  metaKey: აბრუნებს true-ს, თუ იყო დაჭერილი მეტაკლავიშზე მოვლენის გენერაციის დროს
                  shiftKey: აბრუნებს true-ს, თუ იყო დაჭერილი Shift კლავიშზე მოვლენის გენერაციის დროს
                  მაგალითად, კლავიშების მეშვეობით გადავაადგილოთ ელემენტი ვებგვერდზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                      <style>
                          html,
                          body {
                              margin: 0;
                              overflow: hidden;
                          }
                          #blueRect {
                              width: 100px;
                              height: 100px;
                              background-color: blue;
                          }
                      </style>
                  </head>
                  <body>
                      <div id="blueRect"></div>
                      <script>
                          function moveRect(e) {
                              var blueRect = document.getElementById("blueRect");
                              // განვსაზღვროთ blueRect ელემენტის სტილი
                              var cs = window.getComputedStyle(blueRect);
                              var left = parseInt(cs.marginLeft);
                              var top = parseInt(cs.marginTop);
                              switch (e.keyCode) {
                                  case 37:  // თუ დაჭერილი კლავიშია ისარი მარცხნივ
                                      if (left > 0)
                                          blueRect.style.marginLeft = left - 10 + "px";
                                      break;
                                  case 38:   // თუ დაჭერილი კლავიშია ისარი ზევით
                                      if (top > 0)
                                          blueRect.style.marginTop = top - 10 + "px";
                                      break;
                                  case 39:   // თუ დაჭერილი კლავიშია ისარი მარჯვნივ
                                      if (left < document.documentElement.clientWidth - 100)
                                          blueRect.style.marginLeft = left + 10 + "px";
                                      break;
                                  case 40:   // თუ დაჭერილი კლავიშია ისარი ქვევით
                                      if (top < document.documentElement.clientHeight - 100)
                                          blueRect.style.marginTop = top + 10 + "px";
                                      break;
                              }
                          }
                          addEventListener("keydown", moveRect);
                      </script>
                  </body>
                  </html>
                  მოცემულ შემთხვევაში მუშავდება მოვლენა keydown. window.getComputedStyle() მეთოდის მეშვეობით ვიღებთ blueRect ელემენტის სტილს. შემდეგ მისი სტილიდან ვიღებთ თვისებებს marginLeft-ს და marginTop-ს. მოვლენის დამუშავებისას e.keyCode თვისების მეშვეობით ვგებულობთ, თუ რომელ კლავიშზე მოხდა დაჭერა. თუ დაჭერა მოხდა კლავიშებიდან - ისარი მარცხნივ, ისარი მარჯვნივ, ისარი ზევით, ისარი ქვევით - ერთ-ერთზე, ვახდენთ marginLeft ან marginTop თვისების შეცვლა, რითაც ვაღწევთ ელემენტის გადაადგილების ეფექტს. ამასთან document.documentElement.clientWidth და document.documentElement.clientHeight მეთოდების მეშვეობით ისაზღვრება ვებგვერდის ზომები და კონტროლდება, რომ ელემენტი არ გავიდეს ვებგვერდის საზღვრებს გარეთ.
                  
                   `
              },
              
            ]
        },
        {
            title:"თავი 10. მუშაობა ფორმებთან",
            content:[
                {
                    title:"ფორმები და მათი ელემენტები",
                    data:`მომხმარებელთან ურტიერთობის ერთ-ერთი ხერხია html ფორმები. მაგალითად, თუ ჩვენ გვინდა მივიღოთ მომხმარებლისგან გარკვეული ინფორმაცია, შეგვიძლია მოვათავსოთ ვებგვერდზე ფორმა, რომელსაც ექნება ტექსტური ველები ინფორმაციის შესაყვანად და გაგზავნის ღილაკი. მონაცემების შეყვანის შემდეგ ჩვენ შეგვიძლია დავამუშავოთ შეყვანილი ინფორმაცია.

                    ფორმის შესაქმნელად გამოიყენება ელემენტი <form>:
                    
                    <form name="search">
                    </form>
                    ჯავასცრიპტში ფორმა წარმოდგენილია ობიექტით HtmlFormElement. შექმნის მერე ფორმას შეიძლება მივმართოთ რამდენიმე ხერხით. 
                    
                    პირველი ხერხი მდგომარეობს სახელით მიმართვაში:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <form name="search"></form>
                        <form name="settings"></form>
                        <script>
                            var searchForm;
                            for (var i = 0; i < document.forms.length; i++) {
                     
                                if (document.forms[i].name === "search")
                                    searchForm = document.forms[i];
                            }
                            document.write(searchForm.name);
                        </script>
                    </body>
                    </html>
                    name თვისების მეშვეობით ჩვენ შეგვიძლია მივიღოთ html კოდში ფორმის ნებისმიერი ელემენტის ელემენტის name ატრიბუტის მნიშვნელობა.
                    
                    მეორენაირად:
                    
                    var searchForm = document.forms["search"];
                    ასევე შეგვიძლია გამოვიყენოთ ძებნის სტანდარტული მეთოდები id-ის, ტეგის ან სელექტორის მეშვეობით. მაგალითად:
                    
                    var searchForm = document.getElementsByTagname("form")[0];
                    ფორმას გააჩნია თვისებები, რომელთაგან უმნიშვნელოვანესია ზემოთ განხილული თვისება name, ასევე თვისება elements, რომელიც შეიცავს ფორმის ელემენტების კოლექციას:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <form name="search">
                            <input type="text" name="key"></input>
                            <input type="submit" name="send"></input>
                        </form>
                        <script>
                        var searchForm = document.forms["search"];
                        for(var i=0; i<searchForm.elements.length;i++)
                            document.write(searchForm.elements[i].name + "<br/>");
                        </script>
                    </body>
                    </html>
                     
                    
                    JavaScript
                    
                    ფორმის მეთოდებს შორის მნიშვნელოვანია მეთოდი submit(), რომელიც ახდენს ფორმის სერვერზე გაგზავნას და reset(), რომელიც ასუფთავებს ფორმის ელემენტებს:
                    
                    var searchForm = document.forms["search"];
                    searchForm.submit();
                    searchForm.reset();
                    ფორმის ელემენტები
                    
                    ფორმა შეიძლება შეიცავდეს შეყვანის სხვადასხვა html ელემენტებს: input, textarea, button, select და ა. შ. მაგრამ მათ აქვთ საერთო მეთოდები და თვისებები. 
                    
                    ისევე როგორც ფორმას, ფორმის ელემენტებსაც გააცნიათ თვისება name, რომლის მეშვეობითაც შეგვიძლია მივიღოთ name ატრიბუტის მნიშვნელობა:
                    
                    <form name="search">
                        <input type="text" name="key" value="hello world"></input>
                        <input type="submit" name="send"></input>
                    </form>
                    <script>
                    var searchForm = document.forms["search"];
                    // გამოვიტანოთ ყვალა ელემენტის სახელი
                    for(var i=0; i<searchForm.elements.length;i++)
                        document.write(searchForm.elements[i].name + "<br/>");
                        
                    // მოვძებნოთ ტექსტური ველი სახელის მიხედვით
                    var keyBox = searchForm.elements["key"];
                    document.write(keyBox.name); // key
                    </script>
                    მეორე მნიშვნელოვან თვისებას წარმოადგენს value, რომლის მეშვეობით შეგვიძლია მივიღოთ ან შევცვალოთ ველის მნიშვნელობა:
                    
                    var searchForm = document.forms["search"];
                    var keyBox = searchForm.elements["key"];
                    document.write(keyBox.value); // hello world
                    // მნიშვნელობის მინიჭება
                    keyBox.value = "გამარჯობა, სამყაროვ!";
                    form თვისების მეშვეობით შეგვიძლია მივიღოთ ფორმა, რომლის ელემენტსაც წარმოადგენს მიმდინარე ელემენტი:
                    
                    var searchForm = document.forms["search"];
                    var keyBox = searchForm.elements["key"];
                    document.write(keyBox.form.name); // search
                    ეს თვისება შეიძლება სასარგებლო იყოს ფორმის გაგზავნის წინ, როცა საჭიროა ფორმის ყველა ველის ვალიდაცია.
                    
                    type თვისების შეგვიძლია განვსაზღვროთ შეყვანის ველის ტიპი. ეს არის ან ელემენტის ტეგის დასახელება (მაგალითად textarea), ან input ელემენტის type ატრიბუტის მნიშვნელობა.
                    
                    მეთოდებიდან შეგვიძლია გამოვყოთ focus() (ანიჭებს ფოკუსს ელემენტს) და blur() ( აშორებს ელემენტს ფოკუსს):
                    
                    var searchForm = document.forms["search"];
                    var keyBox = searchForm.elements["key"];
                    keyBox.focus();`
                },
                {
                  title:"ღილაკები",
                  data:`ფორმაში შეყვანილი მონაცემების გასაგზავნად გამოიყენება ან ელემენტი button:

                  <button name="send">გაგზავნა</button>
                  ან ელემენტი input:
                  
                  <input type="submit" name="send" value="გაგზავნა" />
                  html-ში ფუნქციონალის მიხედვით ეს ორი ელემენტი მთლად იდენტური არ არის, მაგრამ ამ შემთხვევაში ჩვენ გვაინტერესებს ჯავასკრიტის კოდთან მიმართებაში.
                  
                  ღილაკის ამ ორი ვარიანტიდან ნებისმიერ ის დაჭერისას ხდება ფორმის გაგზავნა მისამართზე, რომელიც მითითებულია action ატრიბუტში, ან ვებგვერდის მისამართზე, თუ action ატრიბუტი არაა მითითებული. მაგრამ ჯავასკრიპტის კოდში ჩვენ შეგვიძლია შევაცეროთ გაგზავნა click მოვლენის დამუშავებისას:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="search">
                          <input type="text" name="key"></input>
                          <input type="submit" name="send" value="გაგზავნა" />
                      </form>
                      <script>       
                          function sendForm(e) {
                              // ვიღებთ key ველის მნიშვნელობას
                              var keyBox = document.search.key;
                              var val = keyBox.value;
                              if (val.length > 5) {
                                  alert("სტრიქონის სიგრძე არაა დასაშვები");
                                  e.preventDefault();
                              }
                              else
                                  alert("გაგზავნა ნებადართულია");
                          }
                          var sendButton = document.search.send;
                          sendButton.addEventListener("click", sendForm);
                      </script>
                  </body>
                  </html>
                  ღილაკზე დაჭერისას წარმოიშობა მოვლენა click, მისი დამუშავება ხდება დამმუშავებელში sendForm. დამმუშავებელში ვამოწმებთ ტექსტურ ველს. თუ მისი სიგრძე მეტია 5-ზე, გამოგვაქვს შეტყობინება დაუშვებელი ტექსტის სიგრძის შესახებ და ვწყვეტთ მოვლენის შესრულებას e.preventDefault() მეთოდის გამოძახებით. შედეგად, ფორმის გაგზავნა არ ხდება. თუ ტექსტის სიგრძე 5-ზე ნაკლებია, ფორმა იგზავნება.
                  
                  ასევე, საჭიროებისას ჩვენ შეგვიძლია შევცვალოთ მისამართი, სადაც იგზავნება ფორმის მონაცემები:
                  
                  function sendForm(e) {
                      // ვიღებთ key ველის მნიშვნელობას
                      var keyBox = document.search.key;
                      var val = keyBox.value;
                      if (val.length > 5) {
                          alert("სტრიქონის სიგრძე არაა დასაშვები");
                          document.search.action = "PostForm";
                      }
                      else
                          alert("გაგზავნა ნებადართულია");
                  }
                  ამ შემთხვევაში, თუ ტექსტის სიგრძე აღემატება დასაშვებს, ფორმის მონაცემები იგზავნება, ოღონდ სხვა მისამართზე.
                  
                  ფორმის გასასუფთავებლად შეგვიძლია გამოვიყენოთ შემდეგი ორი ერთნაირი ფუნქციონალის მქონე ღილაკიდან ერთ-ერთი:
                  
                  <button type="reset">გასუფთავება</button>
                  <input type="reset" value="გასუფთავება" />
                  ღილაკზე დაჭერისას მოხდება ფორმის ველების გასუფთავება. გასუფთავების ფუნქციონალის რეალიზება ასევე შეიძლება reset() მეთოდის გამოყენებით:
                  
                  function sendForm(e) {
                      // ვიღებთ key ველის მნიშვნელობას
                      var keyBox = document.search.key;
                      var val = keyBox.value;
                      if (val.length > 5) {
                          alert("სტრიქონის სიგრძე არაა დასაშვები");
                          document.search.reset();
                          e.preventDefault();
                      }
                      else
                          alert("გაგზავნა ნებადართულია");
                  }
                  გარდა გაგზავნის და გასუფთავების სპეციალური ღილაკებისა, ასევე შეიძლება გამოვიყენოთ ჩვეულებრივი ღილაკები:
                  
                  <input type="button" name="send" value="გაგზავნა " />
                  ასეთ ღილაკზე დაჭერისას ფორმის მონაცემების გაგზავნა არ ხდება, მაგრამ გენერირდება მოვლენა click, რომელიც შეიძლება დავამუშაოთ:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="search">
                          <input type="text" name="key" placeholder="შეიყვანეთ გასაღები"></input>
                          <input type="button" name="print" value="ბეჭდვა" />
                      </form>
                      <div id="printBlock"></div>
                      <script>
                          function printForm(e) {
                   
                              // ვიღებთ key ველის მნიშვნელობას
                              var keyBox = document.search.key;
                              var val = keyBox.value;
                              //ვიღებთ ელემენტს printBlock
                              var printBlock = document.getElementById("printBlock");
                              //ვქმნით ახალ პარაგრაფს
                              var pElement = document.createElement("p");
                              // ვანიჭებთ მას ტექსტს
                              pElement.textContent = val;
                              // ვამატებთ პარაგრაფს printBlock ელემენტსი
                              printBlock.appendChild(pElement);
                          }
                          var printButton = document.search.print;
                          printButton.addEventListener("click", printForm);
                      </script>
                  </body>
                  </html>
                  ღილაკზე დაჭერისას ვიღებთ ტექსტური ველის მნიშვნელობას და ვებგვერდზე ვქმნით ახალ პარაგრაფს მიღებული ტექსტით`
              },
              {
                  title:"ტექსტური ველები",
                  data:`მარტივი ტექსტური ინფორმაციის შესაყვანად გამოიყენება ელემენტი <input type="text">:

                  <input type="text" name="kye" size="10" maxlength="15" value="hello world" />
                  მოცემულ ელემენტებზე წარმოიშობა მოვლენები:
                  
                  focus: წარმოიშობა ფოკუსის მიღებისას
                  blur: წარმოიშობა ფოკუსის დაკარგვისას
                  change: წარმოიშობა ველის მნიშვნელობის ცვლილებისას
                  select: წარმოიშობა ტექსტის მონიშვნისას
                  keydown: წარმოიშობა კლავისის დაჭერისას
                  keypress: წარმოიშობა სიმბოლოების შესაბამისი კლავიშების დაჭერისას
                  keyup: წარმოიშობა დაჭერილი კლავიშის აშვებისას
                  გამოვიყენოთ რამდენიმე მათგანი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="search">
                          <input type="text" name="key" placeholder="შეიყვანეთ გასაღები"></input>
                          <input type="button" name="print" value="ბეჭდვა" />
                      </form>
                      <div id="printBlock"></div>
                      <script>
                          var keyBox = document.search.key;
                   
                          // ტექსტის ცვლილების დამმუშავებელი
                          function onchange(e) {
                              // ვიღებთ printBlock ელემენტს
                              var printBlock = document.getElementById("printBlock");
                              // ვიღებთ ახალ მნიშვნელობას
                              var val = e.target.value;
                              // ვანიჭებთ მნიშვნელობას
                              printBlock.textContent = val;
                          }
                          // ფოკუსის დაკარგვის დამუშავება
                          function onblur(e) {
                              // ვიღებთ ტექსტის მნიშვნელობას და ვაჭრით ცარიელ სიმბოლოებს
                              var text = keyBox.value.trim();
                              if (text === "")
                                  keyBox.style.borderColor = "red";
                              else
                                  keyBox.style.borderColor = "green";
                          }
                          // ფოკუსის მიღების დამუშავება
                          function onfocus(e) {
                              // ველის ჩარჩოს ფერი
                              keyBox.style.borderColor = "blue";
                          }
                          keyBox.addEventListener("change", onchange);
                          keyBox.addEventListener("blur", onblur);
                          keyBox.addEventListener("focus", onfocus);
                      </script>
                  </body>
                  </html>
                  აქ ტექსტურ ველზე მიმაგრებულია სამი მოვლენის დამმუშავებელი: blur, focus და change. change მოვლენის დამუშავებისას მთელი ტექსტი აისახება ელემენტში printBlock. მაგრამ უნდა გავითვალისწინოთ, რომ ასახვა ხდება არა ტექსტის შეყვანისთანავე, არამედ ფოკუსის დაკარგვისას.
                  
                  ფოკუსის დაკარგვის მოვლენის დამუშავებისას ხდება შეყვანილი მნიშვნელობის ვალიდაცია. თუ ტექსტი მხოლოდ ცარიელი სიმბოლოებისგან შედგება ან არ იყო შეყვანილი, ტექსტური ველის ჩარჩო ხდება წითელი:
                  
                  JavaScript
                  
                  ჩვეულებრივი ტექსტური ველის გარდა არის ასევე სპეციალური ტექსტური ველები. მაგალითად, <input type="password"> განკუთვნილია პაროლების შესაყვანად. ფუნქციონალით იგი მეტწილად ჩვეულებრივი ტექსტური ველის ანალოგიურია, მაგრამ შეყვანილი სიმბოლოებისთვის გამოიყენება მასკა, რათა შეყვანილი ტექსტი არ გამოჩნდეს:
                  
                  <input type="password" name="password" />
                  
                  თუ ჩვენ გვინდა როიმ ვებგვერდზე გვქონდეს რაღაც მნიშვნელობა, მაგრამ მომხმარებელი მას ვერ ხედავდეს, გამოიყენება დამალული ველები:
                  
                  <input type="hidden" name="id" value="345" />
                  
                  როგორც წესი, დამალული ველების მოვლენები არ გამოიყენება, მაგრამ ჯავასკრიპტში შეგვიძლია მივიღოთ ასეთი ველების მნიშვნელობები და შევცვალოთ ისინი.
                  
                  ელემენტი textarea
                  
                  მრავალსტრიქონიანი ტექსტური ველების შესაქმნელად გამოიყენება ელემენტი textarea:
                  
                  <textarea rows="15" cols="40" name="textArea"></textarea>
                  
                  ამ ელემენტზე გენერირდება ყველა ის მოვლენა, რაც გაჩნია ჩვეულებრივ ტექსტურ ელემენტს:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="search">
                          <textarea rows="7" cols="40" name="message"></textarea>
                      </form>
                      <div id="printBlock"></div>
                      <script>
                          var messageBox = document.search.message;
                          // სიმბოლოს შეყვანის დამუშავება
                          function onkeypress(e) {
                              // ვიღებთ ელემენტს printBlock
                              var printBlock = document.getElementById("printBlock");
                              // ვიღებთ შეყვანილ სიმბოლოს
                              var val = String.fromCharCode(e.keyCode);
                              // სიმბოლოს დამატება
                              printBlock.textContent += val;
                          }
                          function onkeydown(e) {
                              if (e.keyCode === 8) { // თუ დავაჭერთ Backspace კლავიშზე
                   
                                  // ვიღებთ ელემენტს printBlock
                                  var printBlock = document.getElementById("printBlock"),
                                      length = printBlock.textContent.length;
                                  // ვაჭრით ბოლო სიმბოლოს
                                  printBlock.textContent = printBlock.textContent.substring(0, length - 1);
                              }
                          }
                          messageBox.addEventListener("keypress", onkeypress);
                          messageBox.addEventListener("keydown", onkeydown);
                      </script>
                  </body>
                  </html>
                   აქ ტექსტურ ველზე მიმაგრებულია მოვლენის დამმუშავებლები keypress და keydown. keypress-ის დამმუშავებელში ჩვენ ვიღებთ აკრეფილ სიმბოლოს კლავისის ციფრული კოდის კონვერტაციის გზით:
                  
                  var val = String.fromCharCode(e.keyCode);
                  და მიღებულ სიმბოლოს ვამატებთ printBlock ბლოკის ტექსტს.
                  
                  keypress მოვლენა წარმოიშობა საბეჭდი სიმბოლოს შესაბამის კლავიშზე დაჭერისას და ის აისახება ტექსტურ ველში, მაგრამ არის კლავიშები, რომელთაც არ შეესაბამება საბეჭდი სიმბოლოები და მათ დაჭერას keypress მოვლენა ვერ აღიქვამს. სწორედ ასეთ კლავიშებს მიეკუთვნება Backspace, ამიტომ მასზე დაჭერის დამუშავება შეიძლება keydown მოვლენის დროს.`
              },
              {
                  title:"ალმები და გადამრთველები",
                  data:`შეყვანის ელემენტების განსაკუთრებულ ჯგუფს წარმოადგენენ ალმები და გადამრთველები.

                  ალმები წარმოადგენენ ველებს, რომელთა მონიშვნაც შეიძლება და იქმნება <input type="checkbox"> ელემენტის გამოყენებით. მის განმასხვავებელ ნიშანს წარმოადგენს თვისება checked, რომლის მნიშვნელობაც მონიშნულ მდგომარეობაში არის true:
                  
                   <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="myForm">
                          <input type="checkbox" name="enabled" checked>
                          <span>ჩამრთველი</span>
                      </form>
                      <div id="printBlock"></div>
                      <script>
                          var enabledBox = document.myForm.enabled;
                          function onclick(e) {
                              var printBlock = document.getElementById("printBlock");
                              var enabled = e.target.checked;
                              printBlock.textContent = enabled;
                          }
                          enabledBox.addEventListener("click", onclick);
                      </script>
                  </body>
                  </html>
                  ალამზე დაჭერა აგენერირებს მოვლენას click.მოცემულ შემთხვევაში მაუსის დაჭერის დამუშავებისას div ბლოკსი გამოგვაქვს ინფორმაცია, მონიშნულია თუ არა ალამი:
                  
                  JavaScript
                  
                  გადამრთველები წარმოადგენენ ღილაკების ჯგუფს, რომელთაგან შეგვიძლია მხოლოდ ერთის არჩევა. გადამრთველები იქმნება <input type="radio"> ელემენტის გამოყენებით. ერთ-ერთი მათგანის არჩევა ან მაუსის დაჭერა ასევე აგენერირებს მოვლენას click:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="myForm">
                          <input type="radio" name="languages" checked="checked" value="Java" />
                          <span>Java</span>
                          <input type="radio" name="languages" value="C#" />
                          <span>C#</span>
                          <input type="radio" name="languages" value="C++" />
                          <span>C++</span>
                      </form>
                      <div id="printBlock"></div>
                      <script>
                          function onclick(e) {
                   
                              var printBlock = document.getElementById("printBlock");
                              var language = e.target.value;
                              printBlock.textContent = "თქვენ აირჩიეთ: " + language;
                          }
                          for (var i = 0; i < myForm.languages.length; i++) {
                              myForm.languages[i].addEventListener("click", onclick);
                          }
                      </script>
                  </body>
                  </html>
                  გადამრთველების ჯგუფის შექმნის დროს მათი ატრიბუტი name უნდა იყოს ერთი და იგივე. მოცემულ შემთხვევაში ეს არის language. ანუ გადამრთველები ქმნიან ჯგუფს language. რადგანაც გადამრთველი ბევრია, მათთვის დამმუშავებლის მისამაგრაბლად საჭიროა გადავარჩიოთ მასივი, რომლის მიღებაც შეიძლება ჯგუფის სახელის მიხედვით:
                  
                  for (var i = 0; i < myForm.languages.length; i++) {
                      myForm.languages[i].addEventListener("click", onclick);
                  }
                  არჩეული გადამრთველის მნიშვნელობა შეიძლება გავარკვიოთ Event ობიექტის მეშვეობით: e.target.value:
                  
                  JavaScript
                  
                  ყველა გადამრთველს, ისევე როგორც ალმებს, გააჩნიათ თვისება checked, რომელიც აბრუნებს true-ს, ტუ გადამრთველი არჩეულია. მაგალითად, ავირჩიოთ ბოლო გადამრთველი:
                  
                   myForm.languages[myForm.languages.length-1].checked = true;`
              },
              {
                  title:"სია select",
                  data:`სიების შესაქმნელად გამოიყენება ელემენტი select. ამასთან, მისი მეშვეობით შეიძლება შევქმნათ როგორც ჩამოსაშლელი, ისე მრავალი არჩევანის მქონე სიებიც. მაგალითად, შევქმნათ სტანდარტული სია:

                  <select name="language" size="4">
                      <option value="JS" selected="selected">JavaScript</option>
                      <option value="Java">Java</option>
                      <option value="C#">C#</option>
                      <option value="C++">C++</option>
                  </select>
                  ატრიბუტი size საშუალებას გვაძლევს მივუთიტოტ, თუ რამდენი ელემენტი გამოჩნდება ერთდროულად სიაში. თუ მივანიჭებთ მნიშვნელობას size="1", გამოჩნდება მხოლოდ ერთი ელემენტი, ხოლო სია გახდება ჩამოშლადი. თუ ელემენტს გააჩნია ატრიბუტი multiple, სიაში შესაძლებელი იქნება ერთდროულად რამდენიმე მნიშვნელობის არჩევა.
                  
                  სიის თითოეული ელემენტი განისაზღვრება ელემენტით option, რომელსაც გააჩნია ტექსტი, რომელიც გამოისახება ეკრანზე და მნიშვნელობა, რომელიც განისაზღვრება ატრიბუტით value.
                  
                  ჯავასკრიპტში ელემენტს select შეესაბამება ობიექტი  HTMLSelectElement, ხოლო ელემენტს option - HTMLOptionElement ან უბრალოდ Option.
                  
                  სიის ყველა ელემენტს ჯავასკრიპტში შეესაბამება თვისება options. ხოლო თითოეულ HTMLOptionElement -ს გააჩნია თვისებები: index (ინდექსი options კოლექციაში), text (ტექსტი) და value (მნიშვნელობა). მაგალითად, მოვძებნოთ სიის პირველი ელემენტი და თვისებების მეშვეობით მივიღოთ მის შესახებ ინფორმაცია:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="myForm">
                          <select name="language" size="4">
                              <option value="JS" selected="selected">JavaScript</option>
                              <option value="Java">Java</option>
                              <option value="CS">C#</option>
                              <option value="CPP">C++</option>
                          </select>
                      </form>
                      <script>
                          var firstLanguage = myForm.language.options[0];
                          document.write("Index: " + firstLanguage.index + "<br/>");
                          document.write("Text: " + firstLanguage.text + "<br/>");
                          document.write("Value: " + firstLanguage.value + "<br/>");
                      </script>
                  </body>
                  </html>
                   
                  
                  JavaScript
                  
                  ჯავასკრიპტის მეშვეობით ჩვენ შეგვიძლია არა მხოლოდ სიის ელემენტების მიღება, არამედ დინამიურად მატი მართვა. მაგალითად, დავამატოთ და წავშალოთ ელემენტები სიიდან:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="myForm">
                          <select name="language" size="5">
                              <option value="JS" selected="selected">JavaScript</option>
                              <option value="Java">Java</option>
                              <option value="CS">C#</option>
                              <option value="CPP">C++</option>
                          </select>
                          <p>
                              <input type="text" name="textInput" placeholder="შეიყვანეთ ტექსტი" />
                          </p>
                          <p>
                              <input type="text" name="valueInput" placeholder="შეიყვანეთ მნიშვნელობა" />
                          </p>
                          <p>
                              <input type="button" name="addButton" value="დამატება" />
                              <input type="button" name="removeButton" value="წაშლა" />
                          </p>
                      </form>
                      <script>
                          var addButton = myForm.addButton,
                              removeButton = myForm.removeButton,
                              languagesSelect = myForm.language;
                          // ელემენტის დამატება
                          function addOption() {
                              // მივიღოთ ელემენტის ტექსტი
                              var text = myForm.textInput.value;
                              // მივიღოთ ელემენტის მნიშვნელობა
                              var value = myForm.valueInput.value;
                              // შევქმნათ ახალი ელემენტი
                              var newOption = new Option(text, value);
                              languagesSelect.options[languagesSelect.options.length] = newOption;
                          }
                          // ელემენტის წაშლა
                          function removeOption() {
                              var selectedIndex = languagesSelect.options.selectedIndex;
                              // ელემენტის წაშლა
                              languagesSelect.options[selectedIndex] = null;
                          }
                          addButton.addEventListener("click", addOption);
                          removeButton.addEventListener("click", removeOption);
                      </script>
                  </body>
                  </html>
                  დამატებისთვის ფაორმაზე განკუთვნილია ორი ტექსტური ველი (ერთი ტექსტისთვის, მეორე - მნიშვნელობისთვის) და ღილაკი "დამატება". მონისნული ელემენტის წაშლისთვის განკუთვნილია კიდევ ერთი ღილაკი "წაშლა".
                  
                  დამატებას ახორციელებს ფუნქცია addOption, რომელიც ღებულობს ტექსტს და მნიშვნელობას ახალი ელემენტისთვის, ქმნის ახალ Option ობიექტს და ამატებს სიის ობიექტის options მასივში.
                  
                  წაშლას ახორციელებს ფუნქცია removeOption, რომელშიც ვღებულობთ მონიშნული ელემენტის ინდექსს seectedIndex თვისების მეშვეობით და options კოლექციაში ამ ინდექსის შესაბამის ელემენტს ვუტოლებთ null-ს.
                  
                  JavaScript
                  
                  სიაში ელემენტების დამატებისა და წაშლისთვის ალტერნატივის სახით შეიძლება გამოვიყენოთ select ობიექტის მეთოდები add და remove:
                  
                  languagesSelect.add(newOption);
                  languagesSelect.remove(selectedIndex);
                  select ობიექტის მოვლენები
                  
                  select ობიექტს გააცნია სამი მოვლენის მხარდაჭერა. ესენია: blur (ფოკუსის დაკარგვა) focus (ფოკუსის მიღება) და change (არჩეული ელემენტის შეცვლა). განვიხილოთ ამ მოვლენების გამოყენება:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <form name="myForm">
                          <select name="language" size="5">
                              <option value="JS" selected="selected">JavaScript</option>
                              <option value="Java">Java</option>
                              <option value="CS">C#</option>
                              <option value="CPP">C++</option>
                          </select>
                      </form>
                      <div id="selection"></div>
                      <script>
                          var languagesSelect = myForm.language;
                   
                          function changeOption() {
                              var selection = document.getElementById("selection");
                              var selectedOption = languagesSelect.options[languagesSelect.selectedIndex];
                              selection.textContent = "თქვენ აირჩიეთ: " + selectedOption.text;
                          }
                   
                          languagesSelect.addEventListener("change", changeOption);
                      </script>
                  </body>
                  </html>`
              },
           
            ]
        },
        {
            title:"თავი 11. JSON",
            content:[
                {
                    title:"შესავალი JSON-ში",
                    data:`JSON (JavaScript Object Notation) წარმოადგენს მონაცემთა შენახვის მსუბუქ ფორმატს. JSON აღწერს ჯავასკრიპტის მონაცემების სტრუქტურას და ორგანიზაციას. სიმარტივისა და სიმსუბუქის გამო JSON web გარემოში მონაცემების გადაცემის ყველაზე პოპულარულ ფორმატს წარმოადგენს. მან პრაქტიკულად ჩაანაცვლა მანამდე პოპულარული xml ფორმატი.

                    JSON ობიექტი ძალიან წააგავს ჯავასკრიპტის ობიექტებს. ამასთან მნიშვნელოვანია განვასხვავოთ ისინი: JavaScript წარმოადგენს პროგრამირების ენას, ხოლო JSON წარმოადგენს მონაცემების შენახვის ფორმატს.
                    
                    JSONს გააცნია მონაცემთა სამი ტიპის - პრიმიტიული მნიშვნელობების, ობიექტების და მასივების - მხარდაჭერა. პრიმიტიულ მნიშვნელობებს წარმოადგენენ სტრიქონები, რიცხვები, მნიშვნელობა null, ლოგიკური მნიშვნელობები - true და false.
                    
                    ობიექტები წარმოადგენენ პრიმიტიული მონაცემების, სხვა ობიექტების და მასივების ნაკრებს. მაგალითად:
                    
                    {
                        "name": "Tom",
                        "married": true,
                        "age": 30
                    }
                    ჯავასკრიპტში ამ JSON-ს შეესაბამება შემდეგი ობიექტი:
                    
                    var user = {
                        name: "Tom",
                        married: true,
                        age: 30
                    }
                    მიუხედავად მსგავსებისა ,მათ შორის არის მნიშვნელოვანი განსხვავებები. JSON-ში თვისებები ისმება ბრჭყალებში, როგორც ჩვეულებრივი სტრიქონები. გარდა ამისა, JSON-ის ობიექტებს JavaScript-ის ობიექტებისგან განსხვავებით არ შეუძლიათ ფუნქციების და ცვლადების შენახვა.
                    
                    ობიექტები შეიძლება იყოს რთული:
                    
                    {
                        "name": "Tom",
                        "married": true,
                        "age": 30,
                        "company": {
                            "name": "Microsoft",
                            "address": "USA, Redmond"
                        }
                    }
                    JSON-ის მასივები ჯავასკრიპტის მასივების მსგავსია და შეიძლება შედგებოდეს მარტივი მონაცემებისგან ან ობიექტებისგან:
                    
                    ["Tom", true, 30]
                    ობიექტების მასივი:
                    
                    [{
                        "name": "Tom",
                        "married": true,
                        "age": 30
                    },{
                        "name": "Alice",
                        "married": false,
                        "age": 23
                    }]
                    სერიალიზაცია და დესერიალიზაცია JSON-ში
                    
                    JavaScript-ის ობიექტების სერიალიზაციისთვის გამოიყენება ფუნქცია JSON.stringify():
                    
                    var user = {
                        name: "Tom",
                        married: true,
                        age: 30
                    };
                    var serializedUser = JSON.stringify(user);
                    document.write(serializedUser); // {"name":"Tom","married":true,"age":30}
                    უკუოპერაციისთვის - დესერიალიზაციისთვის ანუ პარსირებისთვის json ობიექტისა ჯავასკრიპტში გამოიყენება მეთოდი JSON.parse():
                    
                    var user = {
                        name: "Tom",
                        married: true,
                        age: 30
                    };
                    // სერიალიზაცია
                    var serializedUser = JSON.stringify(user);
                    // დესერიალიზაცია
                    var tomUser = JSON.parse(serializedUser);
                    document.write(tomUser.name); // Tom`
                },
            ]
        },
        {
            title:"თავი 12. მონაცემების შენახვა",
            content:[
                {
                    title:"cookie",
                    data:`ჯავასკრიპტსი მონაცემთა შენახვის ერთ-ერთ შესაძლებლობას წარმოადგენს ქუქების გამოყენება. ამისათვის გამოიყენება document ობიექტის თვისება cookie. 

                    მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <script>
                            document.cookie = "login=tom32;";
                        </script>
                    </body>
                    </html>
                    ბრაუზერების უმეტესობაში შესაძლებელია ქუქების დათვალიერება და მისი ინფორმაციის ნახვა. მომავალში შესაძლებელია ამ ინფორმაციის გამოყენება.
                    
                    ქუქის გააჩნია ექვსამდე სხვადასხვა პარამეტრი: სახელი, მნიშვნელობა, მოქმედების ვადა (expires), მისამართი (path), დომენი (domain) და secure. ზემოთ იყო გამოყენებული მხოლოდ ორი პარამეტრი: სახელი და მნიშვნელობა: ქუქის სახელია login, მნიშვნელობა - tom32. 
                    
                    მაგრამ ასეთ ქუქს აქვს შეზღუდული სიცოცხლის ხანგრძლივობა: თუ მოქმედების ვადა არ ეთითება, ქუქი წაიშლება ბრაუზერის დახურვასთან ერთად. ასეთი სიტუაცია მისაღებია, თუ გვინდა რომ ბრაუზერის დახურვასთან ერთად გასუფთავდეს ქუქებში შენახული ინფორმაცია. მაგრამ ასეთი რამ ყოველთვის მისაღები არ არის.
                    
                    ასეთ შემთხვევაში ეთითება პარამეტრი expires, ანუ ქუქის მოქმედების ვადა:
                    
                    document.cookie = "login=tom32;expires=Mon, 28 Feb 2018 00:00:00 GMT;";
                    login ქუქის მოქმედების ვადაა 2018 წლის 28 თებერვლის 00:00 სთ. ძალიან მნიშვნელოვანია expires პარამეტრის ფორმატი. თუმცა შესაძლებელია მისი გენერირება პროგრამულად. ამისთვის შეგვიძლია გამოვიყენოთ მეთოდი toUTCString():
                    
                    var expire = new Date();
                    expire.setHours(expire.getHours() + 4);
                    document.cookie = "login=tom32;expires=" + expire.toUTCString() + ";";
                    ამ შემთხვევაში ქუქის მოქმედების ვადა განისაზღვრება 4 საათით.
                    
                    თუ ჩვენ გვინდა ქუქის შენახვა საიტის გარკვეული მისამართისთვის, გამოიყენება პარამეტრი path. მაგალითდ:
                    
                    document.cookie = "login=tom32;expires=Mon, 31 Aug 2015 00:00:00 GMT;path=/home;";
                    სხვა მისამართებისთვის საიტზე, მაგალითად www.mysite.com/shop, ეს ქუქი არ იქნება ხელმისაწვდომი.
                    
                    თუ საიტზე რამდენიმე დომენია და ქუქის შენახვა გვინდა მხოლოდ რომელიმე მათგანისთვის, ეთითება პარამეტრი domain:
                    
                    document.cookie = "login=tom32;expires=Mon, 31 Aug 2015 00:00:00 GMT;path=/;domain=blog.mysite.com;";
                    პარამეტრი path=/ მიუტითებს, რომ ქუქი მოქმედებს www.mysite.com/shop ქვედომენის ყველა დირექტორიისთვის.
                    
                    პარამეტრი secure ნიშნავს SSL (Secure Socket Layer)-ს და გამოიყენება საიტებისთვის, რომლებიც იყენებს https პროტოკოლს. თუ ეს პარამეტრი არის true, ეს ნისნავს რომ ქუქი გამოიყენება მხოლოდ დაცული შეერთების შემთხვევაში. მიუთითებლობისას ამ პარამეტრის მნიშვნელობა არის false.
                    
                    document.cookie = "login=tom32;expires=Mon, 31 Aug 2015 00:00:00 GMT;path=/;domain=blog.mysite.com;secure=true;";
                    ქუქის ამოკითხვა
                    
                    ქუქის ამოსაკითხად საკმარისია მივმართოთ თვისებას document.cookie:
                    
                    var expire = new Date();
                    expire.setHours(expire.getHours() + 4);
                     
                    document.cookie = "city=Berlin;expires="+expire.toUTCString()+";";
                    document.cookie = "country=Germany;expires="+expire.toUTCString()+";";
                    document.cookie = "login=tom32;";
                     
                    document.write(document.cookie);
                    აქ არის შენახული სამი ქუქი და ბრაუზერს გამოაქვს სამივე.
                    
                    ამოკითხული ქუქი არ შეიცავს პარამეტრებს expires, path, domain და secure. ამასთან ქუქები გამოიყოფა ერთმანეთისგან წერტილმძიმით. ამიტომ ქუქების სახელებისა და მნიშვნელობების მისაღებად გარკვეული გარდაქმნა გვჭირდება:
                    
                    var cookies = document.cookie.split(";");
                    for(var i=0; i<cookies.length; i++){
                     
                        var parts = cookies[i].split("="),
                            name = parts[0],
                            value = parts[1];
                        document.write("ქუქის სახელი: " + name + "<br/>");
                        document.write("მნიშვნელობა: " + value + "<br/><br/>");
                    }`
                },
                {
                  title:"Web Storage",
                  data:`თუმცა ქუქები გვაძლევს მონაცემების შენახვის საშუალებას, მას გააცნია მთელი რიგი შეზღუდვები. მაგალითად, ბრაუზერს აქვს შეზღუდვა ქუქის ზომაზე - თიტოეული მათგანი არ უნდა აღემატებოდეს 4 კილობაიტს. ქუქებს გააჩნიათ მოქმედების ვადა, რომლის შემდეგ ისინი იშლება. ქუქები წარმოადგენენ HTTP პროტოკოლის განუყოფელ ნაწილს და ყოველი მოთხოვნის დროს მოთხოვნასთან ერთად გადაეცემა სერვერს. თუმცა ჯავასკრიპტის კოდის შესასრულებლად სერვერზე გადაცემას მნიშვნელობა არა აქვს. გარდა ამისა, ქუქებიდან ინფორმაციის ამოკთხვისთვის გარკვეული კოდის დაწერაა საჭირო.

                  ამიტომ HTML5-ში დაემატა მონაცემების შენახვის ახალი კონცეფცია - Web Storage. იგი შედგება ორი ნაწილისაგან: sesსion storage და local strorage. 
                  
                  session storage წარმოადგენს ინფორმაციის დროებით საცავს და ის ბრაუზერის დახურვასტან ერთად იშლება.
                  
                  local storage წარმოადგენს ინფორმაციის საცავს მუდმივ საფუძვლებზე. მონაცემები local storage-დან ავტომატურად არ იშლება და არ გააჩნიათ მოქმედების ვადა. ეს მონაცემები არ გადაეცემა სერვერზე HTTP მოთხოვნასთან ერთად. გარდა ამისა, local storage-ის მოცულობა Chrome-ში და  Firefox-ში 5 მეგაბაიტია, ხოლო Microsoft Edge-ში 10 მეგაბაიტი.
                  
                  მთელი მონაცემები web storage-ში წარმოადგენს უნიკალური სახელისა და მნიშვნელობის წყვილების ნაკრებს. 
                  
                  ჯავასკრიპტში local storage-სთვის გამოიყენება ობიექტი localStorage, ხოლო session storage-სთვის - ობიექტი sessionStorage. 
                  
                  მონაცემების შენახვისტვის გამოიყენება მეთოდი setItem():
                  
                  localStorage.setItem("login", "tom32@gmail.com");
                  
                  ამ მეთოდს გადაეცემა ორი პარამეტრი: შესანახი ობიექტის გასაღები (სახელი) და მნიშვნელობა. თუ localStorage-ში უკვე არის ობიექტი ასეთი გასაღებით, მოხდება მნიშვნელობის შეცვლა.
                  
                  შენახული მონაცემების ამოკითხვისთვის გამოიყენება მეთოდი getItem():
                  
                  var login = localStorage.getItem("login"); //tom32@gmail.com
                  
                  ამ მეთოდს გადაეცემა ობიექტის გასაღები. 
                  
                  ობიექტის წასაშლელად გამოიყენება მეთოდი removeItem():
                  
                  localStorage.removeItem("login");
                  
                  localStorage-დან ყველა ობიექტის წასაშლელად გამოიყენება მეთოდი clear():
                  
                  localStorage.clear();
                  
                  მარტივი ობიექტების შენახვა სირთულეს არ წარმოადგენს, მაგრამ უნდა გავითვალისწინოთ, რომ მონაცემები ინახება სტრიქონის სახით:
                  
                  localStorage.setItem("age", 23);
                  var age = localStorage.getItem("age");
                  age=parseInt(age)+10;
                  document.write(age); //33
                  თუ არ მოხდება age-ის მნიშვნელობის გარდაქმნა რიცხვად parseInt() მეთოდის გამოყენებით, იგი იმოქმედებს როგორც სტრიქონი და არა როგორც რიცხვი.
                  
                  სირთულე შეიძლება წარმოიშვას რთული ობიექტების შენახვისას:
                  
                  var user ={
                      name: "Tom",
                      age: 23,
                      married: false
                  };
                   
                  localStorage.setItem("user", user);
                  var savedUser = localStorage.getItem("user");
                  document.write(savedUser); //[object Object]
                  document.write(savedUser.name); // undefined - savedUser - სტრიქონია და არა ობიექტი
                  ასეთ დროს უნდა გამოვიყენოთ ობიექტის სერიალიზაცია და დესერიალიზაცია JSON-ში:
                  
                  var user ={
                      name: "Tom",
                      age: 23,
                      married: false
                  };
                   
                  localStorage.setItem("user", JSON.stringify(user));
                  var savedUser = JSON.parse(localStorage.getItem("user"));
                  document.write(savedUser.name + " " + savedUser.age +" " + savedUser.married); // Tom 23 false
                  და ბოლოს, ზოგიერთ ბრაუზერში სპეციალური ინსტრუმენტების მეშვეობით შესაძლებელია ვნახოთ local storage-ს ობიექტები. მაგალითად, Google Chrome-ში:`
              },
             
            ]
        },
        {
            title:"თავი 13. Ajax",
            content:[
                {
                    title:"ობიექტი XMLHttpRequest",
                    data:`თნამედროვე ვებაპლიკაციები, როგორც წესი, იყოფა ორ ნაწილად: კლიენტი და სერვერი. კლიენტი წარმოადგენს ვებგვერდს ჯავასკრიპტის კოდით. სერვერულ ტექნოლოგიებს მიეკუთვნება PHP. Ruby, Node.js, ASP.NETდა ა. შ., რომლებიც იღებენ მოთხოვნას კლიენტისგან, ამუშავებენ მას და დამუშავების შედეგს უბრუნებენ პასუხად.

                    Ajax წარმოადგენს კლიენტის ჯავასკრიპტის კოდიდან სერვერზე ვებგვერდის გადატვირთვის გარეშე მოთხოვნის გაგზავნის ტექნოლოგიას. თვიტონ ტერმინი იშიფრება, როგორც Asynchronous JavaScript And XML. ანუ თავდაპირველად Ajax განსაზღვრული იყო, როგორც კლიენტსა და სერვერს შორის ინფორმაციის გაცვლის საშუალება XML დოკუმენტების მეშვეობით. თუმცა დღეისათვის XML ფორმატი ძირითადად ჩაანაცვლა JSON ფორმატმა. Ajax-მა რევოლუციური ცვლილებები მოახდინა ვებგარემოში, მოგვცა რა დინამიური ვებგვერდების შექმნის შესაძლებლობა.
                    
                    რადგანაც Ajax არის კლიენტისა და ვებსერვერის ურთიერთქმედების სასუალება, მისი მუშაობის გასაცნობად საჭიროა ნებისმიერი ვებსერვერი.
                    
                    ვებგვერდების შესაქმნელად, რომლებიც იყენებენ Ajax-ს, არსებობს სხვადასხვა ხერხი. მათ შორის ყველაზე გავრცელებულს წარმოადგენს ობიექტი XMLHttpRequest:
                    
                    var request = new XMLHttpRequest();
                    
                    XMLHttpRequest ობიექტის შექმნის შემდეგ შესაძლებელია მოთხოვნის გაგზავნა სერვერზე, მაგრამ პირველ რიგსი უნდა მოხდეს open() მეთოდის გამოძახება ინიციალიზაციისათვის:
                    
                    request.open("GET", "http://localhost:8080/hello.txt", false);
                    
                    open() მეთოდს გადაეცემა 3 პარამეტრი: მოთხოვნის ტიპი (GET, POST, HEAD, PUT), მოთხოვნის მისამართი და მესამე არააუცილებელი პარამეტრი - ლოგიკური მნიშვნელობა true ან false, რომელიც მიუთითებს, მეთოდის გამოძახება მოხდება თუ არა ასინქრონულ რეჟიმში. ანუ, მოცემულ შემთხვევაში მოთხოვნის ტიპი იქნება GET, ის გაიგზავნება მისამართზე http://localhost:8080/hello.txt სინქრონულ რეჟიმში (ასინქრონული რეჟიმისთვის ეთითება true).
                    
                    სინქრონული და ასინქრონული რეჟიმი განსხვავდება ერთმანეთისგან იმით, რომ სინქრონულ რეჟიმში სანამ მოთხოვნა არ შესრულდება, ჯავასკრიპტის შემდგომი კოდი არ სრულდება. თუ მესამე პარამეტრი არ მიეთითება, მოთხოვნა სრულდება ასინქრონულ რეჟიმში, რომელიც საშუალებას გვაძლევს მოთხოვნის პარალელურად შესრულდეს ჯავასკრიპტის სხვა კოდიც. უმეტეს შემთხვევაში გამოიყენება სწორედ ასინქრონული რეჟიმი.
                    
                    გარდა ამისა, open() მეტოდს შეიძლება გადაეცეს კიდევ ორი პარამეტრი: მომხმარებლის სახელი და პაროლი, თუ მოთხოვნის შესრულება მოითხოვს ავტორიზაციას:
                    
                    request.open("GET", "http://localhost:8080/home.php", true, "login", "password");
                    
                    open() მეთოდით ინიციალიზაციის შემდეგ ხდება მოთხოვნის გაგზავნა send() მეთოდის მეშვეობით:
                    
                    request.send();
                    
                    XMLHttpRequest-ის თვისებები
                    
                    XMLHttpRequest ობიექტს გააჩნია თვისებები, რომლებიც საშუალებას გვაძლევენ გავაკონტროლოთ მოთხოვნის შესრულება:
                    
                    status: შეიცავს სერვერიდან მოსული HTTP პასუხის სტატუსის კოდს. სტატუსის კოდის მიხედვით შეგვიძლია ვიმსჯელოთ, როგორი წარმატებით შესრულდა მოთხოვნა ან შეცდომებზე, რომლებიც შეიძლებოდა მოხდარიყო მისი შესრულების დროს. მაგალითად, კოდი 200 ნიშნავს, რომ მოთხოვნა შესრულდა წარმატებით. კოდი 403 მიუთითებს, რომ მოთხოვნის შესასრულებლად საჭიროა ავტორიზაცია, ხოლო კოდი 404 ნიშნავს, რომ რესურსი არ მოიძებნა და ა. შ.
                    statusText: აბრუნებს პასუხის სტატუსის ტექსტს, მაგალითად, "200 OK"
                    responseType: აბრუნებს პასუხის ტიპს. არსებობს შემდეგი ტიპები:
                    ""
                    "arraybuffer"
                    "blob"
                    "document"
                    "json"
                    "text"
                    response: აბრუნებს სერვერის პასუხს
                    responseText: აბრუნებს პასუხის ტექსტს
                    responseXML: აბრუნებს xml-ს, თუ სერვერის პასუხი xml ფორმატშია
                    მაგალითად, შევასრულოთ მოთხოვნა ტექსტური ფაილიდან, რომელიც მდებარეობს ლოკალურ ვებსერვერზე. ajax მოთხოვნის შესასრულებლად დაგვჭირდება გაშვებული ლოკალური სერვერი, რომელზეც არსებობს ფაილი hello.txt და რომელიც შეიცავს სტრიქონს: "გამარჯობა, სამყაროვ!":
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <script>
                            var request = new XMLHttpRequest();
                            request.open("GET", "http://localhost:8080/hello.txt", false);
                            request.send();
                            var status = request.status;
                            if (status == 200)
                                document.write("პასუხის ტექსტი: " + request.responseText)
                            else if (status == 404)
                                document.write("რესურსი არ მოიძებნა")
                            else
                                document.write(request.statusText)
                        </script>
                    </body>
                    </html>
                    ვებგვერდის ჩატვირთვისთანავე შესრულდება ajax მოთხოვნა რესურსზე http://localhost:8080/hello.txt. ორონდ უნდა გავითვალისწინოთ, რომ სტატუსის მიღება მოთხოვნის გაგზავნისთანავე იმუშავებს მხოლოდ სინქრონული მოთხოვნების დროს.
                    
                    JavaScript
                    
                    ასინქრონული მოთხოვნები
                    
                    თუმცა სინქრონული მოთხოვნები მუშაობს და შეიძლება მათი გამოყენება, მაგრამ ამავე დროს მათი გამოყენება არაა რეკომენდირებული. ხშირად მოთხოვნის შესრულებას საკმაო დრო სჭირდება, ამ დროის განმავლობაში ხდება დანარჩენი კოდის შესრულების ბლოკირება, რამაც არასასურველი დაყოვნებები შეიძლება გამოიწვიოს. სწორედ ამიტომ ეძლევა უპირატესობა ასინქრონულ მოთხოვნებს.
                    
                    ასინქრონულ მოთხოვნებთან მუშაობა ოდნავ უფრო რთულია, ვიდრე სინქრონულთან, რადგან ამ დროს საჭიროა XMLHttpRequest ობიექტის readystatechange მოვლენის დამუშავება.
                    
                    ასინქრონული მოთხოვნის დროს XMLHttpRequest ობიექტი იყენებს თვისებას readyState მოთხოვნის მდგომარეობის შესანახად. მოთხოვნის მდგომარეობა წარმოადგენს რიცხვს:
                    
                    0: XMLHttpRequest ობიექტი შექმნილია, მაგრამ open() მეთოდის გამოძახება არ მომხდარა მისი ინიციალიზაციისთვის
                    1: მეთოდი open() გამოძახებულია (ანუ ინიციალიზაცია მოხდა), მაგრამ მოთხოვნის გაგზავნა არ მომხდარა send() მეთოდის მეშვეობით
                    2: მოთხოვნა გაგზავნილია, პასუხის სათაურები და სტატუსი მიღებულია და მზადაა გამოყენებისთვის
                    3: პასუხი სერვერიდან მიღებულია
                    4: მოთხოვნის შესრულება დასრულებულია (თუნდაც მიღებული იყოს შეცდომის ოდი, მაგალითად 404)
                    მოვლენა readystatechange გენერირდება ყოველ ჯერზე, როცა ხდება readyState თვისების ცვლილება. მაგალითად, შევასრულოთ ასინქრონული მოთხოვნა:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    </head>
                    <body>
                        <script>
                            var request = new XMLHttpRequest();
                            function reqReadyStateChange() {
                                if (request.readyState == 4) {
                                    var status = request.status;
                                    if (status == 200) {
                                        document.write(request.responseText);
                                    } else {
                                        document.write("სერვერის პასუხი " + request.statusText);
                                    }
                                }
                            }
                            request.open("GET", "http://localhost:8080/hello.txt");
                            request.onreadystatechange = reqReadyStateChange;
                            request.send();
                        </script>
                    </body>
                    </html>
                    გარდა readystatechange მოვლენის დამუშავებისა სერვერის პასუხის მისაღებად ასევე შეიძლება დავამუშავოთ მოვლენა load, რომელიც წარმოიშობა მოთხოვნის შესრულების შემდეგ. მისი გამოყენებაც ანალოგიურია:
                    
                    var request = new XMLHttpRequest();
                    function responceLoad() {
                        if (request.readyState == 4) {
                            var status = request.status;
                            if (status == 200) {
                                document.write(request.responseText);
                            } else {
                                document.write("სერვერის პასუხი " + request.statusText);
                            }
                        }
                    }
                     
                    request.open("GET", "http://localhost:8080/hello.txt");
                    request.onload = responceLoad;
                    request.send();`
                },
                {
                  title:"მონაცემების გაგზავნა",
                  data:`GET მოთხოვნა ხასიათდება იმით, რომ მონაცემები შეიძლება გაიგზავნოს მოთხოვნის სტრიქონშივე:

                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div id="output"></div>
                      <script>
                          // გაგზავნის ობიექტი
                          var user = {
                              name: "Tom",
                              age: 23
                          };
                   
                          var request = new XMLHttpRequest();
                          function reqReadyStateChange() {
                              if (request.readyState == 4) {
                                  var status = request.status;
                                  if (status == 200) {
                                      document.getElementById("output").innerHTML = request.responseText;
                                  }
                              }
                          }
                          // მოთხოვნის სტრიქონი პარამეტრებით
                          var body = "name=" + user.name + "&age=" + user.age;
                          request.open("GET", "http://localhost:8080/postdata.php?" + body);
                          request.onreadystatechange = reqReadyStateChange;
                          request.send();
                      </script>
                  </body>
                  </html>
                  გასაგზავნად ვიღებთ user ობიექტს და მისგან ვახდენთ პარამეტრების სტრიქონის ფორმირებას: "name=" + user.name + "&age="+user.age. შემდეგ ეს სტრიქონი ემატება მოთხოვნის სტრიქონს მეთოდში open("GET", "http://localhost:8080/postdata.php?"+body). საბოლოოდ მოთხოვნის სტრიქონს ექნება შემდეგი სახე: http://localhost:8080/postdata.php?user.name=Tom&age=23.
                  
                  იგულისხმება, რომ მონაცემები ეგზავნება php სკრიპტს postdata.php, რომელსაც შეიძლება ჰქონდეს შემდეგი სახე:
                  
                  <?php
                  $name = "უცნობი";
                  $age = "უცნობი";
                  if(isset($_GET['name'])) $name = $_GET['name'];
                  if (isset($_GET['age'])) $age = $_GET['age'];
                  echo "თქვენი სახელი: $name  <br> თქვენი ასაკი: $age";
                  ?>
                  სერვერის ტექნოლოგიას ამ შემთხვევაში მნიშვნელობა არა აქვს. 
                  
                  პარამეტრების კოდირება
                  
                  GET მოთხოვნაში გასაგზავნი პარამეტრები ერთმანეთისგან გამოიყოფა ამპერსანდით (&). მაგრამ რა მოხდება, თუ თვითონ რომელიმე პარამეტრი შეიცავს ამპერსანდს? მაგალითად:
                  
                  var user = {
                      name: "Tom&Tim",
                      age: 23
                  };
                  // მოთხოვნის სტრიქონი პარამეტრებით
                  var body = "name=" + user.name + "&age="+user.age;
                  ამ შემთხვევაში სერვერმა შეიძლება არასწორად ამოიღოს პარამეტრები მოთხოვნის სტრიქონიდან. გაუგებრობების თავიდან ასაცილებლად საჭიროა გასაგზავნი მონაცემების კოდირება decodeURIComponent() ფუნქციის მეშვეობით:
                  
                  var body = "name=" + encodeURIComponent(user.name) + "&age="+encodeURIComponent(user.age);
                  სტრიქონს "Tom&Tim" კოდირების შემდეგ ექნება ასეთი სახე: "Tom%26Tim".
                  
                  საჭიროების შემთხვევაში შესაძლებელია კოდირებული სტრიქონის დეკოდირება decodeURIComponent() ფუნქციის მეშვეობით:
                  
                  var encodeName = encodeURIComponent(user.name); // Tom%26Tim
                  var decodeName = decodeURIComponent(encodeName); // Tom&Tim
                  POST მოთხოვნები
                  
                  POST მოთხოვნების გაგზავნა ცოტატი განსხვავებულია:
                  
                  var user = {
                      name: "Tom",
                      age: 23
                  };
                   
                  var request = new XMLHttpRequest();
                  function reqReadyStateChange() {
                      if (request.readyState == 4 && request.status == 200)
                          document.getElementById("output").innerHTML = request.responseText;
                  }
                  var body = "name=" + user.name + "&age=" + user.age;
                  request.open("POST", "http://localhost:8080/postdata.php");
                  request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                  request.onreadystatechange = reqReadyStateChange;
                  request.send(body);
                  POST მეთოდით მონაცემების გასაგზავნად საჭიროა მოთხოვნის სათაურის კონტენტის ტიპის (Content-Type) განსაზღვრა setRequestHeader() მეთოდის მეშვეობით. მოცემულ შემთხვევაში მასა აქვს მნიშვნელობა application/x-www-form-urlencoded.
                  
                  ფორმის გაგზავნა. FormData
                  
                  დაწყებული სპეციფიკაციიდან XMLHttpRequest2, ჯავასკრიპტში გამოცნდა ახალი ობიექტი - FormData, რომელიც იძლევა ფორმის სერიალიზაციის საშუალებას მისი შემდგომი გაგზავნისთვის. ამასთან, არაა აუცილებელი ფორმის შექმნა html კოდში, საკმარისია მისი დინამიურად შექმნა ჯავასკრიპტში:
                  
                  var formData = new FormData();
                  formData.append('name', 'Tom');
                  formData.append('age', 23);
                   
                  var request = new XMLHttpRequest();
                  function reqReadyStateChange() {
                      if (request.readyState == 4 && request.status == 200)
                          document.getElementById("output").innerHTML = request.responseText;
                  }
                   
                  request.open("POST", "http://localhost:8080/display.php");
                  request.onreadystatechange = reqReadyStateChange;
                  request.send(formData);
                  ობიექტების დასამატებლად FormData ობიექტს გააჩნია მეთოდი append('პარამეტრის_სახელი',მნიშვნელობა). ამასთან არანაირი სათაურების მითითება არაა საჭირო.
                  
                  ასევე შესაძლებელია ფორმა იყოს განსაზღვრული html კოდში:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <div id="output"></div>
                      <form name="user" action="http://localhost:8080/postdata.php">
                          <input type="text" name="username" placeholder="შეიყვანეთ სახელი" />
                          <br/>
                          <input type="text" name="age" placeholder="შეიყვანეთ ასაკი" />
                          <br/>
                          <input type="submit" name="submit" value="გაგზავნა" />
                      </form>
                      <script>
                          // ვიღებთ ფორმის ობიექტს
                          var form = document.forms.user;
                          // ვამაგრებთ ფორმის დამმუშავებელს
                          form.submit.addEventListener("click", sendRequest);
                   
                          // დაჭერის დამუშავება
                          function sendRequest(event) {
                   
                              event.preventDefault();
                              var formData = new FormData(form);
                   
                              var request = new XMLHttpRequest();
                   
                              request.open("POST", form.action);
                   
                              request.onreadystatechange = function () {
                                  if (request.readyState == 4 && request.status == 200)
                                      document.getElementById("output").innerHTML = request.responseText;
                              }
                              request.send(formData);
                          }
                      </script>
                  </body>
                  </html>
                  ყველა ველის სერიალიზაციისთვის საკმარისია ფორმის ობიექტის გადაცემა კონსტრუქტორში FormData: var formData = new FormData(form);
                  
                  მონაცემების გაგზავნა json ფორმატში
                  
                  json ფორმატში მონაცემების გასაგზავნად საჭიროა მოთხოვნას მივანიჭოთ შესაბამისი სათაური და მონაცემების სერიალიზაცია მოვახდინოთ JSON.stringify მეთოდის დახმარებით:
                  
                  // გასაგზავნი ობიექტი
                  var user = {
                      username: "Tom",
                      age: 23
                  };
                  var json = JSON.stringify(user);
                  var request = new XMLHttpRequest();
                  request.open("POST", "http://localhost:8080/postjson.php");
                  request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
                  request.onreadystatechange = function () {
                          if (request.readyState == 4 && request.status == 200)
                              document.getElementById("output").innerHTML=request.responseText;
                  }
                  request.send(json);`
              },
              {
                  title:"Promise Ajax მოთხოვნებში",
                  data:`როგორც წინა თემებში ვნახეთ, ajax მოთხოვნებში ფაქტობრივად გამოიყენება ერთნაირი გამოძახებები, რომელთაც განსხვავებული აქვთ მხოლოდ დეტალები: მოთხოვნის სტრიქონი, პასუხის დამუშავების ფუნქცია. შესაბამისად, არ იქნებოდა ურიგო ყველა მოქმედებისთვის, რომლებიც დაკავშირებულია ასინქრონულ ajax მოთხოვნებთან, შეგვექმნა საერთო აბსტრაქცია და გამოგვეყენებინა იგი სერვერთან შემდგომი მიმართვებისთვის.

                  აბსტრაქციის დამატებითი დონის შესაქმნელად გამოიყენება ობიექტი Promise, რომელშიც ხდება ასინქრონული ოპერაციის შეფუთვა ერთ ობიექტად, რომელიც შესაძლებლობას გვაძლევს, განვსაზღვროთ მოქმედებები, რომლებიც უნდა შესრულდეს ოპერაციის წარმატებით ან წარუმატებლად დასრულების შემთხვევაში.
                  
                  მოვახდინოთ ასინქრონული მოთხოვნის ინკაფსულაცია Promise ობიექტში:
                  
                  function post(url, requestuestBody) {
                      return new Promise(function (succeed, fail) {
                          var request = new XMLHttpRequest();
                          request.open("POST", url, true);
                          request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                          request.addEventListener("load", function () {
                              if (request.status < 400)
                                  succeed(request.responseText);
                              else
                                  fail(new Error("Request failed: " + request.statusText));
                          });
                          request.addEventListener("error", function () {
                              fail(new Error("Network error"));
                          });
                          request.send(requestuestBody);
                      });
                  }
                  post მეთოდი პარამეტრებად იღებს სერვერის რესურსის მისამართს და გასაგზავნ მონაცემებს. ეს მეთოდი აბრუნებს ობიექტს Promise. კონსტრუქტორი Promise პარამეტრად იღებს უკუგამოძახების ფუნქციას, რომელიც თავის მხრივ იღებს ორ პარამეტრს - ორ ფუნქციას: ერთი სრულდება მოთხოვნის წარმატებით დასრულებისას, მეორე - წარუმატებლობისას.
                  
                  ახლა გამოვიძახოთ მეთოდი post სერვერზე მოთხოვნის გასაგზავნად:
                  
                  var user = {
                      name: "Tom",
                      age: 23
                  };
                  // გასაგზავნი მონაცემები
                  var params = "name=" + user.name + "&age=" + user.age;
                   
                  post("http://localhost:8080/postdata.php", params).then(function (text) {
                      console.log(text);
                  }, function (error) {
                      console.log(error);
                  });
                  Promise ობიექტის შედეგის დასამუშავებლად ხდება then() მეთოდის გამოძახება, რომელიც იღებს ორ პარამეტრს: ფუნქცია, რომლის გამოძახებაც ხდება მოთხოვნის წარმატებით დასრულებისას და ფუნქცია, რომლის გამოძახებაც ხდება წარუმატებლობისას. მეთოდი then() ასევე აბრუნებს ობიექტს Promise. ამიტომ საჭიროებისას შეიძლება გამოვიყენოთ Then მეთოდის გამოძახებატა ჯაჭვი: post().then().then()...`
              },
          
            ]
        },
    ]
},
node:{
    chapters:[
        {
            title:"თავი 1. შესავალი Node.js-ში",
            content:[
                {
                    title:"რა არის Node.js. მუშაობის დაწყება",
                    data:`Node.js წარმოადგენს JavaScript-ის კოდის შესრულების გარემოს, რომელიც აგებულია JavaScript Chrome V8-ის ძრავზე, რომელიც საშუალებას იძლევა მოხდეს JavaScript-ის კოდის ტრანსლირება მოხდეს მანქანურ ენაზე. Node.js პირველ რიგსი განკუთვნილია სერვერული სისტემების შესაქმნელად. თუმცა არსებობს პროექტები დესკტოპ სისტემებისთვისაც (Electron) და მიკროკონტროლიორებისთვისაც კი.

                    Node.js წარმოადგენს ღია პროექტს და მისი პირველადი კოდის ნახვა შეიძლება github.com-ზე. 
                    
                    ინსტალაცია
                    
                    გადმოსატვირთად გადავიდეთ ოფიციალურ საიტზე https://nodejs.org/en/. მთავარ გვერდზე ვნახავთ ორი სხვადასხვა ვერსიის გადმოსაწერ ბმულს: ესენია ბოლო ვერსია და LTS ვერსია:
                    
                    JavaScript
                    
                    გადმოვწეროთ LTS ვერსია და დავაინსტალიროთ.
                    
                    ინსტრუმენტები
                    
                    NodeJS-ის პროექტის შესაქმნელად საკმარისია ნებისმიერი ტექსტური რედაქტორი, როგორიდაა მაგალითად Notepad++. ჩვენ გამოვიყენებთ Visual Studio Code-ს.
                    
                    REPL
                    
                    NodeJS-ის ინსტალაციის შემდეგ ჩვენთვის ხელმისაწვდომია ისეთი ინსტრუმენტი, როგორიცაა REPL (Read Event Printed Loop). მისი მეშვეობით შესაძლებელია JavaScript-ის კოდის შესრულება ბრძანებების ფანჯარაში (CMD).
                    
                    გავუშვათ ბრძანებების ფანჯარაში ბრძანება node. ამის შემდეგ შეგვიძლია JavaScript-ის ნებისმიერი გამოსახულების შესრულება. მაგალითად:
                    
                    C:\WINDOWS\system32>node
                    > 2+6
                    8
                    >
                    ან გამოვიყენოთ ჯავასკრიპტის რომელიმე ფუნქცია:
                    
                    > console.log("Hello NodeJS");
                    Hello NodeJS
                    undefined
                    >
                    შეგვიძლია განვსაზღვროთ საკუთარი ფუნქციები. მაგალითად რიცხვის კვადრატში აყვანა:
                    
                    > function sqrt(x){return x * x;}
                    undefined
                    >sqrt(5)
                    25
                    >
                     
                    
                    JavaScript
                    
                    თუ რამეს არასწორად შევიტანთ, REPL გაგვაფრთხილებს ამის შესახებ.
                    
                    ფაილის შესრულება
                    
                    მთლი კოდის კონსოლსი შეყვანის ნაცვლად, უფრო მოხერხებულია კოდი ჩავწეროთ ფაილსი და შემდეგ გავუშვათ ეს ფაილი. მაგალითად, შევქმნათ ფაილი app.js და მასში ჩავწეროთ:
                    
                    console.log("Hello world");
                    ბრძანებების ფანჯარაში cd ბრძანების მეშვეობით გადავიდეთ საჭირო საქაღალდეზე და შევასრულოთ ბრძანება:
                    
                    > node app.js
                    მოცემული ბრძანებით შესრულდება ფაილში არსებული კოდი:`
                },
                {
                  title:"პირველი პროგრამა Node.js-ზე",
                  data:`დავწეროთ პირველი უმარტივესი პროგრამა Node.js-ზე. ამისათვის შეგვიძლია გამოვიყენოთ JavaScript-ის პრაქტიკულად ყველა სტანდარტული კონსტრუქცია. გამონაკლისს წარმოადგენს DOM-თან მუშაობა, რადგანაც პროგრამა გაიშვებს სერვერზე და არა ბრაუზერში, შესაბამისად ვერ გამოვიყენებთ DOM-ის ობიექტებს, როგორიცაა window ან document.

                  პირველ რიგში შევქმნათ საქაღალდე, მაგალითად d:\\node\helloapp და მასში ფაილი app.js. ფაილში ჩავწეროთ შემდეგი კოდი:
                  
                  var http = require("http");
                  http.createServer(function(request,response){
                      
                      response.end("Hello NodeJS!");
                      
                  }).listen(3000, "127.0.0.1",function(){
                      console.log("The server is listening port 3000");
                  });
                  მოკლედ გავარჩიოთ ეს კოდი.
                  
                  პირველ სტრიქონში ხდება http მოდულის პროექტში ჩართვა, რომელიც აუცილებელია სერვერის შესაქმნელად. ეს ჩაშენებული მოდულია და მის ჩასართავად უნდა გამოვიყენოთ ფუნქცია require().:
                  
                  var http = require("http");
                  შემდეგ createServer() მეთოდის მეშვეობით იქმნება ახალი სერვერი შემომავალი შეერთებების მოსასმენად და მოთხოვნების დასამუშავებლად. პარამეტრის სახით ეს მეთოდი იღებს ფუნქციას, რომელსაც გააცნია ორი პარამეტრი. პარამეტრი request ინახავს მთელ ინფორმაციას მოთხოვნის შესახებ, ხოლო response გამოიყენება პასუხის გასაგზავნად. მოცემულ შემთხვევაში პასუხს წარმოადგენს უბრალო სტრიქონი "Hello NodeJS" და მისი გაგზავნა ხდება მეთოდით response.end().
                  
                  მაგრამ მეთოდი http.createServer() მხოლოდ ქმნის სერვერს. იმისათვის, რომ მან დაიწყოს შემომავალი შეერთებების მოსმენა, უნდა გამოვიძახოთ მისი მეთოდი listen:
                  
                  .listen(3000, "127.0.0.1",function(){
                      console.log("The server is listening port 3000");
                  });
                   
                  
                  ეს მეთოდი იღებს 3 პარამეტრს. პირველი პარამეტრი მიუთითებს ლოკალურ პორტს, რომელზეც უნდა გაეშვას სერვერი. მეორე პარამეტრი წარმოადგენს ლოკალურ მისამართს. მოცემულ შემთხვევაში სერვერი გაიშვებს მისამართზე 127.0.0.1 ანუ localhost და პორტზე 3000. 
                  
                  მესამე პარამეტრი წარმოადგენს ფუნქციას, რომელიც იშვებს პორტის მოსმენის დაწყებისას. ამ შემთხვევაში ამ ფუნქციას გამოაქვს შეტყობინება კონსოლზე.
                  
                  ახლა გავუშვათ სერვერი. ამისათვის გავხსნათ ბრძანებების ფანჯარა, გადავიდეთ ჩვენს საქაღალდეში  და გავუშვათ ბრძანება "node app.js". ან შეგვიძლია პირდაპირ სრული მისამართის მითითებით:
                  
                  node d:/node/helloapp/app.js
                   
                  
                  JavaScript
                  
                  ახლა გავხსნათ ბრაუზერი და მისამართის ზოლში ავკრიფოთ http://localhost:3000:
                  
                  JavaScript
                  
                  ბრაუზერში გამოისახება შეტყობინება, რომლის გაგზავნაც მოხდა მეთოდში response.end().
                  
                  გაშვებული სერვერის გასაჩერებლად ბრძანებების ფანჯარაში უნდა დააჭიროთ Ctrl+C.`
              },
               
            ]
        },
        {
            title:"თავი 2. Node.js-თან მუშაობის საფუძვლები",
            content:[
                {
                    title:"მოდულები",
                    data:`Node.js იყენებს მოდულურ სისტემას. ანუ მთელი ფუნქციონალი დაყოფილია მოდულებად. მოდული წარმოადგენს კოდების ბლოკს, რომლის გამოყენება ხდება მრავალჯერადად სხვა მოდულებში.

                    საჭიროებისას ჩვენ შეგვიძლია ჩავრთოთ პროექტში სხვადასხვა მოდული. თუ რა ჩაშენებული მოდულებია Node.js-ში და რა ფუნქციონალი გააცნია მათ, შეგვიძლია ვნახოთ დოკუმენტაციაში.
                    
                    მოდულების ჩასატვირთად გამოიყენება ფუნქცია require(),რომელსიც გადაეცემა მოდულის დასახელება. მაგალითად, წინა თემაში მოთხოვნების მისაღებად და დასამუშავებლად გამოვიყენეთ მოდული http:
                    
                    var http = require("http");
                    მოდულის პროექტში ჩართვის შემდეგ შეგვიძლია გამოვიყენოთ მასში განსაზღვრული მთელი ფუნქციონალი, რომლის ნახვა ასევე შესაძლებელია დოკუმენტაციაში.
                    
                    ანალოგიურად შეგვიძლია გამოვიყენოთ სხვა ჩაშენებული მოდულებიც. მაგალითად os  მოდულის გამოყენებით შეგვიძლია მივიღოთ ინფორმაცია გარემოცვისა და ოპერაციული სისტემის შესახებ:
                    
                     
                    
                    var os = require("os");
                    // გავიგოთ მიმდინარე მომხმარებლის სახელი
                    var userName = os.userInfo().username;
                     
                    console.log(userName);
                     
                    
                    ჩვენ არა ვართ შეზღუდული ჩაშენებული მოდულებით და საჭიროებისას შეგვიძლია შევქმნათ ჩვენი მოდულები. მაგალითად, წინა თემაში პროექტი შედგებოდა ერთი ფაილისგან app.js, რომელშიც იქმნებოდა სერვერი მოთხოვნების დასამუშავებლად. დავამატოთ იგივე საქაღალდეში ფაილი greeting.js და ჩავწეროთ მასში შემდეგი კოდი:
                    
                    console.log("greeting module");
                    app.js ფაილში ჩავრთოთ ჩვენი მოდული:
                    
                    var greeting = require("./greeting");
                    განსხვავებით ჩაშენებული მოდულებისაგან, ჩვენი მოდულის ჩასართავად საჭიროა მივუთითოთ ამ ფაილის ფარდობითი მისამართი. გაფართოების მითითება აუცილებელი არაა.
                    
                    გავუშვათ სერვერი:
                    
                    JavaScript
                    
                    კონსოლში გამოდის ის სტრიქონი, რომელიც არის განსაზღვრული greeting.js-ფაილში.
                    
                    ახლა შევცვალოთ ფაილი greeting.js:
                    
                    var currentDate = new Date();
                    module.exports.date = currentDate;
                     
                    module.exports.getMessage = function(name){
                        var hour = currentDate.getHours();
                        if(hour > 16)
                            return "Good evening, " + name;
                        else if(hour > 12)
                            return "Good afternoon, " + name;
                        else
                            return "Good morning, " + name;
                    }
                    აქ განსაზღვრულია ცვლადი currentDate, მაგრამ გარედან ის ხელმისაწვდომი არ არის. ცვლადი რომ ხელმისაწვდომი იყოს გარედან, ის უნდა განისაზღვროს ობიექტში module.exports. ობიექტი module .exports არის ის, რასაც აბრუნებს ფუნქცია require().
                    
                    ობიექტი module წარმოადგენს მიმართვას მიმდინარე მოდულზე. ხოლო მისი თვისება exports წარმოადგენს ყველა თვისებასა და მეთოდს, რომელთა ექსპორტირებაც ხდება მოდულიდან სხვა მოდულებში გამოსაყენებლად.
                    
                    მოცემულ შემთხვევაში, განისაზღვრება თვისება date და მეთოდი getMessage, რომელიც იღებს გარკვეულ პარამეტრს.
                    
                    ახლა შევცვალოთ ფაილი app.js:
                    
                    var os = require("os");
                    var greeting = require("./greeting");
                     
                    // მივიღოთ მიმდინარე მომხმარებლის სახელი
                    var userName = os.userInfo().username; 
                     
                    console.log("Request data:" + greeting,data)
                    console.log(greeting.getMessage(userName));
                    ყველა ექსპორტირებული თვისება და მეთოდი ხელმისაწვდომია სახელით:  greeting.date და greeting.getMessage.
                    
                    გავუშვათ პროგრამა:
                    
                    JavaScript
                    
                    კონსტრუქტორებისა და ობიექტების განსაზღვრა მოდულში
                    
                    მარტივი ფუნქციებისა და თვისებების გარდა მოდულში შეიძლება განისაზღვროს რთული ობიექტები და კონსტრუქტორები, რომლებიც შემდგომში გამოიყენება ობიექტების შესაქმნელად. დავამატოთ პროექტის საქაღალდეში ახალი ფაილი user.js:
                    
                    function User(name, age){
                        
                        this.name = name;
                        this.age = age;
                        this.displayInfo = function(){
                            
                           console.log("Name: " + this.name + " Age:" + this.age);
                        }
                    }
                    User.prototype.sayHi = function() {
                        console.log("Hello, my name is " + this.name);
                    };
                     
                    module.exports = User;
                    აქ განსაზღვრულია სტანდარტული კონსტრუქტორის ფუნქცია, რომელსაც აქვს ორი პარამეტრი. ამასთან, მთლიანად მოდული მიუთითებს ამ კონსტრუქტორზე:
                    
                    module.exports = User;
                    ჩავრთოთ და გამოვიყენოთ ეს მოდული app.js-ში:
                    
                    var User = require("./user.js");
                     
                    var tom = new User("Tom", 32);
                    tom.sayHi();`
                },
                {
                  title:"მუშაობა მოდულებთან",
                  data:`განვიხილოთ Node.js-ის მოდულებთან მუშაობის ზოგიერთი ასპექტი. პირველ რიგში უნდა აღვნიშნოთ, რომ ხდება ჩართული მოდულების კეშირება. კერძოდ, ფაილში https://github.com/nodejs/node/blob/master/lib/module.js არის შემდეგი კოდი:

                  var filename = Module._resolveFilename(request, parent, isMain);
                   
                    var cachedModule = Module._cache[filename];
                    if (cachedModule) {
                      return cachedModule.exports;
                  }
                  ეს ერთის მხრივ, ზრდის წარმადობას, მაგრამ მეორეს მხრივ, წარმოსობს გარკვეულ პრობლემებს, თუ ჩვენ არ გავითვალისწინებთ ამ ასპექტს. მაგალითად, განვიხილოთ წინა თემის პროექტი, სადაც app.js-ში ხდებოდა greeting.js ფაილის ჩართვა. გადავაკეთოთ ფაილი greeting.js შემდეგნაირად:
                  
                  module.exports.name = "Alice";
                  ფაილში არის მხოლოდ ერთი სტრიქონი, რომელიც განსაზღვრავს თვისებას name.
                  
                  შევცვალოთ app.js ფაილის კოდიც:
                  
                  var greeting1 = require("./greeting.js");
                  console.log("Hello "  + greeting1.name); //Hello Alice
                   
                  var greeting2 = require("./greeting.js");
                  greeting2.name= "Bob";
                   
                  console.log("Hello " + greeting2.name); //Hello Bob
                  // greeting1.name სახელი შეიცვალა
                  console.log("Hello " + greeting1.name); //Hello Bob
                  მიუხედავად იმისა, რომ ორჯერ მოხდა greeting.js ფაილის ჩართვა - ორივე ცვლადი greeting1  და greeting2 მიუთითებს ერთი და იმავე ობიექტზე.
                  
                  JavaScript
                  
                  მოდულების სტრუქტურა
                  
                  როგორც წესი, პროგრამის მოდულები წარმოქმნიან გარკვეულ ცალკე კრებულს. მოდულების ასეთი კრებულები უმჯობესია მოვათავსოთ ცალკე საქაღალდეებში. მაგალითად, შევქმნათ პროგრამის საქაღალდეში ქვესაქაღალდე welcome და შევქმნათ მასში სამი ფაილი:
                  
                  index.js
                  morning.js
                  evening.js
                  შედეგად პროექტის მთელი სტრუქტურა იქნება შემდეგი სახის:
                  
                  welcome
                  index.js
                  morning.js
                  evening.js
                  app.js
                  greeting.js
                  morning.js ფაილში ჩავწეროთ:
                  
                  module.exports = "Good morning";
                  ანალოგიურად, evening.js ფაილში ჩავწეროთ:
                  
                  module.exports = "Good evening";
                  index.js ფაილში ჩავწეროთ:
                  
                  var morning = require("./morning");
                  var evening = require("./evening");
                   
                  module.exports = {
                      getMorningMessage : function(){ console.log(morning);},
                      getEveningMessage : function(){ console.log(evening);}
                  }
                  მოდულსი განსაზღვრულია ორი ფუნქცია, რომელთაც გამოაქვთ მისალმება დღე-ღამის დროის მიხედვით.
                  
                  ახლა გამოვიყენოთ ეს მოდული app.js-ში:
                  
                  var welcome = require("./welcome");
                   
                  welcome.getMorningMessage();
                  welcome.getEveningMessage();
                  მიუხედავად იმისა, რომ ფაილი welcome.js არ არსებობს, პროექტში თუ არსებობს საქაღალდე, რომელიც შეიცავს ფაილს index.js, ჩვენ შეგვიძლია მივმართოთ ამ მოდულს საქაღალდის სახელით, როგორც მოცემულ შემთხვევაში.`
              },
              {
                  title:"ობიექტი global და გლობალური ცვლადები",
                  data:`Node.js -ს გააჩნია სპეციალური ობიექტი global, რომელიც გვაძლევს საშუალებას გამოვიყენოთ გლობალური, ანუ ხელმისაწვდომი პროექტის ნებისმიერი მოდულიდან, ფუნქციები და ცვლადები. მისი მიახლოებითი ანალოგია ობიექტი window ჯავასკრიპტში. ყველა ხეკმისაწვდომი გლობალური ობიექტი შეიძლება ვნახოთ დოკუმენტაციაში.

                  მაგალითიშთვის შევქმნათ შემდეგი მოდული greeting.js:
                  
                  var currentDate = new Date();
                   
                  global.date = currentDate;
                   
                  module.exports.getMessage = function(){
                      var hour = currentDate.getHours();
                      if(hour >16)
                          return "Good evening, " + global.name;
                      else if(hour >12)
                          return "Good afternoon, " + name;
                      else
                          return "Good morning, " + name;
                  }
                  აქ, ერთის მხრივ, ხდება გლობალური ცვლადის date განსაზღვრა: global.date = currentDate;
                  
                  მეორეს მხრივ, მოდულში ვიღებთ გლობალურ ცვლადს name, რომელიც განისაზღვრება გარედან. ამასთან, გლობალურ ცვლად name-თან მიმართვა შესაძლებელია როგორც ობიექტ global-ის მეშვეობით  - global.name, ასევე პირდაპირ -  name, რადგანაც ცვლადი გლობალურია.
                  
                  app.js-ში ჩავწეროთ:
                  
                  var greeting = require("./greeting");
                   
                  global.name = "Tom";
                   
                  global.console.log(date);
                  console.log(greeting.getMessage());
                  აქ განვსაზღვრავთ გლობალურ ცვლადს name, რომელსაც მიიღებს greeting.js მოდული. ასევე კონსოლში გამოგვაქვს გლობალური ცვლადი date. ამასთან, ყველა გლობალური ფუნქცია და ცვლადი, მაგალითად console, ასევე ხელმისაწვდომია global-ის მეშვეობით. ჩვენ შეგვიძლია დავწეროთ global.console.log() ან პირდაპირ console.log().`
              },
              {
                  title:"NPM და გარე მოდულების ინსტალაცია",
                  data:`გარდა Node.js-ის ჩაშენებული მოდულებისა და საკუთარი მოდულებისა, არსებობს ასევე დიდი რაოდენობა ბიბლიოთეკების, ფრეიმვორკების, უტილიტების, რომლებიც იქმნება სხვადასხვა მწარმოებლების მიერ და რომელთა გამოყენება ასევე შეიძლება ჩვენს პროექტებში, მაგალითად express, grunt, gulp და ა. შ. იმისათვის, რომ ამ გარე გადაწყვეტილებებთან მუშაობა მოხერხებული იყოს, ისინი ვრცელდება პაკეტების სახით. პაკეტი თავისი არსით წარმოადგენს სხვადასხვა ფუნქციონალის ნაკრებს.

                  პაკეტების ინსტალაციისა და განახლების ავტომატიზაციისთვის, როგორც წესი, გამოიყენება პაკეტების მართვის სისტემები ანუ მენეჯერები. Node.js-ში ამ მიზნებისთვის გამოიყენება პაკეტების მენეჯერი NPM (Node Package Manager). NPM ავტომატურად ინსტალირდება Node.js-თან ერთად და დამატებით რამის გაკეთება არ სჭირდება. მაგრამ შესაძლებელია დაინსტალირებული ვერსიის განახლება უახლესამდე, ამისათვის გამოიყენება შემდეგი ბრძანება, რომელიც უნდა გაეშვას ბრძანებების ფანჯარაში (CMD):
                  
                  npm install npm@latest -g
                  npm-ის მიმდინარე ვერსიის გასაგებად შეგვიძლია გამოვიყენოთ ბრძანება:
                  
                  npm -v
                  ჩვენთვის npm მენეჯერი მნიშვნელოვანია იმით, რომ მისი მეშვეობით ადვილია პაკეტების მართვა. მაგალითად, შევქმნათ ახალი საქაღალდე modulesapp (ჩვენს შემთხვევასი სრული მისამართია d:/node/modulesapp). მაგალითისთვის დავაინსტალიროთ პროექტში express. Express წარმოადგენს მსუბუქ ფრეიმფორკს Node.js-თან მუშაობის გასამარტივებლად. ამ თემაში ჩვენ არ განვიხილავთ Express ფრეიმვორკს დაწვრილებით, რადგან ეს ცალკე დიდი თემაა. მას გამოვიყენებთ იმისთვის, რომ გავიგოთ, როგორ უნდა დავაინსტალიროთ გარე მოდულები ჩვენს პროექტში.
                  
                  ინსტალაციისთვის უნდა ბრძანებების ფანჯარაში უნდა გადავიდეთ d დისკზე და cd ბრძანებით გადავიდეთ შესაბამის საქაღალდეში: ამის შემდეგ ვუშვებთ ბრძანებას:
                  
                  npm install express
                   
                  
                  JavaScript
                  
                  ინსტალაციის შემდეგ პროექტის საქაღალდეში გაჩნდება საქაღალდე node_modules, რომელშიც ინახება ყველა დაინსტალირებული გარე მოდულები. კერძოდ, მისამართზე node_modules/express იქნება Express ფრეიმვორკის ფაილები.
                  
                  ახლა შევქმნათ უმარტივესი სერვერის ფაილი:
                  
                  // ჩავრთოთ პროექტში მოდული Express
                  var express = require("express");
                   
                  var app = express();
                   
                  // მარშრუტი
                  app.get("/", function(request, response){
                   
                      response.end("Hello from Express!");
                  });
                  // დავიწყოთ 3000 პორტის მოსმენა
                  app.listen(3000);
                  პირველ სტრიქონში ხდება მოდულის ჩართვა პროექტში.
                  
                  Express-ში ჩვენ შეგვიძლია მოთხოვნის დამუშავება მივაბათ კონკრეტულ მარშრუტთან. მაგალითად "/" - წარმოადგენს მთავარ გვერდს. მოთხოვნის დასამუშავებლად გამოიძახება ფუნქცია app.get(). ფუნქციის პირველი პარამეტრი მარშრუტია, ხოლო მეორე - ფუნქცია, რომელიც დაამუშავებს მოთხოვნას ამ მარშრუტის მიხედვით. 
                  
                  იმისათვის, რომ სერვერმა დაიწყოს პორტის მოსმენა, უნდა გამოვიძახოთ მეთოდი app.listen(), რომელსიც გადაეცემა პორტის ნომერი.
                  
                  გავუშვათ სერვერი ბრძანებით node app.js:
                  
                  JavaScript
                  
                  ბრაუზერის მისამართის ზოლში შევიყვანოთ http://localhost:3000:
                  
                  JavaScript
                  
                  ფაილი package.json
                  
                  პროექტის ფაილებისა და ---კონფიგურაციის მაღტვის მოქნილობისთვის npm-ში გამოიყენება კონფიგურაციის ფაილი package.json. დავამატოთ პროექტის საქაღალდეში ეს ფაილი:
                  
                  {
                      "name": "modulesapp",
                      "version": "1.0.0"
                  }
                  აქ განსზღვრულია მხოლოდ ორი სექცია: პროექტის სახელი -modulesapp და ვერსია - 1.0.0. ეს არის მინიმალურად აუცილებელი კონფუგურაცია. ეს ფაილი შეიძლება შეიცავდეს გაცილებით მეტ სექციებს. დაწვრილებითი ინფორმაციის შეიძლება ნახვა დოკუმენტაციაში.
                  
                  ამის შემდეგ წავშალოთ node_modules საქაღალდე და დავტოვოთ მხოლოდ ორი ფაილი: app.js და package.json. 
                  
                  ახლა თავიდან დავაინსტალიროთ Express ფრეიმვორკი ბრძანებით:
                  
                  npm install express --save
                  ალამი --save მიუთითბს, რომ დამატებული პაკეტის შესახებ ინფორმაცია უნდა შეინახოს package.json-ში:
                  
                  JavaScript
                  
                  თუ ბრძანების შესრულების შემდეგ შევხედავთ package.json-ს, ვნახავთ ინფორმაციას დამატებული პაკეტის შესახებ:
                  
                  {
                      "name": "modulesapp",
                      "version": "1.0.0",
                      "dependencies": {
                          "express": "^4.16.2"
                      }
                  }
                  ინფორმაცია ყველა დამატებული პაკეტის შესახებ, რომელიც გამოიყენება სისტემის გაშვებისას, ინახება სექციაში dependencies.
                  
                  ფაილიpackage.json თამაშობს დიდ როლს და მნიშვნელოვნად აიოლებს პროგრამირებას სხვადასხვა სიტუაციაში. მაგალითად, სხვადასხვა რეპოზიტორებში პროექტის მოთავსებისას შეიძლება შეზღუდული ვიყოთ დისკური სივრცით, მაშინ როცა საქაღალდე node_modules მასში მოთავსებული პაკეტებით შეიძლება  მნიშვნელოვანი ზომისა იყოს. ასეთ დროს შეგვიძლია მოვათავსოთ პროექტის ძირითადი კოდი node_modules გარეშე. ასეთ დროს ყველა საჭირო პაკეტი განსაზღვრულია ფაილში package.json და პროექტის ჩამოტვირთვის შემდეგ უნდა შევასრულოთ ბრძანება:
                  
                  npm install 
                  ეს ბრძანება მოძებნის ყველა საჭირო პაკეტს, რომლებიც განსაზღვრულია სექციაში dependencies და ჩატვირთავს მათ პროექტში.
                  
                  devDependencies
                  
                  გარდა პაკეტებისა, რომლებიც გამოიყენება პროგრამის გაშვების მერე, მაგალითად Express, ანუ "production" მდგომარეობაში, არის პაკეტები, რომლებიც გამოიყენება პროგრამის შექმნის და ტესტირების პროცესში. ასეთი პაკეტები ემატება სხვა სექციაში - devDependencies. წინა მაგალითში ასეთი სექცია არა გვაქვს, მაგრამ თუ დავაინსტალირებდით grunt-ს ან gulp-ს, ისინი იქნებოდნენ სწორედ devDependencies სექციაში.
                  
                  მაგალითისთვის დავამატოთ პაკეტი jasmine-node, რომელიც გამოიყენება ტესტირებისთვის:
                  
                  npm install  jasmine-node --save-dev
                  ალამი --save-dev მიუთითბს, რომ ინფორმაცია პაკეტის შესახებ უნდა შეინახოს devDependencies სექციაში:
                  
                  {
                      "name": "modulesapp",
                      "version": "1.0.0",
                      "dependencies": {
                          "express": "^4.16.2"
                      },
                      "devDependencies": {
                          "jasmine-node": "^1.14.5"
                      }
                  }
                  პაკეტების წაშლა
                  
                  პაკეტების წასაშლელად გამოიყენება ბრძანება npm uninstall. მაგალითად:
                  
                  npm uninstall express
                  ეს ბრძანება შლის პაკეტს node_modules საქაღალდიდან, მაგრამ ინფორმაცია ამ პაკეტის შესახებ package.json ფაილში რჩება. თუ გვინდა ამ ინფორმაციის წაშლაც, უნდა გამოვიყენოთ ალამი --save:
                  
                  npm uninstall express --save
                  სემანტიკური ვერსიონირება
                  
                  პაკეტების ვერსიის დასადგენად გამოიყენება სემანტიკური ვერსიონირება. ვერსიის ნომერი, როგორც წესი, ენიჭება შემდეგი ფორმატით: "major.minor.patch". თუ პაკეტში აღმოჩენილია რამე ბაგი (ხარვეზი) და ის გასწორდა, "patch" იზრდება 1-ით. თუ პაკეტში დამატებულია რამე ახალი ფუნქციონალი, რომელიც შესაბამისობაში პაკეტის წინა ვერსიასთან და ეს ცვლილება მცირეა, ამ შემთხვევაში 1-ით იზრდება რიცხვი "minor". თუ პაკეტში შედის მნიშვნელოვანი ცვლილებები, რომლებიც წინა ვერსიასთან შესაბამისობაში არ მოდიან, ასეთ შემთხვევაში იზრდება რიცხვი "major". ანუ, თუ შევხედავთ პაკეტის სხვადასხვა ვერსიებს, ჩვენ შეგვიძლია გავიგოთ, რამდენად მნიშვნელოვანი განსხვავებაა მათ შორის.
                  
                  express-ის პაკეტის შემთხვევაში ვერსიის ნომერი შეიცავდა დამატებით სიმბოლოს კარეტს (^): "^4.16.2". ეს სიმბოლო ნიშნავს, რომ npm install ბრძანებით პაკეტების დაყენებისას დაინსტალირდება 4.14 -ის ბოლო არსებული ვერსია, ანუ ვერსია, რომელიც არსებობს 4.16.2 - 5.0.0 დიაპაზონში. სემანტიკურ ვერსიონირებაზე უფრო დაწვრილებით შეგიძლიათ წაიკითხოთ აქ.
                  
                  npm-ის ბრძანებები
                  
                  NPM საშუალებას იძლევა განისაზღვროს ბრძანებები, რომლებიც ასრულებენ გარკვეულ მოქმედებებს. მაგალითად, შევცვალოთ ფაილი package.json შემდეგნაირად:
                  
                  {
                      "name": "modulesapp",
                      "version": "1.0.0",
                      "dependencies": {
                          "express": "^4.16.2"
                      },
                      "scripts" : {
                          "start" : "node app.js"
                        },
                      "devDependencies": {
                          "jasmine-node": "^1.14.5"
                      }
                  }
                  აქ დამატებულია სექცია scripts, რომელიც განსაზღვრავს ერთ ბრძანებას start (თუმცა ასეთი ბრძანებები შეიძლება იყოს ბევრი). ბრძანება start განსაზღვრავს "node app.js" ბრძანების შესრულებას. ანუ, პროგრამის გაშვება შეიძლება შემდეგი ბრძანებით:
                  
                  npm start`
              },
              {
                  title:"პარამეტრების გადაცემა პროგრამისთვის",
                  data:`ბრძანებების ფანჯრიდან პროგრამის გაშვებისას ჩვენ შეგვიძლია გადავცეთ მას პარამეტრები. პროგრამის კოდში პარამეტრების მისაღებად გამოიყენება მასივი process.argv. ეს ანალოგიურია C/C++/C#/Java ენებში არგუმენტების სტრიქონული მასივის მეშვეობით გადაცემისა. 

                  ამ მასივის პირველი ელემენტი ყოველთვის მიუთითებს node.exe ფაილის მისამართზე, რომელიც იძახებს პროგრამას. მეორე ელემენტი ყოველთვის მიუთითებს პროგრამის გამშვები ფაილის მისამართზე. მაგალითად, შევქმნათ ფაილი app.js:
                  
                  var nodePath = process.argv[0];
                  var appPath = process.argv[1];
                  var name = process.argv[2];
                  var age = process.argv[3];
                   
                  console.log("nodePath: " + nodePath);
                  console.log("appPath: " + appPath);
                  console.log();
                  console.log("name: " + name);
                  console.log("age: " + age);
                  ამ შემთხვევაში იგულისხმება, რომ პროგრამას გადაეცემა ორი პარამეტრი: name და age.
                  
                  ახლა გავუშვათ პროგრამა ბრძანებით:
                  
                  node app.js Tom 23
                  მოცემულ შემთხვევაში Tom და 23 - ეს ის მნიშვნელობებია, რომლებიც მოთავსდება შესაბამისად process.argv[2] და process.argv[3]-ში.`
              },
              {
                  title:"Nodemon",
                  data:`პროგრამირების პროცესში შეიძლება წარმოიშვას ცვლილების შეტანის საჭიროება უკვე გაშვებულ პროექტში. მაგალითად, ვთქვათ, გვაქვს შემდეგი ფაილი app.js:

                  var http = require("http");
                   
                  var message = "Hello World!";
                  http.createServer(function(request,response){
                      
                      console.log(message);
                      response.end(message);
                      
                  }).listen(3000, "127.0.0.1",()=>{
                      console.log("The server started listening to requests");
                  });
                  ფავუშვათ სერვერი ბრძანებით node app.js. როცა მომხმარებელი ბრაუზერიდან მიმართავს http://localhost:3000 მისამართს, ბრაუზერში გამოისახება სტრიქონი "Hello World!". იმავდროულად იგივე სტრიქონი გამოვა კონსოლშიც:
                  
                  JavaScript
                  
                  ამ დროს სერვერი რჩება გაშვებული. თუ ჩვენ შევცვლით message ცვლადის მნიშვნელობას app.js ფაილში, ეს არანაირად არ შეცვლის სერვერის მუშაობას და ის წინანდებურად დააბრუნებს striqons "Hello World!".
                  
                  იმისათვის, რომ გამოჩნდეს შეცვლილი სტრიქონი, საჭიროა გავაჩეროთ სერვერის მუშაობა და გავუშვათ თავიდან. ეს არც ისე მოხერხებულია, როცა საჭიროა პროგრამაში მრავალი ცვლილების შეტანა და ტესტირება. ამ სიტუაციაში დაგვეხმარება სპეციალური ინსტრუმენტი nodemon.
                  
                  დავაყენოთ nodemon ბრძანებით:
                  
                  npm install nodemon -g
                  ალამი -g წარმოადგენს global-ის შემოკლებას და მიუთითებს, რომ nodemon გამოყენებული იქნება გლობალურად ყველა პროექტისთვის ამ ლოკალურ მანქანაზე.
                  
                  გავუშვათ სერვერი ხელახლა შემდეგი ბრძანებით:
                  
                  nodemon app.js
                  ახლა თუ სერვერის გაშვების შემდეგ შევცვლით პროგრამის კოდს, მაგალითად message ცვლადის მნიშვნელობას "Hello World!"-ს ახლაი მნიშვნელობით "Hello Tom!", სერვერი ავტომატურად გადაიტვირთება:`
              },
              {
                  title:"ასინქრონულობა Node.js-ში",
                  data:`ასინქრონულობა საშუალებას იძლევა ერთდროულად შესრულდეს რამდენიმე ამოცანა. ასინქრონულობას დიდი მნიშვნელობა აქვს Node.js-ში. ვთქვათ app.js ფაილში გვაქვს შემდეგი კოდი:

                  function displaySync(data){
                      console.log(data);
                  }
                  console.log("Getting Started");
                  displaySync("Data processing...");
                  console.log("Shutdown the program");
                  ეს სტანდარტული სინქრონული კოდია, ყველა მოქმედება სრულდება თანმიმდევრობით, რასაც დავინახავთ პროგრამის გაშვებისას:
                  
                  JavaScript
                  
                  ასინქრონულობის განსახილველად შევცვალოთ app.js ფაილის კოდი შემდეგნაირად:
                  
                  function display(data, callback){
                      // შემთხვევითი რიცხვის მიხედვით ვადგენთ შეცდომას
                      var randInt = Math.random() * (10 - 1) + 1;
                      var err = randInt>5? new Error("Runtime Error. randInt more than 5"): null;
                      
                      setTimeout(function(){
                          callback(err, data);
                      }, 0);
                  }
                  console.log("Getting Started");
                   
                  display("Data processing...", function (err, data){
                      if(err) throw err;
                      console.log(data);
                  });
                  console.log("Shutdown the program");
                  დასაწყისში აქაც განისაზღვრება ფუნქცია display, მაგრამ ახლა მონაცემებთან ერთად მეორე პარამეტრად იგი ღებულობს უკუგამოძახების ფუნქციას, რომელმაც უნდა დაამუშავოს მონაცემები.
                  
                  ეს ფუნქცია callback იღებს ორ პარამეტრს - ინფორმაციას შეცდომის შესახებ და საკუთრივ მონაცემებს. ეს უკუგამოძახების ფუნქციის ზოგადი მოდელია, რომელიც გამოიყენება ასინქრონულ მეთოდებში - მასში პირველ პარამეტრად მოდის ინფორმაცია შეცდომის შესახებ, ხოლო შემდგომ თვითონ მონაცემები. 
                  
                  შეცდომის იმიტაციისთვის გამოიყენება შემთხვევითი რიცხვი: თუ ის 5-ზე მეტია იქმნება შეცდომის ობიექტი err, წინააღმდეგ შემთხვევაში ის არის null.
                  
                  და ბოლო მნიშვნელოვანი მომენტი - უკუგამოძახების ფუნქციის შესრულება ხდება setTimeout() ფუნქციის მეშვეობით. ეს გლობალური ფუნქციაა, რომელიც პირველ პარამეტრად იღებს უკუგამოძახების ფუნქციას, ხოლო მეორე პარამეტრი არის დროის შუალედი, რომლის შემდეგაც მოხდება ფუნქციის შესრულება. ჩვენს შემთხვევაში ეს დროის შუალედი არის 0 მილიწამი. 
                  
                  display() ფუნქციის გამოძახებისას მასში გადაეცემა ფუნქცია, რომელიც შეცდომების არარსებობისას მონაცემებს გამოიტანს კონსოლში:
                  
                  display("Data processing...", function (err, data){
                      if(err) throw err;
                      console.log(data);
                  });
                  თუ პროგრამას გავუშვებთ, მივიღებთ შემდეგ სურათს:
                  
                  JavaScript
                  
                  მიუხედავად იმისა, რომ setTimeout ფუნქციას გადაეცემა 0-ის ტოლი დროის შუალედი, display ფუნქცია სრულდება ყველა სხვა ფუნქციის შემდეგ. შესაბამისად,  display ფუნქცია არ ახდენს კოდის შესრულების ბლოკირებას, არამედ კოდის შესრულება გრძელდება. ეს განსაკუთრებით მნიშვნელოვანია იმ შემთხვევაში, როცა პროგრამაში ხდება შეტანა-გამოტანის ფუნქციის, ფაილის წაკითხვის, მონაცემთა ბაზასთან ურთიერთობის მოქმედებების შესრულება, რომელთაც შეიძლება დიდი დრო დასჭირდეს. ამ პროცესების ასინქრონულად შესრულებისას არ ხდება პროგრამის ბლოკირება.
                  
                  რატომ ხდება ასე? იმიტომ რომ ყველა უკუგამოძახების ფუნქცია ასინქრონულ ფუნქციებში (ამისათვის მოცემულ მაგალითში გამოიყენება ფუნქცია setTimeout) დგება სპეციალურ რიგში და იწყებენ შესრულებას მხოლოდ მას შემდეგ, რაც დანარჩენი სინქრონული ფუნქციები დაასრულებენ მუშაობას. სწორედ ამიტომ უკუგამოძახების ფუნქციის შესრულება setTimeout-ში ხდება console.log("Shutdown the program"); სტრიქონის შესრულების შემდეგ.აღსანიშნავია, რომ უკუგამოძახების ფუნქციების რიგში გადადის არა ის ფუნქცია, რომელიც გადაეცემა display-ს, არამედ ის, რომელიც გადაეცემა setTimeout-ს.
                  
                  ვნახოთ მაგალითი ორი ასინქრონული გამოძახებით:
                  
                  function displaySync(callback){
                      callback();
                  }
                  console.log("Getting Started"); 
                   
                  setTimeout(function(){        
                          console.log("timeout 500");
                  }, 500);
                   
                  setTimeout(function(){        
                          console.log("timeout 100");
                  }, 100);
                   
                  displaySync(function(){console.log("without timeout")});
                  console.log("Shutdown the program");
                  შესრულების შედეგი:
                  
                  JavaScript
                  
                  მიუხედავად იმისა, რომ display ფუნქციაში გადაეცემა უკუგამოძახების ფუნქცია, იგი სრულდება სინქრონულად. ხოლო უკუგამოძახების ფუნქციები, რომლებიც იშვებს setTimeout ფუნქციის მეშვეობით, სრულდება ასინქრონულად მხოლოდ მას შემდეგ, რაც სხვა ყველა სინქრონული გამოძახებები შესრულდება.`
              },
              {
                  title:"ფაილებთან მუშაობა",
                  data:`ფაილებთან მუშაობისთვის Node.js-ში განკუთვნილია მოდული fs. ვანხოთ, როგორ უნდა ვიმუშავოთ მასთან.

                  ფაილის წაკითხვა
                  
                  ვთქვათ, app.js-თან ერთად იგივე საქაღალდეში გვაქვს ტექსტური ფაილი hello.txt შემდეგი შიგთავსით:
                  
                  Hello Node JS!
                  ფაილის წასაკითხად სინქრონულ რეჟიმში გამოიყენება ფუნქცია fs.readFileSync():
                  
                  var fileContent = fs.readFileSync("hello.txt", "utf8");
                  ფუნქციას გადაეცემა ფაილის ფარდობითი მისამართი (app.js-თან მიმართებით), ხოლო მეორე პარამეტრად გადაეცემა კოდირება ფაილის ტექსტური შიგთავსის მისაღებად. ფუნქცია აბრუნებს წაკითხულ ტექსტს.
                  
                  ფაილის ასინქრონულად წასაკითხად გამოიყენება ფუნქცია fs.readFile:
                  
                  fs.readFile("hello.txt", "utf8", function(error,data){ });
                  ფუნქციის პირველი და მეორე პარამეტრი იგივეა, რაც სინქრონული ფუნქციის შემთხვევაში. ხოლო მესამე პარამეტრს წარმოადგენს უკუგამოძახების ფუნქცია, რომელიც სრულდება წაკითხვის დასრულების შემდეგ. ამ ფუნქციის პირველი პარამეტრი წარმოდაგენს ინფორმაციას შეცდომის შესახებ, ხოლო მეორე პარამეტრი არის წაკითხული ტექსტი.
                  
                  ფაილის წასაკითხად app.js ფაილში ჩავწეროთ შემდეგი კოდი:
                  
                  var fs = require("fs");
                   
                  // ასინქრონული წაკითხვა
                  fs.readFile("hello.txt", "utf8",
                              function(error,data){
                                  console.log("Asynchronous file reading");
                                  if(error) throw error; // შეცდომის შემთხვევაში
                                  console.log(data);  // წაკითხული მონაცემები
                  });
                   
                  // სინქრონული წაკითხვა
                  console.log("Synchronous file reading")
                  var fileContent = fs.readFileSync("hello.txt", "utf8");
                  console.log(fileContent);
                   
                  
                  JavaScript
                  
                  ყურადღება მიაქციეთ, რომ, მიუხედავად იმისა, რომ ჯერ fs.readFile() ფუნქციის გამოძახება ხდება, იგი შესრულდება ბოლოს, ვინაიდან იგი ასინქრონულია და კოდის შესრულებას არ ბლოკავს.
                  
                  ჩაწერა ფაილში
                  
                  სინქრონულ რეჟიმში ფაილის ცასაწერად გამოიყენება ფუნქცია fs.writeFileSync(), რომელსაც პარამეტრებად გადაეცემა ფაილის მისამართი და ჩასაწერი ტექსტი:
                  
                  fs.writeFileSync("hello.txt", "Hello, World!")
                  ასინქრონულ რეჟიმში ჩასაწერად გამოიყენება ფუნქცია fs.writeFile(), რომელსაც გადაეცემა იგივე ორი პარამეტრი:
                  
                  fs.writeFile("hello.txt", "Hello, World!")
                  დამატებითი პარამეტრის სახით ასინქრონულ ფუნქციას შეიძლება გადაეცეს უკუგამოძახების ფუნქცია, რომელიც შესრულდება ჩაწერის დამთავრების შემდეგ:
                  
                  fs.writeFile("hello.txt", "Hello, World!")
                   
                  
                  JavaScript
                  
                  უნდა აღინიშნოს, რომ ეს მეთოდები მთლიანად გადაწერენ ფაილს. თუ გვინდა დამატება ფაილში, უნდა გამოვიყენოთ მეთოდები fs.appendFile და fs.appendFileSync:
                  
                  var fs = require("fs");
                   
                  fs.appendFileSync("hello.txt", "Text1... ");
                   
                  fs.appendFile("hello.txt", "Text2...", function(error){
                                  if(error) throw error; // შეცდომის შემთხვევაში
                                  
                                  console.log("Asynchronous writing of the file is complete. File contents:");
                                  var data = fs.readFileSync("hello.txt", "utf8");
                                  console.log(data);  // გამოგვაქვს ამოკითხული მონაცემები
                  });`
              },
              {
                title:"მოვლენები",
                data:`Node.js-ის ფუნქციონალის უმეტესი ნაწილი იყენებს ასინქრონულ მოვლენურ არქიტექტურას, რომელიც იყენებს სპეციალურ ობიექტებს - ემიტერებს სხვადასხვა მოვლენის გენერაციისთვის, რომელთა დამუშავება ხდება სპეციალური ფუნქციებით - მოვლენების დამმუშავებლებით და მომსმენებით. ყველა ობიექტი, რომლებიც აგენერირებენ მოვლენებს, წარმოადგენენ EventEmitter კლასის ეგზემპლარებს.

                eventEmitter.on() ფუნქციის მეშვეობით განსაზღვრულ მოვლენას სახელის მიხედვით ებმება ფუნქცია დამმუშავებელი. ამასთან, ერთ მოვლენას შეიძლება ჰქონდეს ბევრი დამმუშავებელი. როცა ობიექტი EventEmitter აგენერირებს მოვლენას, სრულდება ყველა ეს დამმუშავებელი.
                
                ვნახოთ მაგალითი. app.js ფაილში ჩავწეროთ შემდეგი კოდი:
                
                var Emitter = require("events");
                var emitter = new Emitter();
                var eventName = "greet";
                emitter.on(eventName, function(){
                    console.log("Hello all!");
                });
                 
                emitter.on(eventName, function(){
                    console.log("Hi!");
                });
                 
                emitter.emit(eventName);
                მთელი საჭირო ფუნქციონალი თავმოყრილია მოდულში events, რომლის ცართვაც აუცილებელია. on() ფუნქციის მეშვეობით ვაკავშირებთ მოვლენას, რომელიც გადაეცემა პირველ პარამეტრად, გარკვეულ ფუნქციონალთან, რომელიც გადაეცემა მეორე პარამეტრად. მოცემულ შემთხვევაში მოვლენას ჰქვია "greet".
                
                მოვლენის გენერაციისა და დამმუშავებლების გამოძახებისთვის სრულდება ფუნქცია emitter.emit(), რომელსაც გადაეემა მოვლენის სახელი. 
                
                პროგრამის გაშვებისას მოხდება ყველა დამმუშავებლის გამოძახება:
                
                JavaScript
                
                მოვლენისთვის პარამეტრების გადაცემა
                
                მოვლენის გამოძახებისას emit ფუნქციაში მეორე პარამეტრად შეიძლება გადაეცეს რამე ობიექტი, რომელიც შემდეგ გადაეცემა მოვლენის დამმუშავებელს:
                
                var Emitter = require("events");
                var emitter = new Emitter();
                var eventName = "greet";
                emitter.on(eventName, function(data){
                    console.log(data);
                });
                 
                emitter.emit(eventName, "Hello, World!");
                მემკვიდრეობითობა EventEmitter-ში
                
                პროგრამაში ჩვენ შეგვიძლია რთული ობიექტებით ოპერირება, რომელთათვისაც ასევე შეიძლება მოვლენის განსაზღვრა, მაგრამ ამისათვის საჭიროა მისი დაკავშირება ობიექტთან EventEmitter. მაგალითად:
                
                var util = require("util");
                var EventEmitter = require("events");
                 
                function User(){
                }
                util.inherits(User, EventEmitter);
                 
                var eventName = "greet";
                User.prototype.sayHi = function(data){
                    this.emit(eventName, data);
                }
                var user = new User();
                // ობიექტს user დავამატოთ "greet" მოვლენის დამუშავება
                user.on(eventName, function(data){
                    console.log(data);
                });
                 
                user.sayHi("Hello, World!");
                აქ განსაზღვრულია User-ის, რომელიც წარმოადგენს მომხმარებელს, კონსტრუქტორის ფუნქცია. User-ის პროტოტიპისთვის განისაზღვრება მეთოდი sayHi, რომელშიც გენერირდება მოვლენა "greet".
                
                მაგრან, იმისათვის, რომ დავაკავშიროთ User ობიექტი EventEmitter-თან, უნდა გამოვიძახოთ ფუნქცია util.inherits(User, EventEmitter);.ამის შემდეგ on()  მეთოდის მეშვეობით ჩვენ შეგვიძლია User ობიექტის მოვლენას მივაბათ დამმუშავებელი, რომლის გამოძახებაც მოხდება user.say.Fi() მეტოდის შესრულებისას.`
            },
            {
                title:"Stream",
                data:`Stream წარმოადგენს მონაცემთა ნაკადს. ნაკადი შეიძლება იყოს სხვადასხვა ტიპის, რომელთა შორის შეიძლება გამოიყოს ნაკადები წაკითხვისთვის და ნაკადები ჩაწერისთვის.

                პირველ თავში სერვერის შექმნისას ჩვენ უკვე შევეხეთ ნაკადებს:
                
                var http = require("http");
                 
                http.createServer(function(request, response){
                        
                }).listen(3000);
                პარამეტრები request და response,რომლებიც გადაეცემა ფუნქციას და რომელთა მეშვეობით ჩვენ შეგვიძლია მივიღოთ მონაცემები მოთხოვნების შესახებ და ვმართოთ სერვერის პასუხები, თავისი არსით წარმოადგენენ ნაკადებს: request - წარმოადგენს ნაკადს წაკითხვისთვის და response - ნაკადს ჩაწერისთვის.
                
                წაკითხვის და ჩაწერის ნაკადების მეშვეობით ჩვენ შეგვიძლია ფაილიდან ინფორმაციის წაკითხვა და მასში ჩაწერა. მაგალითად:
                
                var fs = require("fs");
                 
                var writeableStream = fs.createWriteStream("hello.txt");
                writeableStream.write("Hello, World!!");
                writeableStream.write("Continue recording...");
                writeableStream.end("Completion of a record");
                var readableStream = fs.createReadStream("hello.txt", "utf8");
                 
                readableStream.on("data", function(chunk){
                    console.log(chunk);
                });
                ფაილში ჩაწერის ნაკადის შესაქმნელად გამოიყენება მეტოდი fs.createWriteStream(), რომელსაც გადაეცემა ფაილის სახელი. თუ ასეთი ფაილი არ არსებობს, ის იქმნება.
                
                მონაცემთა ჩაწერა ხდება write() მეთოდის მეშვეობით, რომელსიც გადაეცემა მონაცემები. ჩაწერის დასრულებისთვის გამოიყენება მეთოდი end(). 
                
                წაკითხვის ნაკადის შესაქმნელად გამოიყენება მეთოდი fs.createReadStream(), რომელსაც ასევე გადაეცემა ფაილის სახელი. მეორე არააუცილებელ პარამეტრად შეიძლება გადაეცეს კოდირება, რაც საშუალებას გვაძლევს მივიღოთ ამოკითხული ინფორმაცია ტექსტის სახით მითითებულ კოდირებაში.
                
                თვითონ ნაკადი იყოფა ნაწილებად ანუ ჩანკებად (chunk). თითოეული ასეთი ნაწილის წაკითხვისას წარმოიშობა მოვლენა data. on() მეთოდის მეშვეობით ჩვენ შეგვიძლია ამ მოვლენის დამუშავების მეშვეობით გამოვიტანოთ თითოეული ნაწილი კონსოლზე:
                
                readableStream.on("data", function(chunk){
                    console.log(chunk);
                });
                გავუშვათ ფაილი შესრულებაზე:
                
                JavaScript
                
                ფაილებთან მუშაობით ნაკადების ფუნქციონალი არ ამოიწურება. არსებობს ასევე ქსელური ნაკადები, შიფრაციის ნაკადები, არქივაცია და ა. შ., მაგრამ მათთან მუშაობის ზოგადი პრინციპები იგივეა, რაც ფაილურ ნაკადებთან მუშაობის დროს.`
            },
            {
                title:"Pipe",
                data:`Pipe - ეს არის არხი, რომელიც აერთიანებს წაკითხვის და ჩაწერის ნაკადებს და საშუალებას გვაძლევს გადავწეროთ წაკითხვის ნაკადიდან ჩაწერის ნაკადში. რისთვის არის ის საჭირო? ავიღოთ მაგალითისთვის ერთი ფაილიდან მეორეში კოპირება.

                ვთქვათ, პროექტის საქაღალდეში გვაქვს ფაილი hello.txt. გადავაკოპიროთ მისი შიგთავსი ახალ ფაილში some.txt:
                
                var fs = require("fs"); 
                var readableStream = fs.createReadStream("hello.txt", "utf8"); 
                var writeableStream = fs.createWriteStream("some.txt"); 
                readableStream.on("data", function(chunk){
                    writeableStream.write(chunk);
                });
                ასეთი კოდი სავსებით მუშაა და მისი შესრულებისას საქაღალდესი გაცნდება ახალი ფაილი some.txt.
                
                თუმცა ერთი ფაილიდან მეორეში გადაწერეის ამოცანა საკმაოდ ხშირია და ასეთ შემთხვევებში pipes ანუ არხები მნიშვნელოვნად ამცირებს კოდს:
                
                var fs = require("fs");
                var readableStream = fs.createReadStream("hello.txt", "utf8");
                var writeableStream = fs.createWriteStream("some.txt");
                readableStream.pipe(writeableStream);
                წაკითხვის ნაკადზე ხდება pipe() მეტოდის გამოძახება, რომელსაც პარამეტრად გადაეცემა ჩაწერის ნაკადი.
                
                ვნახოთ მეორე პრობლემა - ფაილის არქივაცია. ამ შემთხვევაში საჭიროა ფაილიდან ამოკითხვა, მონაცემების შეკუმშვა და ჩაწერა სხვა ფაილში. Pipes გამოყენება მოსახერხებელია ამ შემთხვევაში:
                
                var fs = require("fs");
                var zlib = require("zlib");
                var readableStream = fs.createReadStream("hello.txt", "utf8");
                var writeableStream = fs.createWriteStream("hello.txt.gz");
                var gzip = zlib.createGzip();
                readableStream.pipe(gzip).pipe(writeableStream);
                არქივაციისთვის ხდება zlib მოდულის ჩართვა პროექტში. თითოეული მეთოდი pipe() აბრუნებს წაკითხვის ნაკადს, რომელზეც ისევ შეიძლება pipe() მეთოდის გამოყენება სხვა ნაკადში ჩასაწერად.`
            },
           
            
            ]
        },
        {
            title:"თავი 3. სერვერიი",
            content:[
                {
                    title:"სერვერის შექმნა",
                    data:`სერვერთან და http პროტოკოლთან მუშაობისთვის Node.js-ში გამოიყენება მოდული http.

                    სერვერის შესაქმნელად გამოიყენება მეტოდი http.createServer():
                    
                    var http = require("http");
                     
                    http.createServer().listen(3000);
                    მეტოდი createServer () აბრუნებს ობიექტს http.Server.სერვერის მოსმენისთვის და შემომავალი შეერთებების დამუშავებისთვის საჭიროა გამოვიძახოთ მეთოდი listen(), რომელსაც პარამეტრად გადაეცემა პორტის ნომერი, რომელზეც იშვებს სერვერი.
                    
                    შეერთებების დამუშავებისთვის მეთოდს createServer გადაეცემა სპეციალური ფუნქცია:
                    
                    var http = require("http");
                     
                    http.createServer(function(request, response){    
                        response.end("Hello world!");
                    }).listen(3000);
                    ეს ფუნქცია იღებს ორ პარამეტრს:
                    
                    request : შეიცავს ინფორმაციას მოთხოვნის შესახებ
                    response : მართავს პასუხის გაგზავნას
                    Request
                    
                    პარამეტრი request საშუალებას გვაძლევს მივიროთ ინფორმაცია მოთხოვნის შესახებ და წარმოადგენს ობიექტს http.incomingMessage. განვიხილოთ ამ ობიექტის ძირითადი თვისებები:
                    
                    headers: აბრუნებს მოთხოვნის სათაურებს
                    method: მოთხოვნის ტიპი (FET, POST, DELETE, PUT)
                    url: წარმოადგენს მოთხოვნის მისამართს
                    მაგალითად, შევქმნათ ფაილი app.js:
                    
                    var http = require("http");
                     
                    http.createServer(function(request, response){
                        
                        console.log("Url: " + request.url);
                        console.log("Request type: " + request.method);
                        console.log("User-Agent: " + request.headers["user-agent"]);
                        console.log("Headers");
                        console.log(request.headers);
                        
                        response.end();
                    }).listen(3000);
                    გავუშვათ სერვერი და ბრაუზერში მივმართოთ მისამართს http://localhost:3000/index.html:
                    
                    JavaScript
                    
                    Response
                    
                    პარამეტრი Response მართავს პასუხის გაგზავნას და წარმოადგენს ობიექტს http.serverResponse. მისი ფუნქციონალიდან აღსანიშნავია შემდეგი მეთოდები:
                    
                    statusCode: პასუხის სტატუსის კოდი
                    statusMessage: შეტყობინება, რომელიც იგზავნება სტატუსის კოდტან ერთად
                    setHeader(name, value): ამატებს პასუხსი ერთ სათაურს
                    write: პასუხის ნაკადში წერს გარკვეულ მონაცემებს
                    writeHead: ამატებს პასუხში სტატუსის კოდს და სათაურებს
                    მაგალითად, შევცვალოთ app.js ფაილი შემდეგნაირად:
                    
                    var http = require("http");
                     
                    http.createServer(function(request, response){
                        
                        response.setHeader("UserId", 12);
                        response.setHeader("Content-Type", "text/html");
                        response.write("<h2>hello world</h2>");
                        response.end();
                    }).listen(3000);`
                },
                {
                  title:"სტატიკური ფაილების გაგზავნა",
                  data:`ნაცვლად იმისა, რომ განვსაზღვროთ კოდი, რომელსაც მიიღებს მომხმარებელი სერვერიდან უშუალოდ სერვერის ფაილში, გაცილებით მოხერხებულია, გავიტანოთ ცალკე html ფაილში. ვნახოთ, როგორ შეიძლება სერვერიდან სტატიკური ფაილების, იგივე html ფაილების გაგზავნა.

                  შევქმნათ პროექტის ახალი საქაღალდე, დავარქვათ მას serverapp. შევქმნათ ამ საქაღალდეში ფაილი app.js. სტატიკური ფაილებისთვის შევქმნათ ცალკე საქაღალდე public და დავამატოთ მასში ფაილი index.html. საბოლოოდ, პროექტს ექნება შემდეგი სახე:
                  
                  app.js
                  public
                  index.html
                  index.html-ში ჩავწეროთ რამე უმარტივესი hrml კოდი:
                  
                  <h1>მთავარი გვერდი</h1>
                  app.js ჩავწეროთ შემდეგი კოდი:
                  
                  var http = require("http");
                  var fs = require("fs");
                   
                  http.createServer(function(request, response){    
                      console.log("The requested address:" + request.url);
                      if(request.url.startsWith("/public/")){        
                          // მივიღოთ მისამართი სლეშის შემდეგ
                          var filePath = request.url.substr(1);
                          fs.readFile(filePath,function(error, data){                
                              if(error){                     
                                  response.statusCode = 404;
                                  response.end("Resource is not found!");
                              }  
                              else{
                                  response.writeHead(200, {"Content-Type": "text/html; charset=utf-8"});
                                  response.end(data);
                              }
                              return;
                          })
                      }
                      else{
                          // სხვა ყველა შემთხვევაში დავაბრუნოთ სტრიქონი hello world!
                          response.end("Hello World!");
                      }
                  }).listen(3000);
                  თუ მოთხოვნის მისამართი იწყება /public/-ით, მაშინ მეთოდით fs.readFile() ამოვიკითხავთ საჭირო ფაილს მისამართის მიხედვით და ამოკუთხულ მონაცემებს ვუბრუნებთ მომხმარებელს. სხვა ყველა შემთხვევაში ვაბრუნებთ სტრიქონს "Hello, World!".
                  
                  მიაქციეთ ყურადღება სტრიქონს response.writeHead(200, {"Content-Type": "text/html; charset=utf-8"});. აქ response-ს ემატება სათაური, რომელშიც მითითებულია გვერდის კოდირება. უნიკოდის სიმბოლოების კორექტულად გამოსაჩენად მისი მითითება აუცილებელია.
                  
                  გავუშვათ სერვერი და ბრაუზერში მივმართოთ მისამართზე: "http://localhost:3000":
                  
                  JavaScript
                  
                  შემდეგ კი მივმართოთ მისამართს "http://localhost:3000/public/index.html"`
              },
              {
                  title:"შაბლონები",
                  data:`წინა თემაში განვიხილეთ html ფაილი, რომელსაც ჰქონდა სტატიკური, უცვლელი შიგთავსი. თუმცა ჩვენ შეგვიძლია გამოვიყენოთ სპეციალური ინსტრუმენტები - შაბლონები, რომელთა ნაცვლად ფაილში ჩაისმება განსაზღვრული ტექსტი.მაგალითად, შევცვალოთ html ფაილის ტექსტი შემდეგნაირად:

                  <h1>{header}</h1>
                  <p>{message}</p>
                  კონკრეტული ტექსტის ნაცვლად აქ განსაზღვრულია შაბლონები (პრეისჰოლდერები) "{header}" და "{message}", რომელთა ნაცვლად შეიძლება ჩაისვას ნებისმიერი ტექსტი.
                  
                  შევცვალოთ app.js:
                  
                  var http = require("http");
                  var fs = require("fs");
                   
                  http.createServer(function(request, response){
                      
                      fs.readFile("public/index.html", "utf8", function(error, data){
                                  
                          var message = "ვსწავლობთ Node.js";
                          var header = "მთავარი გვერდი";
                          data = data.replace("{header}", header).replace("{message}", message);
                          response.writeHead(200, {"Content-Type": "text/html; charset=utf-8"});
                          response.end(data);
                      })
                  }).listen(3000);
                  აქ ვღებულობთ ფაილის შიგთავსს და წინასწარ ვამუშავებთ მას - პრეისჰოლდერებს ვცვლით კონკრეტული ტექსტით data.replace() მეთოდის გამოყენებით.
                  
                  ვებგვერდზე მიმართვისას მივიღებთ სრულყოფილ html გვერდს პრეისჰოლდერების გარეშე`
              },
              {
                  title:"Stream და ფაილების გაგზავნა",
                  data:`თუ ვმუშაობთ დიდი ზომის ფაილებთან, ფაილების გასაგზავნად უფრო ოპტიმალურია ნაკადების გამოყენება. მაგალითად, დავამატოთ პროექტის საქაღალდეში რაიმე ფაილი, ვთქვათ, some.docx.

                  განვსაზღვროთ ფაილი app.js, რომელიც გაუგზავნის ფაილს მომხმარებელს:
                  
                  var http = require("http");
                  var fs = require("fs");
                   
                  http.createServer(function(request, response){
                      
                      if(request.url=="/some.docx"){
                          response.writeHead(200, {"Content-Type" : "application/msword"})
                          fs.createReadStream("some.docx").pipe(response);
                      }
                      else{
                          response.end("hello world!");
                      }
                      
                  }).listen(3000);
                  თუ მივმართავთ მისამართს http://localhost:3000/some.docx, მომხმარებელს გაეგზავნება აღნიშნული ფაილი.
                  
                  ფაილის გასაგზავნად გამოიყენება მეთოდების ჯაჭვი:
                  
                  fs.createReadStream("some.docx").pipe(response);
                  მეთოდი fs.createReadStream("some.docx") ქმნის წაკითხვის ნაკადს - ობიექტს fs.ReadStream. ნაკადიდან მონაცემების მისაღებად ხდება pipe() მეთოდის გამოძახება, რომელშიც გადაეცემა ინტერფეისის ობიექტი Stream.Writable ანუ ჩაწერის ნაკადი. სწორედ ასეთ ობიექტს წარმოადგენს http.ServerResponse, რომელიც ახდენს ამ ინტერფეისის რეალიზებას.
                  
                  შედეგად, როცა მივმართავთ მისამართს http://localhost:3000/some.docx, სერვერიდან ჩამოიტვირთება ფაილი some.docx.
                  
                   `
              },
              
            ]
        },
        {
            title:"თავი 4. Express",
            content:[
                {
                    title:"Express-თან მუშაობის დაწყება",
                    data:`ამ თავში ჩვენ განვიხილავთ სერვერის შექმნას Express ფრეიმვორკის მეშვეობით. ერთი შეხედვით, რისთვის გვჭირდება დამატებითი ფრეიმვორკი, როცა შეგვიძლია ვისარგებლოთ მზა http მოდულით, რომელიც ჩაშენებულია Node.js-ში. საქმე იმაშია, რომ Express თვიტონ იყენებს http მოდულს, მაგრამ ამასთან ერთად გააცნია მთელი რიგი მზა აბსტრაქციები, რომლებიც ამარტივებენ სერვერის და სერვერული ლოგიკის შექმნას, კერძოდ, გამოგზავნილი ფორმების დამუშავება, ქუქებთან მუშაობა, CORS და ა. შ.

                    შევქმნათ პროექტისთვის ახალი საქაღალდე და დავარქვათ, მაგალითად, expressapp. შევქმანთ საქაღალდეში ფაილი package.json შემდეგი შიგთავსით:
                    
                    {
                        "name": "expressapp",
                        "version": "1.0.0"
                    }
                    შემდეგ გადავიდეთ ბრძანებების ფანჯარაში ამ კატალოგზე და გავუშვათ ბრძანება:
                    
                    npm install express --save
                    შევქმნათ პროექტის საქაღალდეში ფაილი app.js:
                    
                    // ჩავრთოთ express
                    var express = require("express");
                    // შევქმნათ ობიექტი
                    var app = express();
                    // განვსაზღვროთ მარშრუტის დამმუშავებელი "/"
                    app.get("/", function(request, response){    
                        // გავაგზავნოთ პასუხი
                        response.send("<h2>გამარჯობა, Express!</h2>");
                    });
                    // დავიწყოთ 3000 პორტის მოსმენა
                    app.listen(3000);
                    Express-ის გამოყენებისთვის დასაწყისში უნდა შევქმნათ ობიექტი:
                    
                    var app = express();
                    მოთხოვნების დასამუშავებლად Express-ში არის ფუნქციები, ერთ-ერთ მათგანს წარმოადგენს app.get(). ის ამუშავებს HTTP პროტოკოლის GET მოთხოვნებს და შაშუალებას იძლევა დააკავშიროს მარშრუტი კონკრეტულ დამმუშავებელთან. ამისათვის პირველ პარამეტრად გადაეცემა მარშრუტი, ხოლო მეორე პარამეტრად ფუნქცია-დამმუშავებელი, რომლის გამოძახებაც მოხდება მოცემული მარშრუტით სერვერზე მოთხოვნის მიღებისას:
                    
                    app.get("/", function(request, response){    
                        // გავაგზავნოთ პასუხი
                        response.send("<h2>გამარჯობა, Express!</h2>");
                    });
                    სერვერის გასაშვებად გამოიყენება მეთოდი app.listen(), რომელსაც პარამეტრად გადაეცემა პორტის ნომერი.
                    
                    გავუშვათ პროექტი და ბრაუზერში გავხსნათ მისამართი http://localhost:3000:
                    
                    JavaScript
                    
                    რაც მნიშვნელოვანია, Express ეყრდნობა მარშრუტების სისტემას, ამიტომ ყველა სხვა მოთხოვნა, რომელიც არ ემთხვევა "/" - ანუ ძირითად მისამართს, არ იქნება დამუშავებული:
                    
                    JavaScript
                    
                    ახლა შევცვალოთ ფაილი app.js:
                    
                    var express = require("express");
                     
                    var app = express();
                    app.get("/", function(request, response){    
                        response.send("<h1>მთავარი გვერდი</h1>");
                    });
                    app.get("/about", function(request, response){    
                        response.send("<h1>საიტის შესახებ</h1>");
                    });
                    app.get("/contact", function(request, response){    
                        response.send("<h1>კონტაქტი</h1>");
                    });
                    app.listen(3000);`
                },
                {
                  title:"მოთხოვნების დამუშავების კონვეიერი და middleware",
                  data:`როცა Express იღებს მოთხოვნას, ის ხვდება მოთხოვნათა დამუშავების კონვეიერში. კონვეიერი შედგება კომპონენტების ნაკრებისგან ანუ middleware-სგან, რომლებიც იღებენ მოთხოვნებს და წყვეტენ, თუ როგორ უნდა დამუშავდეს ისინი.

                  წინა თემასი ფაილი app.js გამოიყურებოდა ასე:
                  
                  var express = require("express");
                   
                  var app = express();
                  app.get("/", function(request, response){    
                      response.send("<h1>მთავარი გვერდი</h1>");
                  });
                  app.get("/about", function(request, response){    
                      response.send("<h1>საიტის შესახებ</h1>");
                  });
                  app.get("/contact", function(request, response){    
                      response.send("<h1>კონტაქტი</h1>");
                  });
                  app.listen(3000);
                  აქ დამუშავების კონვეიერი შედგება app.get() გამოძახებებისგან, რომელთა შედარება ხდება მოთხოვნის მარშრუტთან და თუ მოხდება თანხვედრა, მოცემული მოთხოვნა დამუშავდება ამ app.get() მეთოდით. 
                  
                  საჭიროების შემთხვევაში შეგვიძლია მოთხოვნის დამუშავების კონვეიერის ნებისმიერ ეტაპზე ჩავაშენოთ  ნებისმიერი ფუნქცია middleware. ამისათვის გამოიყენება მეთოდი app.use(). შევცვალოთ app.js ფაილი შემდეგნაირად:
                  
                   
                  
                  var express = require("express");
                   
                  var app = express();
                  app.use(function(request, response, next){    
                      console.log("Middleware 1");
                      next();
                  });
                  app.use(function(request, response, next){    
                      console.log("Middleware 2");
                      next();
                  });
                   
                  app.get("/", function(request, response){    
                      console.log("Route /");
                      response.send("Hello");
                  });
                  app.listen(3000);
                  ფუნქცია, რომელიც გადაეცემა app.use() მეთოდს, იღებს სამ პარამეტრს:
                  
                  request: მოთხოვნის მონაცემები
                  response: ობიექტი პასუხის მართვისთვის
                  next: დამუშავების კონვეიერში შემდეგი ფუნქცია
                  თითოეულ middleware ფუნქციას კონსოლში გამოაქვს შეტყობინება და ბოლოს იძახებს შემდეგ ფუნქციას next() გამოძახებით.
                  
                  სერვერის გაშვების შემდეგ როცა მივმართავთ ბრაუზერში მისამართს http://localhost:3000/ რიგირგობით ამუშავდება სამივე middleware:
                  
                  JavaScript
                  
                  თუმცა არაა აუცილებელი შესრულდეს ყველა middleware, შეგვიძლია რაღაც ეტაპზე შევაჩეროთ დამუშავება:
                  
                   
                  
                  var express = require("express");
                   
                  var app = express();
                  app.use(function(request, response, next){    
                      console.log("Middleware 1");
                      next();
                  });
                  app.use(function(request, response, next){    
                      console.log("Middleware 2");
                      response.send("Middleware 2");
                  });
                   
                  app.get("/", function(request, response){
                      console.log("Route /");
                      response.send("Hello");
                  });
                  app.listen(3000);
                   
                   
                  
                  ახლა დამუშავება შეწყდება middleware2-ზე, რადგან მასში ხდება პასუხის გაგზავნა response.send() მეთოდის მეშვეობით, ხოლო ნეხტ()-ის მეშვეობით შემდეგი ფუნქციის გამოძახება არ ხდება.
                  
                  middlware ფუნქციები შეიძლება შევუსაბამოთ განსაზღვრულ მარშრუტს. მაგალითად:
                  
                  var express = require("express");
                   
                  var app = express();
                  app.use(function(request, response, next){    
                      console.log("Middleware 1");
                      next();
                  });
                  app.use("/about", function(request, response, next){    
                      console.log("About Middleware");
                      response.send("About Middleware");
                  });
                   
                  app.get("/", function(request, response){
                      console.log("Route /");
                      response.send("Hello");
                  });
                  app.listen(3000);
                   
                  
                  NodeJS
                  
                  მოცემულ შემთხვევაში მეორე middleware ფუნქცია განსაზღვრულია "/about" მარშრუტისთვის, ამიტომ ის შესრულდება მხოლოდ "http://localhost:3000/about" მისამართზე მიმართვისას, ხოლო პირველი middleware ფუნქცია იმუშავებს ნებისმიერი მარშრუტის დროს.
                  
                  middleware ფუნქციები გვეხმარება გარკვეული ამოცანების შესრულებაში, რომლებიც უნდა მოხდეს პასუხის გაგზავნამდე. ასეთი სტანდარტული ამოცანაა მოთხოვნების ლოგირება.
                  
                  მაგალითად, შევცვალოთ app.js ფაილი შემდეგნაირად`
              },
              {
                  title:"მარშრუტიზაცია",
                  data:`მოთხოვნების დამუშავებისას Express ფრეიმვორკი ეყრდნობა მარშრუტების სისტემას. პროგრამაში განისაზღვრება მარშრუტები და მათი დამმუშავებლები. თუ მოთხოვნა შეესაბამება გარკვეულ მარშრუტს, მისი დამუშავებისთვის ხდება შესაბამისი დამმუშავებლის გამოძახება.

                  წინა თემებში განხილულ ერთ-ერთ მაგალითში გამოვიყენეთ სამი მარშრუტი:
                  
                  var express = require("express");
                   
                  var app = express();
                  app.get("/", function(request, response){    
                      response.send("<h1>მთავარი გვერდი</h1>");
                  });
                  app.get("/about", function(request, response){    
                      response.send("<h1>საიტის შესახებ</h1>");
                  });
                  app.get("/contact", function(request, response){    
                      response.send("<h1>კონტაქტი</h1>");
                  });
                  app.listen(3000);
                  როცა მოდის მოთხოვნა, Express ადარებს მოთხოვნის მისამართს თითოეულ მარშრუტთან და დამთხვევისას იძახებს შესაბამის ფუნქციას.
                  
                  მარშრუტი შეიძლება შეიცავდეს რეგულარულ გამოსახულებას ან სპეციალურ სიმბოლოებს. კერძოდ, მარშრუტში შიძლება გამოყენებული იყოს სიმბოლოები: ?,+,* და (). 
                  
                  სიმბოლო ? ნიშნავს, რომ მის წინ მდგომი სიმბოლო შეიძლება იყოს ერთხელ ან საერთოდ არ იყოს. შეგვიძლია განვსაზღვროთ ფუნქცია შემდეგი მარშრუტით:
                  
                  app.get("/bo?k", function (request, response) {
                      response.send(request.url)
                  });
                  ასეთი მარშრუტი შეესაბამება მოთხოვნებს მისამართით "/bk" ან "/bok".
                  
                  სიმბოლო + მიუთითებს, რომ წინა სიმბოლო შეიძლება იყოს ერთხელ ან ბევრჯერ:
                  
                  app.get("/bo+k", function (request, response) {
                      response.send(request.url)
                  });
                  ასეთი მარშრუტი შეესაბამება მოთხოვნებს მისამართით "/bok", "/book", "/boook" და ა. შ.
                  
                  სიმბოლო * მიუთითებს, რომ მის ადგილზე შეიძლება იყოს ნებისმიერი რაოდენობის ნებისმიერი სიმბოლო:
                  
                  app.get("/bo*k", function (request, response) {
                      response.send(request.url)
                  });
                  ასეთი მარშრუტი შეესაბამება მოთხოვნებს მისამართით "/bork", "/bonk", "/bor.dak", "/bor/ok" და ა. შ.
                  
                  ფრჩხილების მეშვეობით შეგვიძლია მივუთითოთ სიმბოლოების ერთობლიობა, რომლების შეიძლება გვხვდებოდეს მოთხოვნის მისამართში:
                  
                  app.get("/bo0k(.html)?", function (request, response) {
                      response.send(request.url)
                  });
                  გამოსახულება (.html)? მიუთითებს, რომ მოთხოვნის მისამართში შეიძლება იყოს ან არ იყოს .html სტრიქონი. ეს მარშრუტი შეესაბამება მოთხოვნის მისამართებს: "book" ან "book.html".
                  
                  ასევე, მარშრუტის განსაზღვრის ნაცვლად შეგვიძლია გამოვიყენოთ რეგულარული გამოსახულებები. მაგალითად, ვთქვათ გვინდა დავიჭიროთ ყველა მოთხოვნა, რომლის მისამართი ბოლოვდება ".html"-ით:
                  
                  app.get(/.*(\.)html$/, function (request, response) {
                      response.send(request.url)
                  });
                  პარამეტრების გადაცემა მარშრუტში
                  
                  მარშრუტები შეიძლება შეიცავდნენ პარამეტრებს - URL მისამართის სახელდებულ სეგმენტებს. პარამეტრის სახელი შეიძლება შეიცავდეს სიმბოლოებს [A-Za-z0-9_] დიაპაზონიდან. მარშრუტის განსაზღვრისას პარამეტრი გამოიყოფა ორწერტილით:
                  
                  var express = require("express");
                  var app = express();
                   
                  app.get("/products/:productId", function (request, response) {
                    response.send("productId: " + request.params["productId"])
                  });
                   
                  app.listen(3000);
                  მოცემულ შემთხვევაში პარამეტრის სახელია "productId". request.params კოლექციიდან შეგვიძლია მივიღოთ ყველა პარამეტრი და მათ შორის productId.
                  
                  პარამეტრის გადასაცემად იგი მიეთითება მოთხოვნის სტრიქონის ბოლო სეგმენტში
                  
                  NodeJS            NodeJS
                  
                  შეგვიძლია გამოვიყენოთ პარამეტრების უფრო რთული კომბინაციები:
                  
                  var express = require("express");
                  var app = express();
                   
                  app.get("/categories/:categoryId/products/:productId", function (request, response) {
                      var catId = request.params["categoryId"];
                      var prodId = request.params["productId"];
                      response.charset= "utf-8"; 
                    response.send("კატეგორია: " + catId + "საქონელი:" + prodId);
                  });
                   
                  app.listen(3000);
                   
                  
                  NodeJS
                  
                  ან, მეორენაირად:
                  
                  app.get("/book/:pageName.:pageExt", function (request, response) {
                      var pageName = request.params["pageName"];
                      var pageExt = request.params["pageExt"];
                    response.send("მოთხოვნილი ფაილი: " + pageName.pageExt);
                  });
                   
                  
                  NodeJS
                  
                  express.Router
                  
                  კლასი express.router საშუალებას იძლევა განვსაზღვროთ მარშრუტი, რომლის ფარგლებში შეიძლება შეიქმნას ქვემარშრუტები, რომლებიც დაკავშირებულია ქვემაშრუტებთან.მაგალითდ:
                  
                  var express = require("express");
                   
                  var app = express();
                   
                  var productRouter = express.Router();
                  productRouter.route("/")
                              .get(function(request, response){    
                                  response.send("საქონლის ჩამონათვალი");
                              });
                  productRouter.route("/:id")
                              .get(function(request, response){
                      
                                  response.send("საქონელი" + request.params.id);
                              });
                  app.use("/products", productRouter);
                   
                  app.get("/", function(request, response){
                      
                      response.send("მთარი გვერდი");
                  });
                   
                  app.listen(3000);
                  აქ განსაზღვრულია productRouter, რომელიც ამუშავებს ყველა მოთხოვნას მისამართით "/products". ამ მარშრუტის ფარგლებში შეიძლება იყოს მოთხოვნა "/" და ქვემარშრუტი "/:id", რომელთაც თავ-თავისი დამმუშავებლები გააჩნიათ.`
              },
              {
                  title:"სტატიკური ფაილები",
                  data:`ვნახოთ, როგორ შეიძლება NodeJS-ისა და  Express-ის მეშვეობით მომხმარებლისთვის სტატიკური html ფაილების გაგზავნა. სტატიკურ ფაილებტან სამუშაოდ Express-ში განკუთვნილია სპეციალური კომპონენტი express.static(), რომელიც უთითებს საქაღალდეზე სტატიკური ფაილებით.

                  სტატიკური ფაილებისთვის შევქმნათ პროექტში საქაღალდე public და დავამატოთ მასში ფაილი about.html:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>საიტის შესახებ</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <h1>საიტის შესახებ</h1>
                      <p>შექმნილია Node.js და Express მეშვეობით</p>
                  </body>
                  <html>
                  ახლა შევცვალოთ ფაილი app.js:
                  
                  var express = require("express");
                  var app = express();
                   
                  app.use(express.static(__dirname + "/public"));
                   
                  app.get("/", function(request, response){    
                      response.send("<h1>მთავარი გვერდი</h1>");
                  });
                  app.get("/contact", function(request, response){    
                      response.send("<h1>კონტაქტი</h1>");
                  });
                  app.listen(3000);
                  მოთხოვნის დამუშავებაში express.static()-ის ჩასასმელად გამოიყენება ფუნქცია app.use(). ეს ფუნქცია საშუალებას იძლევა დავამატოთ სხვადასხვა კომპონენტი დამუშავების კონვეიერში, რომელთაც middleware ეწოდება:
                  
                  app.use(express.static(__dirname + "/public"));
                  თვითონ express.static() ფუნქციას პარამეტრად გადაეცემა გზა საქაღალდემდე, სადაც მოთავსებულია სტატიკური ფაილები. სპეციალური გამოსახულება __dirnameსაშუალებას გვაძლევს მივიროთ სრული გზა საქაღალდემდე.
                  
                  გავუშვათ სერვერი და ბრაუზერში მივმართოთ მისამართს http://localhost:3000/about.html:
                  
                  app.use("/static",express.static(__dirname + "/public"));
                  ახლა უკვე სტატიკური ფაილის მიმართვისთვის საჭიროა გამოვიყენოთ მისამართი http://localhost:3000/static/about.html.
                  
                   
                  
                  NodeJS     
                  
                  საჭიროა აღინიშნოს, რომ ფაილზე მიმართვისთვის ჩვენ ვუთითებთ მხოლოდ ფაილის სახელს საქაღალდის გარეშე.
                  
                  დამატებით, შესაძლებელია შევცვალოთ გზა სტატიკურ ფაილებამდე`
              },
              {
                  title:"POST-მოთხოვნები და ფორმის გაგზავნა",
                  data:`რამე რთული მონაცემების გასაგზავნად, როგორც წესი, გამოიყენება ფორმები. ვნახოთ, როგორ მივიღოთ გამოგზავნილი მონაცემები Express-ში.

                  მოთხოვნიდან ფორმის მონაცემების მისაღებად საჭიროა სპეციალური პაკეტის body-parser გამოყენება. ამისათვის ჯერ უნდა დავამატოთ ეს პაკეტი პროექტში ბრძანებით:
                  
                  npm install body-parser --save
                  შევქმნათ პროექტის public საქაღალდეში ფაილი register.html:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>რეგისტრაცია</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <h1>შეიყვანეთ მონაცემები</h1>
                      <form action="/register" method="post">
                          <label>სახელი</label><br>
                          <input type="text" name="userName" /><br><br>
                          <label>ასაკი</label><br>
                          <input type="number" name="userAge" /><br><br>
                          <input type="submit" value="გაგზავნა" />
                      </form>
                  </body>
                  <html>
                  აქ განსაზღვრულია ორი ველი მომხმარებლის სახელის და ასაკის შესაყვანად. ღილაკზე დაჭერის შემდეგ მონაცემები გაიგზავნება მისამართზე "/register".
                  
                  app.js ფაილში განვსაზღვროთ შემდეგი კოდი:
                  
                  var express = require("express");
                  var bodyParser = require("body-parser");
                   
                  var app = express();
                   
                  // შევქმნათ პარსერი (parser) მონაცემებისთვის application/x-www-form-urlencoded
                  var urlencodedParser = bodyParser.urlencoded({extended: false});
                   
                  app.use(express.static(__dirname + "/public"));
                   
                  app.post("/register", urlencodedParser, function (request, response) {
                      if(!request.body) return response.sendStatus(400);
                      console.log(request.body);
                    response.send(request.body.userName - request.body.userAge);
                  });
                   
                  app.get("/", function(request, response){
                      
                      response.send("<h1>მთავარი გვერდი</h1>");
                  });
                   
                  app.listen(3000);
                  გამოგზავნილი მონაცემების მისაღებად პირველ რიგში საჭიროა შევქმნათ პარსერი (parser):
                  
                  var urlencodedParser = bodyParser.urlencoded({extended: false});
                  რადგანაც მონაცემები იგზავნება ფორმიდან, პარსერის შესაქმნელად გამოიყენება ფუნქცია urlencoded(). ამ ფუნქციას გადაეცემა ობიექტი, რომელიც ადგენს პარსინგის პარამეტრებს. მნიშვნელობა extended: false მიუთითებს, რომ პარსინგის შედეგად მიღებული ობიექტი წარმოადგენს გასაღები-მნიშვნელობა წყვილების ერთობლიობას, ხოლო ტითოეული მნიშვნელობა შეიძლება წარმოდგენილი იყოს როგორც სტრიქონი ან მასივი.
                  
                  რადგანაც მონაცემები ფორმიდან იგზავნება მეთოდით POST,მისი დამუშავებისთვის უნდა განისაზღვროს ფუნქცია app.post("/register",...). პირველი პარამეტრი მოთხოვნის მისამართია "/register",  მეორე პარამეტრი - ზემოთ შექმნილი პარსერი, ხოლო მესამე პარამეტრს წარმოადგენს ფუნქცია დამმუშავებელი:
                  
                  app.post("/register", urlencodedParser, function (request, response) {
                      if(!request.body) return response.sendStatus(400);
                      console.log(request.body);
                    response.send(request.body.userName - request.body.userAge);
                  });
                  თვითონ გამოგზავნილი მონაცემების მისაღებად გამოიყენება შემდეგი ტიპის გამოსახულება: request.body.userName, სადაც request.body ახდენს ფორმის ინკაფსულაციას, ხოლო userName წარმოადგენს მონაცემის გასაღებს, რომელიც შეესაბამება შეყვანის ველის ატრიბუტს name html გვერდზე:
                  
                  <input type="text" name="userName" /><br><br>
                  გავუშვათ სერვერი და მივმართოთ გვერდს register.html:
                  
                  NodeJS     
                  
                  გაგზავნის შემდეგ მონაცემები დამუშავდება და დაბრუნდება პასუხი:`
              },
              {
                  title:"JSON და AJAX",
                  data:`JSON წარმოადგენს მონაცემთა შენახვისა და გადაცემის ერთ-ერთ ყველაზე პოპულარულ ფორმატს და Express-ს გააჩნია ყველანაირი შესაძლებლობა მასთან სამუშაოდ. მაგრამ ისევე, როგორც წინა თამაში, json-თან სრულყოფილად სამუშაოდ საჭიროა პაკეტი body-parser, რომლის დამატებაც შესაძლებელია ბრძანებით:

                  npm install body-parser --save
                  ვთქვათ, public საქაღალდეში გვაქვს ფაილი register.html შემდეგი კოდით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>რეგისტრაცია</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <h1>შეიყვანეთ მონაცემები</h1>
                      <form action="/register" method="post" name="registerForm">
                          <label>სახელი</label></br>
                          <input type="text" name="userName" /></br></br>
                          <label>ასაკი</label></br>
                          <input type="number" name="userAge" /></br></br>
                          <input type="submit" value="გაგზავნა" />
                      </form>
                      <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
                      <script>
                          $("form").submit(function(e) {
                              
                              e.preventDefault();
                              var registerForm = document.forms["registerForm"];
                              var userName = registerForm.elements["userName"].value;
                              var userAge = registerForm.elements["userAge"].value;
                              
                              $.ajax({
                                  type: "POST",
                                  url: "/user",
                                  data: JSON.stringify({userName: userName, userAge: userAge}),
                                  dataType: "json",
                                  contentType: "application/json",
                                  success: function(data){
                                      console.log(data);
                                      },
                                  });
                          });
                      </script>
                  </body>
                  <html>
                  აქ, ისევე როგორც წინა თემაში, განთავსებულია ფორმა ორი ველით მომხმარებლის სახელისა და ასაკისთვის. მაგრამ ახლა მონაცემების გაგზავნა ხდება jquery-ს კოდის მეშვეობით ajax-ის საშუალებით, ხოლო თვითონ მონაცემების სერიალიზაცია ხდება json ფორმატში.
                  
                  შევცვალოთ კოდი app.js ფაილში შემდეგი სახით:
                  
                  var express = require("express");
                  var bodyParser = require("body-parser");
                   
                  var app = express();
                  // შევქმნათ პარსერი json ფორმატისთვის
                  var jsonParser = bodyParser.json();
                   
                  app.use(express.static(__dirname + "/public"));
                   
                  app.post("/user", jsonParser, function (request, response) {
                      if(!request.body) return response.sendStatus(400);
                      console.log(request.body);
                      response.json(request.body.userName - request.body.userAge);
                  });
                   
                  app.get("/", function(request, response){    
                      response.send("<h1>მთავარი გვერდი</h1>");
                  });
                   
                  app.listen(3000);
                  პირველ რიგში, მონაცემების მისსაღებად json ფორმატში საჭიროა შევქმნათ პარსერი:
                  
                  var jsonParser = bodyParser.json();
                  რადგანაც კლიენტთქან ურთიერთქმედება ხდება json-ის მეშვეობით, მოთხოვნის პასუხიც გაიგზავნება იგივე ფორმატში:
                  
                  app.post("/user", jsonParser, function (request, response) {
                      if(!request.body) return response.sendStatus(400);
                      console.log(request.body);
                      response.json(request.body.userName - request.body.userAge);
                  });
                  გავუშვათ სერვერი და მივმართოთ register.html-ს. მონაცემების შეყვანისა და გაგზავნის შემდეგ კონსოლის ლოგში გამოისახება სერვერის პასუხი`
              },
              {
                  title:"ხედი (View) და ხედების ძრავა Handlebars",
                  data:`როგორც წესი, ვიზუალური ინტერფეისის შესაქმნელად Express იყენებს არ ასტანდარტულ html ფაილებს, არამედ სპეციალურ ხედებს (Views), რომელთაგანაც შემდეგ იქმნება html ფაილი. ხედების უპირატესობა იმაში მდგომარეობს, რომ ჩვენ შეგვიძლია მათში შევქმნათ გარკვეული შაბლონები, რომლებშიც შემდეგ დინამიურად ისმება გარკვეული შიგთავსი ჯავასკრიპტის კოდის გამოყენებით.

                  ხედების სამართავად გამოიყენება სპეციალური კომპონენტი - ხედების ძრავა (view engine), რომელსაც ასევე უწოდებენ შაბლონების ძრავას (template engine). ხედების ძრავები საკმაოდ ბევრია: Pug, Jade, Dust, Nunjucks, EJS, Handlebars და სხვა. ძრავის არჩევა დამოკიდებულია იმაზე, ტუ ვინ რომელს ანიჭებს უპირატესობას, ძირითადად მათ გააჩნიათ მსგავსი ფუნქციონალი, განსხვავებები არის მხოლოდ დეტალებში. მოცემულ შემთხვევაში მაგალითისთვის განვიხილოთ  მუშაობა ძრავასთან Handlebars ან შემოკლებით hbs.
                  
                  ხედებთან სამუშაოდ დავაინსტალიროთ პაკეტი hbs ბრძანებით:
                  
                  npm install hbs --save
                  ხედების შესანახად შევქმნათ პროექტის საქაღალდეში views საქაღალდე. დავამატოთ მსში ფაილი contact.hbs - hbs არის გაფართოება ხედებისთვის, რომლებიც მუშავდება Handlebars ძრავით. ჩავწეროთ ამ ფაილში უმარტივესი კოდი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>კონტაქტი</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <h1>კონტაქტი</h1>
                      <p>ელექტრონული მისამართი: admin@mycorp.com</p>
                  </body>
                  <html>
                  ფაილი გამოიყურება ისე, როგორც ჩვეულებრივი ვებგვერდი, თუმცა ის არ არის html ვებგვერდი, მაგრამ ჯერ არ შეიცავს არანაირ შაბლონებს.
                  
                  შევცვალოთ ფაილი app.js:
                  
                  var express = require("express");
                  var app = express();
                  app.set("view engine", "hbs");
                   
                  app.get("/", function(request, response){    
                      response.send("მთავარი გვერდი");
                  });
                  app.get("/contact", function(request, response){    
                      response.render("contact.hbs");
                  });
                  app.listen(3000);
                  Express-ის ხედების ძრავად Handlebars-ის დასაყენებლად გამოიძახება ფუნქცია:
                  
                  app.set("view engine", "hbs");
                  "/contact" მარშრუტისთვის გამოიყენება დამმუშავებლის ფუნქცია, რომელიც ახდენს "contact.hbs" ხედის რენდერინგს response.render() ფუნქციის მეშვეობით. ეს ფუნქცია ხედის საფუძველზე ქმნის html გვერდს, რომელიც ეგზავნება კლიენტს.
                  
                  გავუშვათ სერვერი და მივმართოთ მისამართს http://localhost:3000/contact:
                  
                  NodeJS     
                  
                  ხედის მოდელი
                  
                  შაქბლონების ერთ-ერთი უპირატესობა ისაა, რომ ჩვენ შეგვიძლია ხედებში ხედის მოდელის შაბლონის ადგილას გადავცეთ სპეციალური ობიექტები და მონაცემები, რომლებიც იყენებენ ხედის ძრავას რენდერინგისთვის.
                  
                  შევცვალოთ ფაილი app.js შემდეგნაირად:
                  
                  var express = require("express");
                  var app = express();
                  app.set("view engine", "hbs");
                   
                  app.get("/", function(request, response){    
                      response.send("მთავარი გვერდი");
                  });
                  app.get("/contact", function(request, response){    
                      response.render("contact.hbs", {
                          title: "ჩემი კონტაქტები",
                          email: "test@mycorp.com",
                          phone: "+1234567890"
                      });
                  });
                  app.listen(3000);
                  ახლა response.render() ფუნქციას მეორე პარამეტრად გადაეცემა ობიექტი, რომელსაც გააჩნია სამი თვისება.
                  
                  შევცვალოთ contact.hbs ხედის კოდიც:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>{{title}}</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      <h1>{{title}}</h1>
                      <p>ელექტრონული მისამართი: {{email}} </p>
                      <p>ტელეფონი: {{phone}}</p>
                  </body>
                  <html>
                  კონკრეტული მონაცემების ნაცვლად ხედის კოდში გამოიყენება ის მონაცემები, რომლებიც განსაზღვრულია მოდელში. მოდელის თვისებებთან მიმართვისთვის ორმაგ ფიგურულ ფრჩხილებში ეთითება საჭირო თვისება: {{title}}. რენდერინგის დროს ასეთი გამოსახულებების ნაცვლად ჩაისმება მოდელის შესაბამისი თვისებები.
                  
                  ხელახლა გავუშვათ სერვერი და მივმართოთ იგივე მისამართს:
                  
                  NodeJS
                  
                  ვნახოთ უფრო რთული შემთხვევა, ვთქვათ ხედში გადაეცემა მასივი:
                  
                  var express = require("express");
                  var app = express();
                  app.set("view engine", "hbs");
                   
                  app.get("/", function(request, response){    
                      response.send("მთავარი გვერდი");
                  });
                  app.get("/contact", function(request, response){    
                      response.render("contact.hbs", {
                          title: "ჩემი კონტაქტები",
                          emailsVisible: true,
                          emails: ["test1@mycorp.com", "test2@mycorp.com"],
                          phone: "+1234567890"
                      });
                  });
                  app.listen(3000);
                  მონაცემების გამოსატანად შევცვალოთ contact.hbs ფაილის კოდიც:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>{{title}}</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>    
                      <h1>{{title}}</h1>
                      
                      {{#if emailsVisible}}
                          <h3>ელექტრონული მისამართები</h3>
                          <ul>
                              {{#each emails}}
                                  <li>{{this}}</li>
                              {{/each}}
                          </ul>
                      {{/if}}
                      <p>ტელეფონი: {{phone}}</p>
                  </body>
                  <html>
                  ასეთი ტიპის გამოსახულება
                  
                  {{#if emailsVisible}}
                    //კოდი
                  {{/if}}
                  საშუალებას გვაძლევს, კოდის ხილვადობა დამოკიდებული იყოს emailsvisible თვისების მნიშვნელობაზე. თუ ეს თვისება არის true, კოდი {{#if emailsVisible}} და {{/if}}-ს შორის დაემატება ვებგვერდს.
                  
                  მასივის გადასარჩევად გამოიყენება კონსტრუქცია each:
                  
                  {{#each emails}}
                      <li>{{this}}</li>
                  {{/each}}
                  ეს კონსტრუქცია ახდენს emails მასივის ყველა ელემენტის გადარჩევას და მათგან ქმნის <li> ელემენტებს. მიმდინარე მასივის ელემენტი თავსდება ცვლადში this.
                  
                  შედეგად, "/contact" მისამართზე მიმართვისას მივიღებთ ასეთ შედეგს`
              },
              {
                  title:"ნაწილობრივი ხედები",
                  data:`ხშირად ვებგვერდები იყენებენ რაღაც საერთო ელემენტებს. ეს შეიძლება იყოს მენიუ, საიტის სათაური, ფუტერი და სხვა. თუმცა აქ თავს იჩენს პრობლემა - თუ გვინდა რამის შეცვლა ამ ელემენტებში, მოგვიწევს მისი შეცვლა თითოეულ ვებგვერდზე, რომლებზეც ისინია გამოყენებული. უფრო მარტივი იქნებოდა ასეთი ელემენტები შეგვექმნა ერთ ადგილას და შემდეგ ჩაგვერთო ყველა ვებგვერდზე.

                  ამ პრობლემის გადაწყვეტაში გვეხმარება ნაწილობრივი ხედები (partial views), რომელთა ჩასმა შეიძლება ჩვეულებრივ ხედებში.
                  
                  მაგალითად, ჩვენ შეგვიძლია შევქმნათ საერთო მენიუ და ფუტერი. პროექტის საქაღალდეში ნაწილობრივი ხედებისთვის შევქმნათ საქაღალდე views/partials. დავამატოთ ამ საქაღალდეში ფაილი menu.hbs:
                  
                  <nav><a href="/">მთავარი</a> | <a href="/contact">კონტაქტი</a></nav>
                  
                  შემდეგ დავამატოთ იგივე საქაღალდეში ფაილი footer.hbs:
                  
                  <footer><p>MyCorp - Copyright © 2018</p></footer>
                  
                  ეს არის ორი ნაწილობრივი ხედი, რომელთაც ჩავსვამთ ჩვეულებრივ ხედებში.
                  
                  views საქაღალდეში მოვათავსოთ ჩვეულებრივი ხედის ფაილი contact.hbs:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>{{title}}</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>    
                      <h1>{{title}}</h1>
                      
                      {{#if emailsVisible}}
                          <h3>ელექტრონული მისამართები</h3>
                          <ul>
                              {{#each emails}}
                                  <li>{{this}}</li>
                              {{/each}}
                          </ul>
                      {{/if}}
                      <p>ტელეფონი: {{phone}}</p>
                   
                  </body>
                  <html>
                  ნაწილობრივი ხედის ჩასასმელად გამოიყენება გამოსახულება {{ > menu }} , რომელშიც ეთითბა ნაწილობრივი ხედის სახელი გაფართოების გარეშე.
                  
                  ასევე დავამატოთ მეორე ხედი home.hbs:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>მთავარი გვერდი</title>
                      <meta charset="utf-8" />
                  </head>
                  <body>
                      {{> menu}}
                      <h1>მთავარი გვერდი</h1>
                      
                      {{> footer}}
                  </body>
                  <html>
                  ამგვარად, ჩვენ გვაქვს ორი ხედი, რომლებიც იყენებენ ერთი და იმავე ელემენტებს. თუ ჩვენ დაგვჭირდება მენიუში ახალი პუნქტის დამატება, ამის გაკეთება მოგვიწევს ერთ ადგილას menu.hbs ფაილში.
                  
                  შევცვალოთ ფაილი app.js:
                  
                  var express = require("express");
                  var hbs = require("hbs");
                  var app = express();
                  // განვსაზღვროთ ნაწილობრივი ხედების საქაღალდის მისამართი
                  hbs.registerPartials(__dirname + "/views/partials");
                  app.set("view engine", "hbs");
                  app.get("/", function(request, response){    
                      response.render("home.hbs");
                  });
                  app.get("/contact", function(request, response){    
                      response.render("contact.hbs", {
                          title: "ჩემი კონტაქტები",
                          emailsVisible: true,
                          emails: ["test1@mycorp.com", "test2@mycorp.com"],
                          phone: "+1234567890"
                      });
                  });
                  იმისათვის, რომ გამოყენებულ იქნეს ნაწილობრივი ხედები, უნდა განისაზღვროს მათი ადგილსამყოფელი:
                  
                  hbs.registerPartials(__dirname + "/views/partials");
                  თუ გავუშვებთ სერვერს და მივმართავთ ერთ-ერთს შემდეგი მისამართებიდან: http://localhost:3000  ან http://localhost:3000/contact, ხედის რენდერინგის შედეგად ვებგვერდი შეიცავდეს იქნება მენიუს და ფუტერს:`
              },
              {
                title:"ჰელპერები",
                data:`ჰელპერები პრაქტიკულად წარმოადგენენ ფუნქციებს, რომლებიც აბრუნებენ რაღაც სტრიქონებს. მიღების შემდეგ ამ სტრიქონების დამატება შეიძლება ხედის ნებისმიერ ადგილას. სტრიქონი შეიძლება იყოს html კოდიც.

                ჰელპერები საშუალებას იძლევა მოვახდინოთ ხედების კოდის შექმნის ოპტიმიზაცია. კერძოდ, ჩვენ შეგვიძლია ერთხელ განვსაზღვროთ ჰელპერის ფუნქცია, ხოლო შემდეგ მრავალჯერ გამოვიყენოთ სხვადასხვა ადგილას კოდის გენერაციისთვის.
                
                ჰელპერების გამოსაყენებლად შევცვალოთ ფაილი app.js:
                
                var express = require("express");
                var hbs = require("hbs");
                var app = express();
                hbs.registerHelper("getTime", function(){    
                    var myDate = new Date();
                    var hour = myDate.getHours();
                    var minute = myDate.getMinutes();
                    var second = myDate.getSeconds();
                    if (minute < 10) {
                        minute = "0" + minute;
                    }
                    if (second < 10) {
                        second = "0" + second;
                    }
                    return "მიმდინარე დრო: " + hour + ":" + minute + ":" + second;
                });
                 
                app.set("view engine", "hbs");
                app.get("/", function(request, response){    
                    response.render("home.hbs");
                });
                app.listen(3000);
                ჰელპერი განისაზღვრება ფუნქციით hbs.registerHelper(). ფუნქციის პირველი პარამეტრია ჰელპერის სახელი, ხოლო მეორე - ფუნქცია, რომელიც აბრუნებს სტრიქონს. მოცემულ შემთხვევაში აბრუნებს მიმდინარე დროს.
                
                შევცვალოთ ხედი home.hbs:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <title>მთავარი გვერდი</title>
                    <meta charset="utf-8" />
                </head>
                <body>
                    <h1>მთავარი გვერდი</h1>
                    <div>{{getTime}}</div>
                </body>
                <html>
                ჰელპერის გამოსაძახებლად ორმაგ ფიგურულ ფრჩხილებში ეთითება ჰელპერის სახელი:
                
                NodeJS
                
                ჰელპერი შეიძლება აბრუნებდეს არა უბრალოდ სტრიქონს, არამედ html კოდს. ასევე, ჰელპერს შეიძლება გადაეცეს პარამეტრები, რომლებიც გამოიყენება შედეგის გენერაციისთვის. მაგალითად, app.js-ში განვსაზღვროთ კიდევ ერთი ჰელპერი:
                
                var express = require("express");
                var hbs = require("hbs");
                var app = express();
                hbs.registerHelper("getTime", function(){    
                    var myDate = new Date();
                    var hour = myDate.getHours();
                    var minute = myDate.getMinutes();
                    var second = myDate.getSeconds();
                    if (minute < 10) {
                        minute = "0" + minute;
                    }
                    if (second < 10) {
                        second = "0" + second;
                    }
                    return "მიმდინარე დრო: " + hour + ":" + minute + ":" + second;
                });
                 
                hbs.registerHelper("createStringList", function(array){    
                    var result="";
                    for(var i=0; i<array.length; i++){
                        result +="<li>" + array[i] + "</li>";
                    }
                    return new hbs.SafeString("<ul>" + result + "</ul>");
                });
                 
                app.set("view engine", "hbs");
                app.get("/", function(request, response){    
                    response.render("home.hbs", {
                        fruit: [ "apple", "lemon", "banana", "grape"]
                    });
                });
                app.listen(3000);
                აქ დამატებულია მეორე ჰელპერი createStringList(), რომელიც პარამეტრად იღებს სტრიქონების მასივს და მათგან ქმნის სიას (ელემენტს "<ul>"). მაგრამ იმისთვის, რომ დაბრუნებული მნიშვნელობა აღქმული იყოს, როგორც  html კოდი, ის უნდა შეიფუთოს ფუნქციით hbs.safeString().
                
                ასევე შევცვალოთ ხედის ფაილი home.hbs:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <title>მთავარი გვერდი</title>
                    <meta charset="utf-8" />
                </head>
                <body>
                    <h1>მთავარი გვერდი</h1>
                    <div>{{getTime}}</div>
                    <div>{{createStringList fruit}}</div>
                </body>
                <html>
                შედეგად მივიღებთ ასეთ ვებგვერდს:
                
                NodeJS
                
                ამასთან, უნდა აღვნიშნოთ, რომ ჰელპერი განვსაზღვრეთ ერთხელ, ხოლო მისი გამოყენება შეიძლება მრავალჯერ პარამეტრის სხვადასხვა მნიშვნელობის გადაცემით.`
            },
            {
                title:"API-ს შექმნა",
                data:`Express-ის და Node.js-ის მეშვეობით შესაძლებელია სრულყოფილი API-ს რეალიზება REST სტილში მომხმარებელთან ურთიერთქმედებისთვის. REST არქიტექტურა გულისხმობს შემდეგი HTTP მეთოდების და მოთხოვნის ტიპების გამოყენებას სერვერთან ურთიერთობისთვის:

                GET
                POST
                PUT
                DELETE
                REST სტილი განსაკუთრებით მოხერხებულია სხვადასხვა სახის Single Page Application-ის შექმნისთვის, როგორიცაა Javascript ფრეიმვორკები Angular, React, Knockout.
                
                ვნახოთ, როგორ უნდა შევქმნათ API. შევქმნათ პროექტის საქაღალდე webapp და შევქმნათ მასში ფაილი package.json:
                
                {
                    "name": "webapp",
                    "version": "1.0.0",
                    "dependencies": {
                        "body-parser": "^1.16.0",
                        "express": "^4.14.0"
                    }
                }
                პროექტში დაგვჭირდება Express და body-parser მიღებული მონაცემების პარსინგისთვის.
                
                ამის შემდეგ პაკეტების დასამატებლად გავუშვათ ბრძანებების ფანჯარა, გადავიდეთ პროექტის საქაღალდეზე და გავუშვათ ბრძანება:
                
                npm install
                მოცემულ შემთხვევაში ჩვენ შევქმნით პროექტს, რომელიც ინახავს json ფაილში მონაცემებს და გვიჩვენებს, როგორ უნდა შევქმნათ REST სტილის API Node.js-ში. დავამატოთ პროექტის საქაღალდეში ფაილი users.json შემდეგი შიგთავსით:
                
                [{
                    "id":1,
                    "name":"Tom",
                    "age":24
                },
                {
                    "id":2,
                    "name":"Bob",
                    "age":27
                },
                {
                    "id":3,
                    "name":"Alice",
                    "age":"23"
                }]
                ფაილში ჩაწერისა და ამოკითხვისთვის გამოვიყენებთ ჩაშენებულ მოდულს fs. მოთხოვნების დასამუშავებლად შევქმნათ ფაილი app.js:
                
                var express = require("express");
                var bodyParser = require("body-parser");
                var fs = require("fs");
                 
                var app = express();
                var jsonParser = bodyParser.json();
                 
                app.use(express.static(__dirname + "/public"));
                // მონაცემების სიის მიღება
                app.get("/api/users", function(req, res){     
                    var content = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(content);
                    res.send(users);
                });
                 
                // ერთი მომხმარებლის მიღება id-ის მიხედვით
                app.get("/api/users/:id", function(req, res){     
                    var id = req.params.id; // ვიღებთ id-ს
                    var content = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(content);
                    var user = null;
                    // ვეძებთ მასივში id-ის მიხედვით
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==id){
                            user = users[i];
                            break;
                        }
                    }
                    // ვაგზავნით მომხმარებელს
                    if(user){
                        res.send(user);
                    }
                    else{
                        res.status(404).send();
                    }
                });
                // გამოგზავნილი მონაცემების მიღება
                app.post("/api/users", jsonParser, function (req, res) {
                    
                    if(!req.body) return res.sendStatus(400);
                    
                    var userName = req.body.name;
                    var userAge = req.body.age;
                    var user = {name: userName, age: userAge};
                    
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    
                    // მაქსიმალური id-ს მოძებნა
                    var id = Math.max.apply(Math,users.map(function(o){return o.id;}))
                    // ვზრდით 1-ით
                    user.id = id+1;
                    // ვამატებთ მომხმარებელს მასივში
                    users.push(user);
                    var data = JSON.stringify(users);
                    // გადავაწეროთ ფაილი ახალი მონაცემებით
                    fs.writeFileSync("users.json", data);
                    res.send(user);
                });
                 // მომხმარებლის წაშლა id-ის მიხედვით
                app.delete("/api/users/:id", function(req, res){
                     
                    var id = req.params.id;
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    var index = -1;
                    // მოვძებნოთ მომხმარებლის ინდექსი მასივში
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==id){
                            index=i;
                            break;
                        }
                    }
                    if(index > -1){
                        // წავშალოთ მომხმარებელი ინდექსის მიხედვით
                        var user = users.splice(index, 1)[0];
                        var data = JSON.stringify(users);
                        fs.writeFileSync("users.json", data);
                        // ვაგზავნით წაშლილ მომხმარებელს
                        res.send(user);
                    }
                    else{
                        res.status(404).send();
                    }
                });
                // მომხმარებლის რედაქტირება
                app.put("/api/users", jsonParser, function(req, res){
                     
                    if(!req.body) return res.sendStatus(400);
                    
                    var userId = req.body.id;
                    var userName = req.body.name;
                    var userAge = req.body.age;
                    
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    var user;
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==userId){
                            user = users[i];
                            break;
                        }
                    }
                    // ვცვლით მომხმარებლის მონაცემებს
                    if(user){
                        user.age = userAge;
                        user.name = userName;
                        var data = JSON.stringify(users);
                        fs.writeFileSync("users.json", data);
                        res.send(user);
                    }
                    else{
                        res.status(404).send(user);
                    }
                });
                 
                app.listen(3000, function(){
                    console.log("სერვერი ელოდება შეერთებას...");
                });
                მოთხოვნების დასამუშავებლად განსაზღვრულია ხუთი მეთოდი თითოეული ტიპის მოთხოვნებისათვის: app.get(), app.post(), app.put(), app.delete(). როცა სერვერი მიიღებს GET ტიპის მოთხოვნას მისამართით "api/users", ამუშავდება შემდეგი მეთოდი:
                
                app.get("/api/users", function(req, res){     
                    var content = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(content);
                    res.send(users);
                });
                დამუშავების შედეგად მომხმარებელს უნდა გავუგზავნოთ მომხმარებლების მასივი, რომელსაც ამოვიკითხავთ ფაილიდან. კოდის გასამარტივებლად ამ პროექტში ფაილის ამოკითხვა ჩაწერისთვის გამოყენებულია სინქრონული მეთოდები. fs.readFileSync და fs.writeFileSync. რეალურ შემთხვევაში, როგორც წესი, მონაცემები ინახება მონაცემთა ბაზებში, მოგვიანებით ჩვენ განვიხილავთ ამას MongoDB-ს მაგალითზე.
                
                ფაილიდან წაკითხვისას მონაცემებს ვიღებთ სტრიქონში, რომელსაც ვპარსავთ ობიექტების მასივში json.parse() ფუნქციის მეშვეობით. ბოლოს მიღებულ მონაცემებს ვუგზავნით მომხმარებელს res.send() მეთოდით.
                
                ანალოგიურად მუშაობს მეორე app.get() მეთოდი, რომელიც მუშაობს იმ შემთხვევაში, როცა მისამართში მითითებულია მომხმარებლის id:
                
                app.get("/api/users/:id", function(req, res){     
                    var id = req.params.id; // ვიღებთ id-ს
                    var content = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(content);
                    var user = null;
                    // ვეძებთ მასივში id-ის მიხედვით
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==id){
                            user = users[i];
                            break;
                        }
                    }
                    // ვაგზავნით მომხმარებელს
                    if(user){
                        res.send(user);
                    }
                    else{
                        res.status(404).send();
                    }
                });
                ერთადერთი, ამ შემთხვევაში გვჭირდება id-ს შესაბამისი მომხმარებლის მოძებნა მასივში და თუ არ მოიძებნა, დავაბრუნოთ სტატუსის კოდი 404: res.status(404).send().
                
                POSTმეთოდით მოთხოვნის მიღებისას საჭიროა პარსერის jsonParser გამოყენება მოთხოვნიდან მონაცემების ამოსაღებად:
                
                // გამოგზავნილი მონაცემების მიღება
                app.post("/api/users", jsonParser, function (req, res) {
                    
                    if(!req.body) return res.sendStatus(400);
                    
                    var userName = req.body.name;
                    var userAge = req.body.age;
                    var user = {name: userName, age: userAge};
                    
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    
                    // მაქსიმალური id-ს მოძებნა
                    var id = Math.max.apply(Math,users.map(function(o){return o.id;}))
                    // ვზრდით 1-ით
                    user.id = id+1;
                    // ვამატებთ მომხმარებელს მასივში
                    users.push(user);
                    var data = JSON.stringify(users);
                    // გადავაწეროთ ფაილი ახალი მონაცემებით
                    fs.writeFileSync("users.json", data);
                    res.send(user);
                });
                მონაცემების მიღების შემდეგ უნდა შევქმნათ ახალი ობიექტი და დავამატოთ მასივში. ამისათვის ვკითხულობთ ობიექტებს ფაილიდან, ვამატებთ ახალ ობიექტს და გადავაწერთ ფაილს განახლებული მონაცემებით.
                
                წაშლისას ხდება მსგავსი ქმედებები, ოღონდ ამ შემთხვევაში ფაილიდან ამოკითხული მასივიდან ვშლით შესაბამის ობიექტს და ისევ გადავაწერთ ფაილს:
                
                 // მომხმარებლის წაშლა id-ის მიხედვით
                app.delete("/api/users/:id", function(req, res){
                     
                    var id = req.params.id;
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    var index = -1;
                    // მოვძებნოთ მომხმარებლის ინდექსი მასივში
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==id){
                            index=i;
                            break;
                        }
                    }
                    if(index > -1){
                        // წავშალოთ მომხმარებელი ინდექსის მიხედვით
                        var user = users.splice(index, 1)[0];
                        var data = JSON.stringify(users);
                        fs.writeFileSync("users.json", data);
                        // ვაგზავნით წაშლილ მომხმარებელს
                        res.send(user);
                    }
                    else{
                        res.status(404).send();
                    }
                });
                თუ წასაშლელი ობიექტი არ მოიძებნა, ვაბრუნებთ სტატუსის კოდს 404.
                
                თუ სერვერზე მოვიდა PUT მოთხოვნა, ის დამუშავდება მეთოდით app.put(), რომელშიც jsonParser-ის მეშვეობით ვიღებთ მონაცემებს:
                
                // მომხმარებლის რედაქტირება
                app.put("/api/users", jsonParser, function(req, res){
                     
                    if(!req.body) return res.sendStatus(400);
                    
                    var userId = req.body.id;
                    var userName = req.body.name;
                    var userAge = req.body.age;
                    
                    var data = fs.readFileSync("users.json", "utf8");
                    var users = JSON.parse(data);
                    var user;
                    for(var i=0; i<users.length; i++){
                        if(users[i].id==userId){
                            user = users[i];
                            break;
                        }
                    }
                    // ვცვლით მომხმარებლის მონაცემებს
                    if(user){
                        user.age = userAge;
                        user.name = userName;
                        var data = JSON.stringify(users);
                        fs.writeFileSync("users.json", data);
                        res.send(user);
                    }
                    else{
                        res.status(404).send(user);
                    }
                });
                აქაც დასარედაქტირებელი ობიექტის მოსაძებნად ფაილიდან ამოვიკითხავთ ობიექტების მასივს, მოვძებნით შესაბამის ობიექტს id-ს მიხედვით, შევუცვლით მას თვისებებს და ჩავწერთ განახლებულ მასივს ფაილში.
                
                ამგვარად, ჩვენ განვსაზღვრეთ მარტივი API. ახლა დავამატოთ კლიენტის კოდი. როგორც განსაზღვრულია კოდში, Express სტატიკური ფაილების შესანახად იყენებს საქაღალდეს public, ამიტომ შევქმნათ ასეთი საქაღალდე. შევქმნათ ამ საქაღალდეში ფაილი index.html, რომელიც შეასრულებს კლიენტის როლს. index.html ფაილში დავამატოთ შემდეგი კოდი:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8" />
                    <meta name="viewport" content="width=device-width" />
                    <title>მომხმარებლები</title>
                    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" />
                    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
                    <style>
                        body{
                            padding:10px;
                        }
                    </style>
                </head>
                <body>
                    <h2>მომხმარებელთა სია</h2>
                    <form name="userForm">
                        <input type="hidden" name="id" value="0" />
                        <div class="form-group">
                            <label for="name">სახელი:</label>
                            <input class="form-control" name="name" />
                        </div>
                        <div class="form-group">
                            <label for="age">ასაკი:</label>
                            <input class="form-control" name="age" />
                        </div>
                        <div class="panel-body">
                            <button type="submit" class="btn btn-sm btn-primary">შენახვა</button>
                            <a id="reset" class="btn btn-sm btn-primary">გასუფთავება</a>
                        </div>
                    </form>
                    <table class="table table-condensed table-striped table-bordered">
                        <thead><tr><th>Id</th><th>სახელი</th><th>ასაკი</th><th></th></tr></thead>
                        <tbody>
                        </tbody>
                    </table>
                 
                    <script>
                        // მომხმარებელთა სიის მიღება
                        function GetUsers() {
                            $.ajax({
                                url: "/api/users",
                                type: "GET",
                                contentType: "application/json",
                                success: function (users) {
                                    var rows = "";
                                    $.each(users, function (index, user) {
                                        // დავამატოთ მიღებული ელემენტები ცხრილში
                                        rows += row(user);
                                    })
                                    $("table tbody").append(rows);
                                 }
                            });
                        }
                        // ერთი მომხმარებლის მიღება
                        function GetUser(id) {
                            $.ajax({
                                url: "/api/users/"+id,
                                type: "GET",
                                contentType: "application/json",
                                success: function (user) {
                                    var form = document.forms["userForm"];
                                    form.elements["id"].value = user.id;
                                    form.elements["name"].value = user.name;
                                    form.elements["age"].value = user.age;
                                }
                            });
                        }
                        // მომხმარებლის დამატება
                        function CreateUser(userName, userAge) {
                            $.ajax({
                                url: "api/users",
                                contentType: "application/json",
                                method: "POST",
                                data: JSON.stringify({
                                    name: userName,
                                    age: userAge
                                }),
                                success: function (user) {
                                    reset();
                                    $("table tbody").append(row(user));
                                }
                            })
                        }
                        // მომხმარებლის რედაქტირება
                        function EditUser(userId, userName, userAge) {
                            $.ajax({
                                url: "api/users",
                                contentType: "application/json",
                                method: "PUT",
                                data: JSON.stringify({
                                    id: userId,
                                    name: userName,
                                    age: userAge
                                }),
                                success: function (user) {
                                    reset();
                                    $("tr[data-rowid='" + user.id + "']").replaceWith(row(user));
                                }
                            })
                        }
                 
                        // ფორმის გასუფთავება
                        function reset() {
                            var form = document.forms["userForm"];
                            form.reset();
                            form.elements["id"].value = 0;
                        }
                 
                        // მომხმარებლის წაშლა
                        function DeleteUser(id) {
                            $.ajax({
                                url: "api/users/"+id,
                                contentType: "application/json",
                                method: "DELETE",
                                success: function (user) {
                                    console.log(user);
                                    $("tr[data-rowid='" + user.id + "']").remove();
                                }
                            })
                        }
                        // ცხრილის სტრიქონისშექმნა
                        var row = function (user) {
                            return "<tr data-rowid='" + user.id + "'><td>" + user.id + "</td>" +
                                   "<td>" + user.name + "</td> <td>" + user.age + "</td>" +
                                   "<td><a class='editLink' data-id='" + user.id + "'>რედაქტირება</a> | " +
                                    "<a class='removeLink' data-id='" + user.id + "'>წაშლა</a></td></tr>";
                        }
                        // ფორმის გასუფთავება
                        $("#reset").click(function (e) {
                 
                            e.preventDefault();
                            reset();
                        })
                 
                        // ფორმის გაგზავნა
                        $("form").submit(function (e) {
                            e.preventDefault();
                            var id = this.elements["id"].value;
                            var name = this.elements["name"].value;
                            var age = this.elements["age"].value;
                            if (id == 0)
                                CreateUser(name, age);
                            else
                                EditUser(id, name, age);
                        });
                 
                        // რედაქტირების ბმულზე დაჭერა
                        $("body").on("click", ".editLink", function () {
                            var id = $(this).data("id");
                            GetUser(id);
                        })
                        //წაშლის ბმულზე დაჭერა
                        $("body").on("click", ".removeLink", function () {
                            var id = $(this).data("id");
                            DeleteUser(id);
                        })
                 
                        // მომხმარებლის ჩატვირთვა
                        GetUsers();
                 
                    </script>
                </body>
                </html>
                ძირითადი ლოგიკა აქ მოქცეულის ჯავასკრიპტის კოდში. სერვერთან ურთიერთქმედების გასამარტივებლად გამოყენებულია ბიბლიოთეკა jquery. გვერდის ჩატვირთვისას სერვერიდან ვღებულობთ მომხმარებლების სიას getUsers() ფუნქციით:
                
                function GetUsers() {
                    $.ajax({
                        url: "/api/users",
                        type: "GET",
                        contentType: "application/json",
                        success: function (users) {
                            var rows = "";
                            $.each(users, function (index, user) {
                                // დავამატოთ მიღებული ელემენტები ცხრილში
                                rows += row(user);
                                 })
                            $("table tbody").append(rows);
                              }
                         });
                     }
                ცხრილში სტრიქონების დასამატებლად გამოიყენება ფუნქცია row(), რომელიც აბრუნებს სტრიქონს. ამ სტრიქონში განსაზღვრულია ბმულები მომხმარებლის რედაქტირებისა და წაშლისთვის.
                
                ბმული მომხმარებლის რედაქტირებისთვის getUser() ფუნქციის მეშვეობით იღებს სერვერიდან მოცემულ მომხმარებელს:
                
                function GetUser(id) {
                    $.ajax({
                        url: "/api/users/"+id,
                        type: "GET",
                        contentType: "application/json",
                        success: function (user) {
                            var form = document.forms["userForm"];
                            form.elements["id"].value = user.id;
                            form.elements["name"].value = user.name;
                            form.elements["age"].value = user.age;
                             }
                         });
                     }
                არჩეული მომხმარებელი ავსებს ფორმას ცხრილის თავზე. ეს ფორმა გამოიყენება მომხმარებლის დასამატებლადაც. დამალული ველის მეშვეობით, რომელიც ინახავს id-ს, შეგვიძლია გავიგოთ, რომელი მოქმედებაა შესასრულებელი. თუ id 0-ის ტოლია, ხდება მომხმარებლის დამატება CreateUser() ფუნქციით, რომელიც აგზავნის მონაცემებს POST მოთხოვნით:
                
                function CreateUser(userName, userAge) {
                      $.ajax({
                          url: "api/users",
                          contentType: "application/json",
                          method: "POST",
                          data: JSON.stringify({
                              name: userName,
                              age: userAge
                             }),
                          success: function (user) {
                              reset();
                              $("table tbody").append(row(user));
                             }
                         })
                     }
                თუ მანამდე მომხმარებელი იყო ჩატვირთული ფორმაში და id ველში შენახულია მისი მნიშვნელობა (რომელიც მეტია 0-ზე), შესრულდება ფუნქცია EditUser(), რომელიც აგზავნის PUTმოთხოვნას:
                
                function EditUser(userId, userName, userAge) {
                    $.ajax({
                        url: "api/users",
                        contentType: "application/json",
                        method: "PUT",
                        data: JSON.stringify({
                            id: userId,
                            name: userName,
                            age: userAge
                             }),
                        success: function (user) {
                            reset();
                            $("tr[data-rowid='" + user.id + "']").replaceWith(row(user));
                             }
                         })
                     }
                გავუშვათ სერვერი და ბრაუზერში მივმართოთ მისამართს http://localhost:3000 და ჩვენ შევძლებთ მომხმარებლების მართვას, რომლებიც ინახება json ფაილში`
            },
           
            ]
        },
        {
            title:"თავი 5. ტესტირება",
            content:[
                {
                    title:"Mocha",
                    data:`Node.js-ზე პროგრამირებისას მნიშვნელოვანი ადგილი უჭირავს ტესტირებას. ამისათვის გაცილებით უფრო მოსახერხებელია არსებული ფრეიმვორკების გამოყენება, რომლებიც აიოლებენ ტესტირების პროცესს. წერთ-ერთ ასეთ ფრეიმვორკს წარმოადგენს Mocha. დაწვრილებით ფრეიმვორკის შესახებშეგიძლიათ ნახოთ ოფიციალურ საიტზე Mochajs. აქ ჩვენ განვიხილაფთ ფრეიმვორკთან მუშაობის საბაზისო მხარეს.

                    პროექტის საქაღალდეში შევქმნათ ფაილი package.json შემდეგი შიგთავსით:
                    
                    {
                        "name": "testapp",
                        "version": "1.0.0"
                    }
                    დავამატოთ პროექტში პაკეტი mocha შემდეგი ბრძანებით:
                    
                    npm install mocha --save-dev
                    რადგანაც mocha გვჭირდება მხოლოდ ტესტირების პროცესში, ფაილში package.json ის ემატება devDependencies სექციაში --save-dev ბრძანების მეშვეობით.
                    
                    ტესტირებისთვის შევქმნათ უმარტივესი მოდული. ამისთვის დავამატოთ პროექტში ფაილი operations.js შემდეგი შიგთავსით:
                    
                    module.exports.multiply = function(x,y){return x * y;}
                    აქ განსაზღვრულია ფუნქცია ორი რიცხვის გასამრავლებლად.
                    
                    ამ მოდულის ტესტირებისთვის პროექტში დავამატოთ ფაილი operations.test.js:
                    
                    var operations = require("./operations");
                     
                    it("should multiply two numbers", function(){    
                        var expectedResult = 15;
                        var result = operations.multiply(3, 5);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                        }
                    });
                    განვიხილოთ ეს ტესტი. შედეგის ტესტირებისთვის გამოიყენება mocha ფრეიმვორკიდან ფუნქცია it(). ეს ფუნქცია იღებს ორ პარამეტრს: შესასრულებელი ტესტირების ტექსტური აღწერას, რომლითაც შესაძლებელი იქნება მისი იდენტიფიცირება და თვითონ გასატესტ ფუნქციას.
                    
                    ჩვენს მაგალითში, უნდა შემოწმდეს ფუნქცია multiply(), რომელიც ამრავლებს ორ რიცხვს. აქმისათვის ფუნქციას უნდა გადავცეთ ორი რიცხვი და შევადაროთ შედეგი მოსალოდნელს. თუ შედეგი არ ემთხვევა მოსალოდნელს, გენერირდება შეცდომა.
                    
                    ტესტირების გასაიოლებლად შევცვალოთ ფაილი package.json შემდეგნაირად:
                    
                    {
                        "name": "testapp",
                        "version": "1.0.0",
                        "scripts": {
                            "test": "mocha *.test.js"
                        },
                        "devDependencies": {
                            "mocha": "^5.0.0"
                        }
                    } 
                    დამატებულია სექცია "scripts", სადაც განსაზღვრულია ბრძანება "test". ეს ბრძანება გაუშვებს ბრძანებას mocha *.jtest.s, რომელიც იწყებს ტესტირებას mocha-ს მეშვეობით, გადასცემს რა ფრეიმვორკს ყველა ფაილს, რომელიც მთავრდება ".jtest.s"-ით. როცა გვაქვს მხოლოდ ერთი ფაილი, შეგვიძლია მთლიანად გადავცეთ მისი სახელი: mocha operations.test.js.
                    
                    ამის შემდეგ ბრძანებების ფანჯარაში გადავიდეთ პროექტის საქაღალდეზე და გავუშვათ ბრძანება:
                    
                    npm test
                     
                    
                    NodeJS          
                    
                    მოცემულ შემთხვევაში კონსოლი გვიჩვენებს, რომ ტესტი გავლილია.
                    
                    მაგრამ, თუ შევცვლით ტესტის კოდს:
                    
                    var operations = require("./operations");
                     
                    it("should multiply two numbers", function(){    
                        var expectedResult = 16;
                        var result = operations.multiply(3, 5);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                        }
                    });
                    ტესტირებას ვერ გაივლის, რადგან ფუნქცია აბრუნებს 15-ს, ხოლო მოსალოდნელ შედეგში გვიწერია 16. ტესტი განმეორებითი გაშვებისას კონსოლში დაიწერება ამის შესახებ:
                    
                    NodeJS
                    
                    ანალოგიურად შეიძლება განვსაზღვროთ სხვა ტესტები. მაგალითად, შევცვალოთ ფაილი operations.js:
                    
                    module.exports.multiply = function(x,y){return x * y;}
                    module.exports.add = function(x, y){ return x + y;}
                    ფაილში დაემატა ფუნქცია რიცხვების შესაკრებად. გავტესტოთ იგი operations.test.js-ში:
                    
                    var operations = require("./operations");
                     
                    it("should multiply two numbers", function(){
                        
                        var expectedResult = 15;
                        var result = operations.multiply(3, 5);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                        }
                    });
                    it("should add two numbers", function(){
                        
                        var expectedResult = 16;
                        var result = operations.add(9, 7);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                            
                            
                        }
                    });
                    გავუშვათ ტესტი:
                    
                    NodeJS
                    
                    ასინქრონული ფუნქციების ტესტირება
                    
                    ასინქრონული ფუნქციების ტესტირება ცოტათი განსხვავებულია. მაგალითად, განვსაზღვროთ operations.js მოდულში ასინქრონული ფუნქცია :
                    
                    module.exports.multiply = function(x,y){return x * y;}
                    module.exports.add = function(x, y){ return x + y;}
                     
                    module.exports.multiplayAsync = function (a, b, callback){
                        setTimeout(function(){
                            callback(a * b);
                        }, 1000)
                    }
                    გავტესტოთ ეს ფუნქცია operations.test.js-ში:
                    
                    var operations = require("./operations");
                     
                    it("should multiply two numbers", function(){
                        
                        var expectedResult = 15;
                        var result = operations.multiply(3, 5);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                       
                            
                        }
                    });
                    it("should add two numbers", function(){
                        
                        var expectedResult = 16;
                        var result = operations.add(9, 7);
                        if(result!==expectedResult){
                            throw new Error("Expected" + expectedResult + ", but got" + result);
                         
                          
                        }
                    });
                     
                    it("shoud async multiply two numbers", function(done){
                        
                        var expectedResult = 12;
                        operations.multiplayAsync(4, 3, function(result){
                            if(result!==expectedResult){
                                throw new Error("Expected" + expectedResult + ", but got" + result);
                                
                            
                            }
                            done();
                        });
                    });
                    ასინქრონული ფუნქციების ტესტირების თავისებურებაა ის, რომ ტესტირების დაწყებამდე ასინქრონული ფუნქცია უნდა შესრულდეს, ამისათვის ტესტირების ფუნქციაში გადაეცემა ფუნქცია done(). ამასთან, ტესტირების დასრულებისას უნდა გამოვიძახოთ ეს ფუნქცია. ამგვარად, ასეტი ფუნქციის მეშვეობით Mocha-ს აქვს საშუალება აკონტროლოს ტესტის შესრულება.
                    
                    NodeJS
                    
                    თუ არ გადავცემთ done() ფუნქციას, ტესტი დასრულდება მანამ, სანამ შესრულდება ასინქრონული ფუნქცია.`
                },
                {
                  title:"Assert",
                  data:`წინა თემაში ტესტის შედეგის შესამოწმებლად გამოვიყენეთ მიღებული შედეგის მოსალოდნელთან შედარება:

                  if(result!==expectedResult){
                    throw new Error("Expected" + expectedResult, but got + result);
                   
                  }
                  მსგავსი შედარება საკმაოდ ტრივიალურია და გამოიყენება ბევრ ტესტში მცირეოდენი ცვლილებებით. ტესტის შედეგების შესამოწმებლად Node.js-ში შეიქმნა სპეციალური მოდული assert. ასევე არსებობს სხვადასხვა ბიბლიოთეკები, რომელთაც უწოდებენ Assertions და რომლებიც ემსახურებიან იგივე მიზნებს: should.js, expect.js და სხვა. მოცემულ შემთხვევაში ჩვენ განვიხილოთ მუშაობა Assert მოდულთან.
                  
                  equal
                  
                  ფუნქცია assert.equal() ადარებს ორ მნიშვნელობას. თუ ისინი არაა ტოლი, გენერირდება შეცდომა. მაგალითად, ავიღოთ operations.js მოდულში განსაზღვრული გამრავლების ფუნქცია:
                  
                  module.exports.multiply = function(x,y){return x * y;}
                  გავტესტოთ ის:
                  
                  var assert = require("assert");
                  var operations = require("./operations");
                   
                  it("should multiply two numbers", function(){
                      
                      var expected = 16;
                      var result = operations.multiply(3, 5);
                      assert.equal(result, expected);
                  });
                  თუ მნიშვნელობები ტოლია, კონსოლში დავინახავთ, რომ ტესტი გავლილია. წინააღმდეგ შემთხვევაში ვნახავთ წითელ შეტყობინებას შეცდომის შესახებ:
                  
                  NodeJS
                  
                  როგორც ვხედავთ, assert.equal ფუნქციის გამოყენებით ტესტირება უფრო მარტივია, ვიდრე ხელით შედარება და შემდეგ შედეგის მიხედვით შეცდომის გენერირება.
                  
                  assert.equal() ფუნქციის საპირისპიროს წარმოადგენს ფუნქცია assert.notEqual(). ის აგენერირებს შეცდომას, როცა შედეგი მოსალოდნელის ტოლია:
                  
                  it("should multiply two numbers", function(){
                      
                      var expected = 15;
                      var result = operations.multiply(3, 5);
                      assert.notEqual(result, expected);
                  });
                   `
              },
              {
                  title:"Express-ის ტესტირება",
                  data:`Express-ის გამოყენებისას ფუნქციონალის ტესტირებისთვის გამოიყენება სპეციალური ინსტრუმენტი - supertest. ჯერ დავაყენოთ ის შემდეგი ბრძანებით:

                  npm install supertest --save-dev
                  პირველ რიგში შევქმნათ მარტივი ფაილი app.js:
                  
                  const express = require("express");
                  var app = express();
                   
                  app.get("/", function (request, response){    
                      response.send("Hello Test");
                  });
                   
                  app.listen(3000);
                   
                  module.exports.app = app;
                  მთავარ მისამართზე "/" მიმართვისას იგი აბრუნებს გარკვეულ სტრიქონს: "Hello Test". იმისათვის, რომ გამოვიყენოთ ტესტში, ხდება მისი გაფორმება მოდულის სახით: module.exports.app = app;
                  
                  ტესტირებისთვის შევქმნათ იგივე საქაღალდეში ფაილი app.test.js:
                  
                  const request = require("supertest");
                   
                  var app = require("./app").app;
                   
                  it("should return Hello Test", function(done){    
                      request(app)
                          .get("/")
                          .expect("Hello Test")
                          .end(done);
                  });
                  ტესტირებისთვის ვიღებთ მოდულებს supertest-sს და ჩვენს app მოდულს და ვიყენებთ მეთოდს it(). ტესტის შესასრულებლად request-ს გადაეცემა ჩვენი მოდულის ფუნქციონალი:
                  
                       request(app)
                  
                  ვუთითებთ მისამართს, რომელსაც უნდა მივმართოთ:
                  
                  get("/")
                  ვუთითებთ მოსალოდნელ შედეგს expect მეთოდის მეშვეობით:
                  
                  expect("Hello Test")
                  მეთოდით end() ვასრულებთ ტესტს:
                  
                  end(done);
                  ტესტის გასაშვებად ისევ უნდა იყოს განსაზღვრული ბრძანება test ფაილში package.json:
                  
                  {
                      "name": "testapp",
                      "version": "1.0.0",
                      "scripts": {
                          "test": "mocha *.test.js"
                      },
                      "devDependencies": {
                          "mocha": "^5.0.0",
                          "supertest": "^3.0.0"
                      },
                      "dependencies": {
                          "express": "^4.16.2"
                      }
                  }
                  გავუშვათ ტესტი:
                  
                  NodeJS
                  
                  შეტყობინების ტექსტის მწვანე ფერი მიუთითებს, რომ ტესტი წარმატებით დასრულდა და მეთოდი ნამდვილად აბრუნებს ტექსტს "Hello Test".
                  
                  ვნახოთ კიდევ რამდენიმე ტესტი. ამისთვის შევცვალოთ ფაილი app.js:
                  
                  const express = require("express");
                  var app = express();
                   
                  app.get("/", function (request, response){    
                      response.send("Hello Test");
                  });
                   
                  app.get("/error", function (request, response){    
                      response.status(404).send("NotFound");
                  });
                   
                  app.get("/user", function (request, response){    
                      response.send({name:"Tom", age: 22});
                  });
                   
                  app.listen(3000);
                   
                  module.exports.app = app;
                  აქ მოცემულია სამი სხვადასხვა მარშრუტის დამუშავება. მათი ტესტირებისთვის შევცვალოთ app.test.js ფაილი:
                  
                  const request = require("supertest");
                  const assert = require("assert");
                   
                  var app = require("./app").app;
                   
                  it("should return Hello Test", function(done){
                      
                      request(app)
                          .get("/")
                          .expect("Hello Test")
                          .end(done);
                  });
                   
                  it("should return NotFound with status 404", function(done){
                      
                      request(app)
                          .get("/error")
                          .expect(404)
                          .expect("NotFound")
                          .end(done);
                  });
                   
                  it("should return user with name Tom and age 22", function(done){
                      
                      request(app)
                          .get("/user")
                          .expect(function(response){
                              assert.deepEqual(response.body, {name:"Tom", age:22});
                          })
                          .end(done);
                  });
                  თუ ჩვენ გვინდა სტატუსის კოდის შემოწმება, შეგვიძლია გადავცეთ მოსალოდნელი სტატუსის კოდი მეთოდს expect(404).
                  
                  თუ გვინდა შევამოწმოთ რამე კომპლექსური ობიექტი, რომელიც უბრუნდება კლიენტს, expect მეთოდს უნდა გადაეცეს ფუნქცია, რომელსაც თავის მხრივ, პარამეტრად გადაეცემა პასუხის ობიექტი response, ხოლო response.body-ს მეშვეობით შეგვიძლია მივიღოთ მთლიანი პასუხი, რომელიც შედარდება მოსალოდნელ მნიშვნელობას. კომპლექსური ობიექტების შესადარებლად შეგვიძლია გამოვიყენოთ მეთოდი deepEqual() ან deepStricEqual() assert ბიბლიოთეკიდან. 
                  
                  გავუშვათ ტესტი და შევამოწმოთ შედეგი`
              },
              {
                  title:"ტესტების ორგანიზაცია და მეთოდი describe",
                  data:`პროექტში შეიძლება იყოს ბევრი მოდული და თითოეულზე განსაზღვრული რამდენიმე ტესტი. mocha.js-ის describe() მეთოდის მეშვეობით შესაძლებელია ამ ტესტების დაჯგუფება. მაგალითად, ტესტები ერთი მოდულისთვის შეიძლება გაერთიანდეს ერთ ჯგუფში, მეორე მოდულისთვის - მეორე ჯგუფში და ა. შ. ჯგუფებად დაყოფა აადვილებს იმის იდენტიფიცირებას, ტუ რომელი მოდულისთვის ვერ შესრულდა ტესტი. ეს განსაკუთრებით მნიშვნელოვანია, როცა გვაქვს ბევრი ტესტი.

                  მაგალითად, ვთქვათ პროექტში გვაქვს მოდული operations.js:
                  
                  module.exports.multiply = function(x,y){return x * y;}
                  module.exports.add = function(x, y){ return x + y;}
                  ამ მოდულისთვის შევქმნათ ტესტის ფაილი operations.test.js:
                  
                  var assert = require("assert");
                  var operations = require("./operations");
                   
                  describe("Operation Tests", function(){
                      it("should multiply two numbers", function(){
                          
                          var expected = 15;
                          var result = operations.multiply(3, 5);
                          assert.equal(result, expected);
                      });
                      it("should add two numbers", function(){
                          
                          var expected = 16;
                          var result = operations.add(9, 7);
                          assert.equal(result, expected);
                      });
                  });
                  describe() მეთოდს პირველ პარამეტრად გადაეცემა ტესტების აღწერა, ხოლო მეორე პარამეტრად ფუნქცია, რომელიც შეიცავს ტესტებს.
                  
                  ასევე შევქმნათ პროექტში ფაილი app.js:
                  
                  const express = require("express");
                  var app = express();
                   
                  app.get("/", function (request, response){
                      
                      response.send("Hello Test");
                  });
                   
                  app.get("/error", function (request, response){
                      
                      response.status(404).send("NotFound");
                  });
                   
                  app.get("/user", function (request, response){
                      
                      response.send({name:"Tom", age: 22});
                  });
                   
                  app.listen(3000);
                   
                  module.exports.app = app;
                  მისთვის შევქმნათ ტესტის ფაილი app.test.js:
                  
                  const request = require("supertest");
                  const assert = require("assert");
                   
                  var app = require("./app").app;
                   
                  describe("Express Tests", function(){
                      it("should return Hello Test", function(done){
                          
                          request(app)
                              .get("/")
                              .expect("Hello Test")
                              .end(done);
                      });
                   
                      it("should return NotFound with status 404", function(done){
                          
                          request(app)
                              .get("/error")
                              .expect(404)
                              .expect("NotFound")
                              .end(done);
                      });
                   
                      it("should return user with name Tom and age 22", function(done){
                          
                          request(app)
                              .get("/user")
                              .expect(function(response){
                                  assert.deepEqual(response.body, {name:"Tom", age:22});
                              })
                              .end(done);
                      });
                  });
                  აქ მეთოდი describe() აფორმებს მეორე ჯგუფს.
                  
                  გავუშვათ ტესტი:`
              },
           
            ]
        }
         
    ]

},
jquery:{
    chapters:[
        {
            title:"თავი 1. შესავალი jQuery-ში",
            content:[
                {
                    title:"jQuery-თან მუშაობის დაწყება",
                    data:`რა არის jQuery

                    თანამედროვე ვებ პროგრამირება და ვებსაიტების შექმნა უკვე წარმოუდგენელია JavaScript-ის გამოყენების გარეშე. მაგრამ დღეისათვის სულ უფრო გამოიყენება არა პირდაპირ ჯავასკრიპტი, არამედ ჯავასკრიპტის ფრეიმვორკები და ბიბლიოთეკები. ერთ-ერთ ასეთ ბიბლიოთეკას, ამავე დროს ყველაზე პოპულარულს დღეისათვის, წარმოადგენს jQuery. ზოგიერთი შეფასებით დღეს არსებული საიტების არანაკლებ 50 პროცენტი იყენებს ამ ბიბლიოთეკას.
                    
                    თუმცა ჩვენ jQuery-ს ვეძახით ბიბლიოთეკას, სინამ,დვილეში ის წარმოადგენს ბიბლიოთეკების მთელ სისტემას, რომელიც შემოკრებილია ბაზური ბიბლიოთეკის გარშემო: ესენია jquery.ui, რომელიც განკუთვნილია ვიზუალური ინტერფეისების შესაქმნელად, jquery.mobile, რომელიც გამოიყენება მობილური საიტებისთვის და სხვა.
                    
                    რა უპირატესობები გააჩნია jQuery-ს გამოყენებას?
                    
                    კოდთან მუშაობის გამარტივება. jQuery გვაძლევს ვებგვერდის ელემენტებით მანიპულირების მარტივ და ელეგანტურ სინტაქსს.
                    გაფართოების შესაძლებლობა. jQuery-ის კოდი ღიაა დათვალიერებისა და ცვლილებებისთვის. თუ რამე არ მოგვწონს მასში, შეგვიძლია შევცვალოთ. ასევე შესაძლებელია jQuery-ის საკუთარი პლაგინების შექმნაც.
                    ბრაუზერების მხარდაჭერა. jQuery-ის მხარდაჭერა გააჩნია ბრაუზერების უმრავლესობას, მათ შორის IE7,8-ს. თუმცა, იმის გამო, რომ IE6,8 ბრაუზერები ისტორიას ჩაბარდა, ბიბლიოთეკის ზომების შესამცირებლად მათი მხარდაჭერა jQuery-ის ბოლო ვერსიიდან ამოღებულია.
                    jQuery-ის ბიბლიოთეკის ჩართვა პროექტში
                    
                    jQuery-ს ბიბლიოთეკასთან სამუშაოდ საჭიროა პირველ რიგში მისი ჩამოტვირთვა ოფიციალური საიტიდან: https://jquery.com/download/. მოცემული მომენტისთვის ბოლო ვერსია არის 3.3.1. ტუმცა ვერსიები განსხვავდება ერთმანეთისგან, მაგრამ, როგორც წესი, ეს განსხვავებები არაა მნიშვნელოვანი და ძირითადი ღერძი და საერთო პრინციპები ყველა ვერსიას ერთნაირი აქვს.
                    
                    საიტზე ბიბლიოთეკა წარმოდგენილია ორ ვარიანტად: Compressed (შეკუმშული, ანუ მინიმიზირებული) და Uncompressed (ჩვეულებრივი). მინიმიზირებულ ვერსიას გააცნია იგივე ფუნქციონალი, მხოლოდ იქიდან ამოღებულია ზედმეტი ცარიელი ადგილები, კომენტარები და ასე შემდეგ. ამის ხარჯზე მისი წარმადობა უფრო მეტია, ვიდრე ჩვეულებრივის და რეალურ პროექტში მიზანშეწონილია მისი გამოყენება. მაგრამ თუ გსურთ გაერკვეთ jQuery-ს ლოგიკაში, მაშინ უნდა ისარგებლოთ ჩვეულებრივი ვერსიით. 
                    
                    jQuery-ს ჩართვა პროექტსი ხდება ისევე, როგორც სხვა ჯავასკრიპტის ფაილის. მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Мир jQuery</title>
                        <script src="jquery-3.3.1.min.js"></script>
                    </head>
                    <body>
                    </body>
                    </html>
                    ახლა შევქმნათ მარტივი ვებგვერდი jQuery-ს გამოყენებით:
                    
                    <!DOCTYPE html>
                    <html>
                     
                    <head>
                        <title>jQuery-ს სამყარო</title>
                        <script src="jquery-3.3.1.min.js"></script>
                    </head>
                     
                    <body>
                        <h2>კეთილი იყოს თქვენი მობრძანება jQuery-ს სამყაროში</h2>
                        <button id="btn1">jQuery</button>
                        <button id="btn2" onclick="alert('JavaScript-ის სამყარო'); ">JavaScript</button>
                     
                        <script type="text/javascript">
                            $(function () {
                                $("#btn1").click(function () {
                                    $(this).css('background-color', 'red');
                                    alert('jQuery-ს სამყარო');
                                });
                            });
                        </script>
                    </body>
                     
                    </html>
                    მოცემული ვებგვერდი ერთის მხრივ, იყენებს jquery-ს, მეორეს მხრივ გვიჩვენებს განსხვავებას სტანდარტული ჯავასკრიპტის გამოყენებისაგან.
                    
                    ვებგვერდზე განსაზღვრულია ორი ღილაკი. ერთ მათგანის ღილაკზე დაჭერის დამუშავება (onclick) მოთავსებული აქვს თვითონ ღილაკის განსაზღვრის ადგილას html კოდში: onclick="alert('Мир JavaScript'); ". მეორე ღილაკი აკეთებს პრაქტიკულად იგივეს, ოღონდ jquery-ს მეშვეობით. ამ ღილაკს გააჩნია იდენტიფიკატორი (id="btn1") , რომლის მეშვეობით jquery-ს ფუნქცია მართავს მას. კოდის ბოლოსი განსაზღვრულია jquery-ს ფუნქცია:
                    
                        <script type="text/javascript">
                            $(function () {
                                $("#btn1").click(function () {
                                    $(this).css('background-color', 'red');
                                    alert('jQuery-ს სამყარო');
                                });
                            });
                        </script>
                    $(function(){}); გამოსახულება წარმოადგენს jquery-ს ფუნქციის მოკლე განსაზღვრას. მისი განთავსება მიღებულია კოდის ბოლოსი </body> დამხურავი ტეგის წინ. ეს ფუნქცია მოიცავს jquery-ს მთელ კოდს, რომელიც შესრულდება ვებგვერდის ჩატვირთვისას.
                    
                    კოდის პრინციპი მდგომარეობს იმაში, რომ ხდება ღილაკის მიღება გამოსახულებით $("#btn1") და შემდეგ ხდება მასზე დამმუშავებლის "ჩამოკიდება".  click ტოლფასია html-ის კოდსი გამოყენებული onclick-ის. ამასთან არაა საჭირო html-ის კოდში რამის შეცვლა, ყველაფერს აკეთებს jquery-ს კოდი. მოცემულ შემთხვევაში ხდება ღილაკის ფერის შეცვლა $(this).css('background-color', 'red'); და შეტყობინების გამოტანა alert('jQuery-ს სამყარო');
                    
                    CDN ქსელების გამოყენება
                    
                    მოცემულ შემთხვევაში ჩვენ ჩავრთეთ jquery-ს ფაილი უშუალოდ დისკიდან, თუმცა ასევე შესაძლებელია ამ ფაილის ჩართვა CDN-(Content Delivery Networks). ასეთ შემთხვევაში ბიბლიოთეკა იქნება მოთავსებული რომელიმე CDN ქსელში, ხოლო ჩვენ გამოვიყენებთ მის ბმულს:
                    
                        <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
                    ყველა შესაძლო ვერსია შეიძლება ნახოთ მისამართზე: https://code.jquery.com/. 
                    
                    ასევე შეგვიძლია გამოვიყენოთ CDN-ის სხვა ქსელები:
                    
                    Google CDN: ყველა შესაძლო ვერსიის ნახვა შესაძლებელია მისამართზე https://developers.google.com/speed/libraries/devguide?hl=ru#jquery. ჩართვის ფორმატი იქნება შემდეგი სახის: <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
                    Microsoft CDN: ყველა შესაძლო ვერსიის ნახვა შესაძლებელია მისამართზე https://www.asp.net/ajaxlibrary/cdn.ashx#jQuery_Releases_on_the_CDN_0. ჩართვის ფორმატი იქნება შემდეგი სახის: <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.10.1.min.js"></script>
                    Yandex CDN: ყველა შესაძლო ვერსიის ნახვა შესაძლებელია მისამართზე https://tech.yandex.ru/jslibs/#jquery. ჩართვის ფორმატი იქნება შემდეგი სახის: <script src="http://yandex.st/jquery/1.10.1/jquery.min.js"></script>`
                },
                {
                  title:"jQuery-ის ფუნქცია",
                  data:`ბიბლიოთეკის გამოყენების საკვანძო მომენტია jQuery-ს ფუნქცია. ეს ფუნქცია იშვებს ვებგვერდის ჩატვირთვისთანავე. რადგანაც, როგორც წესი, ფუნქცია შეიცავს კოდს, რომლის მეშვეობითაც ხდება ვებგვერდის ელემენტებით მანიპულირება, აუცილებელია, რომ კოდის ამუშავებამდე ყველა ეს ელემენტი იყოს ჩატვირთული. ამიტომაც jQuery-ს კოდი იწერება html-გვერდის ბოლოში, უშუალოდ დამხურავი body ტეგის წინ.

                  თუ ჩვენ წინა მაგალითში jQuery-ს კოდს მოვათავსებდით head სექციაში, მივიღებდით შეცდომას, რადგან კოდის ამუშავების მომენტისთვის ელემენტები არ იქნებოდა ჩატვირთული.
                  
                  jQuery-ის ფუნქციას აქვს შემდეგი სინტაქსი:
                  
                  jQuery(document).ready(function () {
                      // ფუნქციის კოდი.
                  });
                  jQuery-ის ფუნქციის ფორმალური აღწერაა jquery(object). მოცემულ შემთხვევაში ობიექტის სახით გამოიყენება ობიექტი document, რომელიც წარმოადგენს ვებგვერდის DOM-ის მთელ სტრუქტურას. პარამეტრად გამოიყენება უკუგამოძახების უსახელო ფუნქცია, რომელიც ამუშავდება ვებგვერდის ჩატვირთვისთანავე. 
                  
                  არის ფუნქციის გამოცხადების კიდევ ერთი ხერხი, რომელიც წინასთან თანაბარმნიშვნელოვანია:
                  
                  $(document).ready(function () {
                      // ფუნქციის კოდი.
                  });
                  ნიშანი $ წარმოადგენს jquery-ის ფსევდონიმს.
                  
                  ასევე შეგვიძლია გამოვიყენოთ შემოკლებული ვარიანტი:
                  
                  $(function () {
                      // ფუნქციის კოდი.
                  });
                  ან
                  
                  jquery(function () {
                      // ფუნქციის კოდი.
                  });
                  ყველა მოყვანილი ხერხი თანაბარმნიშვნელოვანია.`
              } 
          
            ]
        },
        {
            title:"თავი 2. ელემენტების ამორჩევა",
            content:[
                {
                    title:"სელექტორები",
                    data:`jQuery-ის ერთ-ერთ უმნიშვნელოვანეს ფუნქციონალს წარმოადგენს ელემენტების ამორჩევა. იმისათვის, რომ რამე მოქმედება განვახორციელოთ ელემენტზე, პირველ რიგში საჭიროა, მივიროთ ეს ელემენტი. ბიბლიოთეკა გვაძლევს ელემენტების ამორჩევის მარტივ და მოხერხებულ საშუალებებს, რომელიც დაფუძნებულია სელექტორებზე. მაგალითად, თუ გვინდა მივიღოთ ყველა ელემენტი img, შეგვიძლია გამოვიყენოთ გამოსახულება: $("img"). მოცემულ შემთხვევაში "img" წარმოადგენს სელექტორს.

                    განვიხილოთ ძირითადი სელექტორები, რომლებიც გამოიყენება ელემენტების ამოსარჩევად:
                    
                    jQuery-ის ძირითადი სელექტორები
                    
                    სელექტორის შაბლონი
                    
                    აღწერა	
                    მაგალითი
                    
                    $("*")
                    
                    ვებგვერდის ყველა ელემენტი	
                    მაგალითად, გამოსახულება $("*").css('background-color', 'red')გააფერადებს ვებგვერდის ყველა ელემენტს და ვებგვერდს წითელი ფერით
                    
                    $("Element")
                    
                    ყველა ელემენტი მოცემული ტეგით	
                    $("img") აბრუნებს ყველა img ელემენტს
                    
                    $("input") აბრუნებს ყველა input ელემენტს
                    
                    $("#id")
                    
                    ელემენტის არჩევა იდენტიფიკატორით id	
                    $("#btn1") აბრუნებს ელემენტს, რომლის იდენტიფიკატორი id არის btn1(მაგალითად, <div id="btn1"></div>)
                    
                    $(".class")
                    
                    ელემენტები ატრიბუტით class	
                    $(".redStyle") აბრუნებს ყველა ელემენტს, რომელთა ატრიბუტი class არის redStyle (მაგალითად, <div class="redStyle"></div>)
                    
                    $("selector1,selector2,selectorN")
                    
                    ყველა ელემენტი, რომლებიც შეესაბამება სელექტორებს	
                    მაგალითად, თუ გვაქვს კოდი:
                    
                    <div class="apple"></div>
                    
                    <div class="apple"></div>
                    
                    <div class="orange"></div>
                    
                    <div class="banana"></div>
                    
                    მაშინ სელექტორი $(".apple, .orange") აბრუნებს ყველა ელემენტს, რომელიც გამუქებულია.
                    
                    
                    ამორჩევის დაკონკრეტება
                    
                    შეგვიძლია გამოვიყენოთ ერთდროულად რამდენიმე სელექტორი, რათა უფრო დეტალურად დავაკონკრეტოთ ემენტების ამორჩევა. მაგალითად:
                    
                       <!DOCTYPE html>
                    
                    <html>
                    <head>
                        <title>Мир jQuery</title>
                    </head>
                    <body>
                        <h2>ლექსიკონი</h2>
                        <table id="tab">
                            <tr class="tabhead">
                                <td>
                                    <p>სიტყვა</p>
                                </td>
                                <td>
                                    <p>თარგმანი</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>table</p>
                                </td>
                                <td>
                                    <p>ცხრილი</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>apple</p>
                                </td>
                                <td>
                                    <p>ვაშლი</p>
                                </td>
                            </tr>
                        </table>
                        <script src="jquery-3.3.1.min.js"></script>
                        <script type="text/javascript">
                            jQuery(document).ready(function () {
                     
                                $("#tab").css('background-color', 'silver');
                            });
                        </script>
                    </body>
                    </html>
                    მოცემულ შემთხვევაში ვიყენებთ სელექტორს #tab, ანუ ვირჩევთ ცხრილს, რომლის id="tab". გამოსახულება css('background-color', 'silver') ანიჭებს ელემენტს ფერს, მოცემულ შემთხვევაში ვერცხლისფერს.
                    
                    თუ გავუშვებთ ვებგვერდს, მივიღებთ შემდეგს:
                    
                    jQuery
                    
                    შეგვიძლია გამოვიყენოთ სელექტორების ნაკრები, რათა უფრო დავაკონკრეტოთ ამოსარჩევი ელემენტები. მაგალითად, ვთქვათ, გვინდა გავაფერადოთ მხოლოდ მხოლოდ პირველი სტრიქონი, რომელსაც აქვს ატრიბუტი class="tabhead". შეგვიძლია გამოვიყენოთ სელექტორი $("#tab .tabhead"). ამ შემთხვევაში სელექტორი ამოირჩევს მხოლოდ იმ ელემენტს, რომელიც მოთავსებულია ელემენტში, რომლის id="tab" და რომლის class="tabhead".
                    
                    jQuery
                    
                    ძებნის არეალის შესამცირებლად შეგვიძლია გამოვიყენოთ უფრო მეტი სელექტორიც. მაგალითად, $("div#menu a.redStyle"). ასეთი სელექტორი ამოირჩევს, მაგალითად, ასეთ ელემენტს:
                    
                    <div id="menu">
                        <a href="m.html" class="redStyle">საიტის ბმული</a>
                    </div>
                    მოცემულ შემთხვევაში ჩვენ გამოვიყენეთ იერარქიული სელექტორი, რაც იმას ნიშნავს რომ ელემენტი მომდევნო სელექტორის მიხედვით უნდა იყოს წინა სელექტორის შესაბამისი ელემენტის შიგნით. გარდა ამისა, ჩვენ შეგვიძლია სხვა იერარქიული სელექტორების გამოყენებაც:
                    
                    სელექტორის შაბლონი
                    
                    აღწერა	
                    მაგალითი
                    
                    მშობელი სელექტორი > შვილი სელექტორი
                    
                    ყველა იმ ელემენტის ამორჩევა, რომელიც შეესაბამება მეორე სელექტორს და არის პირველი სელექტორის შესაბამისი ელემენტის შვილი	
                    მაგალითად, წინა მაგალითში id=#menu ელემენტის შიგნით მდებარე ბმულის ელემენტების მისაღებად შეგვიძლია გამოვიყენოთ სელექტორი $("#menu > a")
                    
                    სელექტორი1 + სელექტორი2
                    
                    იმ ელემენტების ამოსარჩევად, რომლებიც შეესაბამება ‘სელექტორი1’-ს და მდებარეობს უშუალოდ იმ ელემენტის შემდეგ, რომელიც შეესაბამება ‘სელექტორი2--ს, ამასთან, ორივე ელემენტი უნდა იყოს ერთი და იმავე დონეზე.	
                    მაგალითად, თუ გვაქვს ბმულების შემდეგი ბლოკი:
                    
                    <div id="menu">
                    
                                       <a href="1.html" class="open">1.html</a>
                    
                                       <a href="2.html" class="closed">2.html</a>
                    
                                       <a href="3.html">3.html</a>
                    
                                       <a href="4.html" class="open">4.html</a>
                    
                                       <a href="5.html" class="closed">5.html</a>
                    
                                       <a href="6.html" class="open">6.html</a>
                    
                    </div>
                    
                    მაშინ $(".closed + .open") სელექტორი ირჩევს იმ ბმულს, რომელიც გამუქებულია, რადგან მას აქვს ატრიბუტი class=”open” და მოსდევს ელემენტს, რომელსაც აქვს ატრიბუტი class=”closed”.
                    
                    სელექტორი1 ~ სელექტორი2
                    
                    იმ ელემენტების ამოსარჩევად, რომლებიც შეესაბამება ‘სელექტორი1’-ს და მდებარეობს უშუალოდ იმ ელემენტის შემდეგ, რომელიც შეესაბამება ‘სელექტორი2--ს, ამასთან, ორივე ელემენტი უნდა იყოს ერთი და იმავე დონეზე.	
                    მაგალითად, თუ გვაქვს ბმულების შემდეგი ბლოკი:
                    
                    <div id="menu">
                    
                                       <a href="1.html" class="open">1.html</a>
                    
                                       <a href="2.html" class="closed">2.html</a>
                    
                                       <a href="3.html">3.html</a>
                    
                                       <a href="4.html" class="open">4.html</a>
                    
                                       <a href="5.html" class="closed">5.html</a>
                    
                                       <a href="6.html" class="open">6.html</a>
                    
                    </div>
                    
                    მაშინ სელექტორი $(".closed ~ .open") ამოირჩევს იმ ბმულებს, რომლებიც გამუქებულია, რადგან მათ აქვთ ატრიბუტი class=”open” და იმყოფებიან ერთ დონეზე ელემენტთან, რომელსაც აქვს ატრიბუტი class=”closed”.
                    
                    ატრიბუტების სელექტორები
                    
                    ძებნის არეალის შესამცირებლად ბაზური და იერარქიული სელექტორების გარდა ასევე გამოიყენება ატრიბუტების სელექტორები. ამ შემთხვევაში jQuery დააბრუნებს ელემენტებს ატრიბუტების მნიშვნელობისა და განსაზღვრის მიხედვით.
                    
                    სელექტორის შაბლონი	აღწერა	
                    მაგალითი
                    
                    [attr]	ყველა ელემენტის ამორჩევა, რომელთაც აქვთ ატრიბუტი attr	
                    მაგალითად, სელექტორი $("a[class]") ამოირჩევს ყველა ელემენტს, რომელთაც გააჩნიათ ატრიბუტი class
                    
                    [attr='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr უდრის value-ს	მაგალითად, სელექტორი $("a[class='redstyle']"), ამოირჩევს ყველა ელემენტს, რომელთა ატრიბუტი class='value'
                    [attr^='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr იწყება value-თი	მაგალითად, სელექტორი $("a[class^='red']"), ამოირჩევს ყველა ელემენტს, რომელთა ატრიბუტი class იწყება red სტრიქონით, მაგალითად class='redStyle', class='redColor' და ა. შ.
                    [attr$='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr მთავრდება value-თი	მაგალითად, სელექტორი $("a[class$='Style']"), ამოირჩევს ყველა ელემენტს, რომელთა ატრიბუტი class ბოლოვდება style სტრიქონით, მაგალითად class='redStyle', class='greenStyle' და ა. შ.
                    [attr~='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr წარმოადგენს მნიშვნელობათა ჩამონათვალს, ერთმანეთისგან ადგილის გამოტოვებით და ერთ-ერთი მათგანი წარმოადგენს value-ს	მაგალითად, სელექტორი $("a[class~='redStyle']"), ამოირჩევს ყველა ელემენტს, რომელთა ატრიბუტი class შედგება რამდენიმე მნიშვნელობისაგან და ერთ-ერთი მათგანია redStyle, მაგალითად class='redStyle closed'.
                    [attr*='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr შეიცავს ქვესტრიქონს value	მაგალითად, სელექტორი $("a[class*='Style']"), ამოირჩევს ყველა ელემენტს, რომელთა ატრიბუტი class შეიცავს ქვესტრიქონს Style, მაგალითად class='redStyle1'.
                    [attr|='value']	ყველა ელემენტის ამორჩევა, რომელთა ატრიბუტი attr უდრის value-ს ან ან წარმოადგენს დეფისით გამოყოფილ მნიშვნელობათა სიას, რომელთაგან პირველი არის value.	 
                    სელექტორები კონტექსტში
                    
                    ზემოთ ჩვენ ვიყენებდით ასეთ სელექტორებს: $(სელექტორი). ასეთი გამოსახულება უყერებს DOM-ის მთლიან ხეს. მაგრამ ჩვენ შეგვიძლია შევზღუდოთ ძებნის არე  ძებნის კონტექსტის გამოყენებით. კონტექსტი წარმოადგენს სელექტორს, რომლის ფარგლებშიც უნდა მოხდეს ელემენტების ძებნა. მაგალითად, ვთქვათ გვაქვს ასეთი ვებგვერდი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                    <title>jQuery-ს სამყარო</title>
                    </head>
                    <body>
                    <div id="menu">
                        <p><a href="1.html" class="open">ბმული 1</a></p>
                        <p><a href="2.html" class="open">ბმული 2</a></p>
                    </div>
                    <p><a href="3.html" class="open">ბმული 3</a></p>
                     
                    <script src="jquery-3.3.1.min.js"></script>
                    <script type="text/javascript">
                    jQuery(document).ready(function(){
                     
                        $(".open", "div#menu").css('background-color', 'silver');
                    });
                    </script>
                    </body>
                    </html>
                    ვებგვერდზე სამი ბმულია, ყველა მათგანს აქვს ერთი და იგივე კლასი, მაგრამ ორი მათგანი მოთავსებულია div ელემენტში და სწორედ მათი ამორჩევა გვინდა. ამისათვის ვიყენებთ სელექტორს $(".open","div#menu") - სწორედ მეორე პარამეტრიწარმოადგენს ძებნის კონტექსტს. შედეგად მივიღებთ ასეთ სურათს:
                    
                    jQuery
                    
                    მთავარია, არ ავურიოთ ერთმანეთში სელექტორები კონტექსტში და რამდენიმე სელექტორი, მაგალითად $(".open, div#menu") - ეს სხვადასხვა გამოსახულებებია და სვადასხვა შედეგს იძლევა.`
                },
                {
                  title:"jQuery-ის ფილტრები",
                  data:`სელექტორების შესავსებად გამოიყენება ფილტრები. ფილტრები საშუალებას იძლევა სელექტორის შესაბამისი ელემენტები გავფილტროთ გარკვეული პრინციპით. ფილტრების გამოყენება ისეთივე მარტივია, როგორც სელექტორების.მაგალითად, შეგვიძლია მივიღოთ ელემენტები მხოლოდ ლუწი ინდექსით:

                  <!DOCTYPE html>
                <html>
                <head>
                    <titlejQuery-ის სამყარო</title>
                </head>
                <body>
                    <table>
                        <tr>
                            <td>სიტყვა</td>
                            <td>თარგმანი</td>
                        </tr>
                        <tr>
                            <td>Cabbage</td>
                            <td>კომბოსტო</td>
                        </tr>
                        <tr>
                            <td>Carrot</td>
                            <td>სტაფილო</td>
                        </tr>
                        <tr>
                            <td>Potato</td>
                            <td>კარტოფილი</td>
                        </tr>
                        <tr>
                            <td>Tomato</td>
                            <td>პომიდორი</td>
                        </tr>
                    </table>
                    <script src="jquery-3.3.1.min.js"></script>
                    <script type="text/javascript">
                        jQuery(document).ready(function () {
                            $("tr:even").css('background-color', 'silver');
                        });
                    </script>
                </body>
                </html>
                გვაქვს ცხრილი, რომელშიც გვინდა შევუცვალოთ ფერი მხოლოდ ლუწი ინდექსის მქონე სტრიქონებს. ამისთვის ვიყენებთ ფილტრს :even. ფილტრი იწერება სელექტორის შემდეგ $("tr:even").შედეგად ყველა ლუწი ინდექსის მქონე სტრიქონი გაფერადდება ვერცხლისფრად:
                
                jQuery
                
                რადგანაც ნუმერაცია იწყება ნულიდან, პირველი სტრიქონის ინდექსი იქნება ნული, მესამისა ორი და ასე შემდეგ. შესაბამისად რეალურად ცხრილის კენტი სტრიქონები გაფერადდება.
                
                შეგვიძლია გამოვყოთ შემდეგი საბაზისო ფილტრები:
                
                :eq(n) - ირჩევს ელემენტს, რომლის ინდექსია n (ნუმერაცია იწყება 0-დან)
                :even - ირჩევს ლუწ ნომრიან ელემენტებს
                :odd - ირჩევს კენტ ნომრიან ელემენტებს
                :first - ირჩევს პირველ ელემენტს
                :last - ირჩევს ბოლო ელემენტს
                :gt(n) - ირჩევს ელემენტებს, რომლებიც მეტია n-ზე
                :lt(n) - ირჩევს ელემენტებს, რომლებიც ნაკლებია n-ზე
                :header - ირჩევს სათაურებს (h1, h2, h3)
                :not(селектор) - ირჩევს ელემენტებს, რომლებიც არ შეესაბამება სელექტორს, რომელიც ეტითება ფრჩხილებში. მაგალითად, გამოსახულება $("tr:not(.even)") ირჩევს ცხრილის იმ სტრიქონებს, რომელთაც კლასის სახელი არ უდრის even-ს.
                არის სპეციალური ფილტრები - კონტენტის ფილტრები, რომლებიც საშუალებას იძლევა გავფილტროთ ელემენტები შიგთავსის მიხედვით:
                
                :contains('text') - აბრუნებს იმ ელემენტებს, რომლებიც შეიცავენ ტექსტს "text"
                :has('selector') - აბრუნებს იმ ელემენტებს, რომლებიც შეიცავენ ერთ შვილ ელემენტს მაინც, რომელიც შეესაბამება სელექტორს selector
                :empty - აბრუნებს იმ ელემენტებს, რომელთაც არ გააჩნიათ შვილი ელემენტები
                :first-child - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ პირველ შვილ ელემენტს თავისი მშობლებისთვის
                :last-child - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ ბოლო შვილ ელემენტს თავისი მშობლებისთვის
                :nth-child(n) - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ რიგით n ელემენტს თავისი მშობლებისთვის (ნუმერაცია იწყება 1-დან)
                :nth-child(even) - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ ლუწ ელემენტს თავისი მშობლებისთვის (ნუმერაცია იწყება 1-დან)
                :nth-child(odd) - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ კენტ ელემენტს თავისი მშობლებისთვის (ნუმერაცია იწყება 1-დან)
                :only-child - აბრუნებს იმ ელემენტებს, რომლებიც წარმოადგინენ ერთადერთ ელემენტს თავისი მშობლებისთვის
                :parent - აბრუნებს იმ ელემენტებს, რომლებიც შეიცავენ ერთ შვილ ელემენტს მაინც.
                ფილტრების მესამე ჯგუფი საშუალებას გვაძლევს ამოვირჩიოთ html-ის გარკვეული ელემენტები ან მათი ატრიბუტების მიხედვით:
                
                :button - აბრუნებს ყველა button ელემენტს და ელემენტებს input ტიპით button
                :checkbox - აბრუნებს ყველა checkbox ელემენტს
                :checked - აბრუნებს ყველა ჩართულ checkbox და რადიო radio ელემენტს
                :disabled - აბრუნებს ყველა ელემენტს, რომელიც არის არააქტიური (disabled)
                :enabled - აბრუნებს ყველა ელემენტს, რომელიც არის აქტიური (enabled)
                :file - აბრუნებს ყველა file ელემენტს (input type='file')
                :input - აბრუნებს ყველა input ელემენტს
                :hidden - აბრუნებს ყველა დამალულ ელემენტს
                :password - აბრუნებს ყველა password ელემენტს
                :radio - აბრუნებს ყველა radio ელემენტს
                :reset - აბრუნებს ყველა reset ელემენტს
                :selected - აბრუნებს ყველა მონიშნულ option ელემენტს 
                :submit - აბრუნებს ყველა  input ელემენტს ტიპით submit
                :text - აბრუნებს ყველა input ელემენტს ტიპით text
                :visible - აბრუნებს ყველა ხილულ ელემენტს
                შესაძლებელია რამდენიმე სელექტორის და ფილტრის კომბინაცია. მაგალითად, $('#results:odd:has('img')'). მოცემულ შემთხვევაში ჩვენ ვირჩევთ ყველა კენტ ელემენტს, რომლის id="results" და რომლებიც შეიცავენ img ელემენტებს, ანუ სურათებს.
                
                 `
                },
              {
                  title:"ამორჩეულ ელემენტებთან მუშაობა",
                  data:`სელექტორებისა და ფილტრების გამოყენება აბრუნებს ელემენტების ნაკრებს, რომელთაც გააჩნიათ სხვადასხვა მეთოდი და თვისება. ვინაიდან ელემენტების ნაკრები ამავდროულად წარმოადგენს მასივს, ჩვენ შეგვიძლია მივმართოთ მას, როგორც მასივს.

                  ამორჩეული ელემენტების რაოდენობა. თვისება length და მეთოდი size
                  
                  თვისება length აბრუნებს ამორჩეული ელემენტების რაოდენობას: var num=$("tr:nth-child(odd)").length;
                  
                  ალტერნატივას წარმოადგენს size() მეთოდის გამოყენება, რომელიც ასევე აბრუნებს ამორჩეული ელემენტების რაოდენობას: var num=$("tr:nth-child(odd)").size();
                  
                  ელემენტის მიღება
                  
                  რადგან სელექტორით ამორჩეული ელემენტთა ნაკრები წარმოადგენს მასივს, მისი ელემენტების მიღება შესაძლებელია ინდექსის მეშვეობით: var firstElement=$("tr:nth-child(odd)")[0];. მაგალითად:
                  
                  $(function () {
                      var array = $("tr:even");
                      for (var i = 0; i < array.length; i++) {
                          console.log(i.toString() + ". " + array[i].innerHTML);
                      }
                  });
                  ალტერნატივას წარმოადგენს get() მეთოდის გამოყენება: var firstElement=$("tr:nth-child(odd)").get(0);
                  
                  ფუნქცია eq
                  
                  ელემენტის მეღების კიდევ ერთ ხერხს წარმოადგენს eq() ფუნქციის გამოყენება. ეს ფუნქცია პარამეტრად იღებს ინდექსს და აბრუნებს ელემენტების ახალ ნაკრებს, რომელიც ერთი ელემენტისგან შედგება. მაგალითად:
                  
                  $(function(){
                      var array = $("tr:even");
                      array.eq(1).css('background-color', 'silver');
                      array.eq(-1).css('background-color', 'silver');
                  });
                  ასეთი მიდგომის უპირატესობა ისაა, რომ eq ფუნქციის რეზულტატისთვის შეგვიძლია გამოვიყენოთ jQuery-ის მეთოდები (მაგალითად, css სტილის მისაყენებლად, როგორც წინა მაგალითში). ამასთან, ფუნქციას შეიძლება გადაეცეს უარყოფითი პარამეტრი, ამ დროს ათვლა იწყება ბოლოდან.
                  
                  პირველი და ბოლო ელემენტის მიღება
                  
                  ხშირად არის საჭირო პირველი და ბოლო ელემენტის მიღება. ამისათვის გამოიყენება მეთოდები first დაlast:
                  
                  $(function () {
                      var array = $("tr:even");
                      var firstEl = array.first();
                      console.log("პირველი ელემენტი: " + firstEl.html());
                      var lastEl = array.last();
                      console.log("ბოლო ელემენტი: " + lastEl.html());
                  });
                  ამორჩეული ელემენტების გადარჩევა
                  
                  ჩვეულებრივი მასივის სახით გადარჩევის გარდა შესაძლებელია სპეციალური მეთოდის each გამოყენება:
                  
                  $(function () {
                      $("tr:even").each(function (index, elem) {
                          console.log(index + ". " + elem.innerHTML);
                      });
                  });
                  ელემენტის ინდექსი
                  
                  ელემენტის ინდექსის მისაღებად გამოიყენება მეთოდი index(ელემენტი), რომელსაც პარამეტრად გადაეცემა ელემენტი, რომლის ინდექსის გაგებაც გვსურს:
                  
                  $(function () {
                      var array = $("tr:even");
                      var firstEl = array.first();
                      var index = array.index(firstEl);
                      console.log(index); //გამოიტანს 0-ს
                  });
                  მეთოდს პარამეტრად ასევე შეიძლება გადაეცეს სელექტორი:
                  
                  $(function(){
                      var array = $("tr");
                      var index = array.index($("tr.tabhead"));
                      console.log(index);
                  });
                  სელექტორის მიღება
                  
                  selector მეთოდის მეშვეობით შესაძლებელია სელექტორის მიღება:
                  
                  $(function(){
                      var array = $("tr:even");
                      console.log(array.selector); //გამოიტანს tr:even
                  });
                  მეთოდი add და ახალი ელემენტების დამატება
                  
                  add მეთოდის მეშვეობით შესაძლებელია ახალი ელემენტების დამატება. მას გააჩნია სინტაქსის შემდეგი ვარიანტები:
                  
                  add(სელექტორი): "სელექტორის" შესაბამისი ელემენტების დამატება არსებულ ამორჩევაში;
                  add(სელექტორი, კონტექსტი): ელემენტების დამატება, ოღონდ ამ შემთხვევაში ელემენტების ძებნა ხდება კონტექსტის ჭრილში;
                  add(ელემენტი): კონკრეტული ელემენტის დამატება;
                  add(ელემენტების მასივი): ელემენტების მასივის დამატება;
                  add(html): ელემენტის დამატება, რომელიც მოცემულია html-ში. ამასთან ელემენტი ემატება მხოლოდ ამორჩეულ მასივში და არა ვებგვერდზე;
                  add(jQuery): jQuery-ის ფუნქციით მიღებული ობიექტის დამატება.
                  მაგალითად, ამოვირჩიეოთ ლუწი სტრიქონები ცხრილიდან და დავამატოთ მასში პირველი კენტი სტრიქონი:
                  
                  $(function(){
                      var array = $("tr:even").add("tr:odd:first");
                      //ეს გამოსახულება შემდეგის ეკვივალენტურია
                      // var array = $("tr:even, tr:odd:first");
                  });
                  add მეთოდის ნაცვლად შეგვეძლო გამოგვეყენებინა რამდენიმე სელექტორის ნაკრები, რაც მოგვცემდა იგივე შედეგს.`
              },
              {
                title:"ამორჩეული ელემენტების გაფილტვრა",
                data:`ადრე ვისაუბრეთ სელექტორების ფილტრების შესახებ, რომლებიც გვეხმარება უფრო ხარისხიან ამორჩევაში. JQuery-ში ასევე არსებობს სპეციალური მეთოდები, რომლებიც განკუთვნილია ფილტრაციისთვის და რომელთაც აქვთ იგივე ეფექტი, რაც სელექტორების ფილტრებს.

                მეთოდი filter
                
                მეთოდი filter(პირობა) პარამეტრად იღებს ფილტრის პირობას. და თუ ელემენტები არ აკმაყოფილებენ პირობას, ისინი გამოირიცხებიან არჩევიდან. ამ მეთოდს გააჩნია გამოყენების შემდეგი ვარიანტები:
                
                filter(სელექტორი): თუ ობიექტი არ აკმაყოფილებს სელექტორს, ის გამოირიცხება;
                filter(ელემენტი): თუ ობიექტი არ წარმოადგენს html-ის შესაბამის ელემენტს, ის გამოირიცხება;
                filter(jQuery): თუ ობიექტი არ წარმოადგენს jQuery-ის შესაბამის ობიექტს, ის გამოირიცხება;
                filter(ფუნქცია): ყოველი ელემენტისთვის გამოიძახება ფუნქცია და თუ პასუხი არის false, ის ელემენტი გამოირიცხება;
                მაგალითად, ავირჩიოთ ელემენტები, რომელთა ატრიბუტი class="header", რომლებიც ასევე წარმოადგენენ ცხრილის სტრიქონებს:
                
                $(function(){
                    //ფილტრაცია სელექტორით
                    var array = $(".header").filter("tr");
                    array.css('background-color', 'silver');
                    
                    // ფილტრაცია html ელემენტით
                    var elem = document.getElementsByTagName("tr")[0];
                    var array1 = $(".header").filter(elem);
                    array1.css('background-color', 'silver');
                });
                ეს ვარიანტი წარმოადგენს $("tr.header") გამოსახულების ანალოგს, ანუ იგივე შედეგის მიღწევა შესაძლებელია სელექტორების კომბინაციით.
                
                ახლა ვნახოთ ფუნქციის გამოყენება:
                
                $(function(){
                    var array = $("tr").filter(function(){
                        if($(this).hasClass("header")) { return true;}
                        else {return false;}
                    });
                    array.css('background-color', 'silver');
                });
                ფუნქცია გამოიძახება თითოეული ელემენტისთვის, ხოლო მიმდინარე ელემენტს ვიღებთ გამოსახულებით $(this). შემდეგ hasClass("header") მეთოდით ვგებულობთ, გააჩნია თუ არა მიმდინარე ელემენტს ატრიბუტი header.
                
                მეთოდი not
                
                not მეთოდი მუშაობს filter მეთოდის საპირისპიროდ. იგი გამორიცხავს იმ ელემენტებს, რომლებიც აკმაყოფილებენ პირობას. ამ მეთოდს გააჩნია გამოყენების შემდეგი ვარიანტები:
                
                not(სელექტორი): თუ ობიექტი აკმაყოფილებს სელექტორს, ის გამოირიცხება;
                not(ელემენტი): თუ ობიექტი წარმოადგენს html-ის შესაბამის ელემენტს, ის გამოირიცხება;
                not(jQuery): თუ ობიექტი წარმოადგენს jQuery-ის შესაბამის ობიექტს, ის გამოირიცხება;
                not(ფუნქცია): ყოველი ელემენტისთვის გამოიძახება ფუნქცია და თუ პასუხი არის true, ის ელემენტი გამოირიცხება;
                მაგალითად, შეგვიძლია წინა მაგალითში filter მეთოდი შევცვალოთ not მეთოდით და მივიღებთ საპირისპირო შედეგს:
                
                $(function(){
                    var array = $("tr").not(function(){
                        if($(this).hasClass("header")) { return true;}
                        else {return false;}
                    });
                    array.css('background-color', 'silver');
                });
                მეთოდი slice
                
                მეტოდი slice(begin,end) გამორიცხავს არჩევიდან იმ ელემენტებს, რომლებიც არ ხვდებიან begin და end ინდექსებით განსაზღვრულ დიაპაზონში. ინდექსაცია იწყება 0-დან. უარყოფითი ინდექსები ნიშნავს, რომ ათვლა იწყება ბოლოდან. არააუცილებელი end პარამეტრი გვიჩვენებს იმ პოზიციას, რომლიდანაც არ მოხდება ელემენტების არჩევა. თუ end პარამეტრი არაა მითითებული, ელემენტების არჩევა მოხდება ბოლომდე. მაგალითად:
                
                $(function(){
                    var array = $("tr").slice(1,4);
                    array.css('background-color', 'silver');
                });
                მოცემულ შემთხვევაში არჩეული იქნება სამი ელემენტი ინდექსებით (1,2,3). 
                
                მეორე მაგალითი განვიხილოთ end პარამეტრის გარეშე:
                
                $(function(){
                    var array = $("tr").slice(4);
                    array.css('background-color', 'silver');
                });
                ამ შემთხვევაში აირჩევა ყველა ელემენტი, დაწყებული 4-დან.
                
                მეთოდი has
                
                მეთოდი has ამოწმებს ობიექტს ჩასმული ელემენტის არსებობაზე. თუ ობიექტს გააჩნია ჩასმული ელემენტები, ის რჩება ამორჩევაში. არის მეთოდის გამოძახების ორი ვაარიანტი:
                
                has(სელექტორი): თუ ობიექტი შეიცავს სელექტორის შესაბამის ელემენტებს, რჩება ამორჩევაში
                has(ელემენტი): თუ ობიექტი შეიცავს მოცემულ html ელემენტებს, რჩება ამორჩევაში
                მაგალითად, ვთქვათ, გვაქვს ვებგვერდი სიებით.და გვინდა გამოვყოთ ელემენტი, რომელსაც გააჩნია ჩასმული სია:
                
                <ul>
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul>
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3</li>
                </ul>
                შეგვიძლია გამოვიყენოთ შემდეგი გამოსახულება: $('li').has('ul').css('background-color', 'silver');
                
                ამორჩევის გარდაქმნა და მეთოდი map
                
                მეთოდი map(callback) განკუთვნილია ამორჩევის გარდასაქმნელად ფუნქციის მეშვეობით, რომელიც გადაეცემა callback პარამეტრში. ეს ფუნქცია ახდენს ელემენტების ნაკრების გადარჩევას და აბრუნებს ახალ ნაკრებს. ვნახოთ მაგალითი სიის საფუძველზე:
                
                <ul>
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul>
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3</li>
                </ul>
                ახლა ამოვარციოთ მხოლოდ ის ელემენტები, რომლებიც შეიცავენ ჩასმულ სიებს:
                
                $(function(){
                 
                 var array = $('li').map(function(index,elem){
                     return $(elem).children()[0];
                 });
                 
                 array.each(function(index, elem){
                     console.log(elem.innerHTML);
                 });
                 array.css('background-color', 'silver');
                });
                ფუნქცია, რომელიც გადაეცემა მეთოდს map, გადაუვლის ამორჩევის ყველა ელემენტს და ღებულობს ორ პარამეტრს:  index - მიმდინარე ელემენტის ინდექსი და elem - თვითონ ეს ელემენტი. ამ ელემენტზე შესაძლებელია გარკვეული მანიპულაციების ჩატარება და გარკვევა, უნდა მოხვდეს საბოლოო ამორჩევაში თუ არა. 
                
                მოცემულ მაგალითში ელემენტი გადაეცემა jQuery-ს ფუნქციას, სადაც ვიღებთ ელემენტის ჩასმულ სიას $(elem).children()[0] (მეთოდი children აბრუნებს ელემენტის ჩასმულ ანუ შვილ ელემენტებს). მიღებულ მასივზე შესაძლებელია ნებისმიერი მოქმედების შესრულება.
                
                მეთოდი is
                
                მეთოდი is(პირობა) განსაზღვრავს, არის თუ არა ამორჩევაში ელემენტები, რომლებიჩ შეესაბამება ფრჩხილებში მოთავსებულ პირობას. პირობის მიხედვით ამ მეთოდმა შეიძლება მიიღოს შემდეგი სახე:
                is(სელექტორი): ამოწმებს, შეესაბამება თუ არა ამორჩევის ერთი ელემენტი მაინც სელექტორს
                is(ელემენტი): ამოწმებს, შეიცავს თუ არა ამორჩევა მოცემულ html ელემენტს
                is(jQuery): ამოწმებს, შეიცავს თუ არა ამორჩევა jQuery-ს შესაბამის ელემენტს
                is(ფუნქცია): მოცემული html ელემენტის შესაბამისი ობიექტების ძებნა
                მეთოდი აბრუნებს true-ს ან false-ს. მაგალითად:
                
                <ul class="menu">
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul class="submenu">
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3</li>
                </ul>
                გამოვიყენოთ მეთოდი is:
                
                var lists = $('ul');
                if(lists.is('.submenu')){
                    lists.css('background-color', 'silver');
                }
                ვინაიდან სიის ერთ-ერთი  ელემენტი შეიცავს ქვესიას კლასით "submenu", მეთოდი is დააბრუნებს true-ს და მთელი სია გაფერადდება.`
            },
            {
                title:"ძებნა ამორჩევაში",
                data:`ამორჩევაში ძებნისთვის განკუთვნილია მეთოდი find.მას გააჩნია გამოყენების შემდეგი ვარიანტები:

                find(სელექტორი): ამორჩევაში იმ ობიექტების ძებნა, რომლებიც შეესაბამებიან სელექტორს
                find(ელემენტი): ამორჩევაში იმ ობიექტების ძებნა, რომლებიც შეესაბამებიან მოცემულ html ელემენტს
                find(jQuery): ამორჩევაში იმ ობიექტების ძებნა, რომლებიც შეესაბამებიან jQuery-ს ობიექტებს
                მეთოდი find აბრუნებს ახალ ამორჩევას. მაგალითად:
                
                <ul class="menu">
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul class="submenu">
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3
                        <ul class="submenu">
                            <li>ქვეპუნქტი 3.1</li>
                            <li>ქვეპუნქტი 3.2</li>
                        </ul>
                    </li>
                </ul> 
                ახლა რიგ-რიგობით მოვახდინოთ ძებნა სელექტორით, ელემენტით და jQuery-ის ობიექტით:
                
                $(function(){
                    // ძებნა სელექტორით
                    var array0 = $('ul').find('.submenu');
                    array0.css('background-color', 'silver');
                    
                    // ძებნა ელემენტით
                    // ვიღებთ ამორჩევის პირველ ელემენტს
                    var elem = $('ul.submenu')[0];
                    var array1= $('ul').find(elem);
                    array1.css('background-color', 'gray');
                    
                    // jQuery-ს ობიექტის ძებნა
                    var jQueryObject = $('ul.submenu');
                    var array2= $('ul').find(jQueryObject);
                    array2.css('color', 'blue');
                });`
            },
            {
                title:"ნავიგაცია ვებგვერდზე",
                data:`გარდა ამორჩევისა და ფილტრაციისა jQuery გვთავაზობს მეთოდებს ამორჩეული ობიექტების გადარჩევისა და მათგან საჭირო ობიექტების ამოსარჩევად.

                შვილი ელემენტების მიღება. მეთოდი children
                
                შვილი ელემენტების მისაღებად შეგვიძლია გამოვიყენოთ მეთოდი children([სელექტორი]):
                
                <ul class="menu">
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul class="submenu">
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3
                        <ul>
                            <li>ქვეპუნქტი 3.1</li>
                            <li>ქვეპუნქტი 3.2</li>
                        </ul>
                    </li>
                </ul>
                ახლა მივიღოთ შვილი ელემენტები როგორც სელექტორით, ისე სელექტორის გარეშე:
                
                // შვილი ელემენტები სელექტორის გარეშე
                var lists = $('li').children('');
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                 
                //შვილი ელემენტები სელექტორის მიხედვით
                var lists2 = $('li').children('.submenu');
                lists2.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                პირველ შემთხვევაში მეთოდი children გამოიძახება სელექტორის გარეშე, ამიტომ შედეგი იქნება ყველა შვილი ელემენტი. მეორე შემთხვევაში გამოიძახება სელექტორით, ამიტომ შედეგად მივიღებთ მხოლოდ იმ შვილ ელემენტებს, რომელთა მშობელს აქვს კლასი submenu.
                
                მეთოდი closest
                
                მეთოდი closest(პირობა) აბრუნებს მოცემული ელემენტის უახლოეს მშობელს. აქვს გამოყენების შემდეგი ვარიანტები:
                
                closest(სელექტორი[, კონტექსტი]): აბრუნებს უახლოეს მშობელს სელექტორის შესაბამისად. არააუცილებელი პარამეტრის სახით შეიძლება გადაეცეს კონტექსტი, რომლის ფარგლებშიც მოხდება ძებნა
                closest(ელემენტი): აბრუნებს მოცემული html ელემენტის შესაბამის უახლოეს მშობელს
                closest(jQuery): აბრუნებს უახლოეს მშობელს, რომელიც შეესაბამება jQuery-ის შესაბამის ობიექტს
                ვიპოვოთ უახლოესი მშობელი li ელემენტის:
                
                <ul class="menu">
                    <li>პუნქტი 1</li>
                    <li>პუნქტი 2
                        <ul class="submenu">
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li>პუნქტი 3
                        <ul>
                            <li>ქვეპუნქტი 3.1</li>
                            <li>ქვეპუნქტი 3.2</li>
                        </ul>
                    </li>
                </ul>
                 
                <script type="text/javascript">
                $(function(){
                    var list = $('li').closest('ul.submenu');
                    list.each(function(index, elem){
                        console.log(elem.innerHTML);
                    });
                });
                </script>
                შედეგად მივიღებთ პირველ ჩასმულ სიას, ვინაიდან მას აქვს კლასი submenu.
                
                მეთოდი next და მომდევნო ელემენტები
                
                რიგით მომდევნო ელემენტის მისაღებად გამოიყენება მეთოდი next(სელექტორი). ეს მეთოდი არააუცილებელ პარამეტრად იღებს სელექტორს და აბრუნებს ელემენტს, რომელიც არის მიმდინარე ელემენტის მომდევნო და იერარქიაში არის იმავე დონეზე. მნიშვნელოვანია ვიცოდეთ, რომ ეს მეთოდი მუშაობს მხოლოდ ერთი დონის ელემენტებზე, ანუ სიბლინგებზე. სიბლინგები ისეთი ელემენტებია, რომელთაც აქვთ საერთო მშობელი და იმყოფებიან ერთ დონეზე. მაგალითად:
                
                <h2 class="header">სათაური</h2>
                <ul class="menu">
                    <li class="punkti1">პუნქტი 1</li>
                    <li class="punkti2">პუნქტი 2
                        <ul class="submenu">
                            <li>ქვეპუნქტი 2.1</li>
                            <li>ქვეპუნქტი 2.2</li>
                        </ul>
                    </li>
                    <li class="punkti3">პუნქტი 3</li>
                </ul>
                მოცემულ შემთხვევაში სიბილინგებს წარმოადგენს h2 სათაური და მთლიანი სია კლასით menu. თუ ვნახავთ სიის შიგნით, სიბლინგებია სიის ელემენტები კლასით punkti1,punkti2 და punkti3. ამასთან, ვინაიდან ეს ელემენტები იმყოფებიან h2 ელემენტთან მიმართებაში სხვა დონეზე, ისინი მისი სიბლინგები არ იქნებიან.
                
                გამოვიყენოთ მეთოდი next და მივიღოთ სიის პირველი ელემენტის მომდევნო ელემენტი:
                
                $(function () {
                    var lists = $('li.punkti1').next();
                    lists.each(function (index, elem) {
                        console.log(elem.innerHTML);
                    });
                    lists.css('color','red');
                });
                მოცემულ შემთხვევაში მეთოდი next დააბრუნებს ელემენტს კლასით punkti2, რადგან ის არის li ელემენტის კლასით punkti1 მომდევნო ელემენტი.
                
                ჩვენ ასევე შეგვიძლია მივიღოთ იმავე დონის ყველა მომდევნო ელემენტი მეთოდით nextAll(სელექტორი). ეს მეთოდიც არააუცილებელ პარამეტრად იღებს სელექტორს:
                
                // სელექტორის გარეშე
                var lists = $('li.punkti1').nextAll();
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                lists.css('background-color','silver');
                });
                 
                // სელექტორით
                var lists1 = $('li.punkti1').nextAll('.punkti3');
                lists1.each(function (index, elem) {
                    console.log(elem.innerHTML);
                    lists1.css('color','red');
                });
                ასევე შეგვიძლია გამოვიყენოთ მეთოდი nextUntil(სელექტორი). თუ მას გამოვიყენებთ სელექტორის გარეშე, მივიღებთ იგივეს, რასაც nextAll მეთოდისას სელექტორის გარეშე. მაგრამ თუ გამოვიყენებთ სელექტორით, დააბრუნებს იმავე დონის ყველა ელემენტს სელექტორის შესაბამის ელემენტამდე. მაგალითად:
                
                var lists = $('li.punkti1').nextUntil('li.punkti3');
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                წინა ელემენტები. მეთოდი prev
                
                მეთოდების ჯგუფს next/nextAll/nextUntill ჰგავს მეთოდების ჯგუფი prev/prevAll/prevUntill. prev მეთოდს გააჩნია იმავე დონის ელემენტებზე მსგავსი ქმედება, ოღონდ აბრუნებს მიმდინარეს წინა ელემენტებს. გამოვიყენოთ წინა მაგალითებში მოცემული ვებგვერდი და მეთოდი prev:
                
                var lists = $('li.punkti3').prev();
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                მეთოდი prev ასევე იღებს პარამეტრად სელექტორს, რომელიც განსაზღვრავს ამოსარჩევი ელემენტების დიაპაზონს.
                
                nextAll მეთოდის მსგავსად შეგვიძლია გამოვიყენოთ მეთოდი prevAll([სელექტორი]):
                
                // სელექტორის გარეშე
                var lists = $('li.punkti3').prevAll();
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                 
                // სელექტორით
                var lists1 = $('li.punkti3').prevAll('.punkti1');
                lists1.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                nextUntill მეთოდის მსგავსად შეგვიძლია გამოვიყენოთ მეთოდი prevUntill([სელექტორი]):
                
                var lists = $('li.punkt3i').prevUntil('li.punkt1i');
                lists.each(function (index, elem) {
                    console.log(elem.innerHTML);
                });
                ერთი დონის ყველა ელემენტის (სიბლინგების) მიღება
                
                მეთოდი siblings([სელექტორი]) წარმოადგენს nextAll და prevAll მეთოდების კომბინაციას და აბრუნებს მოცემული ელემენტის ყველა სიბლინგს:
                
                var lists = $('.punkt2').siblings();
                მეთოდი parent/parents და მშობლების მიღება
                
                მეთოდი parent([სელექტორი]) აბრუნებს მოცემული ელემენტის უშუალო მშობლებს. მაგალითად, ავიღოთ ვებგვერდი სიებით:
                
                    <body>
                        <ul class="menu">
                            <li class="punkti1">პუნქტი 1</li>
                            <li class="punkti2">პუნქტი 2
                                <ul class="submenu">
                                    <li>ქვეპუნქტი 2.1</li>
                                    <li>ქვეპუნქტი 2.2</li>
                                </ul>
                            </li>
                            <li class="punkti3">პუნქტი 3</li>
                        </ul>
                    </body>
                მოცემულ შემთხვევაში menu სიისთვის უშუალო მშობელი იქნება ელემენტი body. ხოლო li ელემენტებისთვის უშუალო მშობელი იქნება ელემენტი ul:
                
                var lists = $('.menu').parent();
                სელექტორის მეშვეობით შესაძლებელია ამორჩევის დაკონკრეტება სელექტორთან შესაბამისობაზე.
                
                მსგავსი ქმედებით ხასიათდება მეთოდი parents([სელექტორი]). ოღონდ ის აბრუნებს არა მხოლოდ უშუალო მშობლებს, არამედ ყველა მშობელს ყველაზე მაღალ წერტილამდე - html კვანძამდე. მაგალითად, მივიღოთ ყველა მშობელი ელემენტი პირველი სიისთვის:
                
                $('.punkti1').parents();
                ეს გამოსახულება დააბრუნებს შემდეგ ჯაჭვს:  ul->body->html. ჩვენ შეგვიძლია შემოვსაზღვროთ მშობლები სელექტორის გამოყენებით ან სხვა მეთოდის - parentsUntill([სელექტორი]) გამოყენებით. ეს მეთოდი წყვეტს აღმასვლას მშობლების ხეზე სელექტორის შესაბამისი ელემენტით. მაგალითად, თუ არ გვინდა რომ მშობლები გასცდეს ელემენტს body:
                
                $('.punkti1').parentsUntil('body');`
            },
        ]
    },
    {
        title:"თავი 3. ელემენტებით მანიპულაცია jQuery-ში",
        content:[
            {
                title:"ელემენტების ატრიბუტები და თვისებები",
                data:`jQuery-ის ბიბლიოთეკა შეიცავს ინსტრუმენტებს ელემენტების თვისებებითა და ატრიბუტებით მანიპულაციისთვის. მაგრამ სანამ გადავალთ უშუალოდ jQuery-ის მეთოდების განხილვაზე, აღვნიშნოთ, რით განსხვავდება ერთმანეთისგან ატრიბუტები და თვისებები.

                ატრიბუტები წარმოადგენენ html ელემენტის მარკირების ელემენტებს, როგორიცაა id, class, style და ა. შ. თვისებები კი წარმოადგენენ javascript-ის ობიექტების ელემენტებს. მიუხედავად ასეთი განსხვავებისა, მათ გააჩნიათ ურთიერთმიმართებაც. მაგალითად, ატრიბუტი id შეესაბამება თვისებას id. მაგალითად, ვთქვათ გვაქვს ბმული:
                
                <a href="1.html" id="link1">ბმული</a>
                 
                <script type="text/javascript">
                    $(function () {
                        var ahref = document.getElementsByTagName('a')[0]
                        console.log(ahref.id); // გამოიტანს link1
                    });
                </script>
                სკრიპტის შესრულება კონსოლში გამოიტანს id ატრიბუტის მნიშვნელობას. ამასთან, ყველა ატრიბუტს არ შეესაბამება იგივე დასახელების თვისება. მაგალითად, ატრიბუტს class შეესაბამება თვისება className.
                
                თვისებების შეცვლა
                
                თვისებებთან სამუშაოდ jQuery-ში გამოიყენება მეთოდი prop(). თვისების მნიშვნელობის მისაღებად ამ მეთოდს უნდა გადავცეთ თვისების სახელი. მაგალითად, ასეთი ფორმით შეგვიძლია მივიღოთ ვებგვერდის ყველა ბმულის მისამართი:
                
                $('a').each(function (index, elem) {
                    console.log($(elem).prop('href'));
                });
                თვისების მნიშვნელობის შესაცვლელად მეორე პარამეტრად უნდა გადავცეთ ახალი მნიშვნელობა:
                
                $('a').first().prop('href','33.html');
                ამის შემდეგ პირველ ბმულს ვებგვერდზე ექნება ახალი მისამართი: 33.html.
                
                თვისების წაშლა
                
                თვისების წასაშლელად შეგვიძლია გამოვიყენოთ მეთოდი removeProp(თვისების_სახელი):
                
                $('a').first().removeProp('href');
                ამის შემდეგ თვისებას მიენიჭება მნიშვნელობა undefined, რომელიც მიუთითბს, რომ თვისება არაა განსაზღვრული.
                
                მუშაობა ატრიბუტებთან
                
                ატრიბუტებთან მუშაობა მეტწილად წააგავს თვისებებთან მუშაობას. მაგალითად, ელემენტის ატრიბუტის მისაღებად უნდა გამოვიყენოთ მეთოდი attr(ატრიბუტის_სახელი):
                
                $('a').each(function (index, elem) {
                    console.log($(elem).attr('href'));
                });
                ამ მეთოდის მუშაობა ანალოგიურია მეთოდისა, რომელიც იყო მაგალითად მოყვანილი prop მეთოდის განხილვისას: ვებგვერდის ყველა ბმულის მისამართის გამოტანა კონსოლზე.
                
                ატრიბუტის მნიშვნელობის შესაცვლელად მეთოდს მეორე პარამეტრად უნდა გადავცეთ ახალი მნიშვნელობა:
                
                $('a').first().attr('href','33.html');
                ატრიბუტის წასაშლელად უნდა გამოვიყენოთ მეთოდი removeAttr(ატრიბუტის_სახელი):
                
                $('a').first().removeAttr('href');
                ყურადღება უნდა მივაქციოთ იმ ფაქტს, რომ თუ თვისების წაშლისას removeProp მეთოდით თვისების შესაბამისი ატრიბუტი რჩებოდა, მაგრამ მას მიენიჭებოდა განუსაზღვრელი მნიშვნელობა, removeAttr მეთოდით ატრიბუტის წაშლისას ის საერთოდ იშლება ვებგვერდის მარკირებიდან.
                
                მომხმარებლის ატრიბუტები html5-ში
                
                HTML5-ში დაემატა ახალი ფუქციონალი, როგორიცაა მომხმარებლის ატრიბუტები. მისი არსი მდგომარეობს იმაში, რომ შეგვიძლია ელემენტზე გამოვიყენოთ დამატებითი ატრიბუტები, რომლებიც ინახავენ გარკვეულ ინფორმაციას. ასეთი ატრიბუტები იწყება პრეფიქსით data-, რასაც მოსდევს საკუთრივ ატრიბუტის დასახელება და მისი მნიშვნელობა. მაგალითად, დავამატოთ მომხმარებლის ატრიბუტი data-year, რომლის მნიშვნელობაც იქნება წელი: 
                
                <ul data-year="2010">
                    <li>Java</li>
                    <li>C/C++</li>
                    <li>PHP</li>
                </ul>
                მომხმარებლის ატრიბუტებთან სამუშაოდ გამოიყენება მეთოდი data. მას აქვს გამოყენების შემდეგი ვარიანტები:
                
                data('ატრიბუტის სახელი'): პარამეტრად გადაეცემა ატრიბუტის სახელი data- პრეფიქსის გარეშე. მისი მეშვეობით მივიღებთ ატრიბუტის მნიშვნელობას წინა მაგალითიდან:
                
                console.log($('ul').data('year'));
                data(): აბრუნებს javascript-ის ობიექტს, რომელიც შეიცავს ატრიბუტებს გასაღები-მნიშვნელობა წყვილის სახით. 
                
                ვთქვათ, გვაქვს ელემენტი ორი სხვადასხვა მომხმარებლის ატრიბუტით:
                
                <ul data-year="2010" data-description="lang">
                მეთოდი data() დააბრუნებს ობიექტს {description:lang, year:2010}. თითოეული ატრიბუტის მნიშვნელობის მისაღებად უნდა დავწეროთ:
                
                console.log($('ul').data().year);
                data('ატრიბუტი', 'ახალი მნიშვნელობა'): ანიჭებს ატრიბუტს ახალ მნიშვნელობას, რომელიც გადაეცემა მეორე პარამეტრად:
                
                $('ul').first().data('year', '2012');
                ახალი მნიშვნელობა შეიძლება იყოს javascript-ის ობიექტი, ხოლო ატრიბუტის მნიშვნელობა შეიძლება იყოს მთლიანად ეს ობიექტი:
                
                $('ul').first().data('lang', { rate: "tiobe", year: 2012 });
                თუ გვინდა ატრიბუტის წაშლა, უნდა გამოვიყენოთ მეთოდი removeData('ატრიბუტის სახელი'):
                
                $('ul').removeData('year');`
            },
            {
              title:"CSS სტილების შეცვლა",
              data:`სტილის მიღება

              სტილებთან სამუშაოდ გამოიყენება მეთოდი css(). საწირო თვისების მისაღებად პარამეტრად უნდა გადავცეთ ამ თვისების სახელი:
              
              console.log($('body').css('font-size'));
              
              სტილის შეცვლა
              
              სტილის შესაცვლელად იგივე მეთოდს მეორე პარამეტრად უნდა გადავცეთ ახალი მნიშვნელობა:
              
              $('a').css('font-weight', 'bold');
              
              ასევე შესაძლებელია სტილის შეცვლა ფუნქციის მეშვეობით, რომელიც გადაეცემა მეთოდს css() მეორე პარამეტრად. მაგალითად, შევცვალოთ ბმულების შრიფტის ფერი:
              
              $(function () {
                  $('a').css('color', function (index, oldValue) {
                      if (oldValue == 'rgb(0, 0, 238)') { return 'red'; }
                      else { return 'green'; }
                  });
              });
              იმის მიხედვით, თუ რა იყო წინა მნიშვნელობა - oldValue, ფუნქცია აბრუნებს სხვადასხვა მნიშვნელობას და ანიჭებს ამორჩევის სხვადასხვა ელემენტს.
              
              ასევე შესაძლებელია css() მეთოდს გადავცეთ თვისებების მასივი მისანიჭებლად:
              
              $('a').css({'color':'red', 'cursor':'pointer', 'font-size': '14px'});
              აქ პარამეტრად გადაეცემა javascript-ის ობიექტი, რომელშიც გადაეცემა თვისებები ახალი მნიშვნელობების მისანიჭებლად.
              
              ზოგჯერ საჭიროა თვისების წინა მნიშვნელობის გაზრდა ან შემცირება გარკვეული მნიშვნელობით. ამ შემთხვევაში შეგვიძლია დავწეროთ შემდეგნაირად:
              
              $('a').css({'font-size': '-=1', 'margin-left': '+=10'});
              სიგანის და სიმაღლის მინიჭება
              
              გარდა იმისა, რომ შეგვიძლია გამოვიყენოთ თვისებები width და height css მეთოდის მეშვეობით, ასევე შეგვიძლია გამოვიყენოთ მეთოდები width() და height():
              
              var div = $('div').first();
              var newWidth = div.width() + 150;
              div.width(newWidth);
              var newHeight = div.height() + 50;
              div.height(newHeight);`
          },
          {
            title:"კლასების გამოყენება jQuery-ში",
            data:`კლასის დამატება

            ელემენტისთვის კლასისი დასამატებლად გამოიყენება მეთოდი addClass('კლასის_სახელი'), რომელსაც პარამეტრად გადაეცემა კლასის სახელი. რადგანაც ერთ ელემენტს შეიძლება ჰქონდეს ბევრი კლასი, მეთოდსაც შეიძლება გადავცეთ ერთმანითისგან ცარიელი ადგილით გამოყოფილი რამდენიმე კლასის სახელი:
            
            $('ul').first().addClass("redStyle");
            // ორი კლასის დამატება
            $('div').first().addClass("black visible");
             კლასის წაშლა
            
            კლასის წასაშლელად გამოიყენება მეთოდი removeClass('კლასის_სახელი'). მასაც შეიძლება გადავცეთ ერთი ან რამდენიმე კლასის სახელი. თუ ელემენტს გააჩნია ასეთი კლასი ან კლასები, ის წაიშლება:
            
            $('div').first().removeClass("black visible");
            კლასების შემოწმება. მეთოდი hasClass
            
            ხშირად ხდება საჭირო შევამოწმოთ, აქვს ელემენტს ესა თუ ის კლასი თუ არა, განსაკუთრებით იმ შემთხვევაში, თუ ეს კლასები ემატება დინამიურად. ასეთ დროს შეგვიძლია გამოვიყენოთ მეთოდი hasClass('კლასის_სახელი'), რომელიც აბრუნებს true-ს ან false-ს იმის მიხედვით, აქვს ელემენტს პარამეტრად გადაცემული კლასი თუ არა:
            
            if ($('ul').first().hasClass("redStyle")) {
                console.log('Список содержит класс redStyle');
            }
            else {
                console.log('Список не содержит класс redStyle');
            }
            კლასის გადართვა
            
            კლასის გადართვა ხორციელდება toggleClass('კლასის_სახელი') მეთოდის მეშვეობით. თუ ელემენტს გააჩნია კლასი, ეს მეთოდი მას წაშლის, ხოლო თუ არ გააჩნია - მიანიჭებს. მაგალითად, გავაკეთოთ გადართვის ღილაკი:
            
            <!DOCTYPE html>
            <html>
            <head>
                <title> jQuery-ის სამყარო </title>
                <script src="jquery-3.3.1.min.js"></script>
             
                <style>
                    .redStyle {
                        color: red;
                    }
                </style>
            </head>
            <button>კლასის გადამრთველი</button>
            <script type="text/javascript">
             
                $(function () {
                    $('button').click(function () {
                        $(this).toggleClass("redStyle");
                    });
                });
             
            </script>
            </body>
            </html>
            ღილაკზე არის მიბმული მოვლენა click, სადაც ამ მოვლენის დამუშავება ხდება ფუნქციით, რომელიც კლასს მიანიჭებს და წაშლის იმის მიხედვით, ჰქონდა მანამდე კლასი თუ არა.`
        },
        {
            title:"ელემენტის შიგთავსი",
            data:`jQuery გვაძლევს მოხერხებულ ინსტრუმენტებს ელემენტის შიგთავსთან სამუშაოდ html() და text() მეთოდების სახით.

            html-თან მუშაობა
            
            ელემენტის html კოდის მისაღებად ან შესაცვლელად გამოიყენება მეთოდი html(). მას აქვს გამოყენების სემდეგი ვარიანტები:
            
            html(): აბრუნებს ამორჩევის პირველი ელემენტის html კოდს
            html('ახალი_კოდი'): ცვლის ელემენტის html კოდს პარამეტრად მითითებულით
            html(ფუნქცია): html კოდის შეცვლა ფუნქცვიის მეშვეობით
            მივიღოთ და შევცვალოთ ელემენტის html კოდი:
            
            // სიის ელემენტის html კოდის მიღება და გამოტანა კონსოლში
            var html = $('li.punkit2').html();
            console.log(html);
             
            // სიის ელემენტისთვის ახალი html კოდის მინიჭება
            $('li.punkti1').html("პუნქტი 1 <ul class='submenu'><li>პუნქტი 1.1</li></ul>")   
            ახალი html კოდი მტლიანად შეცვლის ძველს. თუ გვინდა უბრალოდ არსებულს დავამატოთ, მაშინ ძველ კოდს უნდა მივუმატოთ ახალი:
            
            var oldHtml = $('div.header').html();
            $('div.header').html(oldHtml + "<p> ახალი პარაგრაფი</p>")
            ასევე შეგვიძლია გამოვიყენოთ ფუნქცია, რომელიც გადაურბენს ყველა ამორჩეულ ელემენტს და დააბრუნებს ელემენტის ინდექსს და html კოდს. ფუნქციის მეშვეობით შეგვიძლია გადავწეროთ წინა მაგალითი შემდეგნაირად:
            
            $('div.header').html(function (index, oldValue) {
                console.log("ძველი კოდი: " + oldValue);
                return oldValue + "<p> ახალი პარაგრაფი</p>";
            });
            ელემენტის ტექსტთან მუშაობა
            
            ელემენტის ტექსტთან სამუშაოდ გვაქვს მეთოდი text(), რომლის მუშაობა მეტწილად ჰგავს html() მეთოდის მუშაობას იმ განსხვავებით, რომ იგი მუშაობს არა html კოდთან, არამედ ელემენტის ტექსტთან:
            
            text(): აბრუნებს ამორჩევის პირველი ელემენტის ტექსტს
            text('ახალი_ტექსტი'): ელემენტის ტექსტს ცვლის პარამეტრის სახით გადაცემული ტექსტით
            text(ფუნქცია): ტექსტის დამუშავება ხდება პარამეტრად გადაცემული ფუნქციით
            $('div.header').text("სტატიის სათაური");
             
            // ფუნქციის გამოყენება
            $('div').first().text(function (index, oldValue) {
                console.log("ძველი ტექსტი: " + oldValue);
                return "ახალი ტექსტი";
            });
            თუმცა text() მეთოდის გამოყენებისას საჭიროა სიფრთხილის დაცვა. თუ ელემენტს გააჩნია html კოდი, ის მთლიანად შეიცვლება ახალი შიგთავსით. ამიტომ, თუ გვსურს მხოლოდ ტექსტის შეცვლა html კოდის შენარჩუნებით, უნდა გამოვიყენოთ სხვა მეთოდები.
            
            ფორმის ელემენტებთან მუშაობა
            
            ფორმის ელემენტების მნიშვნელობების მისაღებად გამოიყენება მეთოდი val(). მისი მუშაობა html() და text() მეთოდების მუშაობის მსგავსია, ოღონდ გამოიყენება ფორმის ელემენტების მნიშვნელობების მიღებისა და შეცვლისთვის:
            
            val(): აბრუნებს ამორჩევის პირველი ელემენტის მნიშვნელობას
            val('ახალი_ტექსტი'): ელემენტის მნიშვნელობას ცვლის პარამეტრის სახით გადაცემული ახალი მნიშვნელობით
            val(ფუნქცია): მნიშვნელობის დამუშავება ხდება პარამეტრად გადაცემული ფუნქციით
            <input type="text" value="შეიყვანეთ მნიშვნელობა" />
            <script type="text/javascript">
                $(function () {
                    // ტექსტური ველი მნიშვნელობის მიღება
                    var oldValue = $('input[type="text"]').val();
                    console.log(oldValue);
             
                    $('input[type="text"]').first().val("შეიყვანეთ მომხმარებლის სახელი");
             
                    // ფუნქციის გამოყენება მნიშვნელობის შესაცვლელად
                    $('input[type="text"]').first().val(function (index, oldValue) {
                        console.log("ძველი მნიშვნელობა: " + oldValue);
                        return "შეიყვანეთ პაროლი";
                    });
                });
            </script>`
        },
    ],
},
       
                  
            {
                title:"თავი 4. მუშაობა ვებგვერდის სტრუქტურასთან",
                content:[
                    {
                        title:"შვილი ელემენტების შექმნა და დამატება",
                        data:`ახალი ელემენტების შექმნა

                        html-ის ახალი ელემენტის შესაქმნელად შეგვიძლია გამოვიყენოთ jQuery-ის ფუნქცია და გადავცეთ მას პარამეტრად html კოდი:
                        
                        var newList = $('<ul><li>Item1</li><li>Item2</li></ul>');
                        console.log(newList.html());
                        აქ ჩვენ მხოლოდ შევქმნეით ახალი ელემენტი. იგი ჯერ არაა დამატებული ვებგვერდზე.
                        
                        მეთოდი clone
                        
                        ახალი ელემენტის ალტერნატიული ხერხია ელემენტიშ შექმნა მეთოდით clone(). ეს მეთოდი უბრალოდ ქმნის არსებული ელემენტის კლონს (ასლს):
                        
                        var newList = $('ul').first().clone();
                        console.log(newList.html());
                        ელემენტების დამატება
                        
                        ელემენტების შექმნა უსარგებლო იქნებოდა, თუ არ შეგვეძლებოდა შექმნილი ელემენტის დამატება ვებგვერდზე. ვებგვერდზე ელემენტის დასამატებლად jQuery-ში არის ორი მეთოდი: append და prepend.
                        
                        მეთოდი append
                        
                        მეთოდი append ელემენტს ამატებს ამორჩევის ბოლოში. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                        
                        append('html კოდი'): ამატებს პარამეტრში მითითებულ html კოდს ამორჩეული ელემენტის ბოლოში
                        append(ელემენტი): ამატებს პარამეტრში მითითებულ ელემენტს ამორჩეული ელემენტის ბოლოში
                        append(jQuery): ამატებს პარამეტრში მითითებულ jQuery-ის ობიექტს ამორჩეული ელემენტის ბოლოში
                        append(ფუნქცია): ამორჩეული ელემენტის ბოლოში ემატება html კოდი, ელემენტი ან jQuery-ის ობიექტი, რასაც აბრუნებს ფუნქცია
                        მაგალითად, გვაქვს ასეთი სია:
                        
                        <ul id="langs">
                            <li>Java</li>
                            <li>C/C++</li>
                            <li>PHP</li>
                        </ul>
                        გამოვიყენოთ მეთოდი append:
                        
                        // html კოდის დამატება
                        $('#langs').append('<li>C#</li>');
                         
                        // ელემენტის დამატება
                        var jsItem = document.createElement('li');
                        jsItem.innerHTML = 'JavaScript';
                        $('#langs').append(jsItem);
                         
                        // jQuery-ის ობიექტის დამატება
                        var vbItem = $('<li>Visual Basic</li>');
                        $('#langs').append(vbItem);
                        საბოლოოდ, სიას ექნება შემდეგი სახე:
                        
                        <ul id="langs">
                            <li>Java</li>
                            <li>C/C++</li>
                            <li>PHP</li>
                            <li>C#</li>
                            <li>JavaScript</li>
                            <li>Visual Basic</li>
                        </ul>
                        ფუნქციის გამოყენებით:
                        
                        $('ul#langs').append(function (index, html) {
                            return $('<li>JavaScript</li>');
                        });
                        ფუნქციის გამოძახება ხდება ამორჩევის თიტოეული ელემენტისთვის და ღებულობს ორ პარამეტრს: index - მიმდინარე ელემენტის ინდექსი და html - მიმდინარე ელემენტის html კოდი. ფუნქცია მოცემულ შემთხვევაში აბრუნებს jQuery-ის ობიექტს, ტუმცა შესაძლებელია დააბრუნოს უბრალოდ სტრიქონი html კოდით ან html ელემენტი.
                        
                        მეთოდი prepend
                        
                        მეთოდი prepend წარმოადგენს append-ის ანალოგიურს იმ განსხვავებით, რომ ის ამატებს ახალ ელემენტს ამორჩეული ელემენტის არა ბოლოში, არამედ დასაწყისში. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                        
                        prepend('html კოდი'): ამატებს პარამეტრში მითითებულ html კოდს ამორჩეული ელემენტის დასაწყისში
                        prepend(ელემენტი): ამატებს პარამეტრში მითითებულ ელემენტს ამორჩეული ელემენტის დასაწყისში
                        prepend(jQuery): ამატებს პარამეტრში მითითებულ jQuery-ის ობიექტს ამორჩეული ელემენტის დასაწყისში
                        prepend(ფუნქცია): ამორჩეული ელემენტის დასაწყისში ემატება html კოდი, ელემენტი ან jQuery-ის ობიექტი, რასაც აბრუნებს ფუნქცია
                        გამოვიყენოთ მეთოდი prepend:
                        
                        // html კოდის დამატება
                        $('#langs').prepend('<li>C#</li>');
                         
                        // ელემენტის დამატება
                        var jsItem = document.createElement('li');
                        jsItem.innerHTML = 'JavaScript';
                        $('#langs').prepend(jsItem);
                         
                        // jQuery-ის ობიექტის დამატება
                        var vbItem = $('<li>Visual Basic</li>');
                        $('#langs').prepend(vbItem);
                        ფუნქციის გამოყენებაც ანალოგიურია, როგორც იყო append მეთოდის შემთხვევაში. წინა კოდის შესრულების შემდეგ სიას ექნება შემდეგი სახე:
                        
                        <ul id="langs">
                            <li>Visual Basic</li>
                            <li>JavaScript</li>
                            <li>C#</li>
                            <li>Java</li>
                            <li>C/C++</li>
                            <li>PHP</li>
                        </ul>
                        მეთოდები appendTo და prependTo
                        
                        მეთოდები appendTo და prependTo ამატებენ ელემენტს, როგორც შვილ ელემენტს ელემენტზე, რომელიც მითითებულია მეთოდის პარამეტრად. ნაწილობრივ გადავწეროთ წინა მაგალითი appendTo და prependTo მეთოდების გამოყენებით:
                        
                        // jQuery-ის ობიექტზე დამატება
                        $('<li>C#</li>').prependTo('#langs');
                         
                        // html ელემენტზე დამატება
                        var list = document.getElementById('langs');
                        $('<li>JavaScript</li>').appendTo(list);`
                    },
                    {
                      title:"ელემენტის შეფუთვა. მეთოდი wrap",
                      data:`წინა პარაგრაფში ჩვენ განვიხილეთ შვილი ელემენტების დამატება უკვე არსებულ ელემენტზე. ასევე შესაძლებელია შევქმნათ ახალი ელემენტი და შევფუთოთ მასში უკვე არსებული ელემენტები. ამისათვის გამოიყენება მეთოდი wrap() და მისი მსგავსი მეთოდები wrapAll() და wrapInner(). მაგალითად, შეიძლება დაგვჭირდეს უკვე არსებული ელემენტების შეფუთვა ელემენტში div, რისთვისაც გამოვიყენებთ ზემოთ აღნიშნულ მეთოდებს.

                      მეთოდი wrap
                      
                      მეთოდი wrap ახდენს ამორჩეული ელემენტების შეფუთვას იმ ელემენტით, რომელიც გადაეცემა wrap მეთოდს პარამეტრად. მეთოდს გააჩნია გამოყენების შემდეგი ვარიანტები:
                      
                      wrap('html კოდი'): ამორჩეულ ელემენტებს ფუთავს ელემენტით, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                      wrap(ელემენტი): ამორჩეულ ელემენტებს ფუთავს ელემენტით, რომელიც გადაეცემა პარამეტრად
                      wrap('სელექტორი'): ამორჩეულ ელემენტებს ფუთავს ელემენტით, რომელიც შეესაბამება სელექტორს
                      wrap(jQuery): ამორჩეულ ელემენტებს ფუთავს jQuer-ის ობიექტით
                      wrap(ფუნქცია): ამორჩეულ ელემენტებს ფუთავს ობიექტით, რომელსაც აბრუნებს ფუნქცია
                      ვთქვათ, გვაქვს შემდეგი htmlკოდი:
                      
                      <ul class="langs">
                          <li>Java</li>
                          <li>C/C++</li>
                          <li>PHP</li>
                      </ul>
                      შევფუთოთ სია wrap მეთოდის გამოყენებით:
                      
                      $('.langs').wrap('<div class="redStyle"></div>');
                      ამის შემდეგ html კოდს ექნება შემდეგი სახე:
                      
                      <div class="redStyle">
                          <ul class="langs">
                              <li>Java</li>
                              <li>C/C++</li>
                              <li>PHP</li>
                          </ul>
                      </div>
                      ანალოგიურად შეგვიძლია გამოვიყენოთ სხვა ვარიანტები:
                      
                              var header = document.getElementById('header');
                              $('.langs').wrap(header);
                      მიაქციეთ ყურადღება, რომ სიის შეფუთვა ხდება არა არსებული ელემენტით, არამედ ხდება არსებული ელემენტის კლონირება და ამ ახალ ელემენტში იფუთება სია.
                      
                      მეთოდი wrapAll
                      
                      ამორჩევის ყველა ელემენტის, როგორც ერთი მთლიანის, შესაფუთად გამოიყენება მეთოდი wrapAll. მას გააჩნია გამოყენების მსგავსი ვარიანტები:
                      
                      wrapAll('html კოდი'): ყველა ამორჩეულ ელემენტს ფუთავს ელემენტით, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                      wrapAll(ელემენტი): ყველა ამორჩეულ ელემენტს ფუთავს ელემენტით, რომელიც გადაეცემა პარამეტრად
                      wrapAll('სელექტორი'): ყველა ამორჩეულ ელემენტს ფუთავს ელემენტით, რომელიც შეესაბამება სელექტორს
                      wrapAll(jQuery): ყველა ამორჩეულ ელემენტს ფუთავს jQuer-ის ობიექტით
                      wrapAll(ფუნქცია): აყველა ამორჩეულ ელემენტს ფუთავს ობიექტით, რომელსაც აბრუნებს ფუნქცია
                      მაგალითად, ვთქვათ გვაქვს ასეთი html კოდი:
                      
                      <div class="lang">Java</div>
                      <div class="lang">C/C++</div>
                      <div class="lang">PHP</div>
                      შევფუთოთ ყველა ელემენტი ერთი ელემენტით div:
                      
                      $('.lang').wrapAll('<div class="langs"></div>');
                      შედეგად მივიღებთ:
                      
                      <div class="langs">
                          <div class="lang">Java</div>
                          <div class="lang">C/C++</div>
                          <div class="lang">PHP</div>
                      </div>
                      მეთოდი wrapInner
                      
                      ელემენტების შიგთავსის შესაფუთად გამოიყენება მეთოდი wrapInner. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                      
                      wrapInner('html კოდი'): ამორჩეული ელემენტების შიგთავსს ფუთავს ელემენტით, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                      wrapInner(ელემენტი): ამორჩეული ელემენტების შიგთავსს ფუთავს ელემენტით, რომელიც გადაეცემა პარამეტრად
                      wrapInner('სელექტორი'): ამორჩეული ელემენტების შიგთავსს ფუთავს ელემენტით, რომელიც შეესაბამება სელექტორს
                      wrapInner(jQuery): ამორჩეული ელემენტების შიგთავსს ფუთავს jQuer-ის ობიექტით
                      wrapInner(ფუნქცია): ამორჩეული ელემენტების შიგთავსს ფუთავს ობიექტით, რომელსაც აბრუნებს ფუნქცია
                      მაგალითად, თუ გვაქვს ასეთი html კოდი:
                      
                      <div class="lang">Java</div>
                      <div class="lang">C/C++</div>
                      <div class="lang">PHP</div>
                      შევფუთოთ ელემენტების შიგთავსი <p> ტეგით:
                      
                      $('li.lang').wrapInner('<p></p>');
                      შედეგად მივიღებთ:
                      
                      <ul>
                          <li class="lang"><p>Java</p></li>
                          <li class="lang"><p>C/C++</p></li>
                          <li class="lang"><p>PHP</p></li>
                      </ul>`
                  },
                  {
                    title:"ელემენტის დამატება იმავე დონეზე",
                    data:`თუ მეთოდი wrap ქმნის მშობელ ელემენტს, ხოლო მეთოდები append/prepend ქმნიან შვილ ელემენტებს, იმავე დონის ელემენტების (ანუ სიბლინგების) შესაქმნელად გამოიყენება მეთოდები: before/after/insertBefore/insertAfter.

                    მეთოდი before
                    
                    მეთოდი before ამატებს ელემენტს ამორჩევის ყოველი ელემენტის წინ. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                    
                    before('html კოდი'): ამორჩევის ყოველი ელემენტის წინ ამატებს ელემენტს, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                    before(ელემენტი): ამორჩევის ყოველი ელემენტის წინ ამატებს ელემენტს, რომელიც გადაეცემა პარამეტრად
                    before(jQuery): ამორჩევის ყოველი ელემენტის წინ ამატებს jQuer-ის ობიექტს
                    before(ფუნქცია): ამორჩევის ყოველი ელემენტის წინ ამატებს ობიექტს, რომელსაც აბრუნებს ფუნქცია
                    ვთქვათ, გვაქვს შემდეგი კოდი:
                    
                    <ul>
                        <li class="lang">Java</li>
                        <li class="lang">C/C++</li>
                        <li class="lang">PHP</li>
                    </ul>
                    before მეთოდის გამოყენებით შეგვიძლია დავამატოთ ახალი ელემენტი სიის დასაწყისში:
                    
                    $('li.lang').first().before('<li class="lang">JavaScript</li>');
                     
                    var vbItem = document.createElement('li');
                    vbItem.innerHTML = 'Visual Basic';
                    $('li.lang').first().before(vbItem);
                    შედეგად მივიღებთ:
                    
                    <ul>
                        <li class="lang">Visual Basic</li>
                        <li class="lang">JavaScript</li>
                        <li class="lang">Java</li>
                        <li class="lang">C/C++</li>
                        <li class="lang">PHP</li>
                    </ul>
                    მეთოდი after
                    
                    მეთოდი after მუშაობს ანალოგიურად იმ განსხვავებით, რომ დამატება ხდება ბოლოში:
                    
                    after('html კოდი'): ამორჩევის ყოველი ელემენტის შემდეგ ამატებს ელემენტს, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                    after(ელემენტი): ამორჩევის ყოველი ელემენტის შემდეგ ამატებს ელემენტს, რომელიც გადაეცემა პარამეტრად
                    after(jQuery): ამორჩევის ყოველი ელემენტის შემდეგ ამატებს jQuer-ის ობიექტს
                    after(ფუნქცია): ამორჩევის ყოველი ელემენტის შემდეგ ამატებს ობიექტს, რომელსაც აბრუნებს ფუნქცია
                    ავიღოთ html-ის წინა მაგალითი სიით და დავამატოთ რამდენიმე ელემენტი:
                    
                    $('li.lang').last().after('<li class="lang">JavaScript</li>');
                     
                    $('li.lang').last().after($('li.lang').last().clone().html('Visual Basic'));
                    მეთოდი insertBefore
                    
                    მეთოდი insertBefore თავისი მოქმედებით ჰგავს before მეთოდს. იგი პარამეტრად ღებულობს ელემენტს, რომლის წინაც მოხდება ელემენტის დამატება. მის გამოყენებას გააჩნია შემდეგი სინტაქსი:
                    
                    insertBefore('html კოდი'): ელემენტი ემატება ელემენტის წინ, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                    insertBefore(ელემენტი): ელემენტი ემატება ელემენტის წინ, რომელიც გადაეცემა პარამეტრად
                    insertBefore(jQuery): ელემენტი ემატება jQuer-ის ობიექტის წინ
                    insertBefore('სელექტორი'): აელემენტი ემატება ელემენტის წინ, რომელიც შეესაბამება სელექტორს
                    ფაქტობრივად, ეს იგივე before მეთოდია, ოღონდ ელემენტი, რომლის ჩასმაც ხდება და ელემენტი, რომლის წინაც ისმება, ადგილს იცვლიან ერთმანეთს.
                    
                    $('<li class="lang">JavaScript</li>').insertBefore('li.lang:first');
                    აქ ელემენტი <li class="lang">JavaScript</li> დაემატება იმ ელემენტის წინ, რომელიც შეესაბამება სელექტორს li.lang:first.
                    
                    მეთოდი insertAfter
                    
                    მეთოდი insertAfter ჰგავს after მეთოდს, ოღონდ insertBefore მეთოდის მსგავსად პარამეტრად იღებს ელემენტს, რომლის მერეც მოხდება ახალი ელემენტის დამატება. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                    
                    insertAfter('html კოდი'): ელემენტი ემატება ელემენტის შემდეგ, რომელიც იქმნება პარამეტრად მითითებული html კოდით
                    insertAfter(ელემენტი): ელემენტი ემატება ელემენტის შემდეგ, რომელიც გადაეცემა პარამეტრად
                    insertAfter(jQuery): ელემენტი ემატება jQuer-ის ობიექტის შემდეგ
                    insertAfter('სელექტორი'): აელემენტი ემატება ელემენტის შემდეგ, რომელიც შეესაბამება სელექტორს`
                },
                {
                    title:"ელემენტების ამოცვლა",
                    data:`მეთოდი replaceWith

                    მეთოდი replaceWith ცვლის ელემენტის შიგთავსს ახლით. მას გააჩნია გამოყენების შემდეგი ვარიანტები:
                    
                    replaceWith('html კოდი'): ელემენტის შიგთავსი იცვლება პარამეტრად მითითებული html კოდით
                    replaceWith(ელემენტი): ელემენტის შიგთავსი იცვლება  ელემენტით, რომელიც გადაეცემა პარამეტრად
                    replaceWith(jQuery): ელემენტის შიგთავსი იცვლება jQuer-ის ობიექტით
                    replaceWith(ფუნქცია): აელემენტის შიგთავსი იცვლება  ობიექტით, რომელსაც აბრუნებს ფუნქცია
                    მაგალითად, შევცვალოთ სიის პირველი ელემენტის შიგთავსი ახლით:
                    
                    $('li.lang').first().replaceWith('<li class="lang">JavaScript</li>');
                    გამოვიყენოთ ფუნქცია ელემენტების შიგთავსის შესაცვლელად. მაგალითად, გვაქვს html კოდი:
                    
                    <div id="list">
                        <div class="lang">Java</div>
                        <div class="lang">C/C++</div>
                        <div class="lang">PHP</div>
                    </div>
                    ვთქვათ, გვინდა div ელემენტების შეცვლა სიის ელემენტებით. შეგვიძლია დავწეროთ:
                    
                    $('div.lang').replaceWith(function () {
                        return '<li class="lang">' + $(this).text() + "</li>";
                    });
                     
                    $('div#list').replaceWith(function () {
                        return '<ol>' + $(this).html() + "</ol>";
                    });
                    ფუნქცია გადაუვლის ამორჩევის ყველა ელემენტს. მიმდინარე ელემენტის მიღება შესაძლებელია საკვანძო სიტყვის this მეშვეობით. ხდება div ელემენტების ჩანაცვლება სიის ელემენტებით. საბოლოოდ ვღებულობთ:
                    
                    <ol>
                        <li class="lang">Java</li>
                        <li class="lang">C/C++</li>
                        <li class="lang">PHP</li>
                    </ol>
                    მეთოდი replaceAll
                    
                    მეთოდი replaceAll(შესაცვლელი_ელემენტი) ცვლის ყველა ელემენტს, რომელიც განსაზღვრულია პარამეტრში, ახალი ელემენტით. შესაცვლელი ელემენტის სახით პარამეტრად შეიძლება გადავცეთ სელექტორი, html ელემენტი ან jQuery-ის ობიექტი. მაგალითად, შევცვალოთ წინა მაგალითში მოყვანილი სიის ყველა ელემენტი ახლით:
                    
                    $('<li class="lang">Элемент списка</li>').replaceAll('li.lang');
                    შედეგად მივიღებთ:
                    
                    <ol>
                        <li class="lang">Элемент списка</li>
                        <li class="lang">Элемент списка</li>
                        <li class="lang">Элемент списка</li>
                    </ol>`
                },
                {
                    title:"ელემენტის წაშლა",
                    data:`
                    მეთოდი remove
                    
                    მეთოდი remove([სელექტორი]) შლის ელემენტებს DOM-ის სტრუქტურიდან. მაგალითად, ვთქვათ, გვაქვს სია:
                    
                    <ul>
                        <li class="lang">Java</li>
                        <li class="lang">C/C++</li>
                        <li class="lang">PHP</li>
                        <li class="lang">JavaScript</li>
                    </ul>
                    შეგვიძლია წავშალოთ ყველა ლუწი სტრიქონი:
                    
                    $('li:even').remove();
                    შედეგად მივიღებთ:
                    
                    <ul>
                        <li class="lang">C/C++</li>
                        <li class="lang">JavaScript</li>
                    </ul>
                    ასევე ჩეგვეძლო გამოგვეყენებინა სელექტორი ფილტრაციისთვის:
                    
                    $('li').remove(':even');
                    მეთოდი detach
                    
                    მეთოდი detach remove მეთოდის ანალოგიურია. განსხვავება მდგომარეობს იმაში, რომ ამ მეთოდით ელემენტის წაშლისას ინახება მასთან დაკავშირებული მონაცემები. მოგვიანებით შეგვიძლია ეს ელემენტი დავამატოთ html კოდის სვა ადგილას:
                    
                    // ვშლით სიის პირველ ელემენტს და ვინახავთ ცვლადში item
                    var item = $('li:first').detach();
                    // ვამატებთ ამ ელემენტს სიის ბოლოში
                    $('ul').append(item);
                    მეთოდი empty
                    
                    მეთოდი empty ასუფთავებს ელემენტის შიგთავსს:
                    
                    $('ul').empty();
                    შედეგად სიის ყველა ელემენტი წაიშლება და დარჩება ცარიელი სია: <ul></ul>.`
                },
                 
                ]
            },     
            ]
     
},
php:{
    chapters:[
        {
            title:"თავი 1. შესავალი PHP-ში",
            content:[
                {
                    title:"პროგრამირების ენა PHp-ს ზოგადი მიმოხილვა",
                    data:`დღეისათვის PHP წარმოადგენს ვებპროგრამირების ერთ-ერთ ყველაზე გავრცელებულ ენას. ინტერნეტში საიტების და ვებსერვისების დიდი ნაწილი შექმნილილა PHP-ს მეშვეობით. ზოგიერთი შეფასებით PHP გამოიყენება საიტების 80%-ში, რომელთა შორისაა facebook.com, vk.com, baidu.com და სხვა. ასეთი პოპულარულობა არაა გასაკვირი.ენის სიმარტივე საშუალებას იძლევა სწრაფად და ადვილად შევქმნათ ნებისმიერი სირთულის საიტები და პორტალები.

                    PHP შეიქმნა 1994 წლს დანიელი პროგრამისტის რასმუს ლერდორფის მიერ და თავიდან წარმოადგენდა სკრიპტების კრებულს პროგრამირების სხვა ენაზე - Perl-ზე. მოგვიანებით მოხდა ამ სკრიპტების გადაწერა პროგრამირების ენა C-ის ინტერპრეტატორზე. შექმნის დღიდან PHP (სახელწოდება მიღებულია Hypertext Preprocessor-ის შემოკლებით) წარმოადგენს ვებსაიტების შექმნის ინსტრუმენტების მოხერხებულ ნაკრებს.
                    
                    რა უპირატესობები აქვს PHP-ს?
                    
                    ყველა ფართოდ გავრცელებული ოპერაციული სისტემისთვის (Windows, MacOS, Linux) არსებობს PHP-ს შესაბამისი პაკეტი, რაც იმას ნიშნავს, რომ ვებსაიტების შექმნა შესაძლებელია ამ ოპერაციული სისტემებიდან ნებისმიერში;
                    PHP მუშაობს სხვადასხვა ვებსერვერებთან, როგორიცაა Apache, Nginx, IIS;
                    გამოყენების და ათვისების სიმარტივე. როგორც წესი, PHP-ზე პროგრამირების მცირე გამოცდილებითაც შესაძლებელია მარტივი ვებსაიტების შექმნა;
                    PHP ჰგავს C-ს, ამიტომ თუ იცით C ან რომელიმე მსგავსი სინტაქსის მქონე ენა, PHP-ს ათვისება იქნება გაცილებით მარტივი;
                    PHP-ს გააჩნია სხვადასხვა მონაცემთა ბაზებთან (MySQL, MSSQL, Oracle, Postgre, MongoDB და სხვა) ურთიერთქმედების შესაძლებლობა;
                    PHP-ს მხარდაჭერა გაცნია ჰოსტინგების აბსოლუტურ უმრავლესობას. როგორც წესი, PHP თავსდება ვებსერვერებზე, რომლებზეც მუშაობს Apache ან Nginx, ისინი თავის მხრივ თავსდება Linux საოპერაციო სისტემაში. ვინაიდან Linux-იც და ძემოთჩამოთვლილი ვებსერვერებიც ვრცელდება უფასოდ, შესაბამისად, მსგავსი ჰოსტინგები არის შედარებით იაფი;
                    მუდმივი განვითარება. PHP გამუდმებით ვითარდება და გადასვლა ახალ ვერსიაზე არ წარმოადგენს სირთულეს. ამ მომენტისთვის (2017 წლის დეკემბერი) PHP-ს ბოლო სტაბილური ვერსია არის PHP 7.2.0.
                    ახლა კი შევქმნათ მცირე საიტი PHP-ს დახმარებით. წინასწარ უნდა ჩავტვირთოთ კომპიუტერში ამისთვის საჭირო ყველა ინსტრუმენტი.`
                },
                {
                  title:"PHP-ის ინსტალაცია",
                  data:`PHP-ის ინსტალაცია შეიძლება სხვადასხვა ხერხით. შეგვიძლია დავაყენოთ კომპონენტები ცალ-ცალკე ან გამოვიყენოთ უკვე არსებული ნაკრებები, მაგალითად Denwer ან EasyPHP. ასეთ ნაკრებებში კომპონენტებს უკვე გააჩნიათ საწყისი პარამეტრები და მზად არიან საიტების შესაქმნელად. მაგრამ ადრე თუ გვიან საჭირო ხდება ცალკეული კომპონენტების კონფიგურაციის შეცვლა ან ახალი მოდულების ჩართვა. ამიტომ, ჩვენ კომპონენტებს დავაყენებთ ცალ-ცალკე. ოპერაციულ სისტემად გამოვიყენებთ Windows-ს.

                  რას ნიშნავს PHP-ს ინსტალაცია? პირველ რიგში საჭიროა PHP-ს ინტერპრეტატორი. გარდა ამისა საჭიროა ვებსერვერი, მაგალითად Apache, რომლის მეშვეობითაც შევძლებთ შექმნილ საიტზე მიმართვას. ვინაიდან ჩვენ გამოვიყენებთ მონაცემთა ბაზებს, ასევე საჭიროა რომელიმე მონაცემთა ბაზის პროგრამა. ავირჩიოთ MySQL, რომელიც ყველაზე უფრო ხშირად გამოიყენება PHP-სთან ერთად.
                  
                  PHP-ს ინსტალაციისთვის შევიდეთ საიტზე http://php.net/. ჩამოტვირთვების გვერდზე არის სხვადასხვა დისტრიბუტივები ოპერაციული სისტემა Linux-ისთვის. ვინაიდან ჩვენ ვაპირებთ დაყენებას Windows-ზე, უნდა გადავიდეთ გვერდზე http://windows.php.net/download/.
                  
                  გადმოვწეროთ PHP-ს ბოლო გამოშვების zip-არქივი:
                  
                  JavaScript
                  
                  როგორც წესი, PHP-ს ვერსია გამოდის ორი სახით: Non Thread Safe და Thread Safe. ჩვენ უნდა ავირჩიოთ Thread Safe. არსებობს ორი ვარიანტი: 32 ბიტიანი და 64 ბიტიანი. უნდა ავირჩიოთ ოპერაციული სისტემის შესაბამისად.
                  
                  ამოვიღოთ ფაილები და საქაღალდეები არქივიდან და მოვათავსოთ მისამართზე c:\php.
                  
                  ახლა საჭიროა PHP-ს მინიმალური კონფიგურაცია. ამისათვის c:\php საქაღალდეში მოვნახოთ ფაილი  php.ini-development. ამ ფაილსი არის ინტერპრეტატორის საწყისი კონფიგურაცია. გადავარქვათ მას სახელი და დავარქვათ php.ini. ამის შემდეგ გავხსნათ ტექსტურ რედაქტორში და მოვძებნოთ სტრიქონი: 
                  
                  ; extension_dir = "./"
                  ეს სტრიქონი უჩვენებს საქაღალდეს PHP-ს გაფართოებებით. მოვხსნათ კომენტარი სტრიქონს (ამისათვის წავშალოთ წერტილმძიმე სტრიქონის დასაწყისში) და შევცვალოთ შემდეგნაირად:
                  
                  extension_dir = "C:/php/ext"
                  რადგანაც ყველა გაფართოება მოთავსებულია ext საქაღალდეში.
                  
                  რადგანაც მონაცემთა ბაზებისთვის ჩვენ უნდა გამოვიყენოთ MySQL,  იგი უნდა მივუთითოთ php.ini ფაილში. შესაბამისი ჩანაწერი ფაილსი უკვე არის, ოღონდ ჩაკომენტარებულია:
                  
                  ;extension=php_mysqli.dll
                  ამოსაკომენტარებლად მოვაშოროთ წერტილმძიმე:
                  
                  extension=php_mysqli.dll
                  სხვა კონფიგურაცია ფაილში დავტოვოთ უცვლელად.`
              },
              {
                title:"Apache ვებსერვერის ინსტალაცია",
                data:`ჩამოვტვირთოთ Apache ვებსერვერის პაკეტი საიტიდან http://www.apachelounge.com/.  ავირჩიოთ სერვერის ბოლო ვერსია. საიტზე ვნახავთ Apache-ს ორ პაკეტს: 32 ბიტიანი და 64 ბიტიანი ვინდოუსისთვის.

                JavaScript
                
                თუ Apache-ს ინსტალაციას ვახდენთ Windows ოპერაციულ სისტემასი, წინასწარ უნდა იყოს დაყენებული C++ პაკეტი, რომლის გადმოტვირთვაც შესაძლებელია მისამართიდან 64-ბიტიანი ვინდოუსისთვის ან 64-ბიტიანი ვინდოუსისთვის.
                
                Apache-ს ჩამოტვირთვის მერე ამოვიღოთ ფაილები და საქაღალდეები არქივიდან. მოვძებნოთ მასში საქაღალდე Apache24 და გადავწეროთ C დისკზე მისამართზე C:\Apache24. 
                
                ახლა საჭიროა Apache-ს დაყენება  Windows-ის სერვისად. ამისათვის გავუშვათ CMD ადმინისტრატორის უფლებებით და გადავიდეთ C:\Apache24\bin საქაღალდეში:
                
                 
                
                cd C:\Apache24\bin
                ამის შემდეგ დავაყენოთ Apache ვინდოუსის სერვისად ბრძანებით:
                
                httpd.exe -k install
                JavaScript
                
                თუ ინსტალაცია წარმატებით დასრულდა, გამოვა შეტყობინება: "The Apache2.4 service is successfully installed". ასევე მოხდება სერვერის ტესტირება. მოცემულ შემთხვევაში ტესტირება წარუმატებლად დასრულდა, ვინაიდან Apache-შ სერვერმა ვერ მოახერხა 80 პორტთან მიერთება, რადგან ეს პორტი დაკავებულია სხვა სერვისის (IIS) მიერ. ეს ერთ-ერთი ყველაზე გავრცელებული შეცდომაა Apache-ს სერვერის დაყენების დროს. პრობლემის აღმოსაფხვრელად საჭიროა IIS-ის გამორთვა ან Apache-სთვის პორტის შეცვლა.
                
                სერვერის ინსტალაციის შემდეგ საჭიროა მისი კონფიგურირება. ამისათვის შევიდეთ C:\Apache24\conf საქაღალდეში, მოვძებნოთ ფაილი httpd.conf და გავხსნათ იგი ტექსტურ რედაქტორში.
                
                პირველ რიგში მოვძებნოთ სტრიქონი 
                
                Listen 80
                ეს სტრიქონი უთითებს პორტს, რომელსაც უსმენს სერვერი. თუ პორტებზე კონფლიქტი არ წარმოიშობა, შეგვიძლია დავტოვოთ, როგორც არის. ჩვენს შემთხვევაში შევცვალოთ პორტით 8080:
                
                Listen 8080
                შემდეგ მოვძებნოთ სტრიქონი
                
                #ServerName www.example.com:80
                და შევცვალოთ იგი:
                
                ServerName localhost:8080
                ახლა ჩავრთოთ PHP. ამისათვის მოვძებნოთ მოდულების ჩატვირთვის ბოლო LoadModule
                
                //......................
                #LoadModule watchdog_module modules/mod_watchdog.so
                #LoadModule xml2enc_module modules/mod_xml2enc.so
                და ამ ბლოკის ბოლოში დავამატოთ:
                
                LoadModule php7_module "C:/php/php7apache2_4.dll"
                PHPIniDir "C:/php"
                ახლა უნდა მივუთითოთ ადგილი, სადაც უნდა მოხდეს საიტების ფაილების შენახვა. ამისათვის შევქმნათ საქაღალდე, მაგალითად C:\localhost. ამის შემდეგ httpd.conf ფაილში სტრიქონები
                
                DocumentRoot "c:/Apache24/htdocs"
                <Directory "c:/Apache24/htdocs">
                 
                ErrorLog "logs/error.log"
                CustomLog "logs/access.log" common
                შევცვალოთ შემდეგნაირად:
                
                DocumentRoot "c:/localhost"
                <Directory "c:/localhost">
                 
                ErrorLog "c:/localhost/error.log"
                CustomLog "c:/localhost/access.log" common
                ასევე უნდა მოვძებნოთ ბლოკი <IfModule mime_module> და დავამატოთ მასში ორი სტრიქონი:
                
                AddType application/x-httpd-php .php
                AddType application/x-httpd-php-source .phps
                და ბოლოს, მოვძებნოთ ბლოკი <IfModule dir_module>:
                
                <IfModule dir_module>
                    DirectoryIndex index.html
                </IfModule>
                და შევცვალოთ შემდეგნაირად:
                
                <IfModule dir_module>
                    DirectoryIndex index.html index.htm index.shtml index.php
                </IfModule>
                ეს არის მინიმალური კონფიგურაცია, რაც საჭიროა PHP-სთან სამუშაოდ. სერვერის სამართავად (გაშვება, შეჩერება, ხელახალი გაშვება), შეგვიძლია გამოვიყენოთ უტილიტა ApacheMonitor.exe, რომელიც მოთავსებულია C:\Apache24\bin საქაღალდეში.გავუშვათ უტილიტა. სათის გვერდზე tree-ში გამოჩნდება ApacheMonitor-ის ნიშანი. დავაჭიროთ მასზე და ავირჩიოთ Start ღილაკი:
                
                JavaScript
                
                თუ ყველაფერს სწორად გავაკეთებთ, გაიშვებს ვებსერვერი. იმისათვის, რომ შევამოწმოთ, რამდენად სწორადაა PHP დაკონფიგურირებული, c:\localhost საქაღალდეში შევქმნათ ფაილი index.php და მასში ჩავწეროთ:
                
                <?php
                phpinfo();
                ?>
                ეს არის სკრიპტი, რომელმაც უნდა გამოიტანოს საერთო ინფორმაცია PHP-ს შესახებ. თუ მივმართავთ ბრაუზერიდან ამ ფაილს მისამართზე http://localhost:8080/index.php, უნდა მივიღოთ შემდეგი:
                
                JavaScript
                
                რადგან კონფიგურაციაში მივუთითეთ, რომ მთავარი საიტი შეიძლება იყოს index.php, შეგვეძლო პირდაპირ ჩაგვეწერა ბრაუზერის მისამართის ზოლში c:\localhost:8080. ორწერტილის შემდეგ ეთითება პორტი, რომელიც ავირჩიეთ სერვერისთვის. თუ დავტოვებდით 80 პორტს, მაშინ პორტის მითითება არ იქნებოდა სავალდებულო.
                
                ამით ვებსერვერის ინსტალაცია დამთავრდა და შეგვიძლია შევქმნათ საიტები PHP-ს დახმარებით.
                
                 `
            },
            {
                title:"MySQL-ის ინსტალაცია",
                data:`ჩვენ შეგვიძლია გამოვიყენოთ მონაცემთა ბაზების სხვადასხვა სისტემა, მაგრამ PHP-სთან ერთად ყველაზე უფრო ხშირად გამოიყენება MySQL. ამასთან, იგი არის უფასო. 

                MySQL-ის ინსტალაციისთვის საჭიროა გადმოვწეროთ მისი საინსტალაციო პაკეტი. ამისათვის უნდა გადავიდეთ მისამართზე https://dev.mysql.com/downloads/mysql/:
                
                
                საიდანაც Go to Download Page ღილაკით გადავალთ გადმოწერის გვერდზე. ამ დროისათვის საინსტალაციო პაკეტის ვერსიაა MySQL Installer 5.7.20.
                
                ჩამოტვირთვის შემდეგ გავუშვათ საინსტალაციო პაკეტი:
                
                
                თუ MySQL უკვე ეყენა კომპიუტერში, ინსტალაციის ნაცვლად შემოგვთავაზებს კომპონენტების დანმატებას ან განახლებას.
                
                სალიცენზიო ხელშეკრულებაზე დათანხმების  შემდეგ უნდა ავირჩიოთ ინსტალაციის ტიპი. ავირჩიოთ Developer Default:
                
                
                შემდეგ ეტაპზე შეიძლება გამოჩნდეს  ფანჯარა, სადაც აისახება ის დამატებითი კომპონენტები, რომლებიც შეიძლება არ იყოს კომპიუტერში:
                
                
                მოცემულ შემთხვევაში კომპიუტერში არაა დაინსტალირებული ექსელი და პიტონი, რაც ხელს უშლის 2 კომპონენტის ინსტალაციას. ვინაიდან ეს კომპონენტები არაა მნიშვნელოვანი, ვაგრძელებთ ინსტალაციას Next ღილაკით. შემდეგ გამოდის დასაყენებელი კომპონენტების ჩამონათვალი:
                
                
                კომპონენტების ინსტალაციისთვის დავაჭიროთ ღილაკს Execute. ინსტალაციის შემდეგ საჭიროა კონფიგურაციის პარამეტრების მინიჭება:
                
                
                დავტოვოთ კონფიგურაციის პარამეტრები უცვლელად. ამის შემდეგ საჭიროა პაროლის მიცემა:
                
                
                შემდეგი ფანჯარა, რომელშიც მითითებულია, რომ MySQL გაიშვებს როგორც ვინდოუსის სერვისი, უნდა დავტოვოთ უცვლელად. ბოლოს გამოვა ფანჯარა, რომ MySQL-ის ინსტალაცია და კონფიგურირება დასრულებულია:
                
                
                 `
            },
            {
                title:"პირველი საიტი PHP-ზე",
                data:`ახლა შევქმნათ პატარა საიტი, რათა გავეცნოთ PHP-ს ზოგად პრინციპებს.

                პროგრამის შესაქმნელად დაგვჭირდება რომელიმე ტექსტური რედაქტორი. დღეისათვის დიდი პოპულარობით სარგებლობს Notepad++ და Visual Studio Code. ჩვენ გამოვიყენებთ Visual Studio Code-ს.
                
                გადავიდეთსაქაღალდეში c:\localhost და შევქმნათ ფაილი index.html. გავხსნათ იგი ტექსტურ რედაქტორში და ჩავწეროთ შემდეგი კოდი:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <title>პირველი საიტი PHP-ზე</title>
                    <meta charset="utf-8">
                </head>
                <body>
                    <h2>შეიყვანეთ თქვენი მონაცემები:</h2>
                    <form action="display.php" method="POST">
                        <p>შეიყვანეთ სახელი:
                            <input type="text" name="firstname" />
                        </p>
                        <p>შეიყვანეთ გვარი:
                            <input type="text" name="lastname" />
                        </p>
                        <input type="submit" value="გაგზავნა">
                    </form>
                </body>
                </html>
                html კოდი შეიცავს ფორმას, რომელსაც აქვს ორი ტექსტური ველი. ღილაკზე დაჭერისას ფორმის მონაცემები ეგზავნება display.php სკრიპტს, ვინაიდან ფორმის action-ში ის არის მითითებული.
                
                ახლა შევქმნათ ეს სკრიპტი. c:\localhost საქაღალდეში შევქმნათ ფაილი display.php. როგორც წესი, PHP-ზე შექმნილი პროგრამის ფაილებს გააცნია .php გაფართოება. გავხსნათ ფაილი display.php და ჩავწეროთ შემდეგი კოდი:
                
                <!DOCTYPE html>
                    <html>
                        <head>
                            <title>პირველი საიტი PHP-ზე</title>
                            <meta charset="utf-8">
                        </head>
                        <body>
                            <?php
                                $name = $_POST["firstname"];
                                $surname = $_POST["lastname"];
                                echo "თქვენი სახელია: <b>".$name . " " . $surname . "</b>";
                            ?>
                    </body>
                </html>
                html კოდის შიგნით ჩასმულია php-ს კოდი. PHP-ს კოდის ჩასამატებლად გამოიყენება ტეგი <?php...?>, რომლის შიგნით იწერება ინსტრუქცია PHP ენაზე. მოცემულ შემთხვევაში, PHP-ს კოდში ვღებულობთ ფორმის მონაცემებს და გამოგვაქვს ვებგვერდზე. 
                
                PHP-ს ყოველი გამოსახულება უნდა დასრულდეს წერტილმძიმით. ზემოთ განხილულ კოდში გვაქვს სამი გამოსახულება. ორი მათგანი იღებს ფორმის მონაცემებს და ინახავს ცვლადებში, მაგალითად: $name = $_POST["firstname"];.
                
                $name წარმოადგენს ცვლადს, რომელიც ინახავს გარკვეულ მნიშვნელობას. PHP-ში ყველა ცვლადის სახელი იწყება $ სიმბოლოთი. რადგანაც index.html-ში html ფორმა იყენებს POST მეთოდს, $_POST["firstname"] გამოსახულების მეშვეობით ვიღებთ მნიშვნელობას, რომელიც იყო შეყვანილი ტექსტურ ველში ატრიბუტით name="firstname". ეს მნიშვნელობა გადაეცემა $name ცვლადს.
                
                echo ოპერატორის მეშვეობით ვებგვერდზე შეგვიძლია გამოვიტანოთ ნებისმიერი მნიშვნელობა ან ტექსტი, რომელიც მოსდევს ოპერატორს. მოცემულ შემთხვევაში - echo "თქვენი სახელია: <b>".$name . " " . $surname . "</b>".  წერტილების მეშვეობით ხდება ტექსტების გაერთიანება, მოცემულ შემთხვევაში ბრჭყალებში ჩასმული ტექსტი ერთიანდება $name და $surname ცვლადების მნიშვნელობებთან და გამოდის ვებგვერდზე.
                
                ახლა მივმართოთ შეყვანის ფორმას მისამართზე: http://localhost:8080:
                
                JavaScript
                
                მონაცემების შეყვანის და გაგზავნის შემდეგ ვღებულობთ:
                
                JavaScript
                
                ამუშავდა სკრიპტი display.php, რომელმაც გაგზავნილი მონაცემები გამოიტანა ვებგვერდზე.`
            },
             
            ]
        },
        {
            title:"თავი 2. PHP-ის საფუძვლები",
            content:[
                {
                    title:"სინტაქსის საფუძვლები",
                    data:`PHP-ზე პირველი პოგრამის შექმნის პროცესში უკვე შევეხეთ PHP ენაზე სკრიპტების შექმნის ძირითად პრინციპებს. განვიხილოთ ისინი უფრო დაწვრილებით.

                    პროგრამას PHP  სკრიპტზე გააცნია .php გაფართოება, ტუმცა ზოგჯერ სკრიპტს ათავსებენ ფაილსი, რომლის გაფართოებაა .html ან .htm.
                    
                    როცა მომხმარებელი იძახებს PHP სკრიპტს ბრაუზერის მისამართების ზოლის მეშვეობით, მაგალითად http://localhost:8080/display.php, ვებსერვერი გადასცემს მას PHP-ს ინტერპრეტატორს. ინტერპრეტატორი ახდენს კოდის დამუშავებას და აგენერირებს html კოდს, რომელიც უბრუნდება მომხმარებელს და ბრაუზერის მეშვეობით გამოდის ეკრანზე.
                    
                    PHP დოკუმენტი PHP კოდთან ერთად შეიძლება შეიცავდეს html კოდსაც. html კოდიდან PHP კოდზე გადასვლისთვის გამოიყენება ტეგი <?php და ?>, რომელთა შორის მოდის PHP-ს კოდი. ასევე შეიძლება მოკლე ვერსიის გამოყენება: <? და ?>. ამისათვის php.ini ფაილში short_open_tag = Off უნდა შევცვალოთ short_open_tag = On მნიშვნელობით. 
                    
                    ვნახოთ PHP-ს უმარტივესი სკრიპტი:
                    
                    <html>
                        <head>
                            <title>ვებგვერდი</title>
                        </head>
                        <body>
                            <?php
                                echo "<p>გამარჯობა, სამყაროვ!!</p>";
                                echo "2 + 2 = " . (2+2);
                            ?>
                        </body>
                    </html>
                    აქ გამოყენებულია PHP-ს ორი ინსტრუქცია (გამოსახულება). თითოეული გამოსახულება სრულდება წერტილმძიმით.
                    
                    ფაილის დამუშავების შემდეგ ინტერპრეტატორი მას გადააქცევს შემდეგ html კოდად:
                    
                    <html>
                    <head>
                        <title>ვებგვერდი</title>
                    </head>
                    <body>
                        <p>გამარჯობა, სამყაროვ!!</p>
                      2 + 2 = 4
                    </body>
                    </html>
                    კომენტარები
                    
                    PHP-ზე სკრიპტის შექმნისას შეგვიძლია გამოვიყენოთ კომენტარები. მაგალითად, ჩვენ შეგვიძლია დავაკომენტაროთ რაღაც მოქმედებები, რათა მომავალში ადვილად გავარკვიოთ, თუ რას აკეთებს ესა თუ ის კოდი:
                    
                    <?php
                        echo "<p>გამარჯობა, სამყაროვ!</p>"; // შეტყობინების გამოტანა
                        //echo "2 + 2 = " . (2+2);
                    ?>
                    ნიშნით // იწყება ერთსტრიქონიანი კომენტარი. ყველაფერი რაც იმავე სტრიქონში მის შემდეგ მოდის ითვლება კომენტარად და ინტერპრეტატორის მიერ არ სრულდება. ინტერპრეტატორი უბრალოდ გამოტოვებს კომენტარებს.
                    
                    თუ გვინდა ჩავაკომენტაროთ რამდენიმე სტრიქონი, გამოიყენება მრავალსტრიქონიანი კომენტარი: /* კომენტარის ტექსტი */:
                    
                    <?php
                        echo "<p>გამარჯობა, სამყაროვ!</p>"; // შეტყობინების გამოტანა
                        /*
                        მრავალსტრიქონიანი კომენტარი
                        არითმეტიკული ოპერაცია
                        echo "2 + 2 = " . (2+2);
                        */
                    ?>
                    კომენტარის ყველა სტრიქონი გამოტოვებული იქნება ინტერპრეტატორის მიერ კოდის დამუშავებისას.`
                },
                {
                  title:"ცვლადები",
                  data:`როგორც პროგრამირების სხვა ენებში, PHP-ში გამოიყენება ცვლადები. ცვლადები ინახავენ გარკვეულ მნიშვნელობებს და მატი გამოყენება შესაძლებელია PHP-ს გამოსახულებებში. PHP-ში ცვლადის სახელი აუცილებლად იწყება $ სიმბოლოთი, მაგალითად:

                  <?php
                  $a = 10;
                  echo $a;
                  ?>
                  აქ განსაზღვრულია ცვლადი $a, რომელსაც მინიჭებული აქვს მნიშვნელობა 10. მნიშვნელობის მისანიჭებლად გამოიყენება ტოლობის ნიშანი =.
                  
                  ერთი ცვლადის მნიშვნელობა შეიძლება მივანიჭოთ სხვა ცვლადს:
                  
                  $a = 10;
                  $b=$a;
                  echo $b;
                  PHP წარმოადგენს რეგისტრზე დამოკიდებულ პროგრამირების ენას. შესაბამისად, $counter და $Counter წარმოადგენს ორ სხვადასხვა ცვლადს.
                  
                  ცვლადების სახელის შერჩევისას ასევე უნდა გავითვალისწინოით, რომ:
                  
                  ცვლადის სახელი უნდა იწყებოდეს ($ სიმბოლოს შემდეგ უნდა მოდიოდეს) ლატინური ანბანის ასო ან გახაზვის სიმბოლო (_);
                  სახელი შეიძლება შეიცავდეს მხოლოდ შემდეგ სიმბოლოებს: a–z, A–Z, 0–9 და _ (გახაზვის სიმბოლო);
                  სახელი არ უნდა შეიცავდეს ცარიელ ადგილს.
                  ცვლადის არსებობის შემოწმება. ოპერატორი isset
                  
                  თუ ცვლადი გამოცხადებულია, მაგრამ არანაირი მნიშვნელობა არა აქვს მინიჭებული (სხვანაირად რომ ვთქვათ, არაა ინიციალიზებული), მისი გამოყენებუა პრობლემური იქნება. მაგალითად:
                  
                  <?php
                  $a;
                  echo $a;
                  ?>
                  ცვლადის მნიშვნელობის გამოტანისას მივიღებთ შეცდომას, რომ ცვლადი არაა განსაზღვრული: Notice: Undefined variable: a in C:\localhost\echo.php on line 3.
                  
                  ოპერატორი isset() გვაძლევს საშუალებას შევამოწმოთ ინიციალიზებულია ცვლადი თუ არა. თუ ცვლადი განსაზღვრულია მეთოდი აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად:
                  
                  <?php
                  $a;
                  if(isset($a))
                      echo $a;
                  else
                      echo "ცვლადი არაა განსაზღვრული";
                  ?>
                  ცვლადის არსებობის შემოწმებისას გამოვიყენეთ კონსტრუქცია if ... else, რომელიც ამოწმებს გამოსახულების ჭეშმარიტებას. თუ გამოსახულება ჭეშმარიტია, სრულდება if ბლოკის შემდგომი გამოსახულება. თუ გამოსახულება მცდარია, სრულდება else ბლოკის შემდგომი გამოსახულება.
                  
                  მოცემულ მაგალითში ცვლადი არაა ინიციალიზებული, შესაბამისად გამოსახულება isset($a) დააბრუნებს false-ს, შესაბამისად შესრულდება გამოსახულება, რომელიც მოდის else ბლოკის შემდეგ.
                  
                  unset() ოპერატორის მეშვეობით შეგვიძლია ცვლადის განადგურება:
                  
                  <?php
                  $a=20;
                  echo $a; // 20
                  unset($a);
                  echo $a; // შეცდომა, ცვლადი არაა განსაზღვრული
                  ?>`
              },
              {
                title:"მონაცემთა ტიპები",
                data:`PHP წარმოადგენს პროგრამირების ენას დინამიური ტიპიზაციით. ეს ნიშნავს, რომ ცვლადს ტიპი ენიჭება მნიშვნელობის მინიჭებისას და ცვლადის წინ მისი ტიპის მითითება არაა საჭირო განსხვავებით სხვა პროგრამირების ენებისგან.

                PHP-ს გააჩნია 8 მარტივი მონაცემთა ტიპის მხარდაჭერა:
                
                boolean (ლოგიკური ტიპი)
                integer (მთელი რიცხვები)
                double (ათწილადები)
                string (სტრიქონები)
                array (მასივები)
                object (ობიექტები)
                resource (რესურსები)
                NULL
                Integer (მთელი რიცხვები)
                
                Integer წარმოადგენს მთელ რიცხვებს ნიშნით ზომით 32 ბიტი (-2 147 483 648-დან 2 147 483 647-მდე).
                
                $int = -100;
                echo $int;
                აქ ცვლადი $int წარმოადგენს მთლი რიცხვის ტიპს, რადგანაც მას მნიშვნელობად მინიჭებული აქვს მთელი რიცხვი.
                
                გარდა ათობითი მთელი რიცხვებისა, PHP-ში შესაძლებელია ორობითი, რვაობითი და თექვსმეტობითი რიცხვების გამოყენებაც. 
                
                ათობითისგან განსხვავებული რიცხვები იწერება შემდეგი შაბლონით:
                
                თექვსმეტობითი: 0[xX][0-9a-fA-F]
                რვაობითი: 0[0-7]
                ორობითი: 0b[01]
                მაგალითად:
                
                <?php
                // ათობით სისტემაში ყველა არის 28
                $int_10 = 28; // ათობითი რიცხვი
                $int_2 = 0b11100; // ორობითი რიცხვი
                $int_8 = 034; // რვაობითი რიცხვი
                $int_16 = 0x1C; // თექვსმეტობითი რიცხვი
                echo "int_10 = $int_10 <br>";
                echo "int_2 = $int_2 <br>";
                echo "int_8 = $int_8 <br>"; 
                echo "int_16 = $int_16";
                ?>
                ტიპი double (ათწილადები)
                
                ათწილადის მაქსიმალური ზომა დამოკიდებულია პლატფორმაზე. როგორც წესი, ათწილადის მაქსიმალურად დასაშვები მნიშვნელობა შეადგენს ~1.8e308 14 ათწილადის ნიშნის სიზუსტით. მაგალითად:
                
                <?php
                $a1 = 1.5;
                $a2 = 1.3e4; // 1.3 * 10^4
                $a3 = 6E-8; // 0.00000006
                echo $a1 . " | " . $a2 . " | " . $a3;
                ?>
                ტიპი boolean (ლოგიკური ტიპი)
                
                ლოგიკური ტიპის ცვლადმა შეიძლება მიიღოს ორი მნიშვნელობა: true და false, ანუ ჭეშმარიტი და მცდარი. ყველაზე ხშირად ლოგიკური ტიპის მნიშვნელობები გამოიყენება პირობით კონსტრუქციებში:
                
                <?php
                $foo = true;
                $a=10;
                $b=5;
                echo "foo = true <br>";
                if($foo)
                  echo $a+$b;
                else
                  echo $a-$b;
                $foo = false;
                echo "<br> foo = false <br>";
                if($foo)
                  echo $a+$b;
                else
                  echo $a-$b;
                ?>
                if() ბლოკსი მოწმდება გამოსახულების ჭეშმარიტება. მოცემულ შემთხვევაში მოწმდება $foo ცვლადის მნიშვნელობა. თუ ის ჭეშმარიტია, ანუ ტოლია true-სი, სრულდება if ბლოკის მომდევნო გამოსახულება. თუ ცვლადი ან გამოსახულება if ოპერატორში მცდარია, ანუ ტოლია false-სი, მაშინ სრულდება else ბლოკის მომდევნო გამოსახულება.
                
                სპეციალური მნიშვნელობა NULL
                
                მნიშვნელობა NULL მიუტითებს, რომ ცვლადის მნიშვნელობა არაა განსაზღვრული. ამ მნიშვნელობის გამოყენება სასარგებლოა იმ შემთხვევასი, როცა გვინდა მივუთითოთ, რომ ცვლადის მნიშვნელობა არაა განსაზღვრული. მაგალითად, თუ ჩვენ უბრალოდ გამოვაცხადებთ ცვლადს, მაგრამ არ მოვახდენთ მის ინიციალიზაციას და შევეცდებით მის გამოყენებას, მივიღებთ შეცდომას, რომ ცვლადის მნიშვნელობა არაა განსაზღვრული:
                
                <?php
                $a;
                echo $a;
                ?>
                NULL მნიშვნელობის გამოყენება აგვაცილებს მსგავს სიტუაციას თავიდან. ამას გარდა, ჩვენ შეგვიძლია შევამოწმოთ ცვლადი მნიშვნელობის არსებობაზე და შედეგის მიხედვით შევასრულოთ ესა თუ ის მოქმედება:
                
                <?php
                $a=NULL;
                if($a)
                    echo "a ცვლადის მნიშვნელობა განსაზღვრულია";
                else
                    echo "a ცვლადის მნიშვნელობა არაა განსაზღვრული";
                ?>
                კონსტანტა NULL არაა მგრძნობიარე რეგისტრის მიმართ, ამიტომ შეიძლება ასეც ჩავწეროთ:
                
                $a=null;
                ტიპი string (სტრიქონები)
                
                ტექსტთან სამუშაოდ გამოიყენება სტრიქონები. სტრიქონი არსებობს ორი სახის: ორმაგ ბრჭყალებში და ერთმაგში. სტრიქონის ტიპზეა დამოკიდებული მისი დამუშავება ინტერპრეტატორის მიერ. ასე, მაგალითად ცვლადები ორმაგ ბრჭყალებში იცვლება მათი მნიშვნელობებით, ხოლო ერთმაგ ბრჭყალებში რჩებიან უცვლელნი.
                
                <?php
                $a=10;
                $b=5;
                $result = "$a+$b <br>";
                echo $result;
                $result = '$a+$b';
                echo $result;
                ?>
                ამ დროს ჩვენ მივიღებთ ასეთ შედეგს:
                
                JavaScript
                
                ჩვეულებრივი სიმბოლოების გარდა სტრიქონი შეიძლება შეიცავდეს სპეციალურ სიმბოლოებს, რომელთა ინტერპრეტირება შეიძლება მოხდეს არასწორად. მაგალითად, ვთქვათ ტექსტი შეიცავს ბრჭყალებს:
                
                $text = "მოდელი "Apple II"";
                ეს ჩანაწერი შეცდომიანია. შეცდომის გამოსასწორებლად შეგვიძლია შევუხამოთ სხვადასხვა ტიპის ბრჭყალები:
                
                $text = 'მოდელი "Apple II"';
                ასევე შეიძლება გამოვიყენოთ სლეში სპეიცალური სიმბოლოების ეკრანირებისთვის:
                
                $text = "მოდელი \"Apple II\"";
                ტიპი resource (რესურსები)
                
                resource არის სპეციალური ტიპი, რომელიც შეიცავს მიმართვას გარე რესურსზე. გარე რესურსის როლსი შეიძლება იყოს, მაგალითად, ფაილი ან მონაცემთა ბაზაზე შეერთება. რესურსებს ქმნიან და იყენებენ სპეციალური ფუნქციები. შემდგომსი უფრო დაწვრილებით განვიხილავთ ფაილებთან და მონაცემთა ბაზებთან მუშაობას.
                
                ტიპი array (ასოციაციური მასივები)
                
                ასოციაციური მასივი წარმოადგენს ელემენტების კრებულს, სადაც თითოეული მათგანი წარმოადგენს გასაღები=> მნიშვნელობა სახის წყვილს. შევქმნათ 4 ელემენტიანი მასივი:
                
                <?php
                $phones = array('iPhone', 'Samsung Galaxy S III', 'Nokia N9', 'Samsung ACE II');
                echo $phones[1];
                ?>
                მასივი იქმნება array() კონსტრუქტორის მეშვეობით, რომელშიც განისაზღვრება ელემენტები. შემდეგ გამოგვაქვს მასივის მე-2 ელემენტი.  ვინაიდან ელემენტების ათვლა მასივში იწყება 0-დან, მე-2 ელემენტისადმი მისამართად უნდა გამოვიყენოთ გამოსახულება $phones[1]. შემდგომში მასივები უფრო დაწვრილებით იქნება განხილული.`
            },
            {
                title:"კონსტანტები",
                data:`კონსტანტები, ისევე როგორც ცვლადები, ინახავენ გარკვეულ მნიშვნელობებს, მაგრამ ცვლადებისაგან განსხვავებით, კონსტანტებს შეიძლება მივანიჭოთ მნიშვნელობა მხოლოდ ერთხელ, ხოლო შემდგომში მისი შეცვლა არ შეიძლება. მაგალითად, განვსაზღვროთ რიცხვითი კონსტანტა:

                <?php
                define("NUMBER", 22);
                echo NUMBER;
                $num = NUMBER;
                echo $num;
                ?>
                კონსტანტის განსაზღვრისთვის გამოიყენება ოპერატორი define, რომელსაც აქვს შემდეგი ფორმა: define(string $name, $value, bool $case_sen=false). პარამეტრი $name წარმოადგენს კონსტანტის სახელს,  $value - მნიშვნელობას. მესამე არააუცილებელი პარამეტრი ღებულობს ლოგიკურ მნიშვნელობას true ან false. თუ მნიშვნელობა არის false, კონსტანტის სახელში რეგისტრს მნიშვნელობა აქვს, თუ true - რეგისტრს მნიშვნელობა არა აქვს. ჩვენს შემთხვევაში მესამე პარამეტრი მითითებული არაა, შესაბამისად იგულისხმება false. 
                
                განსაზღვრის მერე კონსტანტა შეგვიძლია გამოვიყენოთ ისევე, როგორც ცვლადი, ერთადერთი განსხვავება ისაა, რომ ჩვენ არ შეგვიძლია მისი მნიშვნელობის შეცვლა. ცვლადისგან მეორე განსხვავება ისაა, რომ მისი სახელის წინ არ იწერება სიმბოლო $.
                
                ჩაშენებული კონსტანტები
                
                პროგრამისტის მიერშექმნილი კონსტანტების გარდა არსებობს რამდენიმე ჩაშენებული კონსტანტა:
                
                __FILE__: შეიცავს მიმდინარე ფაილის სრულ მისამართს;
                __LINE__: შეიცავს მიმდინარე სტრიქონის ნომერს, რომელსაც ამუშავებს ინტერპრეტატორი;
                __DIR__: შეიცავს მიმდინარე ფაილის საქაღალდის მისამართს;
                __FUNCTION__: მიმდინარე ფუნქციის სახელი;
                __CLASS__: მიმდინარე კლასის სახელი;
                __METHOD__: მიმდინარე მეთოდის სახელი;
                __NAMESPACE__: სახელების სივრცის დასახელება.
                მაგალითად, გამოვიტანოთ მიმდინარე სტრიქონი და ფაილის მისამართი:
                
                <?php
                echo "სტრიქონი " . __LINE__ . " ფაილში " . __FILE__;
                ?>`
            },
            {
                title:"ცვლადის ტიპის განსაზღვრა და მიღება",
                data:`სპეციალური ფუნქციების მეშვეობით შეგვიძლია გავიგოთ ცვლადის ტიპი:

                is_integer($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს მთელ რიცხვს;
                is_string($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს სტრიქონს;
                is_double($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს ნამდვილ რიცხვს;
                is_numeric($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს რიცხვის სტრიქონულ წარმოდგენას. მაგალითად:
                <?php
                $a = 10;
                $b = "10";
                echo is_numeric($a);
                echo "<br>";
                echo is_numeric($b);
                ?>
                ორივე გამოსახულება აბრუნებს TRUE-ს, ვინაიდან ერთი მათგანი არის რიცხვი, ხოლო მეორე - რიცხვის სტრიქონული წარმოდგენა.
                
                is_bool($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს ლოგიკურ მნიშვნელობას TRUE ან FALSE;
                is_scalar($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს მარტივი ტიპებიდან ერთ-ერთს: სტრიქონს, მთელ რიცხვს, ნამდვილ რიცხვს, ლოგიკურ მნიშვნელობას;
                is_null($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს მნიშვნელობასNULL;
                is_array($a): აბრუნებს TRUE, თუ $a ცვლადი წარმოადგენს მასივს;
                is_object($a): აბრუნებს TRUE, თუ $a ცვლადი შეიცავს ობიექტზე მიმართვას;
                gettype($a): აბრუნებს $a ცვლადის ტიპს. მაგალითად: integer (მთლი რიცხვი), double (ნამდვილი რიცხვი), string (სტრიქონი), boolean (ლოგიკური მნიშვნელობა), NULL, array (მასივი), object (ობიექტი) ან unknown type (უცნობი ტიპი). მაგალითად:
                <?php
                $a = 10;
                $b = "10";
                echo gettype($a); // integer
                echo "<br>";
                echo gettype($b);  // string
                ?>
                ტიპის მინიჭება. ფუნქცია settype()
                
                settype() ფუნქციის მეშვეობით შეგვიძლია მივანიჭოთ ცვლადს გარკვეული ტიპი. ის იღებს ორ პარამეტრს: settype("ცვლადი","ტიპი"). პირველი პარამეტრი არის ცვლადი, რომელსაც უნდა მივანიჭოთ გარკვეული ტიპი, მეორე - ტიპის სტრიქონული აღწერა, რასაც აბრუნებს ფუნქცია gettype().
                
                თუ მოხერხდება ტიპის მინიჭება, ფუნქცია აბრუნებს TRUE-ს, თუ არა და - FALSE-ს.
                
                მაგალითად, მივანიჭოთ ცვლადს მთელი რიცხვის ტიპი:
                
                <?php
                $a = 10.7;
                settype($a, "integer");
                echo $a; // 10
                ?>
                რადგანაც ცვლადი $a წარმოადგენს ნამდვილ რიცხვს 10.7-ს, მისი გარდაქმნა მთელ რიცხვად შესაძლებელია წილადი ნაწილის მოშორებით . ამიტომ ამ შემთხვევაში ფუნქცია settype() აბრუნებს TRUE-ს.`
            },
            {
                title:"ოპერაციები PHP-ში",
                data:`PHP-ში შესაძლებელია სხვადასხვა ტიპის ოპერაციები ცვლადებზე: არითმეტიკული, ლოგიკური და ა. შ. განვიხილოთ ეს ოპერაციები.

                არითმეტიკული ოპერაციები
                
                + შეკრება. მაგალითად, $a+5;
                - გამოკლება. მაგალითად, $a-5;
                * გამრავლება. მაგალითად, $a*5;
                / გაყოფა. მაგალითად, $a/5;
                % ნაშთი გაყოფისას. მაგალითად:
                $a=12;
                echo $a % 5; // ტოლია 2-ის
                ++ ინკრემენტი - მნიშვნელობის გაზრდა ერთით. მაგალითად, ++$a. მნიშვნელოვანია განვასხვავოთ ერთმანეთისგან ++$a და $a++:
                <?php
                $a=12;
                $b=12;
                $c=++$a;
                $d=$b++;
                echo $a."<br />";  //13
                echo $b."<br />";  //13
                echo $c."<br />";  //13
                echo $d."<br />";  //12
                ?>
                პირველ შემთხვევაში - $c=++$a; ჯერ ხდება ცვლადის მნიშვნელობის გაზრდა, ხოლო შემდეგ მიღებული მნიშვნელობის მინიჭება მეორე ცვლადზე. ამიტომაც $c-ს მნიშვნელობა იქნება 13-ის ტოლი. მეორე შემთხვევაში - $d=$b++; კი, ჯერ ხდება მნიშვნელობის მინიჭება და ამის მერე ცვლადის მნიშვნელობის გაზრდა, ამიტომ $d-ს მნიშვნელობა იქნება 12. 
                
                -- დეკრემენტი - მნიშვნელობის შემცირება ერთით. აქაც, ისევე როგორც ინკრემენტის შემთხვევაში, გვაქვს ორი სახე: --$a და $a--.
                მინიჭების ოპერაციები
                
                = ცვლადს ენიჭება გარკვეული მნიშვნელობა. მაგალითად, $a = 5;
                += შეკრება მნიშვნელობის შემდგომი მინიჭებით. მაგალითად:
                $a=12;
                $a += 5;
                echo $a; // 17
                -= გამოკლება მნიშვნელობის შემდგომი მინიჭებით. მაგალითად:
                $a=12;
                $a -= 5;
                echo $a; // 7
                *= გამრავლება მნიშვნელობის შემდგომი მინიჭებით. მაგალითად:
                $a=12;
                $a *= 5;
                echo $a; // 35
                /= გაყოფა მნიშვნელობის შემდგომი მინიჭებით. მაგალითად:
                $a=12;
                $a /= 5;
                echo $a; // 2.4
                %= ნაშთი გაყოფისას მნიშვნელობის შემდგომი მინიჭებით. მაგალითად:
                $a=12;
                $a %= 5;
                echo $a; // 2
                .= სტრიქონების გაერთიანება შემდგომი მინიჭებით. გამოიყენება სტრიქონების მიმართ. თუ ცვლადები ინახავენ არა სტრიქონებს, არამედ, მაგალითად, რიცხვებს, ჯერ ხდება მათი გარდაქმნა სტრიქონებად და შემდეგ სრულდება ოპერაცია. მაგალითად:
                <?php
                $a=12;
                $a .= 5;
                echo $a; // 125
                // ანალოგიურად
                $b="12";
                $b .="5"; // 125
                ?>
                შედარების ოპერაციები
                
                შედარების ოპერატორები, როგორც წესი, გამოიყენება პირობით კონსტრუქციებში, როცა საჭიროა ორი მნიშვნელობის შედარება და შედეგის მიხედვით სხვადასხვა მოქმედებების შესრულება. PHP-ში არის შემდეგი შედარების ოპერაციები:
                
                == ტოლობის ოპერატორი ადარებს ორ მნიშვნელობას და თუ ისინი ტოლია, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a == 5;
                == იგივეობის ოპერატორი ასევე ადარებს ორ მნიშვნელობას და თუ ისინი ტოლია, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a === 5;
                != ადარებს ორ მნიშვნელობას და თუ ისინი არაა ტოლი, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a != 5;
                !== ადარებს ორ მნიშვნელობას და თუ ისინი არაა ტოლი, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a !== 5;
                > ადარებს ორ მნიშვნელობას და პირველი მეტია მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a > 5;
                < ადარებს ორ მნიშვნელობას და პირველი ნაკლებია მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a < 5;
                >= ადარებს ორ მნიშვნელობას და პირველი მეტია ან ტოლი მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a >= 5;
                <= ადარებს ორ მნიშვნელობას და პირველი ნაკლებია ან ტოლი მეორეზე, აბრუნებს true-ს, თუ არა და - false-ს. მაგალითად, $a <= 5;
                ტოლობის და იგივეობის ოპერატორები
                
                ტოლობის და იგივეობის ოპერატორები ორივე აბრუნებს true-ს, ტუ შესადარებელი მნიშვნელობები ტოლია. მაგრამ მათ შორის არის არსებითი განსხვავება. თუ ტოლობის ოპერაციაში მონაწილეობენ სხვადასხვა ტიპის ცვლადები, ერთ-ერთი მათგანი გარდაიქმნება მეორე ცვლადის ტიპში იმის მიხედვით, როგორც ჩათვლის ოპტიმალურად ინტერპრეტატორი. მაგალითად:
                
                <?php
                $a = "22a";
                $b = 22;
                if($a==$b)
                    echo "ტოლია";
                else
                    echo "არაა ტოლი";
                ?>
                ცხადად ჩანს, რომ ცვლადები ინახავენ სხვადასხვა ტიპის სხვადასხვა მნიშვნელობას. მაგრამ შედარების დროს ინტერპრეტატორი $a ცვლადს გადაიყვანს რიცხვით ტიპში, რის შედეგადაც იგი გახდება 22-ის ტოლი. საბოლოოდ, ორივე ცვლადი იქნება ტოლი და შედარების შედეგად დაბრუნდება true.
                
                ან მეორე მაგალითი, აქაც ცვლადების მნიშვნელობები ასევე იქნება ტოლი:
                
                $a = false;
                $b = 0;
                ასეთი სიტუაციების თავიდან ასაცილებლად გამოიყენება იგივეობის ოპერატორი, რომელიც ითვალისწინებს არა მხოლოდ მნიშვნელობას, არამედ ცვლადის ტიპსაც:
                
                <?php
                $a = "22a";
                $b = 22;
                if($a===$b)
                    echo "ტოლია";
                else
                    echo "არაა ტოლი";
                ?>
                ახლა უკვე ცვლადები არ იქნება ტოლი. 
                
                ანალოგიურად მუშაობენ უტოლობის ოპერატორები: != და !==.
                
                ლოგიკური ოპერაციები
                
                ლოგიკური ოპერაციები ძირითადად გამოიყენება შედარების ოპერაციების შედეგების გასაერთიანებლად. გვაქვს შემდეგი ლოგიკური ოპერაციები:
                
                && აბრუნებს true-ს, თუ ორივე შედარების ოპერაცია აბრუნებს true-ს, წინააღმდეგ შემთხვევაში აბრუნებს false-ს: $a == 5 && $b = 6;
                and ანალოგიურია && ოპერაციის: $a == 5 and $b > 6;
                || აბრუნებს true-ს, თუ შედარების ერთ-ერთი ოპერაცია მაინც აბრუნებს true-ს, წინააღმდეგ შემთხვევაში აბრუნებს false-ს: $a == 5 || $b = 6;
                or ანალოგიურია || ოპერაციის: $a == 5 or $b > 6;
                ! აბრუნებს true-ს, თუ შედარების ოპერაცია აბრუნებს false-ს: !($a >= 5);
                xor აბრუნებს true-ს, თუ შედარების მხოლოდ ერთი ოპერაცია აბრუნებს true-ს. თუ ორივე აბრუნებს true-ს ან არც ერთი არ აბრუნებს true-ს, მაშინ ოპერაცია აბრუნებს false-ს. მაგალითად:
                <?php
                $a=12;
                $b=6;
                if($a xor $b)
                    echo 'true';
                else
                    echo 'false';
                ?>
                აქ ლოგიკური ოპერაციის შედეგი იქნება false, რადგან ორივე ცვლადს გააჩნია მნიშვნელობა და შესაბამისად, ორივე დააბრუნებს true-ს. შევცვალოთ კოდი:
                
                <?php
                $a=12;
                $b=NULL;
                if($a xor $b)
                    echo 'true';
                else
                    echo 'false';
                ?>
                ახლა უკვე ლოგიკური ოპერაცია დააბრუნებს true-ს, ვინაიდან ერთ-ერთი ცვლადის მნიშვნელობა არის NULL. თუ ცვლადის მნიშვნელობა NULL-ის ტოლია, ლოგიკურ ოპერაციებში მისი მნიშვნელობა იქნება false.
                
                ბიტური ოპერაციები
                
                ბიტური ოპერაციები სრულდება რიცხვის ცალკეულ ბიტებზე. რიცხვები განიხილება ორობით სისტემაში. მაგალითად 2 ორობით სისტემაში იქნება 010, 7 - 111 და ა. შ.
                
                & ლოგიკური გამრავლება. გამრავლება ხორციელდება თანრიგების მიხედვით. თუ ორივე ოპერანდს მოცემულ თანრიგში აქვს 1, შედეგი იქნება 1, წინააღმდეგ შემთხვევაში - 0. მაგალითად:
                <?php
                $a1 = 4; //100
                $b1 = 5; //101
                echo $a1 & $b1; // 4
                ?>
                რიცხვი 4 ორობით წარმოდგენაში არის 100, 5 - 101. თანრიგების მიხედვით გამრავლებით ვიღებთ (1*1=1, 0*0=0, 0*1=0) 100, ანუ 4-ს ორობით სისტემაში.
                
                | ლოგიკური შეკრება. შეკრება ხორციელდება თანრიგების მიხედვით. თუ ერთ-ერთ ოპერანდს მაინც მოცემულ თანრიგში აქვს 1, შედეგი იქნება 1, წინააღმდეგ შემთხვევაში - 0. მაგალითად:
                <?php
                $a1 = 4; //100
                $b1 = 5; //101
                echo $a1 | $b1; // 5
                ?>
                << - x<<y წაანაცვლებს x რიცხვს მარცხნივ y თანრიგით. მგალითად, 4<<1 წაანაცვლებს რიცხვს 4 (რომელიც ორობით სისტემაში არის 100) ერთი თანრიგით მარცხნივ და მივიღებთ 1000 ანუ ათობით სისტემაში 8-ს;
                >> - x>>y წაანაცვლებს x რიცხვს მარჯვნივ y თანრიგით. მგალითად, 16>>1 წაანაცვლებს რიცხვს 16 (რომელიც ორობით სისტემაში არის 10000) ერთი თანრიგით მარჯვნივ და მივიღებთ 1000 ანუ ათობით სისტემაში 8-ს;
                სტრიქონების გაერთიანება
                
                სტრიქონების გაერთიანება ხდება წერტილის მეშვეობით:
                
                <?php
                $a="გამარჯობა, ";
                $b=" სამყაროვ";
                echo $a . $b . "!";  //გამარჯობა, სამყაროვ!
                ?>
                თუ ცვლადები არ წარმოადგენენ სტრიქონებს, ისინი ჯერ გარდაიქმნებიან სტრიქონებად და შემდეგ მოხდება მათი გაერთიანება.`
            },
            {
                title:"პირობითი კონსტრუქციები",
                data:`კონსტრუქცია if .. else

                კონსტრუქცია if(პირობა) ამოწმებს გარკვეულ პირობას და თუ პირობა აღმოჩნდება ჭეშმარიტი, სრულდება გამოსახულებათა ბლოკი, რომელიც მოსდევს if ბლოკს. თუ პირობა მცდარია, if ბლოკის შემდგომი გამოსახულებების ბლოკი არ სრულდება. მაგალითად:
                
                <?php
                $a = 4;
                $b = 2;
                if($a>0)
                {
                    $result= $a * $b;
                    echo "შედეგია: $result <br>";
                }
                echo "პროგრამის დასასრული";
                ?>
                გამოსახულებათა ბლოკი ექცევა ფიგურულ ფრჩხილებში. რადგანაც მოცემულ შემთხვევაში პირობა ჭეშმარიტია, ფიგურულ ფრჩხილებში მოქცეული გამოსახულებები შესრულდება. თუ $a ნაკლები იქნებოდა 0-ზე, პირობა იქნებოდა მცდარი და შესაბამისად, ფიგურულ ფრჩხილებში მოქცეული გამოსახულებები არ შესრულდებოდა.
                
                თუ პირობის ჭეშმარიტებისას შესასრულებელია მხოლოდ ერთი მოქმედება, შესაძლებელია იგი ჩავწეროთ ფიგურული ფრჩხილების გარეშეც:
                
                <?php
                $a = 4;
                $b = 2;
                if($a>0)
                    echo $a * $b."<br>";
                echo "პროგრამის დასასრული";
                ?>
                შეიძლება მთელი კონსტრუქციის ერთ სტრიქონში მოქცევა:
                
                if($a>0) echo $a * $b."<br>";
                else
                
                ბლოკი else შეიცავს ინსტრუქციას, რომელიც შესრულდება როცა if ბლოკში მოცემული პირობა არაა ჭეშმარიტი (უდრის false-ს):
                
                <?php
                $a = 4;
                $b = 2;
                if($a>0)
                {
                    echo $a * $b;
                }
                else
                {
                    echo $a / $b;
                }
                echo "პროგრამის დასასრული";
                ?>
                თუ $a მეტია 0-ზე, სრულდება ბლოკი if, თუ არა და - ბლოკი else.
                
                რადგანაც მოცემულ მაგალითში ორივე ბლოკში ტიტო გამოსახულებაა, შეგვიძლია არ გამოვიყენოთ ფიგურული ფრჩხილები:
                
                if($a>0)
                    echo $a * $b;
                else
                    echo $a / $b;
                elseif
                
                კონსტრუქცია elseif-ს შეაქვს პროგრამაში დამატებითი პირობა:
                
                <?php
                $a = 5;
                $b = 2;
                if($a<0)
                {
                    echo $a * $b;
                }
                elseif($a==0)
                {
                    echo $a + $b;
                }
                elseif($a==5)
                {
                    echo $a - $b;
                }
                else
                {
                    echo $a / $b;
                }
                ?>
                შეიძლება დაემატოს რამდენიმე elseif  ბლოკი. თუ არცერთი if და elseif პირობა არ სრულდება, მაშინ შესრულდება else ბლოკი.
                
                კონსტრუქცია switch .. case
                
                კონსტრუქცია switch .. case წარმოადგენს if .. elseif .. else კონსტრუქციის ალტერნატივას. მაგალითად:
                
                <?php
                $a = 1;
                if($a==1)     echo "შეკრება";
                elseif($a==2) echo "გამოკლება";
                elseif($a==3) echo "გამრავლება";
                elseif($a==4) echo "გაყოფა";
                ?>
                ამის ეკვივალენტური იქნება შემდეგი:
                
                <?php
                $a = 1;
                switch($a)
                {
                    case 1:
                        echo "შეკრება";
                        break;
                    case 2:
                        echo "გამოკლება";
                        break;
                    case 3:
                        echo "გამრავლება";
                        break;
                    case 4:
                        echo "გაყოფა";
                        break;
                }
                ?>
                switch საკვანძო სიტყვის შემდეგ მოდის შესადარებელი გამოსახულება. ამ გამოსახულების მნიშვნელობა თანმიმდევრობით დარდება სხვადასხვა მნიშვნელობებს, რომლებიც დგანან case საკვანძო სიტყვის შემდეგ. თუ თანხვედრა მოიძებნება, სრულდება შესაბამისი ბლოკი case.
                
                case ბლოკის ბოლოსი იწერება break, რათა თავიდან იქნეს აცილებული დანარჩენი ბლოკების შესრულება.
                
                თუ ჩვენ ასევე გვინდა იმ სიტუაციის დამუშავება, როცა თანხვედრა არ მოიძებნება, შეიძლება დავამატოთ ბლოკი default:
                
                <?php
                $a = 1;
                switch($a)
                {
                    case 1:
                        echo "შეკრება";
                        break;
                    case 2:
                        echo "გამოკლება";
                        break;
                    default:
                        echo "მოქმედება თანხვედრის არარსებობისას";
                        break;
                }
                ?>
                ტერნარული ოპერაცია
                
                ტერნარული ოპერაცია შედგება სამი ოპერაციისგან და აქვს შემდეგი სახე: [პირველი ოპერანდი - პირობა] ? [მეორე ოპერანდი ] : [მესამე ოპერანდი ]. პირობიდან გამომდინარე ტერნარული ოპერაცია აბრუნებს მეორე ან მესამე ოპერანდს. თუ პირობა ჭეშმარიტია, ბრუნდება მეორე ოპერანდი, თუ მცდარია - ბრუნდება მესამე ოპერანდი. მაგალითად:
                
                <?php
                $a = 1;
                $b = 2;
                $z = $a < $b ? $a + $b : $a - $b;
                echo $z;
                ?>
                თუ $a ნაკლებია $b -ზე, პირობა ჭეშმარიტია, შესაბამისად $z-ს მიენიჭება მნიშვნელობა $a + $b, თუ არა და - $a - $b.`
            },
            {
                title:"ციკლები",
                data:`განმეორებადი ოპერაციების შესასრულებლად PHP-ში, ისევე როგორც პროგრამირების სხვა ენებში, გამოიყენება ციკლები. PHP-ში არსებობს შემდეგი სახის ციკლები:

                for
                while
                do .. while
                ციკლი for
                
                for ციკლს აქვს შემდეგი სახე:
                
                for ([მრიცხველის ინიციალიზაცია]; [პირობა]; [მრიცხველის შეცვლა])
                {
                    // მოქმედებები
                }
                განვიხილოთ სტანდარტული ციკლი:
                
                <?php
                for ($i = 1; $i < 10; $i++)
                {
                    echo "რიცხვი $i-ის კვადრატი უდრის " . $i * $i . "-ს<br/>";
                }
                ?>
                ციკლის გამოცხადების პირველი ნაწილი $i = 1 ახდენს მრიცხველის $i გამოცხადებას და მის ინიციალიზაციას (საწყისი მნიშვნელობის მინიჭებას). შინაარსობრივად ეს იგივეა, რაც ცვლადის გამოცხადება და ინიციალიზაცია.
                
                მეორე ნაწილი არის პირობა, რომლის დროსაც ციკლის მოქმედებები შესრულდება. მოცემულ შემთხვევაში ციკლი სრულდება მანამ, სანამ $i იქნება 10-ზე ნაკლები.
                
                მესამე ნაწილი - მრიცხველის ცვლილება, მოცემულ შემთხვევაში მრიცხველი იზრდება 1-ით. არაა აუცილებელი, რომ მრიცხველი იზრდებოდეს 1-ით, შეიძლება სხვა სიდიდითაც. ასევე შესაძლებელია მრიცხველი გაზრდის ნაცვლად მცირდებოდეს ($i--).
                
                ციკლის ბლოკი იმუშავებს 9-ჯერ, სანამ მრიცხველის $i-ს მნიშვნელობა არ მიაღწევს 10-ს. თითოეულ ჯერზე მრიცხველი გაიზრდება 1-ით. ციკლის თითოეულ განმეორებას იტერაცია ეწოდება. მაშასადამე, მოცემულ შემთხვევაშო გვექნება 9 იტერაცია.
                
                ციკლი while
                
                ციკლი while ამოწმებს გარკვეულ პირობას და თუ პირობა ჭეშმარიტია, სრულდება ციკლის მოქმედებათა ბლოკი:
                
                <?php
                $counter = 1;
                while($counter<10)
                {
                    echo $counter * $counter . "<br />";
                    $counter++;
                }
                ?>
                თუ ციკლის მოქმედებათა ბლოკში მხოლოდ ერთი მოქმედებაა, ფიგურული ფრჩხილების გამოყენება აუცილებელი არაა:
                
                <?php
                $counter = 0;
                while(++$counter<10)
                    echo $counter * $counter . "<br />";
                ?>
                ციკლი do .. while
                
                ციკლი do .. while ჰგავს while ციკლს, ოღონდ ამ შემთხვევაში ჯერ სრულდება ციკლის ბლოკი, ხოლო მერე მოწმდება პირობა. შესაბამისად, პირობა რომ თავიდანვე მცდარი იყოს, მოქმედებათა ბლოკი ერთხელ მაინც შესრულდება:
                
                <?php
                $counter = 1;
                do
                {
                    echo $counter * $counter . "<br />";
                    $counter++;
                }
                while($counter<10)
                ?>
                ოპერატორები continue და break
                
                ხანდახან საჭიროა გამოვიდეთ ციკლიდან მის დასრულებამდე. ამისათვის გამოიყენება ოპერატორი break:
                
                <?php
                for ($i = 1; $i < 10; $i++)
                {
                    $result = $i * $i;
                    if($result>80)
                    {
                        break;
                    }
                    echo "$i რიხვის კვადრატი ტოლია $result <br/>";
                }
                ?>
                თუ ოპერაციის შედეგი მეტი იქნება 80-ზე, ციკლის შესრულება შეწყდება, ანუ მოხდება ციკლიდან გამოსვლა.
                
                ციკლების მართვისთვის ასევე გამოიყენება ოპერატორი continue. ის ახორციელებს ციკლის მომდევნო იტერაციაზე გადასვლას, ანუ მოხდება ერთი იტერაციის გამოტოვება:
                
                <?php
                for ($i = 1; $i < 10; $i++)
                {
                    if($i==5)
                    {
                        continue;
                    }
                    echo "$i რიხვის კვადრატი ტოლია ".$i * $i."<br/>";
                }
                ?>
                ციკლის შესრულებისას, როცა $i გახდება 5-ის ტოლი, მოხდება მომდევნო იტერაციაზე გადასვლა, ხოლო ის მოქმედებები, რომლებიც continue ოპერატორს მოსდევს, არ შესრულდება.`
            },
            {
                title:"ფუნქციები",
                data:`ფუნქცია წარმოადგენს გარკვეული მოქმედების შემსრულებელი ინსტრუქციების  ნაკრებს. 

                ფუნქციის განსაზღვრის სინტაქსი არის შემდეგი სახის:
                
                function ფუნქციის_სახელი([პარამეტრი [, ...]])
                {
                    // ინსტრუქციები
                }
                ფუნქციის განსაზღვრა იწყება საკვანძო სიტყვით function, რასაც მოსდევს ფუნქციის სახელი. ფუნქციის სახელი უნდა იწყებოდეს ლატინური ანბანის სიმბოლოთი ან გახაზვის სიმბოლოთი (_), რასაც მოსდევს ალფავიტურ-ციფრული სიმბოლოებისა და გახაზვის სიმბოლოს ნებისმიერი რაოდენობა.
                
                ფუნქციის სახელის მერე ფრჩხილებში იწერება პარამეტრების ჩამონათვალი. თუ ფუნქციას არ გააცნია პარამეტრები, ცარიელი ფრჩხილები მაინც იწერება. შემდეგ ფიგურულ ფრჩხილებში მოდის ფუნქციის სხეული, სადაც არის ინსტრუქციების ერთობლიობა.
                
                განვსაზღვროთ უმარტივესი ფუნქცია:
                
                function display()
                {
                    echo " display () ფუნქციის გამოძახება";
                }
                ამ ფუნქციას არ გააჩნია პარამეტრები და ყველაფერი, რასაც ის აკეთებს არის, რომ გამოაქვს გარკვეული შეტყობინება.
                
                ფუნქცია რომ შესრულდეს, საჭიროა მისი გამოძახება. გამოვიძახოთ მოცემული ფუნქცია:
                
                <?php
                display();
                 
                function display()
                {
                    echo " display () ფუნქციის გამოძახება";
                }
                ?>
                მნიშვნელობის დაბრუნება. ოპერატორი return
                
                ფუნქცია შეიძლება აბრუნებდეს გარკვეულ მნიშვნელობას - რიცხვს, სტრიქონს და ა. შ., ანუ გარკვეულ შედეგს. ფუნქციის მნიშვნელობის დასაბრუნებლად გამოიყენება ოპერატორი return, რომლის შემდეგ მოდის დასაბრუნებელი მნიშვნელობა.მაგალითად:
                
                <?php
                $a = get();
                echo "1-დან 9-მდე რიცხვების კვადრატების ჯამი ტოლია $a";
                 
                function get()
                {
                    $result = 0; // დასაბრუნებელი მნიშვნელობა
                    for($i = 1; $i<10; $i++)
                    {
                        $result+= $i * $i;
                    }
                    return $result;
                }
                ?>
                ფუნქცია get() აბრუნებს რიცხვს, რომელიც ტოლია 1-დან 9-მდე რიცხვების კვადრატების ჯამის. ეს რიცხვი ინახება ცვლადში $result. return ოპერატორის მეშვეობით დათვლილი რიცხვი ბრუნდება ფუნქციის შედეგის სახით, რომელიც შეიძლება მივანიჭოთ რამე ცვლადს: $a=get().
                
                პარამეტრების გამოყენება
                
                შევქმნათ ფუნქცია პარამეტრებით:
                
                <?php
                $a = get(1, 10);
                echo "1-დან 9-მდე რიცხვების კვადრატების ჯამი ტოლია $a";
                 
                function get($lowlimit, $highlimit)
                {
                    $result = 0; // დასაბრუნებელი მნიშვნელობა
                    for($i = $lowlimit; $i < $highlimit; $i++)
                    {
                        $result+= $i * $i;
                    }
                    return $result;
                }
                ?>
                რადგანაც ახლა უკვე ფუნქციას გააცნია პარამეტრები, გამოძახების დროს საჭიროა ამ პარამეტრების დაგილას გადავცეთ მნიშვნელობები. თუ გამოძახებისას ყველა პარამეტრის ადგილზე არ გადავცემთ მნიშვნელობებს, ეს გამოიწვევს შეცდომას, მაგალითად არასწორია ასეთი გამოძახება $a=get(1);.
                
                მაგრამ შეიძლება პარამეტრებს ჰქონდეს მნიშვნელობა მიუთითებლობისას (ნაგულისხმევი მნიშვნელობა). მაგალითად:
                
                <?php
                function get($lowlimit, $highlimit=10)
                {
                    $result = 0; // დასაბრუნებელი მნიშვნელობა
                    for($i = $lowlimit; $i < $highlimit; $i++)
                    {
                        $result+= $i * $i;
                    }
                    return $result;
                }
                 
                $a = get(1);
                echo "კვადრატების ჯამი ტოლია $a";
                ?>
                ახლა უკვე ფუნქციის გამოძახება შესაძლებელია მეორე პარამეტრის გარეშე და თუ არ იქნება იგი მითითებული, ის მიიღებს ნაგულისხმევ მნიშვნელობას, ანუ 10-ს.
                
                პარამეტრის გადაცემა ბმულით
                
                წინა მაგალითებში ფუნქციას პარამეტრად გადავცემდით მნიშვნელობას. მაგრამ PHP-ში არის პარამეტრების გადაცემის სხვა გზაც - პარამეტრის გადაცემა ბმულის მეშვეობით. განვიხილოთ პარამეტრის გადაცემის ორი სხვადასხვა სახე და შევადაროთ. სტანდარტულად პარამეტრის გადაცემა გამოიყურება შემდეგნაირად:
                
                <?php
                $number = 10;
                get($number);
                echo "<br /> \$number ტოლია: $number";
                 
                function get($a)
                {
                    $a*=$a;
                    echo "კვადრატი ტოლია: $a";
                }
                ?>
                get() მეთოდის გამოძახების შემდეგ $number ცვლადის მნიშვნელობა არ იცვლება, ვინაიდან ფუნქციას გადაეცემა ცვლადის მნიშვნელობა. ახლა ვნახოთ პარამეტრის გადაცემა ბმულის სახით: 
                
                <?php
                $number = 10;
                get($number);
                echo "<br /> \$number ტოლია: $number";
                 
                function get(&$a)
                {
                    $a*=$a;
                    echo "კვადრატი ტოლია: $a";
                }
                ?>
                ბმულის სახით პარამეტრის გადასაცემად ფუნქციის განსაზღვრისას პარამეტრის წინ იწერება ამპერსანდი (&). ახლა უკვე ინტერპრეტატორი ფუნქციას გადასცემს არა ცვლადის მნიშვნელობას, არამედ ამ ბმულს ამ ცვლადზე მეხსიერებაში. შედეგად ცვლადი $number  პარამეტრის &$a-ს ადგილას გადაცემისას ასევე შეიცვლება.`
            },
            {
                title:"ცვლადების ხედვის არე",
                data:`ცვლადების და ფუნქციების გამოყენებისას გასათვალისწინებელია ცვლადების ხედვის არე. ხედვის არე ეს - არის ცვლადის მოქმედების არე, სადაც ხელმისაწვდომია მოცემული ცვლადი.

                ლოკალური ცვლადები
                
                ლოკალური ცვლადები იქმნება ფუნქციის შიგნით და მათზე მიმართვა შეიძლება მხოლოდ იმ ფუნქციაში, რომელსიც შეიქმნა. მაგალითად:
                
                <?php
                function get($lowlimit, $highlimit)
                {
                    $result = 0; // დასაბრუნებელი მნიშვნელობა
                    for($i = $lowlimit; $i < $highlimit; $i++)
                    {
                        $result+= $i * $i;
                    }
                    return $result;
                }
                $a = $result; // ასე არ შეიძლება, რადგან $result ლოკალური ცვლადია
                echo "1-დან 9-მდე რიცხვების კვადრატების ჯამი ტოლია $a";
                ?>
                მოცემულ შემთხვევაში get() ფუნქციაში განსაზღვრულია ლოკალური ცვლადი $result. საერთო კონტექსტიდან მასზე მიმართვა არ შეიძლება, ანუ რომ დავწეროთ $a = $result, ეს გამოიწვევს შეცდომას, რადგან $result შეიქმნა get() ფუნქციის შიგნით და მასზე მიმართვა შეიძლება მხოლოდ ამ ფუნქციაში. ფუნქციის გარეთ $result არ არსებობს.
                
                იგივე ეხება ფუნქციის პარამეტრებსაც: ფუნქციის გარეთ ასევე არ არსებობს ფუნქციის პარამეტრები $lowlimit და $highlimit.
                
                როგორც წესი, ლოკალური ცვლადები გამოიყენება გამოთვლების შუალედური შედეგების შესანახად.
                
                სტატიკური ცვლადები
                
                ლოკალური ცვლადების მსგავსია სტატიკური ცვლადებიც. ისინი განსხვავდებიან იმით, რომ სტატიკური ცვლადების მნიშვნელობები ფუნქციის მუშაობის დასრულების შემდეგ ინახება. ფუნქციის ყოველი მომდევნო გამოძახებისას გამოიყენება სტატიკური ცვლადის მიერ წინა შესრულებისას მიღებული მნიშვნელობა. მაგალითად:
                
                <?php
                function getCounter()
                {
                    static $counter = 0;
                    $counter++;
                    echo $counter;
                }
                getCounter(); // counter=1
                getCounter(); // counter=2
                getCounter(); // counter=3
                ?>
                იმისათვის, რომ მივუთითოთ, რომ ცვლადი სტატიკურია, მის წინ იწერება საკვანძო სიტყვა static. getCounter() ფუნქციის ზედიზედ სამჯერ გამოძახებისას ცვლადი $counter გაიზრდება თითო ერთეულთ.
                
                თუ ცვლადი არ იქნებოდა სტატიკური, იგი ყოველი შესრულებისას შეიქმნებოდა თავიდან და მისი მნიშვნელობა იქნებოდა 0-ის ტოლი, შესაბამისად ფუნქცია ყოველ ჯერზე დააბრუნებდა 1-ს.
                
                როგორც წესი, სტატიკური ცვლადები გამოიყენება სხვადასხვა მრიცხველების შესაქმნელად, როგორც ზემოთ განხილულ მაგალითში.
                
                გლობალური ცვლადები
                
                ხანდახან საჭიროა, რომ ცვლადი იყოს წელმისაწვდომი ყველგან, ანუ გლობალურად. ასეთი ცვლადები ინახავენ მთელი პროგრამისთვის საერთო მონაცემებს. გლობალური ცვლადების შესაქმნელად გამოიყენება საკვანძო სიტყვა global:
                
                <?php
                function getGlobal()
                {
                    global $gvar;
                    $gvar = 20;
                    echo "$gvar <br />";
                }
                getGlobal();
                echo $gvar;
                ?>
                getGlobal()  ფუნქციის გამოძახების მერე გლობალურ ცვლადზე $gvar მიმართვა შესაძლებელია პროგრამის ნებისმიერი ადგილიდან.`
            },
            {
                title:"გარე ფაილების ჩართვა",
                data:`თუ პროგრამა პატარაა და კოდი ცოტაა, ყველა ოპერაცია შეიძლება განისაზღვროს ერთ ფაილში. მაგრამ როგორც წესი, პროგრამა უამრავი ინსტრუქციისაგან შედგება. თუ ყველაფერს მოვათავსებთ ერთ ფაილში, კოდი მეტისმეტად უზარმაზარი გამოჩნდება. ამიტომ ხშირად კოდის ცალკეულ ფრაგმენტებს ანაწილებენ სხვადასხვა ფაილში, განსაკუთრებით მაშინ, თუ ცალკეული ფრაგმენტების გამოყენება PHP-ის სხვა პროგრამებიდანაცაა საჭირო.

                ინსტრუქცია include
                
                ინსტრუქცია include პროგრამაში ჩართავს გარე ფაილს php კოდით. მაგალითად, შევქმნათ ფაილი factorial.php:
                
                <?php
                function getFactorial($n)
                {
                    $result=1;
                    for($i=1; $i <= $n; $i++)
                        $result*=$i;
                    return $result;
                }
                ?>
                აქ ხდება რიცხვის ფაქტორიალის გამოთვლა. ახლა ჩავრთოთ ეს ფაილი ჩვენს პროგრამაში:
                
                <?php
                include "factorial.php";
                 
                $a = 5;
                $fact = getFactorial($a);
                echo "$a რიცხვის ფაქტორიალი ტოლია $fact";
                ?>
                include ინსტრუქციის განსაზღვრის ადგილას ჩაისმება factorial.php ფაილის მთელი კოდი. ამასთან, ფაილის ცასმა უნდა მოხდეს უფრო ადრე, ვიდრე მასში განსაზღვრული ფუნქციების გამოყენება.
                
                ინსტრუქცია include_once
                
                include ინსტრუქციის გამოყენებას აქვს თავისი ნაკლოვანებები. თუ კოდის სხვადასხვა ადგილას ერთი და იგივე ფაილს შემთხვევით რამდენჯერმე ჩავსვამთ, ეს გამოიწვევს შეცდომას. 
                
                ფაილის განმეორებით თავიდან ასაცილებლად გამოიყენება ინსტრუქცია include_once:
                
                <?php
                include_once "factorial.php";
                 
                $a = 5;
                $fact = getFactorial($a);
                echo "$a რიცხვის ფაქტორიალი ტოლია $fact";
                ?>
                ახლა უკვე თუ შემთხვევით იფგივე ფაილს სხვაგანაც ჩავრთავთ include_once საკვანძო სიტყვის მეშვეობით, ეს ჩართვა იქნება იგნორირებული, რადგან ფაილი უკვე ჩართულია.
                
                ინსტრუქციები require და require_once
                
                require ინსტრუქციის მოქმედება include-ს მსგავსია: ის ასევე ემსახურება გარე ფაილის ჩართვას პროგრამაში. განსხვავება ისაა, რომ თუ ფაილი არ მოიძებნა, პროგრამის მუშაობა შეწყდება.
                
                <?php
                require "factorial.php";
                ?>
                თუ ერთი და იგივე ფაილი რამდენჯერმე იქნება ჩართული require ინსტრუქციის მეშვეობით, ინტერპრეტატორი დააბრუნებს შეცდომას. ამის თავიდან ასაცილებლად გვაქვს ინსტრუქცია require_once:
                
                <?php
                require_once "factorial.php";
                ?>`
            },
            {
                title:"მასივები",
                data:`მასივები განკუთვნილია მონაცემთე ან ელემენტთა ერთობლიობის შესანახად. მასივის თითოეულ ელემენტს გააცნია უნიკალური გასაღები და მნიშვნელობა. მაგალითად, შევინახოთ მასივში ტელეფონის მოდელები:

                <?php
                $phones[0] = "Nokia N9";
                $phones[1] = "Samsung Galaxy ACE II";
                $phones[2] = "Sony Xperia Z3";
                $phones[3] = "Samsung Galaxy III";
                 
                for($i=0;$i<count($phones);$i++)
                    echo "$phones[$i] <br />";
                ?>
                აქ იქმნება მასივი $phones, რომელიც ოთხი ელემენტისგან შედგება. მასივის თითოეული ელემენტი წარმოადგენს გასაღები - მნიშვნელობა სახის წყვილს. ასე მაგალითად, პირველი ელემენტს $phones[0] = "Nokia N9" გააჩნია გასაღები - რიცხვი 0 და მნიშვნელობა - სტრიქონი "Nokia N9". ასეთ მასივებში გასაღებს ასევე ეწოდება ინდექსი.
                
                count() ფუნქციის მეშვეობით ჩვენ შეგვიძლია გავიგოთ მასივის ელემენტთა რაოდენობა. იმის გამო, რომ მასივში ინდექსები იწყება 0-დან და მოდის თანმიმდევრობით, for ციკლის მეშვეობით შეგვიძლია გამოვიტანოთ მასივის ყველა ელემენტი.
                
                უფრო გასაგები რომ იყოს დამოკიდებულება მასივის ელემენტის გასაღებსა და მნიშვნელობას შორის, მასივის ელემენტები გამოვიტანოთ print_r ფუნქციის მეშვეობით:
                
                print_r($phones);
                მივიღებთ ასეთ შედეგს:
                
                Array ( [0] => Nokia N9 [1] => Samsung Galaxy ACE II [2] => Sony Xperia Z3 [3] => Samsung Galaxy III )
                მასივის შექმნა შეიძლება ასევე შემდეგნაირად:
                
                <?php
                $phones[] = "Nokia N9";
                $phones[] = "Samsung Galaxy ACE II";
                $phones[] = "Sony Xperia Z3";
                $phones[] = "Samsung Galaxy III";
                 
                for($i=0;$i<count($phones);$i++)
                    echo "$phones[$i] <br />";
                ?>
                თუ მასივის შექმნისას გასაღებებს არ მივუთითებთ, PHP ავტომატურად იყენებს რიცხვებს, რომელთა ნუმერაცია იწყება 0-დან. შესაბამისად, ასეთი სახით შექმნილი მასივი წინა მაგალითში შექმნილის ეკვივალენტური იქნება.
                
                თუ ვიცით ელემენტის გასაღები, შეგვიძლია ამ ელემენტზე მიმართვა და მნიშვნელობის მიღება ან შეცვლა:
                
                // მივიღოთ ელემენტი გასაღების 1 მიხედვით
                $myPhone = $phones[1];
                echo "$myPhone <br />";
                // მივანიჭოთ ახალი მნიშვნელობა
                $phones[1] = "Samsung X650";
                echo "$phones[1] <br />";
                გასაღებად შეიძლება გამოვიყენოთ არა მხოლოდ მთელი რიცხვები, არამედ სტრიქონებიც:
                
                <?php
                $phones["nokia"] = "Nokia N9";
                $phones["samsumg"] = "Samsung Galaxy III";
                $phones["sony"] = "Sony Xperia Z3";
                $phones["apple"] = "iPhone5";
                echo $phones["samsumg"];
                ?>
                ასეთ მასივებს ასევე უწოდებენ ასოციაციურ მასივებს.
                
                ოპერატორი array
                
                ზემოთ განვიხილეთ მასივის შექმნის ერთი ხერხი. არსებობს მეორეც array ოპერატორის გამოყენებით:
                
                <?php
                $phones = array('iPhone', 'Samsung Galaxy S III', 'Nokia N9', 'Sony XPeria Z3');
                echo $phones[1];
                ?>
                ოპერატორი array() პარამეტრად იღებს ელემენტების ერთობლიობას. რადგანაც ამ შემთხვევაში გასაღებები არ ეთითება, PHPავტომატურად მიანიჭებს გასაღებად მთელ რიცხვებს, დაწყებული 0-დან. თუმცა შესაძლებელია გასაღებების მითითებაც:
                
                <?php
                $phones = array("apple"=>"iPhone5", "samsumg"=>"Samsung Galaxy III",
                                    "nokia" => "Nokia N9", "sony" => "Sony XPeria Z3");
                echo $phones["samsumg"];
                ?>
                ოპერაცია => საშუალებას იძლევა განვსაზღვროთ წყვილი გასაღები - მნიშვნელობა.
                
                ასოციაციური მასივების გადარჩევა
                
                ზემოთ ვნახეთ მასივის ყველა ელემენტის გამოტანა for ციკლის მეშვეობით. ასეთი სახით მასივის ელემენტების გადარჩევა შესაძლებელია მხოლოდ მაშინ, როცა გასაღებები წარმოადგენენ მთელ რიცხვებს. ასიციასიური მასივების შემთხვევაში ეს მეთოდი არ გამოდგება. მათთვის PHP-ში განკუთვნილია ციკლის სპეციალური ფორმა foreach:
                
                <?php
                $phones = array("apple"=>"iPhone5",
                                "samsumg"=>"Samsung Galaxy III",
                                "nokia" => "Nokia N9",
                                "sony" => "Sony XPeria Z3");
                foreach($phones as $item)
                    echo "$item <br />";
                ?>
                foreach ციკლში ხდება მასივის ელემენტების თანმიმდევრული ამოღება და მინიჭება ცვლადზე, რომელი მოსდევს საკვანძო სიტყვას as. მოცემულ შემთხვევაში $item ცვლადს რიგრიგობით ენიჭება მასივის ოთხივე ელემენტის მნიშვნელობა. როცა მოხდება ბოლო ელემენტის ამოღება, ციკლი სრულდება.
                
                foreach ციკლის მეშვეობით შესაძლებელია არა მხოლოდ ელემენტების მნიშვნელობების, არამედ გასაღებების მიღებაც:
                
                <?php
                $phones = array("apple"=>"iPhone5",
                                "samsumg"=>"Samsung Galaxy III",
                                "nokia" => "Nokia N9",
                                "sony" => "Sony XPeria Z3");
                foreach($phones as $key=>$value)
                    echo "$key => $value <br />";
                ?>
                აქ ელემენტების გადარჩევის დროს $key ცვლადს გადაეცემა ელემენტის გასაღები, ხოლო $value-ს - ელემენტის მნიშვნელობა.
                
                foreach ფუნქციის ალტერნატივაა list .. each ფუნქციის გამოყენება:
                
                <?php
                $phones = array("apple"=>"iPhone5",
                                "samsumg"=>"Samsung Galaxy III",
                                "nokia" => "Nokia N9",
                                "sony" => "Sony XPeria Z3");
                while (list($key, $value) = each($phones))
                    echo "$key => $value <br />";
                ?>
                while ციკლი იმუშავებს მანამ, სანამ each ფუნქცია არ დააბრუნებს false-ს. ფუნქცია each გაივლის მასივის ყველა ელემენტს და ელემენტის გასაღებს და მნიშვნელობას გადასცემს list ფუნქციას, რომელიც თავის მხრივ $key ცვლადს მიანიჭებს ელემენტის გასაღებს, ხოლო $values-ს - ელემენტის მნიშვნელობას.
                
                მრავალგანზომილებიანი მასივები
                
                წინა მაგალითებში ჩვენ განვიხილეთ ერთგანზომილებიანი მასივები, სადაც მასივის ელემენტის მნიშვნელობები იყო რიცხვები, სტრიქონები. თუმცა PHP-ში შეიძლება მრავალგანზომილებიანი მასივების გამოყენებაც, სადაც მასივის ელემენტების მნიშვნელობები თავადაც მასივებს წარმოადგენენ. მაგალითად, შევქმნათ მრავალგანზომილებიანი მასივი:
                
                <?php
                $phones = array(
                        "apple"=> array("iPhone5", "iPhone5s", "iPhone6") ,
                        "samsumg"=>array("Samsung Galaxy III", "Samsung Galaxy ACE II"),
                        "nokia" => array("Nokia N9", "Nokia Lumia 930"),
                        "sony" => array("Sony XPeria Z3", "Xperia Z3 Dual", "Xperia T2 Ultra"));
                foreach ($phones as $brand => $items)
                {
                    echo "<h3>$brand</h3>";
                    echo "<ul>";
                    foreach ($items as $key => $value)
                    {
                        echo "<li>$value</li>";
                    }
                    echo "</ul>";
                }
                ?>
                შედეგად ბრაუზერში გამოვა 4 სია:
                
                PHP
                
                იმისათვის, რომ მივმართოთ მასივში ელემენტად შემავალი მასივის ელემენტს, ასევე გამოიყენება გასაღები. მაგალითად, მივმართოთ პირველი მასივის პირველ ელემენტს. პირველი მასივის გასაღები არის "apple", ხოლო მისი პირველი ელემენტისა - 0 (რადგანაც ჩვენ არ მიგვითითებია გასაღებები შემავალი მასივებისთვის, მათი გასაღებები იქნება მთელი რიცხვები დაწყებული 0-დან). შესაბამისად, ელემენტს უნდა მივმართოთ შემდეგნაირად:
                
                echo $phones["apple"][0];
                ანალოგიურად, თუ გვინდა მივიღოთ მესამე მასივის მეორე ელემენტი, უნდა დავწეროთ:
                
                echo $phones["nokia"][1];
                შეიძლება შემავალი მასივებიც იყოს ასოციაციური მასივები:
                
                <?php
                $technics = array(
                        "phones" => array("apple" => "iPhone5",
                                    "samsumg" => "Samsung Galaxy III",
                                    "nokia" => "Nokia N9"),
                        "tablets" => array("lenovo" => "Lenovo IdeaTab A3500",
                                        "samsung" => "Samsung Galaxy Tab 4",
                                        "apple" => "Apple iPad Air"));
                foreach ($technics as $tovar => $items)
                {
                    echo "<h3>$tovar</h3>";
                    echo "<ul>";
                    foreach ($items as $key => $value)
                    {
                        echo "<li>$key : $value</li>";
                    }
                    echo "</ul>";
                }
                // მივანიჭოთ ერთ-ერთ ელემენტს სხვა მნიშვნელობა
                $technics["phones"]["nokia"] = "Nokia Lumnia 930";
                // გამოვიტანოთ ეს მნიშვნელობა
                echo $technics["phones"]["nokia"];
                ?>`
            },
            {
                title:"ოპერაციები მასივებზე",
                data:`ფუნქცია is_array ამოწმებს, წარმოადგენს თუ არა ცვლადი მასივს. თუ წარმოადგენს, ბრუნდება true, წინააღმდეგ შემთხვევაში - false:

                $isar = is_array($technics);
                echo ($isar==true)?"ეს მასივია":"ეს მასივი არაა";
                ფუნქციები count და sizeof
                
                ფუნქციები count და sizeof აბრუნებს მასივის ელემენტების რაოდენობას:
                
                $number = count($technics);
                // იგივეა, რაც
                // $number = sizeof($technics);
                echo "მასივში technics $number ელემენტია";
                ფუნქცია shuffle
                
                ფუნქცია shuffle გადაანაცვლებს მასივის ელემენტებს შემთხვევითი თანმიმდევრობით:
                
                <?php
                $os = array("Windows 95", "Windows XP", "Windows Vista", "Windows 7", "Windows 8", "Windows 10");
                shuffle($os);
                print_r($os);
                // ერთ-ერთი შესაძლო ვარიანტი
                // Array ( [0] => Windows 95 [1] => Windows 7 [2] => Windows Vista [3] => Windows XP [4] => Windows 10 [5] => Windows 8)
                ?>
                ფუნქცია compact
                
                ფუნქცია compact საშუალებას გვაძლევს მონაცემთა ერთობლიობიდან შევქმნათ ასოციაციური მასივი, სადაც გასაღები იქნება თვითონ ცვლადის სახელი:
                
                <?php
                $model = "Apple II";
                $producer = "Apple";
                $year = 1978;
                 
                $data = compact('model', 'producer', 'year');
                print_r($data);
                // მივიღებთ შემდეგს
                // Array ( [model] => Apple II [producer] => Apple [year] => 1978 )
                ?>
                ფუნქცია compact ფრჩხილების შიგნით იღებს ცვლადების სახელების ერთობლიობას. თიტოეული ცვლადი მიეთითება ბრჭყალებში $ სიმბოლოს გარეშე. ფუნქციის შედეგია ახალი მასივი.
                
                მასივის სორტირება
                
                PHP-ში გვაქვს მასივის სორტირების 2 ტიპი: სტრიქონების სორტირება ანბანის მიხედვით და რიცხვების სორტირება ზრდადობით/კლებადობით. თუ დასასორტირებელია სტრიქონები, სორტირება ხდება ანბანის მიხედვით, თუ რიცხვები - ზრდადობის მიხედვით. მიუთითებლობისას PHP თვითონ ირჩევს სორტირების შესაბამის ტიპს.
                
                ზრდადობის მიხედვით სორტირებისთვის გამოიყენება ფუნქცია asort:
                
                <?php
                $tablets = array("lenovo" => "Lenovo IdeaTab A3500",
                                        "samsung" => "Samsung Galaxy Tab 4",
                                        "apple" => "Apple iPad Air");
                asort($tablets);
                 
                echo "<ul>";
                foreach ($tablets as $key => $value)
                {
                    echo "<li>$key : $value</li>";
                }
                echo "</ul>";
                ?>
                მოცემულ შემთხვევაში მასივის ელემენტების მნიშვნელობები წარმოადგენენ სტრიქონებს, ამიტომ სორტირება მოხდება ანბანის მიხედვით. თუმცა დამატებითი პარამეტრების მეშვეობით შეგვიძლია ცხადად მივუთითოთ სორტირების ტიპი. ამ პარამეტრს გააჩნია სამი შესაძლო მნიშვნელობა:
                
                SORT_REGULAR: სორტირების ავტომატური არჩევა
                SORT_NUMERIC: რიცხვითი სორტირება
                SORT_STRING: სორტირება ანბანით
                მივუთითოთ სორტირების ტიპი ცხადად:
                
                asort($tablets, SORT_STRING);
                მასივის საწინააღმდეგო მიმარTულებით სორტირებისთვის გამოიყენება ფუნქცია arsort:
                
                arsort($tablets);
                სორტირება გასაღებებით
                
                ფუნქცია asort ახდენს მასივის სორტირებას ელემენტების მნიშვნელობების მიხედვით. ასევე შეიძლება მასივის სორტირება გასაღებების მიხედვით, ამისთვის გამოიყენება ფუნქციები ksort და krsort:
                
                ksort($tablets, SORT_STRING);
                დაღმავლობით სორტირება:
                
                krsort($tablets, SORT_STRING);
                ბუნებრივი სორტირება
                
                თუმცა ზემოთ აღწერილი ფუნქციები მშვენივრად ასრულებენ თავის მოვალეობებს, მათი შესაძლებლობები მაინც არ არის საკმარისი. მაგალითად, დავასორტიროთ აღმავლობით შემდეგი მასივი:
                
                <?php
                $os = array("Windows 7", "Windows 8", "Windows 10");
                asort($os);
                print_r($os);
                // შედეგი
                // Array ( [2] => Windows 10 [0] => Windows 7 [1] => Windows 8 )
                ?>
                რადგანაც ელემენტების მნიშვნელობები სტრიქონებია, PHP მათ სორტირებას ახდენს ანბანის მიხედვით. მაგრამ ასეთი სორტირება არ ითვალისწინებს რიცხვებს და რეგისტრებს. ამიტომაც მნიშვნელობა "Windows 10" აღმოჩნდება თავში და არა ბოლოში, როგორც იქნებოდა უმჯობესი. ამ პრობლემის გადასაწყვეტად PHP-ში არის ფუნქცია natsort(), რომელიც ახორციელებს ბუნებრივ სორტირებას:
                
                <?php
                $os = array("Windows 7", "Windows 8", "Windows 10");
                natsort($os);
                print_r($os);
                // შედეგი
                // Array ( [0] => Windows 7 [1] => Windows 8 [2] => Windows 10)
                ?>
                თუ გვინდა ამავე დროს რეგისტრის გათვალისწინებაც, უნდა გამოვიყენოთ ფუნქცია natcasesort():
                
                natcasesort($os);`
            },
             
            ]
        },
        {
            title:"თავი 3. პარამეტრების გადაცემა. ფორმებთან მუშაობა",
            content:[
                {
                    title:"ფორმების დამუშავება. მეთოდი POST",
                    data:`ვებგვერდისთვის ინფორმაციის გადაცემის ერთ-ერთი უმთავრესი სახეა ფორმების დამუშავება. ფორმა წარმოადგენს html-ის სპეციალურ ელემენტს, რომელიც შეიცავს ინფორმაციის შეყვანის სხვადასხვა ელემენტებს: ტექსტურ ველებს, ღილაკებს და ა. შ. ფორმის მეშვეობით ჩვენ შეგვიძლია შევიყვანოთ გარკვეული მონაცემები და გავაგზავნოთ სერვერზე შემდგომი დამუშავებისთვის.

                    ფორმის შექმნა მოიცავს შემდეგ საფეხურებს:
                    
                    <form></form> ელემენტის შექმნა html-ში;
                    ერთი ან რამდენიმე შეყვანის ველის დამატება;
                    მონაცემთა გადაცემის მეთოდის მინიჭება: GET,POST;
                    მისამართის დადგენასადაც გაიგზავნება შეყვანილი მონაცემები.
                    შევქმნათ ფორმა. ამისათვის შევქმნათ ახალი ფაილი form.php და მოვათავსოთ მასში შემდეგი კოდი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                    <meta charset="utf-8">
                    </head>
                    <body>
                    <h3>საიტზე შესვლა</h3>
                    <form action="login.php" method="POST">
                        მომხმარებელი: <input type="text" name="login" /><br><br>
                        პაროლი: <input type="text" name="password" /><br><br>
                        <input type="submit" value="შესვლა">
                    </form>
                    </body>
                    </html>
                    ფორმის ატრიბუტი action="login.php" მიუთითებს იმაზე, რომ მონაცემების დამუშავება მოხდება login.php სკრიპტის მიერ., რომელიც უნდა იმყოფებოდეს form.php ფაილთან ერთ საქაღალდეში. ხოლო ატრიბუტი method="POST" მიუთითებს იმაზე, რომ მონაცემთა დამუშავებისთვის გამოყენებული იქნება მეთოდი POST.
                    
                    ახლა შევქმნათ ფაილი login.php:
                    
                    <?php
                    $login = "უცნობი";
                    $password = "უცნობი";
                    if(isset($_POST['login'])) $login = $_POST['login'];
                    if (isset($_POST['password'])) $password = $_POST['password'];
                     
                    echo "თქვენი მომხმარებელია: $login  <br> თქვენი პაროლია: $password";
                    ?>
                    ფორმის მონაცემების მისაღებად გამოიყენება გლობალური ცვლადი $_POST.ის წარმოადგენს მონაცემთა ასოციაციურ მასივს, რომელიც გადაიცემა POST მეთოდით. გასაღებების გამოყენებით ჩვენ შეგვიძლია მივიღოთ გამოგზავნილი მონაცემები. გასაღების როლში გამოდის ფორმის ველების name ატრიბუტის მნიშვნელობები.
                    
                    რადგანაც მომხმარებლის სახელის შესაყვან ველს name ატრიბუტის მნიშვნელობა აქვს login (<input type="text" name="login" />), $_POST მასივში ამ ველის შესაბამისი ელემენტის გასაღები იქნება 'login',შესაბამისად მისი მნიშვნელობის მიღება შეიძლება შემდეგნაირად: $_POST['login'].
                    
                    რადგანაც შეიძლება იყოს სიტუაცია, როცა შეყვანის ველში არაა მნიშვნელობა შეყვანილი, ამიტომ მონაცემთა მიღებამდე და დამუშავებამდე სასურველია შემოწმდეს მათი არსებობა isset() ფუნქციის მეშვეობით. თუ მნიშვნელობა შეყვანილია, ფუნქცია აბრუნებს true-ს.
                    
                    ახლა შეგვიძლია მივმართოთ ფორმას:
                    
                    PHP
                    
                    ღილაკზე დაჭერისას ფორმაში შეყვანილი მონაცემები POST მეთოდით გაეგზავნება login.php სკრიპტს:
                    
                    PHP
                    
                    არაა აუცილებელი ფორმის მონაცემების გაგზავნა სხვა სკრიპტისთვის, შესაძლებელია მატი დამუშავება იმავე ფაილში. ამისატვის შევცვალოთ ფაილი form.php შემდეგნაირად:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                    <meta charset="utf-8">
                    </head>
                    <body>
                    <div>
                    <?php
                    if(isset($_POST['login']) && isset($_POST['password'])){    
                        $login=$_POST['login']; 
                        $password = $_POST['password']; 
                        echo "თქვენი მომხმარებელია: $login  <br> თქვენი პაროლია: $password";    
                    }
                    ?>
                    </div>
                    <h3>საიტზე შესვლა</h3>
                    <form method="POST">
                        მომხმარებელი: <input type="text" name="login" /><br><br>
                        პაროლი: <input type="text" name="password" /><br><br>
                        <input type="submit" value="შესვლა">
                    </form>
                    </body>
                    </html>
                     
                    
                    PHP
                    
                    მონაცემთა უსაფრთხოება
                    
                    PHP-ში დიდი მნიშვნელობა აქვს მონაცემთა უსაფრთხოების ონრგანიზებას. განვიხილოთ რამდენიმე მარტივი მექანიზმი, რომლებიც დაგვეხმარება ჩვენი ვებგვერდის უსაფრთხოების დაცვაში.
                    
                    ზემოთ განხილულ მაგალითში ვცადოთ გარკვეული მონაცემების შეყვანა. მაგალითად, მომხმარებელში ჩავწეროთ "<script>alert(hi);</script>", ხოლო პაროლში - "<h2>password</h2>".. გაგზავნის მერე html კოდში ჩანერგილი იქნება ჯავასკრიპტი, რომელსაც გამოაქვს შეტყობინება. მსგავსი პრობლემის აღმოსაფხვრელად გამოიყენება ფუნქცია htmlentities():
                    
                     
                    
                    if(isset($_POST['login']) && isset($_POST['password'])){    
                        $login=htmlentities($_POST['login']);
                        $password = htmlentities($_POST['password']);
                        echo "თქვენი მომხმარებელია: $login  <br> თქვენი პაროლია: $password";    
                    }
                    ახლა უკვე html-ის ან JavaScript-ის კოდის შეყვანისას, მოხდება ყველა ტეგის ეკრანირება და მივიღებთ ასეთ შედეგს:
                    
                    PHP
                    
                    კიდევ ერთი ფუნქცია strip_tags() საშუალებას იძლევა საერთოდ მოვაშოროთ html ტეგები:
                    
                    if(isset($_POST['login']) && isset($_POST['password'])){    
                        $login=strip_tags($_POST['login']);
                        $password = strip_tags($_POST['password']);
                        echo "თქვენი მომხმარებელია: $login  <br> თქვენი პაროლია: $password";    
                    }`
                },
                {
                  title:"მონაცემების მიღება მოთხოვნის სტრიქონიდან. მეთოდი GET",
                  data:`მონაცემების სერვერზე გაგზავნის მეორე გავრცელებულ ფორმას წარმოადგენს მეთოდი GET. მისი არსი მდგომარეობს იმაში, რომ მონაცემები გადაიცემა ბრაუზერის მისამართის სტრიქონის მეშვეობით.

                  შევქმნათ მარტივი სკრიპტი get.php შემდეგი კოდით:
                  
                  <?php
                  $name = "არაა განსაზღვრული";
                  $age = "არაა განსაზღვრული";
                  if(isset($_GET['name'])){ 
                      $name = $_GET['name'];
                  }
                  if(isset($_GET['age'])){ 
                      $age = $_GET['age'];
                  }
                      echo "თქვენი სახელია: $name <br> თქვენი ასაკია: $age";
                  ?>
                  PHP-ში განსაზღვრულია გლობალური ასოციაციური მასივი $_GET, რომელიც ინახავს ყველა მნიშვნელობას, რაც გადაეცემა მოთხოვნის სტრიქონში. მისი მოქმედება $_POST მასივის ანალოგიურია: აქაც გასაღების მიხედვით შეგვიძლია მნიშვნელობის გაგება.
                  
                  ახლა მივმართოთ შექმნილ სკრიპტს, მაგალითად ასე: http://localhost:8080/get.php?name=Tom&age=27:
                  
                  PHP
                  
                  პარამეტრების გადასაცემად სკრიპტის სახელის შემდეგ ისმება კითხვის ნიშანი, რასაც მოსდევს პარამეტრების პარამეტრი = მნიშვნელობა წყვილები, რომლებიდ ერთმანეთისაგან გამოიყოფა ამპერსანდით (&). პარამეტრის დასახელება იქნება გასაღები $_GET მასივში.
                  
                  GET მეთოდით შესაძლებელია ფორმის მონაცემების გაგზავნაც. ამისათვის საკმარისია ფორმას მივუთითოთ ატრიბუტი method="get". ამ შემთხვევაში ფორმაში შეყვანილი მონაცემები გაიგზავნება მოთხოვნის სტრიქონის მეშვეობით:
                  
                  <form method="GET">
                      მომხმარებელი: <input type="text" name="login" /><br><br>
                      პაროლი: <input type="text" name="password" /><br><br>
                      <input type="submit" value="გაგზავნა">
                  </form>`
              },
              {
                title:"ფორმის ველებთან მუშაობა",
                data:`ფორმები შეიცავენ სხვადასხვა ელემენტებს მონაცემების შესაყვანად - ტექსტური ველები, ალმები, გადამრთველები და ა. შ. მათ დამუშავებას გააცნია თავისებურებები.

                ალმების დამუშავება
                
                ალმებს ანუ ჩეკბოქსებს (checkbox) გააჩნიათ ორი მდგომარეობა - ჩართული (checked) და ამორთული. მაგალითად:
                
                დამახსოვრება: <input type="checkbox" name="remember" checked="checked" />
                 
                
                PHP
                
                თუ ალამი ამორთულ მდგომარეობაშია, მაგალითდ:
                
                დამახსოვრება: <input type="checkbox" name="remember" />
                ფორმის გაგზავნისას ალმის მონაცემები სერვერზე არ იგზავნება.
                
                თუ ალამი ჩართულია, მაშინ სერვერზე გაგზავნისას remember ველისთვის გადაეცემა მნიშვნელობა on:
                
                $remember = $_GET['remember'];
                თუ მნიშვნელობა on არ გვაწყობს, შეგვიძლია value ატრიბუტის მეშვეობით შეგბიძლია მივანიჭოთ სასურველი მნიშვნელობა:
                
                დამახსოვრება: <input type="checkbox" name="remember" value=1/>
                ხანდახან საჭიროა ალმების ნაკრების შექმნა,შადაც შესაძლებელია რამდენიმეს მონიშვნა. მაგალითდ:
                
                ASP.NET: <input type="checkbox" name="technologies[]" value="ASP.NET" />
                PHP: <input type="checkbox" name="technologies[]" value="PHP" />
                RUBY: <input type="checkbox" name="technologies[]" value="Ruby" />
                ასეთ დროს name ატრიბუტის მნიშვნელობას უნდა ჰქონდეს კვადრატული ფრცხილები, რის შედეგადაც სერვერზე გაიგზავნება მონიშნული მნიშვნელობების მასივი:
                
                $technologies = $_POST['technologies'];
                foreach($technologies as $item) echo "$item<br />";   
                მოცემულ შემთხვევაში ცვლადი $technologies  წარმოადგენს მასივს.
                
                გადამრთველები
                
                გადამრთველები ანუ რადიობუტონები საშუალებას იძლევიან გავაკეთოთ არჩევანი რამდენიმე ურთიერთგამომრიცხავი ვარიანტიდან:
                
                <input type="radio" name="course" value="ASP.NET" />ASP.NET <br>
                <input type="radio" name="course" value="PHP" />PHP <br>
                <input type="radio" name="course" value="Ruby" />RUBY <br>
                 
                
                PHP
                
                სერვერზე გადაეცემა არჩეული გადამრთველის value ატრიბუტის მნიშვნელობა. 
                
                if(isset($_POST['course']))
                {
                    $course = $_POST['course'];
                    echo $course;
                }
                სია
                
                სია წარმოდგენილია select ელემენტის სახით, რომელშიც შესაძლებლობა გვაქვს ავირჩიოთ ერთი ან რამდენიმე ელემენტი:
                
                <select name="course" size="1">
                <option value="ASP.NET">ASP.NET</option>
                <option value="PHP">PHP</option>
                <option value="Ruby">RUBY</option>
                <option value="Python">Python</option>
                </select>
                ელემენტი <select> შეიცავს რამდენიმე ელემენტს არჩევისთვის:
                
                PHP
                
                ახლა მივიღოთ არჩეული ელემენტი:
                
                <?php
                    if(isset($_POST['course']))
                    {
                        $course = $_POST['course'];
                        echo $course;
                    }
                ?>
                ელემენტი <select> ასევე იძლევა საშუალებას ავირჩიოთ რამდენიმე ელემენტი. ამ შემთხვევაში მონაცემების დამუშავება შეიცვლება, რადგან სერვერმა უნდა მიიღოს მასივი:
                
                <select name="courses[]" size="4" multiple="multiple">
                <option value="ASP.NET">ASP.NET</option>
                <option value="PHP">PHP</option>
                <option value="Ruby">RUBY</option>
                <option value="Python">Python</option>
                </select>
                ასეთ სიებს აქვთ ატრიბუტი multiple="multiple". მასივის გადასაგზავნად name ატრიბუტს ემატება ბოლოსი კვადრატული ფრჩხილები: name="course[]".
                
                PHP
                
                ახლა მივიღოთ PHP-ში არჩეული მნიშვნელობები:
                
                <?php
                if(isset($_POST['courses']))
                {
                    $courses = $_POST['courses'];
                    foreach($courses as $item) echo "$item<br>";
                }
                ?>`
            },
            {
                title:"ფორმის დამუშავების მაგალითი",
                data:`ვნახოთ ფორმის დამუშავების კომპლექსური მაგალითი, რომელშიც გავაერთიანებთ მონაცემთა შეყვანის სხვადასხვა ელემენტებს. განვსაზღვროთ ასეთი ფორმა:

                <form action="input.php" method="POST">
                <p>შეიყვანეთ სახელი:<br>
                <input type="text" name="firstname" /></p>
                <p>სწავლების ფორმა: <br>
                <input type="radio" name="eduform" value="დასწრებული" />დასწრებული <br>
                <input type="radio" name="eduform" value="დაუსწრებელი" />დაუსწრებელი </p>
                <p>სჭირდება საერთო საცხოვრებელი:<br>
                <input type="checkbox" name="hostel" />დიახ</p>
                <p>აირჩიეთ კურსები: <br>
                <select name="courses[]" size="5" multiple="multiple">
                    <option value="ASP.NET">ASP.NET</option>
                    <option value="PHP">PHP</option>
                    <option value="Ruby">RUBY</option>
                    <option value="Python">Python</option>
                    <option value="Java">Java</option>
                </select></p>
                <p>მოკლე კომენტარი: <br>
                <textarea name="comment" maxlength="200"></textarea></p>
                <input type="submit" value="არჩევა">
                </form>
                 
                
                PHP
                
                ახლა შევქმნათ სკრიპტი input.php, რომელიც დაამუშავებს ამ ფორმას:
                
                <?php
                if(isset($_POST['firstname']) && isset($_POST['eduform']) &&
                    isset($_POST['comment']) && isset($_POST['courses']))
                {
                    $name = htmlentities($_POST['firstname']);
                    $eduform = htmlentities($_POST['eduform']);
                    $hostel = "არა";
                    if(isset($_POST['hostel'])) $hostel = "დიახ";
                    $comment = htmlentities($_POST['comment']);
                    $courses = $_POST['courses'];
                    $output ="
                    <html>
                    <head>
                    <title>საანკეტო მონაცემები</title>
                    </head>
                    <body>
                    სახელი: $name<br />
                    სწავლების ფორმა: $eduform<br />
                    სჭირდება საერთო საცხოვრებელი: $hostel<br />
                    არჩეული კურსები:
                    <ul>";
                    foreach($courses as $item)
                        $output.="<li>" . htmlentities($item) . "</li>";
                    $output.="</ul></body></html>";
                    echo $output;
                }
                else
                {  
                    echo "შეყვანილი მონაცემები არასწორია";
                }
                ?>
                `
            },
         
             
            ]
        },
        {
            title:"თავი 4. PHP-ის საბაზისო შესაძლებლობები",
            content:[
                {
                    title:"სტრიქონებთან მუშაობა",
                    data:`სტრიქონებთან მუშაობას ძალიან დიდი მნიშვნელობა აქვს, რადგან ხსირად ხდება საჭირო მისი პარსირება, ამიტომ განვიხილოთ სტრიქონებთან მუშაობის საბაზისო ფუნქციები. სანამ სტრიქონებთან მუშაობას შევუდგებოდეთ, გავხსნათ php.ini ფაილი და მოვძებნოთ მასსი სტრიქონი:

                    ;extension=php_mbstring.dll
                    მოვაშოროთ წერტილმძიმე დასაწყისში, რითაც მოხდება მისი ამოკომენტარება. რადგანაც php.ini ფაილი შეიცვალა, საჭიროა Apache ვებსერვერის ხელახლა გაშვება.
                    
                    php_mbstring.dll გაფართოების ჩართვა საშუალებას გვაძლევს გამოვიყენოთ სტრიქონებთან მუშაობის დამატებითი ფუნქციები, რომლებიც PHP-ის სტანდარტულ ნაკრებში არ შედის.
                    
                    ფუნქციები strpos() და mb_strpos()
                    
                    ფუნქცია strpos($str, $search) აბრუნებს $search სტრიქონის ან სიმბოლოს პოზიციას $str სტრიქონში. თუ $str სტრიქონი არ შეიცავს $search-ს, მაშინ ფუნქცია აბრუნებს false-ს:
                    
                    <?php
                    $input = 'This is the end';
                    $search = 'is';
                    $position = strpos($input, $search); // 2
                    if($position!==false)
                    {
                        echo "'$input' სტრიქონში '$search' ქვესტრიქონის პოზიციაა: $position";
                    }
                    ?>
                    ამ ფუნქციის გამოყენებისას უნდა გავითვალისწინოთ, რომ სიმბოლოების ინდექსაცია იწყება 0-დან. შესაბამისად, T სიმბოლოს პოზიცია იქნება 0. გამომდინარე აქედან, შედარება $position != false არ იქნება კორექტული, ვინაიდან false და 0-ის ერთ ტიპამდე დაყვანისას მათ ერთნაირი მნიშვნელობა ექნებათ. ამიტომ აუცილებლად უნდა გამოვიყენოთ ეკვივალენტობის ოპერაციები: $position !== false ან $position === false.
                    
                    <?php
                    $input = 'თეთრი რაში';
                    $search = 'რი';
                    $position = strpos($input, $search); // 9
                    if($position!==false)
                    {
                        echo "'$input' სტრიქონში '$search' ქვესტრიქონის პოზიციაა: $position";
                    }
                    ?>
                    ვნახავთ, რომ ფუნქცია დააბრუნებს 9-ს, თუმცა უნდა დაებრუნებინა 3. საქმე იმაშია, რომ მოცემული ფუნქცია არაკორექტულად მუშაობს უნიკოდის სიმბოლოებთან. ასეთ შემთხვევაში გამოიყენება ფუნქცია mb_strpos().
                    
                    <?php
                    $input = 'თეთრი რაში';
                    $search = 'რი';
                    $position = mb_strpos($input, $search); // 3
                    if($position!==false)
                    {
                        echo "'$input' სტრიქონში '$search' ქვესტრიქონის პოზიციაა: $position";
                    }
                    ?>
                    ფუნქცია strrpos() da mb_strrpos()
                    
                    ფუნქცია strrpos() strpos() ფუნქციის ანალოგიურია, ოღონდ ეძებს ქვესტრიქონის არა პირველ, არამედ ბოლო თანხვედრას:
                    
                    $input = 'This is the end';
                    $search = 'is';
                    $position = strrpos($input, $search); // 5
                    უნიკოდის სიმბოლოების შემთხვევაში გამოიყენება ფუნქცია mb_strrpos().\:
                    
                    $position = mb_strrpos($input, $search);
                    ფუნქცია trim()
                    
                    ფუნქცია trim() აშორებს სტრიქონს ცარიელ სიმბოლოს და სამართავ სიმბოლოებს ('\n', '\r', '\t'):
                    
                    $input = '  Hello, World!  ';
                    $input = trim($input);
                    რეგისტრის შეცვლა
                    
                    სტრიქონის დაბალ რეგისტრში გადასაყვანად გამოიყენება ფუნქცია strtolower():
                    
                    $input = 'The World is Mine';
                    $input = strtolower($input);
                    თუ სტრიქონი შეიცავს უნიკოდის სიმბოლოებს (მაგალითად, რუსულ კირიკიცას), უნდა გამოვიყენოთ ფუნქცია mb_strtolower:
                    
                    $input = mb_strtolower($input);
                    მაღალ რეგისტრში გადასაყვანად გამოიყენება ფუნქციები strtoupper() და mb_strtoupper().
                    
                    ფუნქცია strlen()
                    
                    ფუნქცია strlen() აბრუნებს სტრიქონის სიგრძეს ანუ სიმბოლოების რაოდენობას სტრიქონში:
                    
                    $input = 'Hello world';
                    $num = strlen($input);
                    echo $num;
                    უნიკოდის სიმბოლოების შემთხვევაში უნდა გამოვიყენოთ ფუნქცია mb_strlen():
                    
                    $input = 'Hello world';
                    $num = mb_strlen($input);
                    echo $num;
                    ქვესტრიქონის მიღება
                    
                    substr($str, $start [, $length]) ფუნქციის გამოყენებით შეგვიძლია მივიღოთ სტრიქონის გარკვეული ნაწილი. მოცემული ფუნქცია ამოჭრის საწყისი სტრიქონიდან ქვესტრიქონს დაწყებული $start  პოზიციიდან ბოლომდე (თუ დამატებიტი პარამეტრი არაა მითითებული), ან $length-ში მითითებული რაოდენობის სიმბოლოებს:
                    
                    <?php
                    $input = 'The world is mine!';
                    $subinput1 = substr($input, 2);
                    $subinput2 = substr($input, 2, 6);
                    echo $subinput1;
                    echo "<br />";
                    echo $subinput2;
                    ?>
                    უნიკოდის სიმბოლოების შემთხვევაში გამოიყენება ფუნქცია mb_substr:
                    
                    $subinput1 = mb_substr($input, 2);
                    $subinput2 = mb_substr($input, 2, 6);
                    ქვესტრიქონების ამოცვლა
                    
                    სტრიქონის გარკვეული ნაწილის ამოსაცვლელად გამოიყენება ფუნქცია str_replace($old, $new, $input). ეს ფუნქცია $input სტრიქონში შემავალ ყველა $old ქვესტრიქონს ამოცვლის $new ქვესტრიქონით:
                    
                    <?php
                    $input = 'კატა და თაგვი, მგელი და კრავი';
                    $input = str_replace("და", "ან", $input);
                    echo $input;
                    ?>`
                },
                {
                  title:"ქუქებთან მუშაობა",
                  data:`ქუქები (cookie) წარმოადგენს მონაცემთა მცირე (არაუმეტეს 4 კილობაიტისა), რომელთა მეშვეობით ვებგვერდი მომხმარებლის კომპიუტერზე ინახავს ნებისმიერ ინფორმაციას. ქუქების მეშვეობით შესაძლებელია თვალი მივადევნოთ საიტზე მომხმარებლის აქტივობას: არის თუ არა დალოგინებული, რომელი გვერდები დაათვალიერა და ა. შ.

                  ქუქების შენახვა
                  
                  მომხმარებლის კომპიუტერზე ქუქების შესანახად გამოიყენება ფუნქცია setcookie(). მას აქვს შემდეგი სინტაქსი:
                  
                  bool setcookie(string $name, string $value, int $expire,
                          string $path, string $domain, bool $secure, bool $httponly);
                  ფუნქციამ შეიძლება, მიიღოს შემდეგი პარამეტრები:
                  
                  name: cookie-ს სახელი, რომელსაც გამოვიყენებთ მასზე მიმართვისთვის;
                  value: cookie-ს მნიშვნელობა - ნებისმიერი ტექსტი, არაუმეტეს 4 კილობაიტისა;
                  expire (არააუცილებელი პარამეტრი): მოქმედების ვადა, რომლის შემდეგაც cookie ნადგურდება. თუ ეს პარამეტრი არ გადაეცემა ან მისი მნიშვნელობა 0-ის ტოლია, წაიშლება ბრაუზერის დახურვის შემდეგ;
                  path (არააუცილებელი პარამეტრი): საქაღალდე სერვერზე, რომლისთვისაც იქნება ხელმისაწვდომი ეს ქუქი. თუ მისი მნიშვნელობაა '/', ქუქი ხელმისაწვდომი იქნება მთელი საიტისთვის. მაგალითად, თუ მივუთითებთ მნიშვნელობად '/mydir/', ქუქი ხელმისაწვდომი იქნება mydir საქაღალდიდან და ყველა მის შიგნით არსებული საქაღალდეებიდან. მიუთითებლობისას მას ენიჭება მიმდინარე საქაღალდის მნიშვნელობა. 
                  domain (არააუცილებელი პარამეტრი): უთითებს დომენს, რომლისთვისაც მოქმედებს ქუქი. მაგალითად, თუ დომენი მეორე დონისაა, მაგალითად test.com, ქუქი ხელმისაწვდომი იქნება ამ დომენისთვის და ყველა მისი ქვედომენისთვის, მაგალითად blog.test.com. თუ მითითებულია ქვედომენი, მაშინ მხოლოდ ამ ქვედომენისთვის;
                  secure (არააუცილებელი პარამეტრი): მიუთითებს, რომ ქუქი უნდა გადაეცეს HTTPS პროტოკოლით. მიუთითებლობისას მისი მნიშვნელობაა false;
                  httponly (არააუცილებელი პარამეტრი): თუ მნიშვნელობაა true, cookie ხელმისაწვდომი იქნება მხოლოდ http პროტოკოლით. ანუ არ იქნება ხელმისაწვდომი სკრიპტული ენებისთვის, მაგალითად JavaScript-სთვის. მიუთითებლობისას მნიშვნელობაა false.
                  შევინახოთ ქუქი:
                  
                  $value1 = "სინგაპური";
                  $value2 = "ჩინური";
                  setcookie("city", $value1);
                  setcookie("language", $value2, time()+3600);  // მოქმედების ვადა 1 სთ
                  აქ ხდება ორი ქუქის შენახვა: "city" და "language". პირველი იშლება ბრაუზერის დახურვისთანავე, მეორე კი 3600 წამის, ანუ 1 საათის შემდეგ.
                  
                  ქუქებში შესაძლებელია ნებისმიერი ინფორმაციის შენახვა, მაგრამ არაა მიზანშეწონილი უსაფრთხოებისთვის მნიშვნელოვანი ინფორმაციის, მაგალითად პაროლების, შენახვა. თუ მაინც შევინახავთ ასეთ ინფორმაციას, უნდა შევინახოთ დაშიფრულად.
                  
                  ქუქების მიღება (ამოკითხვა)
                  
                  ქუქების ამოსაკითხად უნდა გამოვიყენოთ გლობალური ასოციაციური მასივი $_COOKIE, მაგალითად $_COOKIE["city"].  ასე მივიღებთ ადრე შენახულ ქუქს, რომელსაც მოქმედების ვადა არ გასვლია:
                  
                  if (isset($_COOKIE['city'])) echo "ქვეყანა: " . $_COOKIE["city"] . "<br>";
                  if (isset($_COOKIE['language'])) echo "ენა: " . $_COOKIE["language"];
                  მასივების შენახვა ქუქებში
                  
                  ქუქებში მასივების შენახვას გააჩნია თავისებურებები. მაგალითად, შევინახოთ ასეთი მასივი:
                  
                  setcookie("lan[1]", "PHP");
                  setcookie("lan[2]", "C#");
                  setcookie("lan[3]", "Java");
                  ახლა კი ამოვიკითხოთ და გამოვიტანოთ ვებგვერდზე:
                  
                  if (isset($_COOKIE['lan'])) {
                      foreach ($_COOKIE['lan'] as $name => $value) {
                          $name = htmlspecialchars($name);
                          $value = htmlspecialchars($value);
                          echo "$name. $value <br />";
                      }
                  }
                  ქუქების წაშლა
                  
                  ქუქების წასაშლელად საკმარისია მის მოქმედების ვადაში მივუთითოთ წარსული დრო, მაგალითად:
                  
                  setcookie ("city", "", time() - 3600);`
              },
              {
                title:"სესიები",
                data:`სესია წარმოადგენს მონაცემთა ნაკრებს, რომელიც ინახება სერვერზე (ან ნაწილი ინახება სერვერზე, ნაწილი კი - ბრაუზერის ქუქებში) და რომლებიც განკუთვნილია მხოლოდ მიმდინარე მომხმარებლისთვის. რაღაც ნაწილში, სესია წარმოადგენს ქუქების ალტერნატივას მომხმარებლის შესახებ ინფორმაციის შენახვისთვის.

                სესიის გასაშვებად უნდა გამოვიძახოთ ფუნქცია session_start(). 
                
                მონაცემების შესანახად და ამოსაკითხათ უნდა გამოვიყენოთ გლობალური ასოციაციური მასივი $_SESSION. შენახვა ხდება შემდეგნაირად:
                
                $_SESSION['ცვლადის სახელი'] = $ცვლადი;
                შენახული მნიშვნელობის ამოკითხვა ხდება შემდეგნაირად:
                
                $ცვლადი = $_SESSION['ცვლადის სახელი'];
                გავუშვათ სესია და შევინახოთ მონაცემები:
                
                session_start();
                $_SESSION['city'] = "სინგაპური";
                $_SESSION['lang'] = "ჩინური";
                ახლა ამოვიკითხოთ შენახული ინფორმაცია და გამოვიტანოთ ვებგვერდზე:
                
                if (isset($_SESSION['city']) && isset($_SESSION['lang']))
                {
                    $city = $_SESSION['city'];
                    $language = $_SESSION['lang'];
                    echo "ქალაქი: $city <br /> ენა: $language";
                }
                სესიის გაშვებისას მას ენიჭება უნიკალური იდენტიფიკატორი. ეს იდენტიფიკატორი ქუქების მეშვეობით ინახება ბრაუზერში. სპეციალური ფუნქციების მეშვეობით ჩვენ შეგვიძლია მივიღოთ ეს იდენტიფიკატორი:
                
                echo session_id(); // სესიის იდენტიფიკატორი
                echo session_name();  // სახელი - PHPSESSID
                სესიის იდენტიფიკატორის მიღება შესაძლებელია უშუალოდ ქუქებიდანაც:
                
                echo $_COOKIE['PHPSESSID'];
                სესიის დახურვა
                
                სესია იხურება ბრაუზერის დახურვისთანავე. თუმცა შესაძლებელია ამის გაკეთება პროგრამულადაც session_destroy() ფუნქციის მეშვეობით:
                
                session_start();
                 
                $_SESSION = array();
                // ქუქის წაშლა სესიის იდენტიფიკატორით
                if (session_id() != "" || isset($_COOKIE[session_name()]))
                   setcookie(session_name(), '', time()-2592000, '/');
                session_destroy();
                სესიის დახურვისთვის ჯერ $_SESSION მასივს ენიჭება ცარიელი მასივი, შემდეგ იშლება ქუქებიდან ჩანაწერი სესიის იდენტიფიკატორით და ბოლოს გამოიძახება მეთოდი session_destroy().`
            },
       
             
            ]
        },
        {
            title:"თავი 5. ფაილებთან მუშაობა",
            content:[
                {
                    title:"ამოკითხვა და ჩაწერა ფაილებში",
                    data:`ფაილის გასახსნელად PHP-ში გამოიყენება ფუნქცია fopen().  მას აქვს შემდეგი სახე: fopen(string $filename, string $mode). პირველი პარამეტრი $filename წარმოადგენს ფაილის მისამართს, ხოლო მეორე - გახსნის რეჟიმს. ფაილის გახსნის მიზნებიდან გამომდინარე ამ პარამეტრმა შეიძლება მიიღოს შემდეგი მნიშვნელობები:

                    'r': ფაილი იხსნება მხოლოდ წაკითხვისთვის. თუ ფაილი არ არსებობს, ბრუნდება false;
                    'r+': ფაილი იხსნება წაკითხვისთვის ჩაწერის შესაძლებლობით. თუ ფაილი არ არსებობს, ბრუნდება false;
                    'w': ფაილი იხსნება ჩაწერისთვის. თუ ფაილი არსებობს, მას გადაეწერება ახალი ფაილი, თუ არა - შეიქმნება ახალი;
                    'w+': ფაილი იხსნება ჩაწერისთვის წაკითხვის შესაძლებლობით. თუ ფაილი არსებობს, მას გადაეწერება ახალი ფაილი, თუ არა - შეიქმნება ახალი;
                    'a': ფაილი იხსნება ჩაწერისთვის. თუ ფაილი არსებობს, მონაცემები ჩაიწერება ფაილის ბოლოში, ხოლო არსებულიც დარჩება. თუ ფაილი არ არსებობს, ის შეიქმნება;
                    'a+': ფაილი იხსნება წაკითხვისადა ჩაწერისთვის. თუ ფაილი არსებობს, მონაცემები ჩაიწერება ფაილის ბოლოში, ხოლო არსებულიც დარჩება. თუ ფაილი არ არსებობს, ის შეიქმნება;
                    fopen ფუნქციის შედეგია ფაილის დესკრიპტორი. იგი გამოიყენება ფაილთან ოპერაციებისთვის და მის დასახურად. მუშაობის დასრულების შემდეგ ფაილი უნდა დაიხუროს fclose() ფუნქციის მეშვეობით, რომელიც პარამეტრად იღებს ფაილის დესკრიპტორს. მაგალითად, გავხსნათ და დავხუროთ ფაილი:
                    
                    $fd = fopen("form.php", 'r') or die("ფაილის გახსნა ვერ მოხერხდა");
                    fclose($fd);
                    თუ წინა გამოსახულება აბრუნებს false-ს, კონსტრუქციას or die("ფაილის გახსნა ვერ მოხერხდა")  გამოაქვს შეტყობინება და ასრულებს სკრიპტის მუშაობას. 
                    
                    ფაილის წაკითხვა
                    
                    ფაილის წაკითხვისთვის შეგვიძლია გამოვიყენოთ რამდენიმე ფუნქცია. სტრიქონ-სტრიქონ წასაკითხად გამოიყენება ფუნქცია fgets(),  რომელიც იღებს ფაილის დესკრიპტორს და აბრუნებს ერთ ამოკითხულ სტრიქონს. გავიაროთ სტრიქონ-სტრიქონ მთელი ფაილი:
                    
                    <?php
                    $fd = fopen("form.php", 'r') or die("ფაილის გახსნა ვერ მოხერხდა");
                    while(!feof($fd))
                    {
                        $str = htmlentities(fgets($fd));
                        echo $str;
                    }
                    fclose($fd);
                    ?>
                    fgets ფუნქციის ყოველ გამოძახებაზე PHP გადააადგილებს კურსორს წაკითხული სტრიქონის ბოლოში და მომდევნო გამოძახებისას მოხდება მომდევნო სტრიქონის წაკითხვა. რომ გავიგოთ, როდის დამთავრდება ფაილი, გამოიყენება ფუნქცია feof(), რომელიც აბრუნებს true-ს ფაილის დასრულებისას. სანამ არ მიაღწევს ფაილის დასასრულს, შეგვიძლია გამოვიყენოთ ფუნქცია fgets().
                    
                    ფაილის წაკითხვა სრულად
                    
                    თუ გვინდა ფაილის სრულად წაკითხვა, გამოიყენება ფუნქცია file_get_contents():
                    
                    <?php
                    $str = htmlentities(file_get_contents("form.php"));
                    echo $str;
                    ?>
                    ამასთან, არაა აუცილებელი ცხადად გავხსნათ ფაილი, მივიღოთ დესკრიპტორი და წაკითხვის შემდეგ დავხუროთ.
                    
                    ამოკითხვა ბლოკებად
                    
                    ასევე შესაძლებელია ფაილის ამოკითხვა ბლოკებად, ანუ ფაილიდან განსაზღვრული რაოდენობის ბაიტების ამოკითხვა fread() ფუნქციის მეშვეობით:
                    
                    <?php
                    $fd = fopen("form.php", 'r') or die("ვერ მოხერხდა ფაილის გახსნა");
                    while(!feof($fd))
                    {
                        $str = htmlentities(fread($fd, 600));
                        echo $str;
                    }
                    fclose($fd);
                    ?>
                    ფუნქცია fread() ღებულობს ორ პარამეტრს: ამოსაკითხი ფაილის დესკრიპტორს და ზომას ბაიტებში. ბლოკის წაკითხვის შემდეგ კურსორი დგება წაკითხულის ბოლოში. feof() ფუნქციით შესაძლებელია  გავიგოთ ფაილის დასრულება.
                    
                    ფაილის ჩაწერა
                    
                    ფაილის ჩასაწერად გამოიყენება ფუნქცია fwrite(), რომელიც წერს ფაილში ტექსტს:
                    
                    <?php
                    $fd = fopen("hello.txt", 'w') or die("ვერ მოხერხდა ფაილის შექმნა");
                    $str = "გამარჯობა, სამყაროვ!";
                    fwrite($fd, $str);
                    fclose($fd);
                    ?>
                    ანალოგიურად მუშაობს მეორე ფუნქცია fputs():
                    
                    <?php
                    $fd = fopen("hello.txt", 'w') or die("ვერ მოხერხდა ფაილის შექმნა");
                    $str = "გამარჯობა, სამყაროვ!";
                    fputs($fd, $str);
                    fclose($fd);
                    ?>
                    მუშაობა ფაილის კურსორთან
                    
                    ფაილის გახსნისას კურსორი დგება ფაილის დასაწყისში. მონაცემების წაკითხვისას PHPკურსორს გადააადგილებს წაკითხულის ბოლოში. თუმცა შესაძლებელია კურსორის მართვა ხელოვნურად და მისი გადაადგილება საჭირო ადგილზე. ამისათვის გამოიყენება ფუნქცია fseek, რომელსაც აქვს შემდეგი სახე:
                    
                     
                    
                    int fseek (resource $handle , int $offset [, int $whence = SEEK_SET ] )
                    პარამეტრი $handle წარმოადგენს ფაილის დესკრიპტორს, $offset - წანაცვლება ბაიტებში ფაილის დასაწყისიდან, სადაც გადაადგილდება კურსორი. მესამე არააუცილებელი პარამეტრი მიუთითებს, თუ საიდან ხდება კურსორის გადაადგილება. მას შეუძლია სამი მნიშვნელობის მიღება:
                    
                    SEEK_SET: მნიშვნელობა მიუთითებლობისას. კურსორი გადაადგილდება ფაილის დასაწყისიდან $offset-ში მითითებული ბაიტების ოდენობით;
                    SEEK_CUR: კურსორი გადაადგილდება მიმდინარე პოზიციიდან $offset-ში მითითებული ბაიტების ოდენობით;
                    SEEK_END: კურსორი გადაადგილდება ფაილის ბოლოდან $offset-ში მითითებული ბაიტების ოდენობით;
                    კურსორის წარმატებით გადაადგილებისას ფუნქცია აბრუნებს 0-ს, წარუმტებლობის შემთხვევაში აბრუნებს -1-ს.
                    
                    ვნახოთ ფუნქციის გამოყენების მაგალითი:
                    
                    <?php
                    $fd = fopen("hello.txt", 'w+') or die("ფაილის გახსნა ვერ მოხერხდა");
                    $str = "xxx!"; // სტრიქონი ჩაწერისთვის
                    fwrite($fd, $str); // ჩავწეროთ სტრიქონი დასაწყისში
                    fseek($fd, 0); // გადავაადგილოთ კურსორი ფაილის დასაწყისში
                    fwrite($fd, "zzz"); // ჩავწეროთ სტრიქონი დასაწყისში
                    fseek($fd, 0, SEEK_END); // გადავაადგილოთ კურსორი ბოლოში
                    fwrite($fd, $str); // ჩავწეროთ სტრიქონი ბოლოში
                    fclose($fd);
                    ?>`
                },
                {
                  title:"ფაილების და კატალოგების მართვა",
                  data:`ფაილის გადასატანად (სახელის გადასარქმევად) გამოიყენება ფუნქცია rename():

                  <?php
                  if (!rename("hello.txt", "subdir/hello.txt"))
                      echo "ფაილის გადატანის შეცდომა";
                  else echo "ფაილი გადატანილია";
                  ?>
                  თუ მიმდინარე საქაღალდეში არსებობს hello.txt ფაილი და საქაღალდე subdir, ფაილი გადავა ამ საქაღალდეში. თუ ფაილი წარმატებით გადავიდა, ფუნქცია დააბრუნებს true-ს.
                  
                  ფაილის კოპირება
                  
                  ფაილის კოპირებისთვის გამოიყენება ფუნქცია copy(). იგი პარამეტრებად ღებულობს დასაკოპირებელი ფაილის და კოპირებული ფაილის სახელებს. თუ კოპირება წარმატებით დასრულდა, აბრუნებს true-ს:
                  
                  <?php
                  if (copy("hello.txt", "hello_copy.txt"))
                      echo "ფაილი დაკოპირდა";
                  else echo "ფაილის კოპირების შეცდომა";
                  ?>
                  ფაილის წაშლა
                  
                  ფაილის წასაშლელად გამოიყენება ფუნქცია unlink(), რომელიც პარამეტრად იღებს წასაშლელი ფაილის სახელს და აბრუნებს true-ს, ტუ წაშლა წარმატებით განხორციელდა:
                  
                  <?php
                  if (unlink("hello.txt"))
                      echo "ფაილი წაშლილია";
                  else echo "ფაილის წაშლის შეცდომა";
                  ?>
                  საქაღალდის შექმნა
                  
                  საქაღალდის შესაქმნელად გამოიყენება ფუნქცია mkdir():
                  
                  <?php
                  if (mkdir("newdir"))
                      echo "საქაღალდე შეიქმნა";
                  else echo "საქაღალდის შექმნის შეცდომა შეცდომა";
                  ?>
                  საქაღალდის წაშლა
                  
                  საქაღალდის წასაშლელად გამოიყენება ფუნქცია rmdir():
                  
                  <?php
                  if (rmdir("newdir"))
                      echo "საქაღალდე წაშლილია";
                  else echo "საქაღალდის წაშლის შეცდომა შეცდომა";
                  ?>
                  ოპერაციები საქაღალდესთან
                  
                  მიმდინარე საქაღალდის სრული მისამართის მისაღებად გამოიყენება ფუნქცია getcwd(), რომელიც აბრუნებს მისამართს სტრიქონის სახით:
                  
                  $path = getcwd();
                  echo $path; // C:\localhost
                  ფუნქცია opendir() ხსნის საქაღალდეს მისი ფაილების ამოსაკითხად. წარმატებით გახსნის შემთხვევაში ფუნქცია აბრუნებს გახსნილი საქაღალდის დესკრიპტორს. საქაღალდესთან მუშაობის დასრულების შემდეგ ის უნდა დავხუროთ ფუნქციით closedir(). საქაღალდეში ფაილის ამოსაკითხად გამოიყენება ფუნქცია readdir().
                  
                  გავაერთიანოთ ეს ფუნქციები და გამოვიტანოთ საქაღალდის ფაილები და ქვეკატალოგები ვებგვერდზე:
                  
                  <?php
                  $dir = getcwd(); // მიმდინარე საქაღალდის მისამართი
                   
                  if (is_dir($dir)) // წარმოადგენს თუ არა მისამართი საქაღალდეს
                  {
                      if ($dh = opendir($dir)) // გავხსნათ საქაღალდე
                      {
                          // ამოვიკითხოთ ფაილები რიგ-რიგობით
                          // სანამ ბოლომდე არ ჩავალთ
                          while (($file = readdir($dh)) !== false)
                          {
                              // გამოვტოვოთ სიმბოლოები .. და .
                              if($file=='.' || $file=='..') continue;
                              // თუ საქაღადეა ან ფაილი
                              if(is_dir($file)) echo "საქაღალდე: $file <br>";
                              else echo "ფაილი:    $file <br>";
                          }
                          closedir($dh); // დავხუროთ საქაღალდე
                      }
                  }
                  ?>`
              },
              {
                title:"ფაილის ბლოკირება. ფუნქცია flock",
                data:`თუ ვებსაიტზე შედის ბევრი ადამიანი, ერთი და იგივე ფაილს შეიძლება ერთდროულად მიმართოს რამდენიმე ადამიანმა. ამან შეიძლება გამოიწვიოს პრობლემები, რადგან სანამ ერთი კითხულობს, მეორე შეიძლება ცდილობდეს ჩაწერას, ან რამდენიმე ერთდროულად ცდილობდეს ჩაწერას. ამან შეიძლება ფაილის დაზიანება გამოიწვიოს ან მოგვცეს მოულოდნელი შედეგი. 

                ფაილთან წვდომის შეზღუდვისთვის PHP-ში გამოიყენება ფუნქცია flock(). ეს ფუნქცია ბლოკავს ფაილს, რომელიც დაკავებულია სხვა მომხმარებლის მიერ, ხოლო სხვა მოთხოვნები ამ ფაილზე დგება რიგში. ფაილის გათავისუფლების მერე მას მოეხსნება ბლოკი, გადაეცემა მეორე მომხმარებელს და ისევ იბლოკება. ფუნქციას აქვს შემდეგი სახე:
                
                bool flock (resource $handle , int $operation [, int &$wouldblock ])
                პირველი პარამეტრი არის ფაილის დესკრიპტორი, რომელსაც აბრუნებს ფუნქცია fopen(). 
                
                მეორე პარამეტრი მიუთითებს ბლოკირების ტიპს. მან შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                
                LOCK_SH (ან რიცხვი 1): გაზიარებული ბლოკირება (ფაილის ამოკითხვა)
                LOCK_EX (ან რიცხვი 2): გამომრიცხავი ბლოკირება (ფაილის ჩაწერა)
                LOCK_UN (ან რიცხვი 3): ბლოკირების მოსახსნელად
                LOCK_NB (ან რიცხვი 4): ეს კონსტანტა გამოიყენება ზემოთ ჩამოთვლილთაგან რომელიმესთან ერთად ბიტურ მასკაში (მაგალითად, LOCK_EX | LOCK_NB), თუ არ უნდა ველოდოთ, სანამ flock() მიიღებს ბლოკირებას
                მესამე არააუცილებელი პარამეტრი $wouldblock უნდა იყოს true, თუ ბლოკირება იქნება დამბლოკავი.
                
                წარმატებით შესრულებისას ფუნქცია flock აბრუნებს true-ს, ხოლო შეცდომის შემთხვევაში - false-ს.
                
                გამოვიყენოთ flock ფაილის ბლოკირებისთვის:
                
                <?php
                $fd = fopen("hello.txt", 'r+') or die("ფაილის გახსნის შეცდომა");
                $str = "Hello World!";
                 
                if (flock($fd, LOCK_EX)) // გამომრიცხავი ბლოკირება
                {
                    fseek($fd, 0, SEEK_END); //ფაილის ბოლოში გადასვლა
                    fwrite($fd, "$str") or die("ჩაწერის შეცდომა"); // ჩაწერა
                    flock($fd, LOCK_UN); // ბლოკირების მოხსნა
                }
                fclose($fd);
                ?>
                ფაილში ცვლილების შეტანის დროს ბლოკირება ხდება უშუალოდ ცვლილების შეტანის წინ და ცვლილების შეტანისთანავე იხსნება. სხვანაირად პროგრამა შეიძლება შენელდეს. მიაქციეთ ყურადღება, რომ ფაილის გასახსნელად გამოიყენება რეჟიმი 'r+' და არა 'w' ან 'w+', რადგან  'w' და 'w+' უკვე გულისხმობს ფაილის ცვლილებას. ამიტომაც ფაილის ბლოკირების დროს მათი გამოყენება არაა მიზანშეწონილი.
                
                თუ ჩვენ გვინდა წავშალოთ ფაილის შიგთავსი და ჩავწეროთ თავიდან გამოიყენება ფუნქცია ftruncate():
                
                <?php
                $fd = fopen("hello.txt", 'r+') or die("ფაილის გახსნის შეცდომა");
                $str = "Hello World!";
                 
                if (flock($fd, LOCK_EX)) // გამომრიცხავი ბლოკირება
                {
                    ftruncate($fd, 0); // ვასუფთავებთ ფაილს
                    fwrite($fd, "$str") or die("ჩაწერის შეცდომა"); // ჩაწერა
                    flock($fd, LOCK_UN); // ბლოკირების მოხსნა
                }
                fclose($fd);
                ?>`
            },
            {
                title:"ფაილის გაგზავნა სერვერზე",
                data:`ფაილის სერვერზე გასაგზავნად უნდა გამოვიყენოთ ფორმა პარამეტრით enctype='multipart/form-data' და მასივი $_FILES. შევქმნათ ფაილი upload.php შემდეგი შიგთავსით:

                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                if ($_FILES && $_FILES['filename']['error']== UPLOAD_ERR_OK)
                {
                    $name = $_FILES['filename']['name'];
                    move_uploaded_file($_FILES['filename']['tmp_name'], $name);
                    echo "ფაილი ატვირთულია";
                }
                ?>
                <h2>ფაილის ატვირთვა</h2>
                <form method="post" enctype='multipart/form-data'>
                აირჩიეთ ფაილი: <input type='file' name='filename' size='10' /><br /><br />
                <input type='submit' value='ატვირთვა' />
                </form>
                </body>
                </html>
                აქ განსაზღვრულია ფორმა ატრიბუტით enctype='multipart/form-data'. ფორმა შეიცავს სპეციალურ ველს ფაილის ასარჩევად. ასატვირთი ფაილი ხვდება ასოციაციურ მასივში  $_FILES. იმის გასაგებად, არის მასივში საერთოდ ფაილები თუ არა, ვიყენებთ კონსტრუქციას if: if( $_FILES).
                
                მასივი  $_FILES წარმოადგენს ორგანზომილებიან მასივს. ჩვენ შეგვიძლია ავტვირთოთ რამდენიმე ფაილი და თითოეული ფაილის მიღება შეიძლება გასაღებით, რომელიც ემთხვევა ფაილის ატრიბუტს name. 
                
                რადგანაც ფაილის ატვირთვის ელემენტის ატრიბუტი name='filename',  ამიტომ ამ ფაილის მიღება შეგვიძლია გამოსახულებით  $_FILES[''filename].
                
                თითოეულ ფაილს გააჩნია პარამეტრები, რომელთა მიღებაც შეგვიძლია:
                
                $_FILES['file']['name']: ფაილის სახელი
                $_FILES['file']['type']: ფაილის ტიპი, image/jpeg
                $_FILES['file']['size']: ფაილის ზომა ბაიტებში
                $_FILES['file']['tmp_name']: სერვერზე შენახული დროებითი ფაილის სახელი
                $_FILES['file']['error']: შეცდეომის კოდი ატვირთვისას
                ჩვენ შეგვიძლია შევამოწმოთ შეცდომის არსებობა. თუ შეცდომა არა გვაქვს, $_FILES['filename']['error'] შეიცავს მნიშვნელობას UPLOAD_ERR_OK.
                
                ფაილის სერვერზე ატვირთვისას ის ჯერ იტვირთება დროებით ადგილზე, საიდანაც move_uploaded_file() ფუნქციით გადაადგილდება სერვერის კატალოგში.
                
                ფუნქცია move_uploaded_file() იღებს ორ პარამეტრს: ატვირთული დროებითი ფაილის მისამართი და მისამართი, სადაც უნდა განთავსდეს ფაილი.
                
                შეზღედვები და ატვირთვის მახასიათებლები
                
                მიუთითებლობისას ასატვირთი ფაილის ზომა შეზღუდულია 2 მბ-ით. თუმცა ამ პარამეტრის შეცვლა შეიძლება კონფიგურაციის ფაილიდან. შევცვალოთ ეს მახასიათებელი 10მბ-მდე. ამისათვის მოვძებნოთ php.ini ფაილში შემდეგი სტრიქონი:
                
                upload_max_filesize = 2M
                შევცვალოთ იგი:
                
                upload_max_filesize = 10M
                ასევე შეიძლება მივუთიტოთ საქაღალდე დროებითი ფაილებისთვის. ამისათვის php.ini ფაილში მოვძებნოთ სტრიქონი:
                
                ;upload_tmp_dir =
                და გადავაკეთოთ:
                
                upload_tmp_dir = "C:/php/upload"
                ასევე php საქაღალდეში უნდა შევქმნათ upload საქაღალდე.
                
                მულტიატვირთვა
                
                შევცვალოთ სკრიპტი ისე, რომ შესაძლებელი იყოს ბევრი ფაილის ერთდროულად ატვირთვა:
                
                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                if($_FILES)
                {
                    foreach ($_FILES["uploads"]["error"] as $key => $error) {
                        if ($error == UPLOAD_ERR_OK) {
                            $tmp_name = $_FILES["uploads"]["tmp_name"][$key];
                            $name = $_FILES["uploads"]["name"][$key];
                            move_uploaded_file($tmp_name, "$name");
                        }
                    }
                }
                ?>
                <h2>ფაილის ატვირთვა</h2>
                <form method="post" enctype='multipart/form-data'>
                <input type='file' name='uploads[]' /><br />
                <input type='file' name='uploads[]' /><br />
                <input type='file' name='uploads[]' /><br />
                <input type='submit' value='ატვირთვა' />
                </form>
                </body>
                </html>
                ფაილის არჩევის თითოეულ ველს გააჩნია ატრიბუტი name='uploads[]', ამიტომ სერვერი ატვირთულ ფაილებს აღიქვამს, როგორც ერთიან მასივს. შემდეგ გამოყენებულია ციკლი, რომელიც დაივლის თითოეულ ფაილს და ჩაწერს ვებგვერდის საქააღალდეში.`
            },
          
            ]
        },
        {
            title:"თავი 6. ობიექტზე ორიენტირებული პროგრამირება",
            content:[
                {
                    title:"ობიექტები და კლასები",
                    data:`PHP-ზე პროგრამის და მისი ცალკეული ბლოკების შესაქმნელად სავსებით საკმარისია ის შესაძლებლობები და ფუნქციონალი, რასაც ფუნქციები გვაძლევს. თუმცა PHP-ს გააჩნია სხვა შესაძლებლობებიც, რომლებიც დაკავშირებულია ობიექტზე ორიენტირებულ პროგრამირებასთან. ბევრ შემთხვევაში პროგრამები, რომლებიც იყენებენ ოპიექტზე ორიენტირებულ პროგრამირებას, უფრო მარტივი გასაგებია და უფრო ადბილია მათი მხარდაჭერა და შეცვლა.

                    ობიექტზე ორიენტირებული პროგრამირების საკვანძი ცნებებია კლასი და ობიექტი. კლასი წარმოადგენს ობიექტის აღწერას, ხოლო ობიექტი - კლასის კონკრეტულ ეგზემპლარს. 
                    
                    კლასის შესაქმნელად PHP-ში გამოიყენება საკვანძო სიტყვა class. მაგალითად, ახალი კლასი, რომელიც წარმოადგენს მომხმარებელს:
                    
                    class User
                    {}
                    კლასის ობიექტის შესაქმნელად გამოიყენება საკვანძო სიტყვა new:
                    
                    <?php
                    class User
                    { }
                     
                    $user = new User;
                    print_r($user);
                    ?>
                    მოცემულ შემთხვევაში ცვლადი $user წარმოადგენს User კლასის ობიექტს. print_r ფუნქციის მეშვეობით შესაძლებელია კლასის გამოტანა ვებგვერდზე, ისევე როგორც მასივის შემთხვევაში.
                    
                    თვისებები და მეთოდები
                    
                    კლასს შეიძლება გააჩნდეს თვისებები, რომლებიც აღწერენ მის მახასიათებლებს და მეთოდები, რომლებიც განსაზღვრავენ მის ქცევას. დავამატოთ User კლასს რამდენიმე თვისება და მეთოდი:
                    
                    <?php
                    class User
                    {
                        public $name, $age;
                        
                        function getInfo()
                        {
                            echo "სახელი: $this->name ; ასაკი: $this->age <br>";
                        }
                    }
                     
                    $user = new User;
                    $user->name="Tom"; // თვისება $name-ის მინიჭება
                    $user->age=30; // თვისება $age-ის მინიჭება
                    $user->getInfo(); // getInfo() მეთოდის გამოძახება
                    print_r($user);
                    ?>
                    აქ User კლასს გააცნია ორი თვისება: $name და $age. თვისებები ცხადდება, როგორც ჩვეულებრივი ცვლადები, რომელთა წინ იწერება წვდომის მოდიფიკატორი, მოცემულ შემთხვევაში - public.
                    
                    მეთოდები წარმოადგენენ ჩვეულებრივ ფუნქციებს, რომლებიც ასრულებენ გარკვეულ მოქმედებებს. ჩვენს მაგალითში მეთოდი getInfo() გამოიტანს ზემოთ გამოცხადებული ცვლადების (თვისებების) მნიშვნელობებს.
                    
                    იმავე კლასიდან მიმდინარე ობიექტზე მიმართვისთვის გამოიყენება საკვანძო სიტყვა $this - ის წარმოადგენს მიმდინარე ობიექტს. ობიექტის თვისებებისა და მეთოდებისადმი მიმართვის გამოიყენება ოპერატორი ->. მაგალითად, $name თვისების მნიშვნელობის მისაღებად უნდა დავწეროთ $this->name. ამასთან, თვისებებთან მიმართვისთვის $ სიმბოლო არ იწერება.
                    
                    კლასის ობიექტის გამოყენების დროს მისი თვისებებისა და მეთოდებისადმი მიმართვის ასევე გამოიყენება ოპერატორი ->.
                    
                    კონსტრუქტორი
                    
                    კონსტრუქტორი წარმოადგენს სპეციალურ მეთოდს, რომელიც სრულდება ობიექტის შექმნისას და მისი დანიშნულებაა ობიექტის და მისი თვისებების ინიციალიზაცია. კონსტრუქტორის შესაქმნელად უნდა გამოვაცხადოთ ფუნქცია სახელით __construct (ორი გახაზვის სიმბოლოთი დასაწყისში):
                    
                    <?php
                    class User
                    {
                        public $name, $age;
                        function __construct($name, $age)
                        {
                            $this->name = $name;
                            $this->age = $age;
                        }
                        
                        function getInfo()
                        {
                            echo "სახელი: $this->name ; ასაკი: $this->age <br>";
                        }
                    }
                     
                    $user2 = new User("Tom", 33);
                    $user2->getInfo();
                    ?>
                    მოცემულ შემთხვევაში კონსტრუქტორს გააჩნია ორი პარამეტრი, რომლებიც გადაეცემა მნიშვნელობად შესაბამის თვისებებს. ახლა უკვე კლასის ობიექტის შესაქმნელად და თვისებების მისანიჭებლად საკმარისია კონსტრუქტორის გამოძახება და შესაბამისი პარამეტრების გადაცემა: $user2 = new User("Tom", 33);
                    
                    პარამეტრები მიუთითებლობისას (ნაგულისხმევი)
                    
                    ჩვენ შეგვიძლია კონსტრუქტორის ერთი ან რამდენიმე პარამეტრი გავხადოთ არააუცილებელი. ამისათვის მას უნდა ჰქონდეს მნიშვნელობა მიუთითებლობისას:
                    
                    function __construct($name="Tom", $age=33)
                    {
                      $this->name = $name;
                      $this->age = $age;
                    }
                    ასეთ შემთხვევაში თუ რომელიმე პარამეტრს არ მივუთითებთ, ის მიიღებს ნაგულისხმევ მნიშვნელობას. ახლა უკვე კლასის ობიექტის შექმნა შეგვიძლია რამდენიმე სხვადასხვა ხერხით:
                    
                    $user1 = new User("John", 25);
                    $user1->getInfo();
                    $user2 = new User("Jack");
                    $user2->getInfo();
                    $user3 = new User();
                    $user3->getInfo();
                    დესტრუქტორი
                    
                    დესტრუქტორი ემსახურება პროგრამის მიერ დაკავებული რესურსების გამოთავისუფლებას - გახსნილი ფაილების გათავისუფლებას, მონაცემთა ბაზასთან კავშირისას დაკავებული რესურსების გათავისუფლებას და ა. შ. ობიექტის დესტრუქტორს იძახებს თვითონ PHP-ს ინტერპრეტატორი პროგრამიდან ამ ობიექტზე ბოლო მიმართვის გაქრობისას. 
                    
                    დესტრუქტორი განისაზღვრება ფუნქციით __destruct(ორი გახაზვის სიმბოლოტი დასაწყისში) :
                    
                    <?php
                    class User
                    {
                        public $name, $age;
                        function __construct($name, $age)
                        {
                            $this->name = $name;
                            $this->age = $age;
                        }   
                        
                        function getInfo()
                        {
                            echo "სახელი: $this->name ; ასაკი: $this->age <br>";
                        }
                     
                        function __destruct()
                        {
                            echo "დესტრუქტორის გამოძახება";
                        }
                    }
                    ?>
                    დესტრუქტორი განისაზღვრება პარამეტრების გარეშე და როცა პროგრამაში არ დარჩება არცერთი მიმართვა ობიექტზე, მოხდება მისი გამოძახება ინტერპრეტატორის მიერ და ობიექტი განადგურდება.`
                },
                {
                  title:"მემკვიდრეობითობა",
                  data:`მემკვიდრეობითობა წარმოადგენს ობიექტზე ორიენტირებული პროგრამირების ერთ-ერთ უმნიშვნელოვანეს ასპექტს. მემკვიდრეობითობა საშუალებას გვაძლევს უკვე არსებული კლასების ფუნქციონალი ხელახლა განვსაზღვროთ მემკვიდრე კლასებში. თუ ჩვენ გვაქვს კლასი, რომელსაც არ ჰყოფნის რამდენიმე თვისება ან მეთოდი ახალი მისიის შესასრულებლად, გაცილებით მარტივია შევქმნათ კლასი მემკვიდრე რამდენიმე ახალი თვისების და მეტოდის დამატებით, ვიდრე გადავწეროთ მთლიანმად კლასი და იქ დავამატოთ. 

                  იმისათვის, რომ კლასი გავხადოთ სხვა კლასის მემკვიდრე, უნდა გამოვიყენოთ ინსტრუქცია extends. მაგალითად, შევქმნათ კლასი Customer, როგორც User კლასის მემკვიდრე:
                  
                  <?php
                  class User
                  {
                      public $name, $age;
                      
                      function __construct($name, $age)
                      {
                          $this->name = $name;
                          $this->age = $age;
                      }
                      function getClassInfo()
                      {
                          echo "კლასი User აღწერს მომხმარებლებს<br />";
                      }
                      function getInfo()
                      {
                          echo "სახელი: $this->name ; ასაკი: $this->age <br />";
                      }
                  }
                  class Customer extends User
                  {
                      public $account, $sum;
                      
                      function __construct($name, $age, $acc)
                      {
                          // საბაზისო კლასის კონსტრუქტორის გამოძახება
                          parent::__construct($name, $age);
                          $this->account=$acc;
                          $this->sum=20;
                      }
                      
                      // ცვლის მშობელ მეთოდს getClassInfo()
                      function getClassInfo()
                      {
                          echo "კლასი Customer აღწერს კლიენტებს <br />";
                      }
                      
                      function getInfo()
                      {
                          parent::getInfo();
                          echo "ანგარიშის ნომერი: $this->account ; თანხა: $this->sum <br />";
                      }
                  }
                   
                  $client = new Customer("John", 25, "1123400895");
                  $client->getInfo();
                  $client->getClassInfo();
                  ?>
                  კლასი Customer მსობელი კლასისგან User მემკვიდრეობით იღებს ყველა მის ფუნქციონალს, ასევე ემატება ორი ახალი თვისება $account და $sum. მიუხედავად იმისა, რომ თვისება $name განსაზღვრულია კლასში User, მისი მიღება ასევე შესაძლებელია Customer კლასში $this->name.
                  
                  თუ მემკვიდრე კლასში განსაზღვრულია მეთოდი იგივე სახელით, რაც მშობელ კლასშია, ხდება მეთოდის შეცვლა ახლით. ჩვენს შემთხვევაში ხდება მეთოდის getClassInfo ხელახლა განსაზღვრა. ამიტომ Customer მიმართავს თავის მეთოდს getClassInfo.
                  
                  თუ ჩვენ გვინდა მივმართოთ მშობელი კლასის მეთოდს, უნდა გამოვიყენოთ ინსტრუქცია parent:
                  
                  parent::getInfo();
                  შესაბამისად, Customer კლასიდან getInfo მეთოდის გამოძახებისას ჯერ მოხდება მშობელი კლასის getInfo მეთოდის გამოძახება, ხოლო შემდეგ შესრულდება დანარჩენი ინსტრუქცია:
                  
                  function getInfo()
                  {
                      parent::getInfo();
                      echo "ანგარიშის ნომერი: $this->account ; თანხა: $this->sum <br />";
                  }
                  კლასი Customer ასევე განსაზღვრავს საკუთარ კონსტრუქტორს:
                  
                  function __construct($name, $age, $acc)
                  {
                      // საბაზისო კლასის კონსტრუქტორის გამოძახება
                      parent::__construct($name, $age);
                      $this->account=$acc;
                      $this->sum=20;
                  }    
                  აქაც ჯერ ხდება მშობელი კლასის კონსტრუქტორის გამოძახება, ხოლო შემდეგ მოდის საკუთარი ინსტრუქციები.
                  
                  ინსტრუქცია final
                  
                  განხილულ მაგალითში ხდებოდა მშობელი კლასი getInfo და getClassInfo მეთოდების ხელახალი განსაზღვრა მემკვიდრეობით მიღებულ კლასში. ხანდახან საჭიროა, რომ აიკრძალოს მეთოდების ხელახალი განსაზღვრა მემკვიდრეობით მიღებულ კლასში. ამისათვის მშობელ კლასში გამოიყენება მოდიფიკატორი final:
                  
                  class User
                  {
                  . . .
                      final function getInfo()
                      {
                          echo "სახელი: $this->name ; ასაკი: $this->age <br />";
                      }
                  }
                  ახლა უკვე მემკვიდრე კლასში ვერ განვსაზღვრავთ მეთოდს იგივე სახელით.`
              },
              {
                title:"წვდომის მოდიფიკატორები",
                data:`სპეციალური მოდიფიკატორების მეშვეობით შეგვიძლია განვსაზღვროთ კლასის თვისებებისა და მეთოდების ხედვის არე. PHP-ში არსებობს 3 ასეთი მოდიფიკატორი:

                public: ამ მოდიფიკატორით განსაზღვრულ თვისებებს და მეთოდებს შეგვიძლია მივმართოთ გარე კოდიდან და პროგრამის ნებისმიერი ადგილიდან
                protected: ამ მოდიფიკატორით განსაზღვრულ თვისებებსა და მეთოდებს შეგვიძლია მივმართოთ მიმდინარე კლასიდან, ასევე მემკვიდრე კლასებიდან
                private: ამ მოდიფიკატორით განსაზღვრულ თვისებებსა და მეთოდებს შეგვიძლია მივმართოთ მხოლოდ მიმდინარე კლასიდან
                ვნახოთ მაგალითი:
                
                <?php
                class User
                {
                    private $privateA ="private";
                    public  $publicA = "public";
                    protected $protectedA = "protected";
                    
                    private function getPrivateMethod()
                    {
                        echo "private method <br />";
                        echo "$this->privateA <br />";
                        echo "$this->protectedA <br />";
                        echo "$this->publicA <br />";
                    }
                    
                    protected function getProtectedMethod()
                    {
                        echo "protected method <br />";
                    }
                    
                    public function getPublicMethod()
                    {
                        echo "public method <br />";
                        $this->getPrivateMethod();
                    }
                }
                ?>
                კლასში განსაზღვრულია სამი თვისება და სამი მეთოდი სხვადასხვა წვდომის მოდიფიკატორებით. ამ კლასის ნებისმიერი მეთოდიდან შეგვიძლია მივმარტოთ ამ კლასის ნებისმიერ თვისებას ან მეთოდს.
                
                ახლა შევქმნათ ამ კლასის მემკვიდრე კლასი:
                
                class Customer extends User
                {
                    public function getCustomerMethod()
                    {
                        //echo $this->privateA; //შეუძლებელია, რადგანაც privateA წარმოადგენს private-ს მშობელ კლასში
                        echo $this->protectedA;
                        echo $this->publicA;
                        //$this->getPrivateMethod(); //შეუძლებელია, რადგანაც წარმოადგენს private-ს მშობელ კლასში
                        $this->getProtectedMethod();
                        $this->getPublicMethod();
                    }
                }
                მემკვიდრე კლასში ხელმისაწვდომია ყველა თვისება და მეთოდი მოდიფიკატორებით public და protected, მაგრამ შეუძლებელია იმ თვისებებზე და მეთოდებზე მიმართვა, რომელთაც აქვთ მოდიფიკატორი private.
                
                ახლა ვნახოთ User კლასის გამოყენება გარე კოდიდან:
                
                $user = new User;
                // $user->getPrivateMethod(); // შეუძლებელია, რადგანაც არის private
                // $user->getProtectedMethod(); // შეუძლებელია, რადგანაც არის protected
                $user->getPublicMethod();
                // echo $user->privateA; // შეუძლებელია, რადგანაც არის private
                // echo $user->protectedA; // შეუძლებელია, რადგანაც არის protected
                echo $user->publicA;
                გარე კოდიდან ხელმისაწვდომია მხოლოდ ის თვისებები და მეთოდები, რომლებიც არიან განსაზღვრული მოდიფიკატორით public, ხოლო protected და private მოდიფიკატორით განსაზღული თვისებებისა და მეთოდების გამოყენება შეუძლებელია.
                
                `
            },
            {
                title:"სტატიკური მეთოდები და თვისებები. კონსტანტები",
                data:`გარდა ჩვეულებრივი თვისებებისა და მეთოდებისა სხვადასხვა მოდიფიკატორებით, კლასი შეიძლება შეიცავდეს სტატიკურ თვისებებსა და მეთოდებს. ასეთი თვისებები და მეთოდები მოინიშნება საკვანძო სიტყვით static:

                <?php
                class User
                {
                    static function getClassInfo()
                    {
                        echo "ეს არის კლასი User, რომელიც განსაზღვრავს მომხმარებელს <br />";
                    }
                }
                User::getClassInfo();
                ?>
                სტატიკური მეთოდის გამოსაძახებლად გამოიყენება კლასის სახელი და ოპერატორი ::, ნაცვლად წვდომის ოპერაციისა ->, რადგანაც სტატიკური მეთოდი ეკუთვნის მთლიანად კლასს და არა მის რომელიმე ობიექტს. 
                
                სტატიკურ მეთოდებთან ერთად გამოიყენება სტატიკური თვისებები. სტატიკური თვისებაც ეკუთვნის მთლიანად კლასს და არა მის რომელიმე ობიექტს. გამობიყენოთ სტატიკური თვისება ობიექტების მრიცხველებისთვის:
                
                <?php
                class User
                {
                    private $id;
                    private static $counter=0;
                    
                    function __construct()
                    {
                        self::$counter++;
                        $this->id=self::$counter;
                    }
                    
                    static function getCounter()
                    {
                        return self::$counter;
                    }
                    function getId()
                    {
                        return $this->id;
                    }
                }
                 
                $user1 = new User;
                echo "პირველი მომხმარებლის Id: " . $user1->getId() . "<br />";
                $user2 = new User;
                echo "მეორე მომხმარებლის Id: " . $user2->getId() . "<br />";
                echo "სულ მომხმარებლების რაოდენობაა: " .  User::getCounter();
                ?>
                კლასის შიგნით სტატიკურ თვისებებთან მიმართვისთვის გამოიყენება საკვანძო სიტყვა self და ოპერატორი ::, მაგალითად, $self::$counter++.
                
                კონსტრუქტორში ჩვენ ვზრდით სტატიკურ ცვლადს 1-ით და მერე ამ მნიშვნელობას ვანიჭებთ ობიექტს იდენტიფიკატორად. 
                
                ჩვეულებრივი თვისებების გარდა კლასს შეიძლება ჰქონდეს კონსტანტები. კონსტანტა წარმოადგენს ველს, რომლის მნიშვნელობაც არ იცვლება. კონსტანტების განსაზღვრისთვის გამოიყენება ინსტრუქცია const:
                
                <?php
                class User
                {
                    const EMPLOYEE = 1;
                    const MANAGER = 2;
                    const ADMIN = 3;
                }
                 
                echo User::MANAGER; //2
                ?>
                კონსტანტებზე მიმართვა ხდება სტატიკურ თვისებებზე მიმართვის ანალოგიურად: User::MANAGER.`
            }
             
            ]
        },
        {
            title:"თავი 7. მუშაობა მონაცემთა ბაზებთან. MySQL",
            content:[
                {
                    title:"MySQL და phpMyAdmin",
                    data:`ოგორც წესი, მონაცემთა შესანახად გამოიყენება მონაცემთა ბაზები. PHP იყენებს მონაცემთა ბაზის სხვადასხვა სისტემას, მაგრამ ყველაზე პოპულარული დღეისათვის PHP-სთან კავშირში არის MySQL. MySQL წარმოადგენს უფასო პროგრამულ უზრუნველყოფას, რომელიც იყენებს პროგრამირების ენას SQL-ს. ადრე ჩვენ განვიხილეთ MySQL-ის დაყენება და კონფიგურირება.

                    MySQL-თან მუშაობის გასამარტივებლად დავაყენოთ სკრიპტების სპეციალური ნაკრები phpMyAdmin. იგი წარმოადგენს ინტუიციურად გასაგებ ვებინტერფეისს MySAL-ის ბაზების სამართავად. ამ ინსტრუმენტის მეშვეობით გაცილებით მარტივია ბაზების მართვა, ვიდრე კონსოლის მეშვეობით.
                    
                    დასაყენებლად გადმოვწეროთ არქივი და არქივიდან ამოღებული სსაქაღალდე ჩავწეროთ c:\localhost საქაღალდეში. ამოარქივებულ საქაღალდეს სიმარტივისთვის დავარქვათ phpMyAdmin. შევქმნათ ამ საქაღალდის შიგნით ფაილი config.inc.php შემდეგი შიგთავსით:
                    
                    <?php
                       $i = 0;
                       $i++;    //  MySQL-ის პირველი სერვერისთვის
                       $cfg['Servers'][$i]['host'] = 'localhost';
                       $cfg['Servers'][$i]['extension'] = 'mysqli';
                       $cfg['Servers'][$i]['connect_type'] = 'tcp';
                       $cfg['Servers'][$i]['compress'] = false;
                       $cfg['Servers'][$i]['auth_type'] = 'config';
                       $cfg['Servers'][$i]['user'] = 'root';
                       $cfg['Servers'][$i]['password'] = '1'; //პაროლი მომხმარებლისთვის root
                     ?>
                    იმისათვის, რომ დავრწმუნდეთ, რომ ყველაფერი სწორადაა დაკონფიგურირებული, გავუშვათ ბრაუზერში phpMyAdmin,ამისათვის ბრაუზერში ავკრიფოთ  http://localhost:8080/phpmyadmin:
                    
                    
                    მარცხენა სვეთში ჩანს უკვე არსებული მონაცემთა ბაზები. მიუხედავად იმისა, რომ ჩვენ არცერთი ბაზა არ შეგვიქმნია, იქ მაინც არის რაღაც ბაზები, რომლებიც ავტომატურად იქმნება.
                    
                    ინტერფეისის მარჯვენა ნაწილში არის სხვადასხვა ინსტრუმენტი, ასევე კონფიგურაციის ინფორმაცია.
                    
                    მონაცემთა ბაზის შექმნა
                    
                    მონაცემთა ბაზის შექმნა შესაძლებელია MySQL-ის კონსოლიდან, ასევე phpMyAdmin-ის ვიზუალური ინტერფეისიდან.
                    
                    გავხსნათ phpMyAdmin-ის ინტერფეისი და გადავიდეთ ჩანართზე Databases. "Create database" ნიშნულის ქვეშ შევიყვანოთ ბაზის სახელი, მაგალითად "compstore" და დავაჭიროთ ღილაკს Create:
                    
                    
                    ამის შემდეგ მივიღებთ შეტყობინებას ბაზის წარმატებით შექმნის შესახებ და ის დაემატება ბაზების ჩამონათვალში.
                    
                    ახალი ბაზა ჯერჯერობით ცარიელია და არ შეიცავს არაფერს. დავამატოთ მასში ცხრილი, რომელშიც შევძლებთ მონაცემების შენახვას. თუ დავდგებით ბაზაზე, მარჯვნივ გამოჩნდება მისის ტრუქტურა და ახალი ცხრილის დასამატებელი ველი, სადაც უნდა ჩავწეროთ ცხრილის სახელი, მივუთითოთ სვეტების რაოდენობა და დავაჭიროთ ღილაკს Go:
                    
                    
                    ვთქვათ, ცხრილი უნდა ინახავდეს მონაცემებს ტელეფონების შესახებ, დავარქვათ მას Phones და სვეტების რაოდენობაში მივუთითოთ 3:
                    
                    
                    Go ღილაკზე დაჭერის შემდეგ გამოჩნდება უჯრები, სადაც უნდა მივუთითოთ ცხრილის სვეტების პარამეტრები. მივუთითოთ სვეტების სახელებო id, name, company. სვეტის ტიპში მივუთითოთ: id - INT, name, company - VARCHAR. name და company სვეტებს lenght/values ველში მივუთითოთ 200 - იგი მიუთითებს სვეტში სიმბოლოების მაქსიმალურ რაოდენობას. ასევე id სვეტისთვის მივუთითოთ ინდექსი PRIMARYდა ველში A_I (Auto Increment) ჩავრთოთ ალამი:
                    
                    
                    Save ღილაკზე დაჭერის შედეგად შეიქმნება ცხრილი, რომელსაც ექნება უნიკალური იდენტიფიკატორი id და სვეტები დასახელებისთვის (name) და მწარმოებლისთვის (company).
                    
                    შექმნის შემდეგ ბაზის ქვემოთ გაჩნდება ჩვენი ცხრილი თავისი სვეტებით:
                    
                    
                    ეს არაა ერთადერთი მეტოდი ცხრილის შესაქმნელად.  ცხრილის შექმნა ასევე შესაძლებელია SQL კოდის მეშვეობით. ამისათვის მარცხენა მხარეს უნდა დავდგეთ ბაზაზე და მარჯვნივ ავირჩიოთ ჩანართი SQL. გამოცნდება SQL მოთხოვნების ჩასაწერი ვეილ, სადაც ჩავწეროთ:
                    
                    CREATE Table phones1
                    (
                        id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(200) NOT NULL,
                        company VARCHAR(200) NOT NULL
                    )
                    PHP
                    
                    ეს არის ცხრილის შექმნის სტანდარტული ბრძანება SQL-ის ენაზე. საკვანძო სიტყვების CREATE Table შემდეგ მოდის ცხრილის სახელი phones1, ხოლო შემდეგ ფრჩხილებში სვეტების აღწერა.
                    
                    თიტოეული სვეტის აღწერა შედგება სვეტის სახელისგან, ტიპისგან და სხვა მახასიათებლებისგან. მაგალითად, id  სვეტის აღწერა ( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY) მიუთითებს, რომ სვეტის ტიპი არის INT, რომ სვეტს აუცილებლად უნდა ჰქონდეს მნიშვნელობა - NOT NULL, რომ მისი მნიშვნელობა ახალი ელემენტის დამატებისას ავტომატურად გაიზრდება 1-ით - AUTO_INCREMENT, და რომ ეს სვეტი არის ცხრილის პირველადი გასაღები - PRIMARY KEY. 
                    
                    მთლიანობაში, ამ ხერხით შექმნილი ცხრილი ადრე შექმნილის ზუსტი ანალოგი იქნება და არა აქვს მნიშვნელობა, რომელი ხერხით შევქმნით მას. Go ღილაკზე დაჭერით შეიქმნება ცხრილი phones1`
                },
                {
                  title:"MySQL-თან მიერთება და მოთხოვნების შესრულება",
                  data:`MySQL-თან მისაერთებლად უნდა მივუთითოთ შეერთების პარამეტრები: სერვერის მისამართი, მომხმარებელი, პაროლი, ბაზის სახელი და ა. შ. რადგანაც, როგორც წესი, ბაზასთან შეერთება სჭირდება ბევრ სკრიპტს, ხშირად ეს მიერთება გააქვთ ცალკე ფაილში, რაც საშუალებას იძლევა, საჭიროების შემთხვევაში, ოპერატიულად შევცვალოთ მასში რამე.

                  შევქმნათ ფაილი connection.php და ჩავწეროთ მასში:
                  
                  <?php
                  $host = 'localhost'; // სერვერის მისამართი
                  $database = 'compstore'; // მონაცემთა ბაზის სახელი
                  $user = 'root'; // მომხმარებლის სახელი
                  $password = '1234567'; // პაროლი
                  ?>
                  რადგანაც ჩვენ უნდა შევუერთდეთ სერვერს ლოკალურ მანქანაზე, სერვერის მისამართი იქნება localhost. მონაცემთა ბაზად ავირჩიოთ წინა თემაში შექმნილი ბაზა compstore.
                  
                  MySQL-ზე მიუთითებლობისას უკვე არის მომხმარებელი root, რომელსაც მივუთითებთ მომხმარებლად და უნდა ჩავწეროთ ის პაროლი, რომელიც მივუთითეთ MySQL-ის ინსტალაციისას.
                  
                  ახლა უკვე შეგვიძლია შევუართდეთ მონაცემთა ბაზას:
                  
                  <?php
                  require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                   
                  // მივუერთდეთ სერვერს
                  $link = mysqli_connect($host, $user, $password, $database)
                      or die("შეცდომა " . mysqli_error($link));
                   
                  // შევასრულოთ მოქმედებები მონაცემთა ბაზაში
                      
                  // დავხუროთ შეერთება
                  mysqli_close($link);
                  ?>
                  პირველ რიგში უნდა ჩავრთოთ სკრიპტი შეერთების მონაცემებით require_once ინსტრუქციის მეშვეობით.
                  
                  შეერთების გასახსნელად ვიყენებთ ფუნქციას mysqli_connect(). ის იღებს კონექციის პარამეტრებს და უერთდება სერვერს (ხსნის კონექციას). შეცდომის შემთხვევაში ამუშავდება ოპერატორი die(), რომელიც გამოიტანს შეცდომის ტექსტს და შეწყვეტს სკრიპტის მუშაობას. წარმატების შემთხვევაში კი ფუნქცია აბრუნებს შეერთების ობიექტს $link ცვლადის სახით.
                  
                  მუშაობის დასრულების შემდეგ შეერთება უნდა დაიხუროს. ამისათვის გამოიყენება ფუნქცია mysqli_close(), რომელიც პარამეტრად ღებულობს შეერთების ობიექტს.
                  
                  მონაცემთა ბაზაში მოთხოვნის შესასრულებლად გამოიყენება ფუნქცია mysqli_query(), რომელიც პარამეტრებად ღებულობს შეერთების ობიექტს და SQL ენაზე შედგენილ მოთხოვნის სტრიქონს. მაგალითად:
                  
                  <?php
                  require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                   
                  // მივუერთდეთ სერვერს
                  $link = mysqli_connect($host, $user, $password, $database)
                      or die("შეცდომა " . mysqli_error($link));
                   
                  // შევასრულოთ მოქმედებები მონაცემთა ბაზაში
                  $query ="SELECT * FROM phones";
                  $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                  if($result)
                  {
                      echo "მოთხოვნა წარმატებით შესრულდა";
                  }    
                  // დავხუროთ შეერთება
                  mysqli_close($link);
                  ?>
                  ფუნქცია mysqli_query აბრუნებს ობიექტს $result, რომელიც შეიცავს მოთხოვნის შედეგს. წარუმატებლობის შემთხვევაში ეს ობიექტი შეიცავს მნიშვნელობას false.`
              },
              {
                title:"ცხრილის შექმნა და წაშლა",
                data:`ცხრილის შესაქმნელად უნდა გამოვიყენოთ SQL-ის ბრძანება "CREATE TABLE":

                <?php
                require_once 'connection.php';
                 
                $link = mysqli_connect($host, $user, $password, $database)
                    or die("შეცდომა " . mysqli_error($link));
                 
                $query ="CREATE Table phones2
                (
                    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                    name VARCHAR(200) NOT NULL,
                    company VARCHAR(200) NOT NULL
                )";
                $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                if($result)
                {
                    echo "ცხრილის შექმნა წარმატებით დასრულდა";
                }
                 
                mysqli_close($link);
                ?>
                სკრიპტის შესრულების შემდეგ შეიქმნება ცხრილი phones2, რომელიც ადრე phpMyAdmin-დან შექმნილი ცხრილების ანალოგიური იქნება. ჩვენ შეგვიძლია გავხსნათ phpMyAdmin და ვნახოთ ეს ცხრილი.
                
                ცხრილის წასაშლელად გამოიყენება SQL-ის ბრძანება "DROP TABLE":
                
                <?php
                require_once 'connection.php';
                 
                $link = mysqli_connect($host, $user, $password, $database)
                    or die("შეცდომა " . mysqli_error($link));
                 
                $query ="DROP TABLE phones2";
                 
                $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                if($result)
                {
                    echo "ცხრილის წაშლა წარმატებით დასრულდა";
                }
                 
                mysqli_close($link);
                ?>`
            },
            {
                title:"მონაცემების დამატება ცხრილში",
                data:`მონაცემთა ბაზაში გვაქვს წინა თემებში დამატებული ცხრილი phones სვეტებით id, name, company. დავამატოთ მასში მონაცემები.

                ცხრილში მონაცემების დასამატებლად გამოიყენება SQL-ის ბრძანება "INSERT":
                
                $query ="INSERT INTO phones VALUES(NULL, 'Samsung Galaxy III','Samsumg')";
                მოცემულ შემთხვევაში ბრძანება "INSERT" ამატებს ბაზაში ერთ ჩანაწერს. INTO საკვანძო სიტყვის შემდეგ ეთითება ცხრილის სახელი, ხოლო VALUES სიტყვის შემდეგ ფრჩხილებში ყველა სვეტის მნიშვნელობა. რადგანაც ცხრილში სამი სვეტია, მითითებულია სამი მნიშვნელობა.
                
                რადგანაც სვეტი id განსაზღვრულია, როგორც AUTO_INCREMENT, არაა აუცილებელი მისთვის მნიშვნელობის გადაცემა, შეგვიძლია მივუთითოთ მნიშვნელობა NULL, ხოლო MySQL მას მიანიჭებს მომდევნო დასაშვებ მნიშვნელობას.
                
                ახლა ვნახოთ მონაცემების დამატება კონკრეტულ მაგალითზე. შევქმნათ ამისთვის ფაილი create.php და დავამატოთ მასში შემდეგი კოდი:
                
                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                 
                if(isset($_POST['name']) && isset($_POST['company'])){
                 
                    // მივუერთდეთ სერვერს
                    $link = mysqli_connect($host, $user, $password, $database)
                        or die("შეცდომა " . mysqli_error($link));
                    
                    // სიმბოლოების ეკრანირება mysql-სთვის
                    $name = htmlentities(mysqli_real_escape_string($link, $_POST['name']));
                    $company = htmlentities(mysqli_real_escape_string($link, $_POST['company']));
                    
                    // მოთხოვნის სტრიქონის შექმნა
                    $query ="INSERT INTO phones VALUES(NULL, '$name','$company')";
                    
                    // შევასრულოთ მოთხოვნა
                    $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                    if($result)
                    {
                        echo "<span style='color:blue;'>მონაცემები დამატებულია</span>";
                    }
                    // დავხუროთ კონექცია
                    mysqli_close($link);
                }
                ?>
                <h2>ახალი მოდელის დამატება</h2>
                <form method="POST">
                <p>შეიყვანეთ მოდელი:<br>
                <input type="text" name="name" /></p>
                <p>მწარმოებელი: <br>
                <input type="text" name="company" /></p>
                <input type="submit" value="დამატება">
                </form>
                </body>
                </html>
                მოცემულ მაგალითში ფორმაში შეყვანილი მონაცემები იგზავნება მონაცემთა ბაზაში და ემატება ცხრილში.
                
                MySQL და უსაფრთხოება
                
                წინა მაგალიში ჩვენ გამოვიყენეთ ფუნქცია mysqli_real_escape_string(). მისი დანიშნულებაა სიმბოლოების ეკრანირება სტრიქონში, რომელიც შემდეგ გამოიყენება SQL მოთხოვნაში. პარამეტრებად იგი იღებს შეერთების ობიექტს და სტრიქონს, რომლის ეკრანირებაც უნდა მოხდეს. ამგვარად, ფაქტობრივად ჩვენ ვიყენებთ ეკრანირებას ორჯერ: ჯერ SQL გამოსახულებისთვის mysqli_real_escape_string() ფუნქციის მეშვეობით, შემდეგ html-ისთვის htmlentities() ფუნქციის სახით. ეს საშუალებას გვაძლევს თავი დავიცვათ ერთდროულად ორი ტიპის შეტევისაგან: XSS-შეტევა და SQL ინექცია.`
            },
        
            {
                title:" მონაცემების მიღება",
                data:`მონაცემების მისაღებად გამოიყენება SQL-ის ბრძანება ""SELECT. მაგალითად, მივიროთ ყველა ჩანაწერი ცხრილიდან phones:

                $query ="SELECT * FROM phones";
                ვნახოთ მაგალითი. შევქმნათ index.php ფაილი, რომელიც გამოიტანს ყველა მნიშვნელობას phones ცხრილიდან:
                
                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                 
                $link = mysqli_connect($host, $user, $password, $database)
                    or die("შეცდომა " . mysqli_error($link));
                    
                $query ="SELECT * FROM phones";
                 
                $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                if($result)
                {
                    $rows = mysqli_num_rows($result); // მიღებული სტრიქონების რაოდენობა
                    
                    echo "<table><tr><th>Id</th><th>მოდელი</th><th>მწარმოებელი</th></tr>";
                    for ($i = 0 ; $i < $rows ; ++$i)
                    {
                        $row = mysqli_fetch_row($result);
                        echo "<tr>";
                            for ($j = 0 ; $j < 3 ; ++$j) echo "<td>$row[$j]</td>";
                        echo "</tr>";
                    }
                    echo "</table>";
                    
                    // გავასუფთავოთ შედეგი
                    mysqli_free_result($result);
                }
                 
                mysqli_close($link);
                ?>
                </body>
                </html>
                შედეგების გამოსატანად აქ გამოიყენება ციკლი for. for ციკლისთვის ჩვენ გვჭირდება იმის ცოდნა, ტუ რამდენი სტრიქონია $result ცვლადში. ამისათვის გამოიყენება ფუნქცია mysqli_num_rows(). 
                
                სტრიქონების გადარჩევისთვის გამოიყენება შემდეგი ციკლი:
                
                for ($i = 0 ; $i < $rows ; ++$i)
                {
                    $row = mysqli_fetch_row($result);
                    echo "<tr>";
                        for ($j = 0 ; $j < 3 ; ++$j) echo "<td>$row[$j]</td>";
                    echo "</tr>";
                }
                ცალკეული სტრიქონის ამოსაღებად გამოიყენება ფუნქცია mysqli_fetch_row(). ამ ფუნქციის გამოძახების შემდეგ კურსორი გადადის $result მასივის შემდეგ სტრიქონზე, შესაბამისად, ყოველ ახალ გამოძახებაზე მივიღებთ ახალ სტრიქონს.
                
                შიდა ციკლი ახორციელებს მიმდინარე სტრიქონის უჯრების გადარჩევას:
                
                for ($j = 0 ; $j < 3 ; ++$j) echo "<td>$row[$j]</td>";
                რადგანაც ყოველ სტრიქონში სამი მონაცემია (ცხრილი შედგება სამი სვეტისგან), მრიცხველი $j გაივლის 0-დან 3-მდე. რადგანაც სტრიქონი წარმოადგენს უჯრების მასივს, გამოსახულება $row[$j] აბრუნებს მიმდინარე უჯრის მნიშვნელობას. 
                
                for ციკლის ნაცვლად შეიძლება გამოვიყენოთ ციკლი while:
                
                while ($row = mysqli_fetch_row($result)) {
                    echo "<tr>";
                        for ($j = 0 ; $j < 3 ; ++$j) echo "<td>$row[$j]</td>";
                    echo "</tr>";
                }
                რადგანაც მოთხოვნის შესრულების შემდეგ ცვლადი $result შეიცავდეს იქნება მნიშვნელობას, საჭიროა ბოლოს გავასუფთავოთ იგი. ამისათვის გამოიყენება ფუნქცია mysqli_free_result(). 
                
                PHP
                
                შეგვიძლია მივიღოთ მნიშვნელობები არა ყველა სვეტისთვის, არამედ, მაგალითად, მხოლოდ დასახელებები:
                
                $query ="SELECT name FROM phones";
                 
                $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                if($result)
                {
                    echo "<ul>";
                    while ($row = mysqli_fetch_row($result)) {
                        echo "<li>$row[0]</li>";
                    }
                    echo "</ul>";
                    
                    mysqli_free_result($result);
                }
                ამ შემთხვევაში ყოველი სტრიქონი შეიცავდეს იქნება მხოლოდ ერთ უჯრას და მიმართვა $row[1] გამოიწვევს შეცდომას, რადგან მოთხოვნის მიხედვით მონაცემები მოდის მხოლოდ ერთი სვეტიდან.`
            },
            {
                title:"მონაცემების რედაქტირება",
                data:`უკვე არსებული მონაცემების რედაქტირება ცოტა უფრო რთულია, ვიდრე მონაცემების დამატება და მიღება, რადგანაც ამ დროს საჭიროა ჯერ არსებული მონაცემების მიღება, ხოლო შემდგომ მონაცემთა ბაზის განახლება ახალი მონაცემებით. 

                მონაცემების განახლებისთვის გამოიყენება SQL ბრძანება "UPDATE":
                
                $query ="UPDATE phones SET name='Samsung ACE II', company='Samsung' WHERE id='1'";  
                
                SET საკვანძო სიტყვის შემდეგ მოდის სვეტების სახელების ჩამონათვალი მათი ახალი მნიშვნელობებით. მოთხოვნის სტრიქონის ბოლოს ეთითება სელექტორი (ფილტრი) WHERE გამოსახულების სახით. მოცემულ შემთხვევაში ყველა სტრიქონს, რომლის id='1', ენიჭება მნიშვნელობები name='Samsung ACE II' და company='Samsung'. 
                
                ახლა შევქმნათ ფაილი edit.php და დავამატოთ მასში შემდეგი კოდი:
                
                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                // მივუერთდეთ სერვერს
                $link = mysqli_connect($host, $user, $password, $database)
                        or die("შეცდომა " . mysqli_error($link));
                    
                // თუ გვაქვს POST მოთხოვნა
                if(isset($_POST['name']) && isset($_POST['company']) && isset($_POST['id'])){
                 
                    $id = htmlentities(mysqli_real_escape_string($link, $_POST['id']));
                    $name = htmlentities(mysqli_real_escape_string($link, $_POST['name']));
                    $company = htmlentities(mysqli_real_escape_string($link, $_POST['company']));
                    
                    $query ="UPDATE phones SET name='$name', company='$company' WHERE id='$id'";
                    $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                 
                    if($result)
                        echo "<span style='color:blue;'>მონაცემები განახლებულია</span>";
                }
                 
                // თუ გვაქვს GET მოთხოვნა
                if(isset($_GET['id']))
                {  
                    $id = htmlentities(mysqli_real_escape_string($link, $_GET['id']));
                    
                    // მოთხოვნის სტრიქონის შექმნა
                    $query ="SELECT * FROM phones WHERE id = '$id'";
                    // ვასრულებთ მოთხოვნას
                    $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                    //თუ მოთხოვნის შედეგში 0-ზე მეტი სტრიქონია
                    if($result && mysqli_num_rows($result)>0)
                    {
                        $row = mysqli_fetch_row($result); // ვიღებთ პირველ სტრიქონს
                        $name = $row[1];
                        $company = $row[2];
                        
                        echo "<h2>მოდელის შეცვლა</h2>
                            <form method='POST'>
                            <input type='hidden' name='id' value='$id' />
                            <p>შეიყვანეთ მოდელი:<br>
                            <input type='text' name='name' value='$name' /></p>
                            <p>მწარმოებელი: <br>
                            <input type='text' name='company' value='$company' /></p>
                            <input type='submit' value='შენახვა'>
                            </form>";
                        
                        mysqli_free_result($result);
                    }
                }
                // დავხუროთ კონექცია
                mysqli_close($link);
                ?>
                </body>
                </html>
                სტრუქტურულად მთელი კოდი იყოფა ორ ნაწილად: POST მოთხოვნის დამუშავება და GET მოთხოვნის დამუშავება. POST მოთხოვნის დამუშავება მონაცემთა დამატების მსგავსია, ოღონდ მოთხოვნის სტრიქონია შეცვლილი ზემოთ მითითებულით: $query ="UPDATE tovars SET name='Samsung ACE II', company='Samsung' WHERE id='1'";
                
                GET მოთხოვნის დამუშავებისას id-ის მნიშვნელობის მიხედვით ვღებულობთ მთლიან სტრიქონს მოთხოვნით SELECT * FROM phones WHERE id = '$id'. თუ პასუხი შეიცავს სტრიქონს, გამოგვაქვს მონაცემები რედაქტირებისთვის.
                
                ახლა, პირველი სტრიქონის რედაქტირებისთვის უნდა მივმართოთ ბრაუზერში სკრიპტს შემდეგ მისამართზე http://localhost:8080/edit.php?id=1. 
                
                რადგანაც ბრაუზერის მისამართის ზოლში გადაცემული მოთხოვნა წარმოადგენს GET მოთხოვნას, PHP გამოტოვებს POST მოთხოვნის დამუშავებას და შეასრულებს GET მოთხოვნის დამუშავებას. იგი მიიღებს მონაცემთა ბაზიდან შესაბამის სტრიქონს და შექმნის რედაქტირების ფორმას. ფორმაში შეგვიძლია შევიტანოთ ცვლილებები და შენახვის ღილაკზე დაჭერით შესრულდება POST მოთხოვნის დამუშავება და მონაცემები განახლდება სერვერზე`
            },
            {
                title:"მონაცემთა წაშლა",
                data:`მონაცემთა წასაშლელად გამოიყენება SQL-ის ბრძანება "DELETE":

                $query ="DELETE FROM phones WHERE id = '5'";
                
                მოცემულ შემთხვევაში წაიშლება სტრიქონი, რომლისთვისაც id=5.
                
                წაშლისას, ისევე როგორც რედაქტირებისას, სკრიპტს უნდა გადავცეთ წასაშლელი სტრიქონის id. შევქმნათ სკრიპტი delete.php შემდეგი შიგთავსით:
                
                <?php
                require_once 'connection.php';
                if(isset($_GET['id']))
                {  
                    $link = mysqli_connect($host, $user, $password, $database)
                            or die("შეცდომა " . mysqli_error($link));
                    $id = mysqli_real_escape_string($link, $_GET['id']);
                    
                    $query ="DELETE FROM phones WHERE id = '$id'";
                 
                    $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                    mysqli_close($link);
                }
                ?>
                თუ მივმართავთ სკრიპტს ბრაუზერიდან მოთხოვნით http://localhost:8080/delete.php?id=1, წაიშლება ცხრილის 1-;ი სტრიქონი.
                
                წაშლის ასეთი მეთოდი მარტივია და მშვენივრად მუშაობს, მაგრამ ის არ არის უსაფრთხო. მაგალითად, მივიღეთ ელექტრონული წერილი, რომელშიც ჩასმულია სურათი ემდეგი ტეგით:
                
                <img src="http://ჩვენი საიტის მისამართი/delete.php?id=1" />
                ასეთი წერილის გახსნისას ცხრილის პირველი ასევე წაიშლება. ეს ეხება არა მხოლოდ წერილებს, სხვა ადგილებშიც შესაძლებელია მსგავსი კოდის ჩანერგვა. ამის თავიდან ასაცილებლად შევცვალოთ კოდი შემდეგნაირად:
                
                <!DOCTYPE html>
                <html>
                <head>
                <meta charset="utf-8">
                </head>
                <body>
                <?php
                require_once 'connection.php'; // ჩავრთოთ სკრიპტი
                    
                if(isset($_POST['id'])){
                 
                $link = mysqli_connect($host, $user, $password, $database)
                            or die("შეცდომა " . mysqli_error($link));
                    $id = mysqli_real_escape_string($link, $_POST['id']);
                    
                    $query ="DELETE FROM phones WHERE id = '$id'";
                    $result = mysqli_query($link, $query) or die("შეცდომა " . mysqli_error($link));
                 
                    mysqli_close($link);
                    // გადამისამართება index.php სკრიპტზე
                    header('Location: index.php');
                }
                 
                if(isset($_GET['id']))
                {  
                    $id = htmlentities($_GET['id']);
                    echo "<h2>წავშალოთ მოდელი?</h2>
                        <form method='POST'>
                        <input type='hidden' name='id' value='$id' />
                        <input type='submit' value='წაშლა'>
                        </form>";
                }
                ?>
                </body>
                </html>
                ახლა სკრიპტზე მიმართვისას გამოჩნდება ფორმა, რომელსაც აქვს დამალული ველი id-ის მნიშვნელობით და წაშლის ღილაკი. ღილაკზე დაჭერით შესრულდება POST მოთხოვნა და ჩანაწერი წაიშლება. წაშლის მერე ხდება გადამისამართება index.php გვერდზე header() ფუნქციის მეშვეობით.`
            },
           
             
            ]
        }

    ]

}



}