export default Data = {
    htmlcss:{
    chapters:[
        {
            title:"თავი 1.HTML5-ის შესავალი",
            content:[
                {
                    title:"რა არის HTML",
                    data:`HTML (HyperText Markup Language) წარმოადგენს ჰიპერტექსტური მარკირების ენას, რომელიც ძირითადად გამოიყენება ინტერნეტის ქსელის დოკუმენტების შესაქმნელად. HTML სათავეს იღებს გასული საუკუნის 90-იანი წლებიდან, როგორც ვებგვერდების შესაქმნელი პრიმიტიული ენა, ხოლო დღეისთვის ინტერნეტი წარმოუდგენელია ამ ენის გარეშე. საიტების აბსოლუტური უმრავლესობა ასე თუ ისე იყენებს HTML-ს.

                    2014 წელს ოფიციალურად დასრულდა მუშაობა ახალ სტანდარტზე - HTML5-ზე, რომელმაც ფაქტიურად რევოლუციური ცვლილებები შეიტანა HTML-ში.
                    
                    კონკრეტულად რა მოიტანა HTML5-მა?
                    
                    HTML 5-მა განსაზღვრა პარსინგის ახალი ალგორითმი DOM-ის (Document Object Model) სტრუქტურის შესაქმნელად;
                    ახალი ელემენტების და ტეგების დამატება, როგორიცაა ელემენტები video, audio და სხვა;
                    HTML-ის არსებული ელემენტების გამოყენების წესების და სემანტიკის ხელახალი განსაზღვრა.
                    ახალი ფუნქციების დამატებით HTML5 გახდა არა უბრალოდ HTML-ის ახალი ვერსია, არამედ ფაქტიურად გახდა პლატფორმა პროგრამული უზრუნველყოფის შესაქმნელად, ხოლო მისი გამოყენების სფერო შორს გასცდა ინტერნეტის ფარგლებს: HTML5 გამოიყენება მობილური აპლიკაციებისთვის ანდროიდის, iOS, Windows Mobile ბაზაზე, ასევე დესკტოპ-პროგრამების შესაქმნელადაც.
                    
                    საბოლოოდ, HTML5 ძირითადად გამოიყენება შემდეგი დანიშნულებით:
                    
                    HTML5, როგორც ჰიპერტექსტური მარკირების განახლებული ენა, როგორც წინა HTML4-ის განვითარება;
                    HTML5, როგორც მძლავრი პლატფორმა ვებაპლიკაციების შექმნისთვის, რომელიც HTML5-თან ერთად ასევე მოიცავს პროგრამირების ენა JavaScript -ს და სტილების კასკადურ ცხრილებს CSS3-ს.
                    HTML5-ის განვითარებით დაკავებულია World Wide Web Consortium (შემოკლებით W3C  - მსოფლიო ქსელის კონსორციუმი) - დამოუკიდებელი საერთაშორისო ორგანიზაცია, რომელიც განსაზღვრავს HTML5-ის სტანდარტებს სპეციფიკაციების სახით. მიმდინარე სრული სპეციფიკაციის ნახვა შესაძლებელია მისამართზე https://www.w3.org/TR/html5/.
                    
                    ბრაუზერების მხარდაჭერა
                    
                    უნდა აღინიშნოს, რომ HTML5-ის სპეციფიკაციებსა და ვებბრაუზერების მიერ ამ ტექნოლოგიების გამოყენებას შორის ყოველთვის იყო სხვაობა, თუმცა ბრაუზერების უმეტესობამ ამ სტანდარტების დანერგვა დაიწყო ჯერ კიდევ მის ოფიციალურად გამოქვეყნებამდე და დღეისათვის ბრაუზერების ბოლო ვერსიების უმრავლესობა იყენებს HTML5-ის ფუნქციონალის უმეტეს ნაწილს (Google Chrome, Firefox, Opera, Internet Explorer 11, Microsoft Edge), ამასთნ ბრაუზერების ძველ ვერსიებს არ გააჩნიათ HTML5-ის მხარდაჭერა, მაგალითად Internet Explorer 8 და უფრო ადრეული ვერსიები, ხოლო IE 9, 10-ს გააჩნია სტანდარტების მხოლოდ ნაწილის მხარდაჭერა.
                    
                    ამასთან, იმ ბრაუზერებს, რომელთაც გააჩნიათ HTML5-ის სტანდარტების მხარდაჭერა, შესაძლოა არ გააჩნდეთ კონკრეტული ელემენტების მხარდაჭერა და ეს უნდა გავითვალისწინოთ მუშაობისას.
                    
                    ბრაუზერის მიერ HTML5-ს სტანდარტების მხარდაჭერის დონის შემოწმება შესაძლებელია სპეციალური სერვისის მეშვეობით მისამართზე: http://html5test.com.
                    
                    საჭირო ინსტრუმენტები
                    რა არის საჭირო HTML5-თან სამუშაოდ? პირველ რიგში საჭიროა ტექსტური რედაქტორი ვებგვერდის html-ის ტექსტის ასაკრეფად. ამ დროისათვის ერთ-ერთი ტექსტური რედაქტორი, რომელიც ფართოდ გამოიყენება არის Notepad++, მისი ნახვა და გადმოწერა შეიძლება შემდეგი მისამართიდან: http://notepad-plus-plus.org. მისი უპირატესობა მდგომარეობს იმაში რომ არის უფასო და გააჩნია კოდის შემოწმების ინსტრუმენტები.
                    
                    ასევე ფართოდ გამოიყენება კროსპლატფორმული ტექსტური რედაქტორი Visual Studio Code. მას გააჩნია უფრო მეტი შესაძლებლობები, ვიდრე Notepad++-ს და ასევე არის უფასო, გარდა ამისა, მისი გამოყენება შეიძლება როგორც Windows-ში, ასევე MacOS-ში და Linux-ის ბაზაზე არსებულ ოპერაციულ სისტემებში. ამ სახელმძღვანელოს შექმნის პროცესში გამოყენებულ იქნა Visual Studio Code.
                    
                    ასევე დაგვჭირდება ვებბრაუზერი შექმნილი ვებგვერდების გაშვებისა და შემოწმებისთვის. ამ მიზნებისთვის გამოდგება ნებისმიერი გავრცელებული ბრაუზერი - Google Chrome, Mozilla Firefox, Microsoft Edge, Opera.`
                },
                {
                    title:"HTML5-ის ელემენტები და ატრიბუტები",
                    data:`სანამ შევუდგებით საკუთარი ვებგვერდის შექმნას, განვიხილოთ ძირითადი სამშენებლო ბლოკები, აგურები, რისგანაც შედგება ვებგვერდი.

                    HTML5-ის დოკუმენტი, ისევე როგორც ნებისმიერი სხვა დოკუმენტი, შედგება ელემენტებისაგან, ხოლო ელემენტები შედგება ტეგებისაგან. როგორც წესი, ელემენტს გააჩნია საწყისი და საბოლოო ტეგი, რომლებიც მოქცეულია კუთხოვან ფრჩხილებში. მაგალითად:
                    
                    <div>div ელემენტის ტექსტი</div>
                    
                    აქ განსაზღვრულია ელემენტი div, რომელსაც გააჩნია საწყისი ტეგი <div> და საბოლოო ტეგი</div>. მათ შორის მოქცეულია div ელემენტის შიგთავსი. ამ შემთხვევაში შიგთავსის სახით წარმოდგენილია ტექსტი "div ელემენტის ტექსტი".
                    
                    ელემენტი ასევე შეიძლება შედგებოდეს ერთი ტეგისგან, მაგალითად ელემენტი <br />, რომლის დანიშნულებაა სტრიქონის გადატანა:
                    
                    <div>div ელემენტის <br />ტექსტი </div>
                    
                    ასეთ ელემენტს ასევე უწოდებენ ცარიელ ელემენტს. თუმცა მაგალითში გამოყენებულია სლეში ("/"), მაგრამ მისი გამოყენება შესაძლებელია სლეშის გარეშეც შემდეგი სახით: <br>.
                    
                    თითოეულ ელემენტს საწყის ტეგში შეიძლება ჰქონდეს ატრიბუტები, მაგალითად:
                    
                    <div style="color:red;">ღილაკი</div>    
                    <input type="button" value="დააჭირეთ">
                    აქ მოცემულია 2 ელემენტი: div და input. div ელემენტს გააჩნია ატრიბუტი style. ტოლობის ნიშნის შემდეგ ბრჭყალებში წერია ატრიბუტის მნიშვნელობა type="color:red;". ამ შემთხვევაში "color:red;" განსაზღვრავს, რომ ტექსტის ფერი არის წითელი. მეორე ელემენტს - input-ს გააჩნია 2 ატრიბუტი: type (მიუთითებს ელემენტის ტიპს - ღილაკი) და value (განსაზღვრავს ღილაკის ტექსტს).
                    
                    არსებობს გლობალური, ანუ ყველა ელემენტისათვის საერთო ატრიბუტები, როგორიცაა მაგალითად, style, და არის სპეციფიური, რომელიც გამოიყენება მხოლოდ ზოგიერთი ელემენტისათვის, მაგალითად type. ჩვეულებრივი ატრიბუტების გარდა არსებობს ლოგიკური ატრიბუტები, რომელთაც შეიძლება მნიშვნელობა არ მიენიჭოს, მაგალითად disabled:
                    <View style={{color:"red"}}>
                    <input type="button" value="დააჭირეთ" disabled>
                    </View>                    
                    ატრიბუტი disabled მიუთითებს, რომ ელემენტი არააქტიურია.
                    
                    გლობალური ატრიბუტები
                    
                    HTML5-ში არის გლობალური ატრიბუტები, რომლებიც გამოიყენება ყველა ელემენტისათვის:
                    
                    accesskey: განსაზღვრავს სწრაფ კლავიშს ელემენტისთვის
                    
                    class: ელემენტს ანიჭებს CSS-ის კლასს 
                    
                    contenteditable: განსაზღვრავს, რედაქტირებადია თუ არა ელემენტი
                    
                    contextmenu: განსაზღვრავს ელემენტის კონტექსტურ მენიუს,რომელიც გაიხსნება ელემენტზე მაუსის მარჯვენა კლავიშის დაჭერისას
                    
                    dir: განსაზღვრავს ტექსტის მიმართულებას ელემენტში
                    
                    draggable: განსაზღვრავს, შეიძლება თუ არა ელემენტის გადათრევა
                    
                    dropzone: განსაზღვრავს, კოპირდება თუ არა გადასატანი მონაცემები ელემენტზე გადათრევისას
                    
                    hidden: მალავს ელემენტს
                    
                    id: ელემენტის უნიკალური იდენტიფიკატორი. ვებგვერდზე იდენტიფიკატორი არ უნდა მეორდებოდეს
                    
                    lang: განსაზღვრავს ელემენტის ენას
                    
                    spellcheck: განსაზღვრავს, იქნება თუ არა მართლწერის შემოწმება გამოყენებული ელემენტის მიმართ
                    
                    style: განსაზღვრავს ელემენტის სტილს
                    
                    tabindex: განსაზღვრავს თანმიმდევრობას, რომლითაც მოხდება გადართვა ელემენტიდან ელემენტზე TAB კლავიშით
                    
                    title: ელემენტის დამატებითი აღწერა
                    
                    translate: განსაზღვრავს, უნდა ითარგმნოს თუ არა ელემენტის შინაარსი
                    
                    სამომხმარებლო ატრიბუტები
                    
                    წინა ვერსიებისგან განსხვავებით, HTML5-ში დაემატა სამომხმარებლო ატრიბუტები (custom attributes). ახლა უკვე ვებგვერდის შემქმნელს შეუძლია დაამატოს ნებისმიერი პარამეტრი, რომელსაც წინსართად უნდა ჰქონდეს data. მაგალითად:
                    
                    <input type="button" value="დააჭირეთ" data-color="red">
                    
                    აქ ელემენტზე დამატებულია სამომხმარებლო ატრიბუტი data-color, რომელსაც აქვს მნიშვნელობა red .
                    
                    ერთმაგი და ორმაგი ბრჭყალები
                    
                    ატრიბუტების მნიშვნელობის განსაზღვრისას შეიძლება გამოყენებულ იქნეს როგორც ერთმაგი, ისევე ორმაგი ბრჭყალები, თუმცა უფრო ხშირად გამოიყენება ორმაგი ბრჭყალები. ერთმაგი ბრჭყალები ძირითადად გამოიყენება იმ შემთხვევაში, როცა ატრიბუტის მნიშვნელობა თვითონ შეიცავს ბრჭყალებს. მაგალითად:
                    
                    <input type="button" value='ღილაკი "გამარჯობა, მსოფლიო"'>`
                },  {
                    title:"HTML5-ის დოკუმენტის შექმნა",
                    data:`ელემენტები წარმოადგენენ აგურებს, რომლებისგანაც შედგება html5-ის დოკუმენტი. დოკუმენტის შესაქმნელად საჭიროა შევქმნათ ტექსტური ფაილი და გაფართოება შევცვალოთ .html-ზე. შევქმნათ ფაილი და დავარქვათ index.html. შემდეგ გავხსნათ ეს ფაილი ნებისმიერი ტექსტური რედაქტორით და დავამატოთ შემდეგი ტექსტი:

                    <!DOCTYPE html>
                    <html>
                        
                    </html>
                    HTML5-ის დოკუმენტის შესაქმნელად პირველ რიგში საჭიროა 2 ელემენტი: DOCTYPE და html. ელემენტი doctype ანუ Document Type Declaration ამცნობს ბრაუზერს დოკუმენტის ტიპს, ჩვენს შემთხვევაში დოკუმენტის ტიპია html, რაც იმას ნიშნავს, რომ გამოიყენება HTML5 და არა რომელიმე წინა ვერსია. ხოლო html საწყის და საბოლოო ტეგებს შორის მოქცეული იქნება მთელი დოკუმენტი. html ელემენტის შიგნით დავამატოთ ორი ახალი ელემენტი: head და body. ელემენტი head შეიცავს ვებგვერდის მეტამონაცემებს: გვერდის სათაური, კოდირების ტიპი, და ა.შ., ასევე მიმართვებს რესურსებისადმი: სტილები, სკრიპტები, თუ ისინი გამოიყენება ვებ-გვერდზე. ელემენტი body კი შეიცავს ვებგვერდის მთელ შინაარსს.
                    
                    მოდით, შევცვალოთ index.html ფაილის შიგთავსი შემდეგი სახით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>HTML5-ის დოკუმენტი</title>
                        </head>
                        <body>
                            <div>HTML5-ის დოკუმენტის ტექსტი</div>
                        </body>
                    </html>
                    ელემენტში head გვაქვს ორი ელემენტი:
                    
                    ელემენტი title წარმოადგენს ვებგვერდის სათაურს
                    ელემენტი meta წარმოადგენს გვერდის მეტაინფორმაციას. ჩვენს შემთხვევაში ატრიბუტი charset="utf-8" უჩვენებს, რომ გვერდის კოდირება არის utf-8. ქართული ნაწერის კორექტულად გამოსაჩენად უნდა მივუთითოთ ეს კოდირება.
                    ელემენტ body-ის შიგნით გვაქვს მხოლოდ ერთი ელემენტი div, რომელიც განსაზღვრავს ცალკე ბლოკს. შიგნით უბრალო ტექსტია.
                    
                    შევინახოთ ფაილი და გავუშვათ ბრაუზერში:
                    
                    HTML5-ის დოკუმენტი
                    
                    ამგვარად, ჩვენ შევქმენით HTML5-ის დოკუმენტი, რომელსაც სათაურად აქვს "HTML5-ის დოკუმენტი" და ბრაუზერში ჩანართზე სწორედ ეს წარწერაა, ბრაუზერის ძირითად ველში კი ჩანს ის ტექსტი, რომელიც ჩავწერეთ body -ის div ელემენტში.`
                },  {
                    title:"HTML5-ის სინტაქსის სტილები",
                    data:`HTML5-ის დოკუმენტის შექმნისას შეიძლება გამოვიყენოთ ორი განსხვავებული სტილი: HTML და XML.

                    სტილი HTML ითვალისწინებს შემდეგ პრინციპებს:
                    
                    ელემენტს შეიძლება არ ჰქონდეს საწყისი და საბოლოო ტეგები
                    ელემენტს შეიძლება არ ჰქონდეს საბოლოო ტეგი
                    მხოლოდ ცარიელი ტეგები (მაგალითად br,img,link) შეიძლება დაიხუროს სლეშის მეშვეობით />
                    ტეგების და ატრიბუტების რეგისტრს არა აქვს მნიშვნელობა
                    ატრიბუტების მნიშვნელობები შეიძლება არ მოვაქციოთ ბრჭყალებში
                    ზოგიერთ ატრიბუტს შეიძლება არ ჰქონდეს მნიშვნელობა (checked, disabled)
                    სპეციალური სიმბოლოების ეკრანირება არ ხდება
                    დოკუმენტს უნდა ჰქონდეს ელემენტი DOCTYPE
                    ეს არის ე.წ. დაშვებული სტილი, რომელიც გარკვეულწილად ლოიალურია წესების მიმართ დოკუმენტის შექმნისას.
                    
                    HTML5 დოკუმენტი ასევე შეიძლება იყოს აღწერილი XML სინტაქსის მეშვეობით. ასეთ სტილს ასევე უწოდებენ XHTML. ის გამოიყენება, თუ დოკუმენტის თავში content type -ს აქვს მნიშვნელობა application/xml+xhtml. ამ სტილისათვის დამახასიათებელია შემდეგი წესები:
                    
                    ყველა ელემენტს უნდა ჰქონდეს საწყისი ტეგი
                    არაცარიელ ტეგებს ასევე უნდა ჰქონდეთ საბოლოო ტეგი
                    ნებისმიერი ელემენტის დახურვა შესაძლებელია სლეშით />
                    ტეგების და ატრიბუტების სახელები მგრძნობიარეა რეგისტრის მიმართ, როგორც წესი, იწერება დაბალ რეგისტრში
                    ატრიბუტების მნიშვნელობები უნდა იყოს მოქცეული ბრჭყალებში
                    არ დაიშვება ატრიბუტები მნიშვნელობის გარეშე (checked="checked" უბრალოდ checked-ის ნაცვლად)
                    უნდა მოხდეს სპეციალური სიმბოლოების ეკრანირება
                    შევადაროთ ეს ორი სინტაქსის სტილი. HTML5:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset=utf-8>
                        <title>სათაური</title>
                    </head>
                    <body>
                        <p>HTML5-ის დოკუმენტის ტექსტი<br>
                        <input type=button value=დააჭირეთ>
                    </body>
                    </html>
                    იგივე მაგალითი XHTML სტილში:
                    
                    <!doctype html>
                    <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                        <meta charset="utf-8">
                        <title>სათაური</title>
                        </head>
                    <body>
                        <p>HTML5-ის დოკუმენტის ტექსტი<br />
                        <input type="button" value="დააჭირეთ" /></p>
                    </body>
                    </html>
                    XHTML სტილის გამოყენებისას ასევე უნდა მივუთითოთ დოკუმენტის სახელების არე <html xmlns="http://www.w3.org/1999/xhtml">.
                    
                    კონკრეტული სტილის არჩევა პროგრამისტის ან ვებდიზაინერის სურვილზეა დამოკიდებული. ხშირად გამოიყენება შერეული სტილი, როცა წესები აღბულია როგორც ერთი, ასევე მეორე სტილისგან. ამასთან, საჭიროა გავითვალისწინოით, რომ ელემენტისთვის საწყისი და საბოლოო ტეგების არსებობა ამცირებს იმის ალბათობას, რომ ელემენტი არასწორად იქნება ინტერპრეტირებული ბრაუზერის მიერ. ასევე, ატრიბუტის მნიშვნელობების ბრჭყალებში ჩასმით თავს დავიზღვევთ მოსალოდნელი შეცდომებისაგან. მაგალითად, ატრიბუტმა კლასმა შეიძლება ერთდროულად რამდენიმე მნიშვნელობა მიიღოს: <div class="navmenu bigdesctop">. თუ მნიშვნელობას არ ჩავსვამთ ბრჭყალებში, ბრაუზერი class-ის მნიშვნელობად მიიღებს მხოლოდ navmenu-ს, ხოლო bigdesctop-ს ჩათვლის სხვა ატრიბუტად, რის გამოც ელემენტი არასწორად აისახება ბრაუზერში.
                    
                    იმის შესამოწმებლად, თუ რამდენად სწორადაა შედგენილი html დოკუმენტი, შეგვიძლია ვისარგებლოთ ვალიდატორით: https://validator.w3.org.`
                    
                },
            ]
        },
        {
          title:"თავი 2. HTML5-ის ელემენტები",  
          content:[
              {
                  title:"ელემენტი head  და ვებგვერდის მეტამონაცემები",
                  data:`როგორც წესი, html დოკუმენტის ერთ-ერთ უმნიშვნელოვანეს ელემენტს წარმოადგენს head, რომლის დანიშნულებაც მდგომარეობს ვებ-გვერდის მეტამონაცემების და თანმდევი ინფორმაციის განსაზღვრაში. მეტამონაცემები შეიცავენ ინფორმაციას ვებ-გვერდის შესახებ.

                  სათაური
                  
                  სათაურის მისათითებლად გამოიყენება ელემენტი title:
                  
                  <title>ვებ-გვერდის სათაური</title>
                  
                  ელემენტი base
                  
                  ელემენტი base განსაზღვრავს ვებ-გვერდის საბაზისო მისამართს, რომლის მიმართაც განისაზღვრება გვერდზე გამოყენებული სხვა მისამართები:
                  
                  <!doctype html>
                  <head>
                      <base href="content/">
                      <meta charset="utf-8">
                      <title>ვებ-გვერდის სათაური</title>
                  </head>
                  <body>
                      <a href="newpage.html">ახალ გვერდზე გადასვლა</a>
                  </body>
                  </html>
                  მიუხედავად იმისა, რომ ბმულს "ახალ გვერდზე გადასვლა" მისამართში უწერია "newpage.html", ფაქტიური მისამართი იქნება "content/newpage.html". ანუ ვებ-გვერდის საქაღალდეში უნდა იყოს ქვესაქაღალდე content და მასში ფაილი newpage.html.
                  
                  შეიძლება base ელემენტში მივუთითოთ სრული მისამართიც:
                  
                  <base href="http://microsoft.com/">
                  
                  ამ შემთხვევაში ბმული გადაგვიყვანს მისამართზე "http://microsoft.com/newpage.html".
                  ელემენტი meta
                  ელემენტი meta განსაზღვრავს ვებგვერდის მეტამონაცემებს.
                  
                  იმისათვის, რომ უნიკოდის ტექსტის შემცველი გვერდები კორექტულად გამოჩნდეს ბრაუზერში, აუცილებელია მივუთითოთ კოდირება utf-8:
                  
                  <meta charset="utf-8">
                  
                  ამასთან, თვითონ დოკუმენტის კოდირებაც უნდა ემთხვეოდეს meta კოდირებას.
                  ელემენტს meta ასევე აქვს 2 ატრიბუტი: name და content. name არის ატრიბუტის სახელი, content - ატრიბუტის მნიშვნელობა.
                  
                  HTML დოკუმენტში არის 5 ტიპის მეტამონაცემები:
                  
                  application name: ვებ-აპლიკაციის სახელი, რომლის ნაწილიცაა ეს დოკუმენტი
                  
                  author: დოკუმენტის ავტორი
                  
                  description: დოკუმენტის მოკლე აღწერა
                  
                  generator: პროგრამის სახელი, რომელშიც დაგენერირდა დოკუმენტი
                  
                  keywords: საკვანძო სიტყვები (გამოიყენება საძიებო სისტემების მიერ ძებნისთვის)
                  
                  უნდა აღინიშნოს, რომ მეტად მნიშვნელოვანი ატრიბუტია description. მის მნიშვნელობას საძიებო სისტემები ხშირად იყენებენ, როგორც ანოტაციას ვებგვერდისთვის.
                  
                  დავამატოთ დოკუმენტში რამდენიმე meta ელემენტი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <base href="content/">
                          <title>ვებგვერდის სათაური</title>
                          <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                          <meta name="author" content="ავტორი">
                      </head>
                      <body>
                          <a href="newpage.html">HTML5 დოკუმენტის შინაარსი</a>
                      </body>
                  </html>`
              },
              {
                title:"დაჯგუფების ელემენტები",
                data:`HTML-ში არის რიგი ელემენტებისა, რომლებიც განკუთვნილია ვებგვერდის შიგთავსის (content) დასაჯგუფებლად.

                ელემენტი div
                
                ელემენტი div გამოიყენება ვებგვერდის შიგთავსის სტრუქტურულად დაჯგუფებისთვის, ცალ-ცალკე ბლოკებში მოსაქცევად. div ქმნის ბლოკს, რომელიც ბრაუზერის მთელ სიგანეზე ვრცელდება (თუ სხვა რამეს არ მივუთითებთ). div-ის მომდევნო ელემენტი გადადის ახალ სტრიქონზე. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <div>დოკუმენტის სათაური</div>
                        <div>დოკუმენტის ტექსტი</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                პარაგრაფები
                
                პარაგრაფები იქმნება <p> და </p> ტეგების მეშვეობით. თითოეული პარაგრაფი იწყება ახალი სტრიქონიდან.მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <div>დოკუმენტის სათაური</div>
                        <div>
                            <p>პირველი პარაგრაფი</p>
                            <p>მეორე პარაგრაფი</p>
                        </div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                თუ ერთი პარაგრაფის ფარგლებში გვინდა სტრიქონის გადატანა, უნდა გამოვიყენოთ ელემენტი <br>:
                <p>პირველი სტრიქონი.<br />მეორე სტრიქონი.</p>
                
                ელემენტი pre
                ელემენტ pre-ს გამოაქვს წინასწარ დაფორმატებული ტექსტი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <base href="content/">
                        <title>ვებგვერდის სათაური</title>
                        <meta name="description" content="ჩემი პირველი HTML5 დოკუმენტი">
                        <meta name="author" content="ავტორი">
                    </head>
                    <body>
                        <pre>
                            პირველი სტრიქონი
                            მეორე სტრიქონი
                            მესამე სტრიქონი
                        </pre>
                    </body>
                </html>
                 
                HTML5-ის დოკუმენტი
                
                ელემენტი span
                ელემენტი span-თ ხდება გარკვეული ტექსტის შემოგარსვა მთელ სიგრძეზე და მის სტილიზაციას ემსახურება. განსხვავებით div ელემენტისაგან და პარაგრაფისგან, span-ს არ გადააქვს ტექსტი ახალ სტრიქონზე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5-ის დოკუმენტი</title>
                    </head>
                    <body>
                        <div>HTML5-ის დოკუმენტის სათაური</div>
                        <div>
                            <p><span style="color:red;">პირველი</span> პარაგრაფი</p>
                            <p><span>მეორე</span> პარაგრაფი</p>
                        </div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                აღსანიშნავია, რომ თვითონ span არაფერს არ აკეთებს, მეორე პარაგრაფში იგი არ ცვლის ტექსტს არანაირად. პირველ პარაგრაფში span-ს გააჩნია ატრიბუტი style="color:red;", რომელიც ცვლის ტექსტის სტილს (ცვლის ფერს).
                თუ div და p არის ბლოკის ტიპის ელემენტები და ისინი შეიძლება შეიცავდნენ ნებისმიერ ელემენტებს, span არის სტრიქონული ტიპის. ამასთან არაა რეკომენდირებული span-ის შიგნით მოვაქციოთ ბლოკური ელემენტები.`
            },
            {
                title:"სათაურები",
                data:`ელემენტები <h1>, <h2>, <h3>, <h4>, <h5> и <h6> ემსახურება სხვადასხვა დონის სათაურების შექმნას:

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>HTML5 -ის სათაურები</title>
                </head>
                <body>
                    <h1>პირველი დონის სათაური</h1>
                    <h2>მეორე დონის სათაური</h2>
                    <h3>მესამე დონის სათაური</h3>
                    <h4>მეოთხე დონის სათაური</h4>
                    <h5>მეხუთე დონის სათაური</h5>
                    <h6>მეექვსე დონის სათაური</h6>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სათაურებს გააჩნია გამუქებული შრიფტი და შრიფტის ზომა ყველაზე დიდი <h1> -დან ყველაზე პატარა <h6>-მდე.
                
                სათაურების დამატებისას უნდა გავითვალისწინოთ, რომ ვებგვერდს უნდა ჰქონდეს მხოლოდ ერთი პირველი დონის სათაური <h1>. ის ასრულებს ვებგვერდის ძირითადი სათაურის როლს.`
            },
            {
                title:"ტექსტის ფორმატირება",
                data:`html-ის მთელი რიგი ელემენტები განკუთვნილია ტექსტის ფორმატირებისთვის, მაგალითად გასამუქებლად, ხაზგასასმელად და ა. შ. განვიხილოთ ეს ელემენტები:

                <b>: ტექსტის გამუქება
                <del>: ტექსტის გადახაზვა 
                <i>: ტექსტის დახრა
                <em>: ტექსტის დახრა, ოღონდ <i>-საგან განსხვავებით, ატარებს ლოგიკურ ხასიათს და ხაზს უსვამს მის მნიშვნელობას
                <s>: ტექსტის გადახაზვა
                <small> ტექსტის დაპატარავება
                <strong> ტექსტის გამუქება, ოღონდ <b>-საგან განსხვავებით, ატარებს ლოგიკურ ხასიათს და ხაზს უსვამს მის მნიშვნელობას 
                <sub>: ტექსტის ჩამოწევა სტრიქონის ქვემოთ
                <sup>: ტექსტის აწევა სტრიქონის ზევით
                <u>: ტექსტის ხაზგასმა
                <ins>: ჩასმული (დამატებული) ტექსტი
                <mark>: ტექსტის გამოყოფა ფერით. ხაზს უსვამს მის მნიშვნელობას
                გამოვიყენოთ ეს ელემენტები:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ტექსტის ფორმატირება HTML5-ში</title>
                    </head>
                    <body>
                        <p>ფორმატირება <mark>HTML5</mark>-ში</p>
                        <p>ეს <b>გამუქებული</b> ტექსტია</p>
                        <p>ეს <strong>მნიშვნელოვანი</strong> ტექსტია</p>
                        <p>ეს <del>გადახაზული</del> ტექსტია</p>
                        <p>ეს <s>გაუქმებული</s> ტექსტია</p>
                        <p>ეს <em>მნიშვნელოვანი</em> ტექსტია</p>
                        <p>ეს ტექსტი <i>დახრილია</i> </p>
                        <p>ეს <ins>დამატებული</ins> ტექსტია</p>
                        <p>ეს <u>ხაზგასმული</u> ტექსტია</p>
                        <p>X<sub>i</sub> = Y<sup><small>2</small></sup> + Z<sup><small>2</small></sup></p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი`
            },
            {
                title:"სურათებთან მუშაობა",
                data:`სურათების გამოსატანად HTML-ში გამოიყენება ელემენტი <img>, რომელსაც გააჩნია ორი მნიშვნელოვანი ატრიბუტი: 

                src: სურათის მისამართი. ეს შეიძლება იყოს ფარდობითი ან აბსოლუტური მისამართი ფაილურ სისტემაში ან მისამართი ინტერნეტში
                alt: სურათის ტექსტური აღწერა. თუ რაღაც მიზეზით ვერ ხერხდება სურათის გამოტანა ეკრანზე, მის ნაცვლად გამოჩნდება alt ატრიბუტში მითითებული მნიშვნელობა
                alt-ს კიდევ ერთი დანიშნულება აქვს. საძიებო სისტემებში სურათის ინდექსირება ხდება სწორედ მისი მნიშვნელობით.
                
                იგივე საქაღალდეში, სადაც index.html-ია დავდოთ რამე სურათი და გამოვიტანოთ ის ვებგვერდზე:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <img src="kanioni.jpg" alt="martvilis kanioni">
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სტილებისა და ფორმატირების ელემენტების გამოყენებით შესაძლებელია სურათისა და ტექსტის კომბინირება. მაგალითად:
                
                 
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <div>
                        <img src="kanioni.jpg" alt="მარტვილის კანიონი" style="float:left; margin-right:10px;" />
                        <h1>Lorem Ipsum</h1>
                        <b>Lorem Ipsum</b> is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry....
                    </div>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სურათისთვის მნიშვნელოვანი ატრიბუტებია ასევე ზომები width და height. მათი მითითების გარეშე სურათი იღებს ორიგინალურ ზომებს, ხოლო მითითების შემთხვევაში - მითითებულს. შესაძლებელია მივუთითოთ მხოლოდ ერთ-ერთი (სიგანე ან სიმაღლე), მეორე პროპორციულად მიენიჭება ავტომატურად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სურათი HTML5-ში</title>
                </head>
                <body>
                    <img src="kanioni.jpg" alt="martvilis kanioni" width="250px" height="165">
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი`
            },
            {
                title:"სიები",
                data:`სიების შესაქმნელად HTML5-ში გამოიყენება ელემენტები <ol> (დანომრილი სია) და <ul> (უნომრო სია):

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სიები HTML5-ში</title>
                </head>
                <body>
                    <h2>დანომრილი სია</h2>
                    <ol>
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ol>
                    <h2>უნომრო სია</h2>
                    <ul>
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თუ სპეციალურად არ მივუთითებთ, დანომრილ სიაში ნუმერაცია ხორციელდება ნატურალური რიცხვებით 1-დან, სოლო უნომრო სიაში - შავი მუქი წერტილით. საჭიროების შემთხვევაში ჩვენ შეგვიძლია შევცვალოთ ნუმერაცია სტილის list-style-type მეშვეობით. ჩამოვთვალოთ ძირითადი და ხშირად გამოყენებული სტილები:
                
                დანომრილი სიებისთვის:
                
                decimal: რიცხვები, ათვლა იწყება 1-დან
                decimal-leading-zero: რიცხვები, რომელთაც წინ უძღვის 0, მაგალითად 01,02,03,...98,99
                lower-roman: დაბალი რეგისტრის რომაული რიცხვები, მაგალითად, i, ii, iii, iv, v
                upper-roman: მაღალი რეგისტრის რომაული რიცხვები, მაგალითად, I, II, III, IV, V…
                lower-alpha: დაბალი რეგისტრის ლათინური ასოები,მაგალითად, a, b, c..., z
                upper-alpha: მაღალი რეგისტრის ლათინური ასოები,მაგალითად, A, B, C, … Z
                georgian: ქართული ანბანის ასოები, ა,ბ,გ,დ,...ჰ
                დანომრილ სიებს start ატრიბუტის მეშვეობით შეიძლება მივუთითოთ, თუ საიდან დაიწყება ნუმერაცია. მაგალითად:
                
                <h2>list-style-type = decimal</h2>
                    <ol style="list-style-type:decimal;" start="3">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ol>
                    <h2>list-style-type = upper-roman</h2>
                    <ol style="list-style-type:upper-roman;" start="10">
                        <li>iPhone 6S Plus</li>
                        <li>Galaxy S7 Edge</li>
                        <li>Nexus 6P</li>
                        <li>Lumia 950 XL</li>
                    </ol>
                    <h2>list-style-type = lower-alpha</h2>
                    <ol style="list-style-type:lower-alpha;">
                        <li>LG G 5</li>
                        <li>Huawei P8</li>
                        <li>Asus ZenFone 2</li>
                    </ol>
                    <h2>list-style-type = georgian</h2>
                    <ol style="list-style-type:georgian;">
                        <li>ერთი</li>
                        <li>ორი</li>
                        <li>სამი</li>
                        <li>ოთხი</li>
                        <li>ხუთი</li>
                    </ol>
                 
                
                HTML5-ის დოკუმენტი
                
                უნომრო სიებისთვის list-style-type-მა შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                
                disk: შავი წრე
                circle: ცარიელი წრე
                square: შავი კვადრატი
                მაგალითად:
                
                    <h2>list-style-type = disk</h2>
                    <ul style="list-style-type:disk;">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                    <h2>list-style-type = circle</h2>
                    <ul style="list-style-type:circle;">
                        <li>iPhone 6S Plus</li>
                        <li>Galaxy S7 Edge</li>
                        <li>Nexus 6P</li>
                        <li>Lumia 950 XL</li>
                    </ul>
                    <h2>list-style-type = square</h2>
                    <ul style="list-style-type:square;">
                        <li>LG G 5</li>
                        <li>Huawei P8</li>
                        <li>Asus ZenFone 2</li>
                    </ul>
                 
                
                HTML5-ის დოკუმენტი
                
                კიდევ ერთ საინტერესო შესაძლებლობას სიებისთვის გვაძლევს სტილი list-style-image. მისი მეშვეობით შესაძლებელია სიის გვერდით გამოვიტანოთ სურათი. მაგალითად:
                
                <ul style="list-style-image:url(phone.jpeg);">
                        <li>iPhone 6S</li>
                        <li>Galaxy S7</li>
                        <li>Nexus 5X</li>
                        <li>Lumia 950</li>
                    </ul>
                 
                
                HTML5-ის დოკუმენტი
                
                ჰორიზონტალური სია
                
                ჰორიზონტალური სიის მისაღებად სიის ყველა ელემენტისთვის უნდა დავაყენოთ სტილი display:inline:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სიები HTML5-ში</title>
                    <style>
                        ul#menu li {
                            display:inline;
                        }
                    </style>
                </head>
                <body>
                    <ul id="menu">
                        <li>|მთავარი|</li>
                        <li>|ბლოგი|</li>
                        <li>|ფორუმი|</li>
                        <li>|საიტის შესახებ|</li>
                    </ul>
                </body>
                </body
                </html>`
            },
            {
                title:"ელემენტი details",
                data:`ელემენტი details საშუალებას იძლევა შეიქმნას ჩამოშლადი ბლოკი, რომელიც თავდაპირველად დამალულია. ის შეიცავს ელემენტს summary, რომელიც ყოველთვის ჩანს, როგორც სათაური, ხოლო დანარჩენი ნაწილი გამოჩნდება ისარზე ან სათაურზე დაჭერის შემთხვევაში. მაგალითად:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტი details HTML5-ში</title>
                    </head>
                    <body>
                        <details>
                            <summary>2015 წლის ფლაგმანები</summary>
                            <ul>
                                <li>iPhone 6S Plus</li>
                                <li>Nexus 6P</li>
                                <li>Galaxy S6 Edge</li>
                                <li>Lumia 950 XL</li>
                            </ul>
                        </details>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სათურზე ან ისარზე დაჭერისას გაიშლება დამალული ნაწილი:
                
                HTML5-ის დოკუმენტი
                
                უნდა გავითვალისწინოთ, რომ ამ დროისთვის ამ ელემენტის მხარდაჭერა ყველა ბრაუზერს არა აქვს.`
            },
            {
                title:"განმარტებების სია",
                data:`განმარტებების სია (definition list) არის ისეთი სია, რომელიც შეიცავს ტერმინს და მის განმარტებას. ასეთი წყვილი - ტერმინი-განმარტება სიაში შეიძლება იყოს ბევრი. განმარტებების სიის შესაქმნელად გამოიყენება ტეგი <dl></dl>. ამ ტეგების შიგნით თავსდება სიის ელემენტები. თითოეული ელემენტი შედგება ტერმინისგან <dt></dt> (dt - "definition term") და განმარტებისგან <dd></dd>(dd- "definition description"). მაგალითად:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>განმარტებების სია HTML5-ში</title>
                    </head>
                    <body>
                        <dl>
                            <dt>რასობრივი დისკრიმინაცია</dt>
                            <dd>დანაშაული, რომელსაც პირი სჩადის ეროვნული ან რასობრივი მტრობის ან განხეთქილების
                                    ჩამოგდების, ეროვნული პატივისა და ღირსების დამცირების მიზნით.</dd>
                            <dt>რეაბილიტაცია</dt>
                            <dd>უკანონოდ ან დაუსაბუთებლად მსჯავრდებული ან ბრალდებული პირისათვის უფლებების
                                    აღდგენა, როდესაც დადგინდება მისი უდანაშაულობა გამამართლებელი განაჩენით, ან მის
                                    მიმართ გამოტანილი იქნება დადგენილება (განჩინება) სისხლისსამართლებრივი დევნის
                                    შეწყვეტის თაობაზე.</dd>
                            <dt>რესტიტუცია</dt>
                            <dd>პირვანდელი მდგომარეობის აღდგენა. სახელშეკრულებო ურთიერთობებში რესტიტუცია ხდება
                                    ხელშეკრულებიდან მხარეთა გასვლისას იმ დროს, რათა ისინი ამ ხელშეკრულების დადებამდე
                                    არსებულ ვითარებას დაუბრუნდნენ.</dd>
                        </dl>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი`
            },
            {
                title:"ცხრილები",
                data:`ცხრილების შესაქმნელად გამოიყენება ელემენტი table. თითოეული ცხრილი <table> და </table> ტეგებს შორის შეიცავს სტრიქონებს tr ელემენტის სახით, რომელიც თავის მხრივ შეიცავს უჯრებს td ელემენტის სახით.

                შევქმნათ მარტივი ცხრილი:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                </head>
                <body>
                    <table>
                        <tr>
                            <td>მოდელი</td>
                            <td>კომპანია</td>
                            <td>ფასი</td>
                        </tr>
                        <tr>
                            <td>Nexus 6P</td>
                            <td>Huawei</td>
                            <td>700</td>
                        </tr>
                        <tr>
                            <td>iPhone 6S PLus</td>
                            <td>Apple</td>
                            <td>650</td>
                        </tr>
                        <tr>
                            <td>Lumia 950 XL</td>
                            <td>Microsoft</td>
                            <td>450</td>
                        </tr>
                    </table>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ცხრილი შედგება სამი სვეტისგან და ოთხი სტრიქონიდან. პირველი სტრიქონი ასრულებს სათაურის მოვალეობას. თუმცა html5-ში გათვალისწინებულია ელემენტები, რომელთა საშუალებითაც შესაძლებელია ცხრილის სათაურის, სვეტების სათაურის, ცხრილის ტანისა და ქვედა ნაწილის გამოყოფა. ამისთვის გათვალისწინებულია ელემენტები: caption, thead,tbody,tfoot. შევცვალოთ ცხრილი შემდეგნაირად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                </head>
                <body>
                    <table>
                        <caption><b>2015 წლის პოპულარული სმარტფონები</b></caption>
                        <thead>
                        <tr>
                            <th>მოდელი</th>
                            <th>კომპანია</th>
                            <th>ფასი</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Nexus 6P</td>
                            <td>Huawei</td>
                            <td>700</td>
                        </tr>
                        <tr>
                            <td>iPhone 6S PLus</td>
                            <td>Apple</td>
                            <td>650</td>
                        </tr>
                        <tr>
                            <td>Lumia 950 XL</td>
                            <td>Microsoft</td>
                            <td>450</td>
                        </tr>
                        </tbody>
                        <tfoot>
                            <tr>
                                <th colspan="3">* 12 სექტემბრის მდგომარეობით</th>
                            </tr>
                        </tfoot>
                    </table>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სათურის სტრიქონი მოქცეულია thead ელემენტის შიგნით. სათაურის უჯრებისთვის გამოიყენება არა td, არამედ th. იგი სათურის ტექსტს ამუქებს. ცხრილის ქვედა ნაწილი - ფუტერი შეიცავს მხოლოდ ერთ უჯრას. სტრიქონის რამდენიმე უჯრის გასაერთიანებლად გამოიყენება ატრიბუტი colspan. მისი მნიშვნელობა "3" მიუთითებს, რომ გაერთიანებულია 3 უჯრა. ანალოგიურად, სვეტში რამდენიმე უჯრის გასაერთიანებლად გამოიყენება ატრიბუტი rowspan. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>ცხრილები HTML5-ში</title>
                    <style>
                        td {
                            width: 60px;
                            height: 60px;
                            border: solid 1px silver;
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                    <table>
                        <tr>
                            <td rowspan="2" style="background-color:green;">1</td>
                            <td>2</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td colspan="2" style="background-color:red;">7</td>
                        </tr>
                    </table>
                </body>
                </html>`
            },
            {
                title:"ბმულები",
                data:`ბმულები, რომლებიც წარმოდგენილია <a></a> ელემენტის სახით ასრულებენ მნიშვნელოვან როლს: ისინი უზრუნველყოფენ ნავიგაციას ცალკეულ დოკუმენტებს შორის. ამ ელემენტს გააჩნია შემდეგი ატრიბუტები:

                href: განსაზღვრავს ბმულის მისამართს
                hreflang: მიუტითებს დოკუმენტის ენას, სადაც გადავყავართ ბმულს
                media: განსაზღვრავს მოწყობილობას, რომლისთვისაცაა განკუთვნილი ბმული
                rel: განსაზღვრავს დამოკიდებულებას მიმდინარე დოკუმენტსა და იმ რესურსს შორის, სადაც გადავყავართ ბმულს
                target: განსაზღვრავს ბმულის გახსნის ადგილს
                type: განსაზღვრავს რესურსის mime-type-ს, სადაც გადავყავართ ბმულს
                ყველაზე მნიშვნელოვანი ატრიბუტია href:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბმულები</title>
                    </head>
                    <body>
                        <a href="content.html">HTML5-ის სახელმძღვანელო</a>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                აქ გამოყენებულია ფარდობითი მისამართი content.html, ანუ index.html-თან იგივე საქაღალდეში უნდა იყოს ფაილი content.html. ასევე შესაძლებელია ინტერნეტის სრული მისამართის გამოყენებაც.
                
                ნავიგაცია დოკუმენტის შიგნით
                
                ბმულების მეშვეობით შესაძლებელია ნავიგაცია ერთი დოკუმენტის შიგნით ბლოკებს შორის. ამისათვის მისამართად გამოიყენება დიეზი (#), რომელსაც მოსდევს იმ ელემენტის id, სადაც უნდა გადავყავდეთ ბმულს. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>შიდა ბმულები</title>
                    </head>
                    <body>
                        <a href="#paragraph1">პარაგრაფი 1</a> | <a href="#paragraph2">პარაგრაფი 2</a> | <a href="#paragraph3">პარაგრაფი 3</a>
                        <h2 id="paragraph1">პარაგრაფი 1</h2>
                        <p>პარაგრაფი 1-ის შინაარსი</p>
                        <h2 id="paragraph2">პარაგრაფი 2</h2>
                        <p>პარაგრაფი 2-ის შინაარსი</p>
                        <h2 id="paragraph3">პარაგრაფი 3</h2>
                        <p>პარაგრაფი 3-ის შინაარსი</p>
                    </body>
                </html
                 
                
                HTML5-ის დოკუმენტი
                
                ატრიბუტი target
                
                მითითების გარეშე ბმული იხსნება იმავე ფანჯარაში, რომელშიც იმყოფება მიმდინარე დოკუმენტი. target ატრიბუტის მეშვეობით შესაძლებელია შევცვალოთ ეს ადგილი. იგი ღებულობს შემდეგ მნიშვნელობებს:
                
                _blank: დოკუმენტის გახსნა ბრაუზერის ახალ ფანჯარაში ან ჩანართში
                _self: დოკუმენტის გახსნა იგივე ფრეიმში ან ფანჯარაში
                _parent: დოკუმენტის გახსნა მშობელ ფრეიმში ან ფანჯარაში, თუ ბმული მოთავსებულია შიდა ფრეიმში
                _top: დოკუმენტის გახსნა ბრაუზერის მთელ ფანჯარაში
                framename: დოკუმენტის გახსნა ფრეიმში სახელად framename (ფრეიმის სახელი შეიძლება ნებისმიერი იყოს)
                მაგალითად, ბმულის გასახსნელად ახალ ფანჯარაში უნდა დავწეროთ:
                
                <a href="http://progbook.terasoft.ge/" target="_blank">HTML5-ის სახელმძღვანელო</a>
                
                ბმულების სტილიზაცია
                
                მითითბის გარეშე ბმულს გააჩნია ლურჯი ფერი და ხაზგასმულია. მაუსის დაჭერისას ბმული ხდება აქტიური და ფერი ხდება წითელი. დაჭერისა და ბმულის მისამართზე გადასვლის შემდეგ ბმული იცვლის ფერს, როგორც წესი, ხდება იისფერი. ასეთ სტილიზაციას ბმულს აძლევს ბრაუზერი, მაგრამ სურვილის შემთხვევაში შესაძლებელია შევცვალოთ სტილების მეშვეობით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბმულები</title>
                        <style>
                            a:link    {color:blue; text-decoration:none}
                            a:visited {color:green; text-decoration:none}
                            a:hover   {color:red; text-decoration:underline}
                            a:active  {color:yellow; text-decoration:underline}
                        </style>
                    </head>
                    <body>
                        <a href="index.html">HTML5-ის სახელმძღვანელო</a>
                    </body>
                </html>
                აქ განსაზღვრულია ბმულის სტილი სხვადასხვა მდგომარეობაში: 
                
                a:link ბმული ჩვეულებრივ მდგომარეობაში, როცა მაუსი არაა დაჭერილი ან მიმართული ბმულისკენ
                a:visited ბმული, რომელზეც უკვე იყო განხორციელებული გადასვლა
                a:hover ბმულის მდგომარეობა, როცა მაუსი მიმართულია მისკენ
                a:active ბმული მაუსის დაჭერის მომენტში
                სტილი color განსაზღვრავს ფერს, ხოლო text-decoration ხაზგასმას: none - ხაზგასმის გარეშე, underline - ხაზგასმული
                
                სურათი ბმული
                
                თუ მოვათავსებთ <a> ელემენტის შიგნით ელემენტს <img>, მივიღებთ სურათს ბმულით:
                
                    <a href="index.html">
                       <img src="cover.png" alt="HTML tutorial">
                    </a>`
            },
            {
                title:"ელემენტები figure და figcaption",
                data:`ელემენტი figure გამოიყენება ილუსტრაციების, დიაგრამების, სურათების ანოტაციისთვის. ხოლო figcaption შეიცავს სათაურს figure ელემენტის შიგთავსისთვის. 

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტი Figure HTML5-ში</title>
                    </head>
                    <body>
                        <div>
                            <p>Lorem ipsum dolor … </p>
                            <figure>
                                <figcaption>მარტვილის კანიონი</figcaption>
                                <img src="kanioni.jpg" alt="მარტვილის კანიონი">
                            </figure>
                            <p>Lorem ipsum dolor … </p>
                        </div>   
                    </body>
                </html
                 
                
                `
            },
            {
                title:"ფრეიმები",
                data:`ფრეიმები საშუალებას გვაძლევს ვებგვერდში ჩავაშენოთ სხვა ვებგვერდი. ამისთვის გამოიყენება ელემენტი iframe.

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფრეიმი HTML5-ში</title>
                    </head>
                    <body>
                        <h2>ელემენტი iframe</h2>
                        <iframe src="http://wikipedia.com" width="500" height="300">
                        </iframe>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ელემენტ iframe გააჩნია შემდეგი ატრიბუტები:
                
                src: ჩასატვირთი ვებგვერდის სრული მისამართი
                width: სიგანე
                height: სიმაღლე
                უნდა აღინიშნოს, რომ ფრეიმებში ყველა საიტის ჩატვირთვა არ შეიძლება, რადგან ზოგიერთი ვებსერვერი კრძალავს საიტების ჩატვირთვას ფრეიმებში.`
            },
          ]
        },
        {
            title:"თავი 3. ფორმებთან მუშაობა",
            content:[
                {
                    title:"ფორმები",
                    data:`ფორმა წარმოადგენს მონაცემთა შეყვანისა და გაგზავნის ერთ-ერთ საშუალებას. ფორმის ყველა ველი თავსდება <form> და </form> ტეგებს შორის. შევქმნათ უმარტივესი ფორმა:

                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფორმები HTML5-ში</title>
                    </head>
                    <body>
                        <form  method="post" action="http://localhost:8080/login.php">
                            <input name="login"/>
                            <input type="submit" value="შესვლა"/>
                        </form>
                    </body>
                    </html>
                     
                    
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    ფორმას შეიძლება განესაზღვროს შემდეგი ატრიბურები:
                    
                    method: მონაცემების სერვერზე გაგზავნის მეთოდი post და get
                    action: ვებსერვერის მისამართი
                    enctype: გადასაცემი ინფორმაციის ტიპი:
                    application/x-www-form-urlencoded: მონაცემების გადაცემის კოდირება იმ შემთხვევაში, თუ არ მივუთითებთ
                    multipart/form-data: კოდირება ფაილების გასაგზავნად
                    text/plain: უბრალო ტექსტი
                    ზემოთ მოყვანილ მაგალითში ფორმას გააჩნია post მეთოდი, ვებსერვისის მისამართია http://localhost:8080/login.php.
                    
                    როგორც წესი, მითითებულ მისამართზე მუშაობს ვებსერვისი, რომელიც იყენებს რომელიმე სერვისის ტექნოლოგიას(PHP, NodeJS, ASP.NET და სხვა). ახლა ჩვენ არ გავამახვილებთ ყურადღებას სერვერის ტექნოლოგიებზე, არამედ განვიხილავთ მონაცემების გაგზავნის მეთოდებს.
                    
                    ავტოშევსება
                    
                    ხშირად ბრაუზერები იმახსოვრებენ შეყვანილ მონაცემებს და მორიგი შესვლისას ჩნდება ჩამოსაშლელი დამახსოვრებული მონაცემებით:
                    
                    HTML5-ის დოკუმენტი
                    
                    საჭიროების შემთხვევაში შესაძლებელია ავტოშევსების გამორთვა, ამისთვის გამოიყენება ატრიბუტი autocomplete. ღებულობს მნიშვნელობებს on (ავტოშევსება ჩართულია) და off (ავტოშევსება გამორთულია). ეს ატრიბუტი შეიძლება მიეთიტოს როგორც ფორმას, ასევე მის ცალკეულ ელემენტს. ფორმაზე მითითებული ატრიბუტი ვრცელდება ყველა მის ელემენტზე, თუ თვითონ ელემენტს არა აქვს მითითებული იგივე ატრიბუტი განსხვავებული მნიშვნელობით. მაგალითად:
                    
                     
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფორმები HTML5-ში</title>
                    </head>
                    <body>
                        <form  method="post" autocomplete="off" action="http://localhost:8080/login.php">
                            <input name="login"  autocomplete="on" />
                            <input name="password" />
                            <input type="submit" value="შესვლა"/>
                        </form>
                    </body>
                    </html>
                     
                    
                    მოცემულ მაგალითში ავტოშევსება გამორთულია ყველა ელემენტზე, გარდა პირველისა, რადგან პურველ ელემენტს თვითონ აქვს მითითებული on.
                    
                     `
                },
                {
                  title:"ფორმის ელემენტები",
                  data:`ფორმა შედგება ერთი ან რამდენიმე მონაცემთა შეყვანის ელემენტისგან. შეყვანის ყველაზე გავრცელებულ ელემენტს წარმოადგენს ელემენტი input. ელემენტის რეალურ სახეს განსაზღვრავს ატრიბუტი type. ის ღებულობს შემდეგ მნიშვნელობებს:

                  text: ჩვეულებრივი ტექსტური ველი
                  password: ასევე ტექსტური ველი, ოღონდ შეყვანილი სიმბოლოების ადგილას გამოჩნდება ვარსკვლავი. ეს ველი ძირითადად გამოიყენება პაროლების შესაყვანად
                  radio: რადიოღილაკი ანუ გადამრთველი. რადიოღილაკების ჯგუფიდან შეიძლება მხოლოდ ერთის არჩევა
                  checkbox: ჩამრთველი ელემენტი (ალამი), რომელიც შეიძლება იყოს ჩართულ ან გამორთულ მდგომარეობაში
                  hidden: დამალული ველი
                  submit: ფორმის მონაცემების გაგზავნის ღილაკი
                  color: ფერის შესაყვანი ველი
                  date: თარიღის შესაყვანი ველი
                  datetime: თარიღის და დროის შესაყვანი ველი
                  datetime-local: სასაათო სარტყლის გაუთვალისწინებლად თარიღის და დროის შესაყვანი ველი
                  email: ელექტრონული მისამართის შესაყვანი ველი
                  month: თვისა და წლის შესაყვანი ველი
                  number: რიცხვების შესაყვანი ველი
                  range: გარკვეული დიაპაზონიდან რიცხვების ასარჩევი მცოცავი ველი
                  tel: ტელეფონის ნომრის შესაყვანი ველი
                  time: დროის შესაყვანი ველი
                  week: წლისა და კვირის შესაყვანი ველი
                  url: url მისამართის შესაყვანი ველი
                  file: გასაგზავნი ფაილის ასარჩევი ველი
                  image: ქმნის ღილაკს სურათის ფორმით
                  ელემენტი input-ის გარდა არის კიდევ რამდენიმე ელემენტი, რომლებიც გამოიყენება ფორმებთან მუშაობისას:
                  
                  button: ქმნის ღილაკს
                  select: ჩამოსაშლელი სია
                  label: ქმნის წარწერას, რომელიც გამოისახება შეყვანის ველის გვერდით
                  textarea: მრავალსტრიქონიანი ტექსტური ველი
                  ატრიბუტები name და value
                  
                  შეყვანის ყველა ელემენტს გააჩნია ატრიბუტები name და value. name ატრიბუტის მიხედვით შესაძლებელია ელემენტის იდენტიფიცირება, ხოლო value ანიჭებს ელემენტს მნიშვნელობას. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form method="get" action="index.html">
                          <input type="text" name="login" value="Tom"/>
                          <input type="password" name="password"/>
                          <input type="submit" value="შესვლა" />
                      </form>
                  </body>
                  </html>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  შესვლის ღილაკზე დაჭერისას შეიცვლება მისამართის ზოლი:
                  
                  HTML5-ის დოკუმენტი
                  
                  index.html-ის მერე მისამართს დაემატა კითხვის ნიშანი და login=Tom&password=qwerty. ასეთი სახით ხდება ფორმის მონაცემების გაგზავნა სერვერზე, წყვილების "გასაღები"="მნიშვნელობა" სახით, რომლებიც ერთმანეთთან & სიმბოლოთია გადაბმული. ამ მონაცემების მიღების შემდეგ სერვერი ღებულობს ფორმაში შეყვანილ მონაცემებს და აბრუნებს შესაბამის პასუხს.`
              },
              {
                  title:"ღილაკები",
                  data:`ღილაკები წარმოდგენილია ელემენტით button. მას გააჩნია კონფიგურაციის ბევრი შესაძლებლობა. ატრიბუტი type მიხედვით შეგვიძლია შევქმნათ ღილაკის შემდეგი ტიპები:

                  submit: ღილაკი ფორმის მონაცემების გაგზავნისთვის
                  reset: ღილაკი ფორმის მნიშვნელობების გასუფთავებისთვის
                  button: ღილაკი რამე სპეციალური დანიშნულების გარეშე
                  თუ ღილაკი განკუთვნილია მონაცემების გაგზავნისთვის, ანუ თუ მინიჭებული აქვს ატრიბუტი type="submit", შეგვიძლია მივანიჭოთ დამატებითი ატრიბუტები:
                  
                  form: განსაზღვრავს ფორმას, რომელზედაც არის მიმაგრებული ღილაკი
                  formaction: განსაზღვრავს მისამართს, რომელზეც იგზავნება ფორმის მონაცემები. თუ ელემენტს form მინიჭებული აქვს ატრიბუტი action, ხდება მისი ამოცვლა ფორმის formaction-ის მნიშვნელობით
                  formenctype: განსაზღვრავს მონაცემების გაგზავნის ფორმატს. თუ ელემენტს form  მინიჭებული აქვს ატრიბუტი enctype, ხდება მისი ამოცვლა ღილაკის formenctype-ის მნიშვნელობით
                  formmethod: განსაზღვრავს მონაცემების გაგზავნის მეთოდს (post ან get). თუ ელემენტს form მინიჭებული აქვს ატრიბუტი method, ხდება მისი ამოცვლა ღილაკის formmethod-ის მნიშვნელობით
                  მაგალითად, შევქმნათ ფორმა მონაცემთა გაგზავნის და გასუფთავების ღილაკებით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="login" /></p>
                          <p><input type="password" name="password" /></p>
                          <p>
                              <button type="submit" formmethod="get" formaction="index.html">გაგზავნა</button>
                              <button type="reset">გასუფთავება</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  გარდა ელემენტისა button ღილაკის შექმნა შეიძლება ასევე ელემენტით input , რომლის type ატრიბუტის მნიშვნელობა არის submit, reset an button. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="login" /></p>
                          <p><input type="password" name="password" /></p>
                          <p>
                              <input type="submit" formmethod="get" formaction="index.html" value="გაგზავნა" />
                              <input type="reset" value="გასუფთავება" />
                          </p>
                      </form>
                  </body>
                  </html>
                  ელემენტი input-სგან ატრიბუტის type="image"  გამოყენებით ვღებულობთ სურათს, რომელიც გამოიყენება, როგორც ღილაკი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ფორმები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <input type="text" name="search" />
                              <input type="image" src="search.png" name="submit" />
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  გარდა იმისა, რომ ღილაკს აქვს სურათი, მისი მოქმედება ისეთივეა როგორც ელემენტის input type="submit" ან button type="submit".`
              },
              {
                  title:"ტექსტური ველები",
                  data:`ერთსტრიქონიანი ტექსტური ველი იქმნება ელემენტით input რომელსაც ატრიბუტი type-ის მნიშვნელობა აქვს text.

                  <input type="text" name="login" />
                  დამატებითი ატრიბუტების მეშვეობით შესაძლებელია დავაკონფიგურიროთ ტექსტური ველი:
                  
                  dirname: ტექსტის მიმართულება
                  maxlength: სიმბოლოების მაქსიმალური რაოდენობა
                  pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი ტექსტი
                  placeholder: ტექსტი, რომელიც ჩანს ცარიელ ტექსტურ ველში
                  readonly: ამ ატრიბუტით ტექსტურ ველი ხდება მხოლოდ წაკითხვისთვის
                  required: უთითებს, რომ ველი აუცილებლად შესავსებია
                  size: ველის სიგანე ხილული სიმბოლოების რაოდენობით
                  value: ველის მნიშვნელობა ავტომატურად, სანამ არ შევცვლით
                  გამოვიყენოთ რამდენიმე ატრიბუტი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p><input type="text" name="userName" placeholder="შეიყვანეთ სახელი" size="26" /></p>
                          <p><input type="text" name="userPhone" placeholder="შეიყვანეთ ტელეფონის ნომერი" size="26" maxlength="11" /></p>
                          <p>
                              <button type="submit">შენახვა</button>
                              <button type="reset">გაუქმება</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ მაგალითში ტექსტურ ველს ერთდროულად 2 ატრიბუტი აქვს  maxlength და size. ამასთან  size ანუ ზომა უფრო მეტია, ვიდრე  maxlength ანუ დასაშვები სიმბოლოების რაოდენობა. მიუხედავად ამისა ჩვენ ვერ შევიყვანთ  maxlength-ზე მეტ სიმბოლოს ამ ტექსტურ ველში.
                  
                  ასევე მნიშვნელოვანია განვასხვავოთ ატრიბუტები value და placeholder. ორივე მათგანი ტექსტურ ველს ანიჭებს ხილულ ტექსტს, მაგრამ placeholder წარმოადგენს მხოლოდ მინიშნებას და ამიტომ იგი იწერება მკრთალად, მაშინ როდესაც value წარმოადგენს ველის მნიშვნელობას:
                  
                  <p><input type="text" name="userName" value="Tom" size="26" /></p>
                  <p><input type="text" name="userPhone" placeholder="შეიყვანეთ ტელეფონის ნომერი" size="26" maxlength="11" /></p>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ატრიბუტები readonly და disabled ორივე ზღუდავს ტექსტური ველის რედაქტირებას, მაგრამ მათ განსხვავებული ვიზუალური ეფექტი ახლავს. თუ readonly ველს გარეგნულად არ ცვლის, disabled ველს ხდის ნაცრისფერს:
                  
                  <p><input type="text" name="userName" value="Tom" readonly /></p>
                  <p><input type="text" name="userPhone" value="123456789" disabled /></p>
                   
                  
                   HTML5-ის დოკუმენტი
                  
                  
                  
                  ტექსტური ველის ატრიბუტებს შორის აღსანიშნავია ატრიბუტი  list, რომელიც მიმართავს ელემენტს datalist. ეს უკანასკნელი შეიცავს ტექსტების ნაკრებს, რომელიც ტექსტურ ველზე გამოდის სიის სახით მინიშნებებისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <input list="phonesList" type="text" name="model" placeholder="აირჩიეთ მოდელი" />       
                          <button type="submit">შენახვა</button>     
                      </form>
                      <datalist id="phonesList">
                          <option value="iPhone 6S" label="54000"/>
                          <option value="Lumia 950">35000</option>
                          <option value="Nexus 5X"/>
                      </datalist>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ტექსტური ველის ატრიბუტს list ენიჭება datalist-ის იდენტიფიკატორის (id) მნიშვნელობა. თვითონ datalist შეიცავს ელემენტებს option, რომლებიც წარმოადგენენ სიის ელემენტებს.
                  
                  ძებნის ველი
                  
                  ძებნის ველის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="search". ფორმით ის წარმოადგენს ჩვეულებრივ ტექსტურ ველს:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ტექსტური ველი HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <input type="search" name="term" />
                          <input type="submit" value="ძებნა" />
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პაროლის ველი
                  
                  პაროლის ველის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="password". მისი განმასხვავებელი ნიშანია ის, რომ შეყვანილი სიმბოლოების ნაცვლად მასში გამჩნდება წერტილები:
                  
                  <form>
                      <p><input type="text" name="login" /></p>
                      <p><input type="password" name="password" /></p>
                      <input type="submit" value="ავტორიზაცია" />
                  </form>
                   
                  
                  HTML5-ის დოკუმენტი`
              },
              {
                  title:"ნიშნულები და ავტოფოკუსი",
                  data:`შეყვანის ტექსტურ ველებთან ერთად ხშირად გამოიყენება ნიშნულები, რომლებიც იქმნება ელემენტის label მეშვეობით. ნიშნულები წარმოადგენენ ტექსტური ველის ანოტაციას ან სათაურს და უთითებენ, რისთვისაა ეს ველი განკუთვნილი:

                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ნიშნულები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="login">მომხმარებელი: </label>
                              <input type="text" id="login" name="login" />
                          </p>
                          <p>
                              <label for="password">პაროლი: </label>
                              <input type="password" id="password" name="password" />
                          </p>
                          <p>
                              <button type="submit">შესვლა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                  ტექსტურ ველს აქვს ატრიბუტი  id="login", ამიტომ მის შესაბამის ნიშნულს აქვს ატრიბუტი for="login". ნიშნულზე მაუსის დაჭერით მისი შესაბამისი ველი იღებს ფოკუსს:
                  
                  HTML5-ის დოკუმენტი
                  
                  ნიშნულების როლი ამით ამოიწურება. ასევე შეგვიძლია რომელიმე ველს მივანიჭოთ ავტოფოკუსი და გვერდზე შესვლისას ფოკუსი იქნება ამ ველზე. ამისთვის გამოიყენება ატრიბუტი autofocus:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ნიშნულები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="login">მომხმარებელი: </label>
                              <input type="text" id="login" name="login" autofocus />
                          </p>
                          <p>
                              <label for="password">პაროლი: </label>
                              <input type="password" id="password" name="password" />
                          </p>
                          <p>
                              <button type="submit">შესვლა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   `
              },
              {
                  title:"ელემენტები რიცხვების შესაყვანად",
                  data:`რიცხვების შესაყვანად გამოიყენება ელემენტი input ატრიბუტით type="number". მისი კონფიგურაცია შესაძლებელია შემდეგი დამატებითი ატრიბუტების გამოყენებით:

                  min: მინიმალური დასაშვები მნიშვნელობა
                  max: მაქსიმალური დასაშვები მნიშვნელობა
                  readonly: მხოლოდ წაკითხვისთვის
                  required: მიუთითებს, რომ ველის შევსება აუცილებელია
                  step: მნიშვნელობა, რომლითაც ხდება ველის ზრდა (ბიჯი)
                  value: თავდაპირველი მნიშვნელობა 
                  გამოვიყენოთ რიცხვითი ველი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="age">ასაკი: </label>
                                  <input type="number" step="1" min="1" max="100" value="10" id="age" name="age"/>
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                      </body>
                  </html>
                  მოცემულ მაგალითში რიცხვითი ველის თავდაპირველი მნიშვნელობაა 10, მინიმალური მნიშვნელობა 1, მაქსიმალური 100. ბიჯი ტოლია 1-ის.
                  
                  სხვადასხვა ბრაუზერში ეს ელემენტი გამოჩნდება სხვადასხვანაირად. მაგალითად:
                  
                  Google Chrome-ში
                  
                  HTML5-ის დოკუმენტი
                  
                  Microsoft Edge-ში
                  
                  HTML5-ის დოკუმენტი
                  
                  
                  
                  თუმცა თანამედროვე ბრაუზერების უმეტესობაში, გარდა IE 11-სა და Microsoft Edge-სი რიცხვით ველს მარჯვნივ აქვს ისრები მნიშვნელობის გაზრდა-შემცირებისთვის step ატრიბუტში მითითებული ბიჯით.
                  
                  როგორც ტექსტურ ველებში, რიცხვით ველებშიც შეგვიძლია გამოვიყენოთ სიები შესაძლო მნიშვნელობებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="price">ფასი: </label>
                                  <input type="number" list="priceList"
                                      step="1" min="3" max="100" value="10" id="price" name="price"/>
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                          <datalist id="priceList">
                              <option value="15" />
                              <option value="20" />
                              <option value="25" />
                          </datalist>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მცოცავი ველი
                  
                  მცოცავი წარმოადგენს სკალას, სადაც შეიძლება მნიშვნელობების არჩევა. მის შესაქმნელად გამოიყენება ელემენტი input  ატრიბუტით type="range".  როგორც რიცხვით ველს, მასაც გააჩნია ატრიბუტები min, max, step და value:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>რიცხვითი ველები HTML5-ში</title>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="price">Цена:</label>
                                  <input type="range" step="1" min="0" max="100" value="10" id="price" name="price"/>100
                              </p>
                              <p>
                                  <button type="submit">შენახვა</button>
                              </p>
                          </form>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ალმები და გადამრთველები",
                  data:` 
                  ალამი წარმოადგენს ელემენტს, რომელსაც გააჩნია ორი მდგომარეობა: ჩართული და გამორთული. მის შესაქმნელად გამოიყენება ელემენტი input ატრიბუტით type="checkbox":
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ალამი HTML5-ში</title>
                  </head>
                  <body>
                      <h2>ტექნოლოგიები</h2>
                      <form>
                          <p>
                              <input type="checkbox" checked name="html5" />HTML5
                          </p>
                          <p>
                              <input type="checkbox" name="dotnet" />.NET
                          </p>
                          <p>
                              <input type="checkbox" name="java" />Java
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ატრიბუტი checked საშუალებას გვაძლევს დავაყენოთ ალამი ჩართულ მდგომარეობაში.
                  
                  
                  
                  გადამრთველები
                  
                  გადამრთველები ანუ რადიოღილაკები ჰგავს ალმებს და მათაც გააჩნიათ ორი მდგომარეობა: ჩართული და გამორთული. მაგრამ გადამრთველები ერთიანდებიან ჯგუფებში და ერთ ჯგუფში მხოლოდ ერთი რადიოღილაკი შეიძლება იყოს ჩართული:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>გადამრთველები HTML5-ში</title>
                  </head>
                  <body>
                      <form>
                          <h2>მიუთითეთ სქესი</h2>
                          <p>
                              <input type="radio" value="man" checked name="gender" />კაცი
                          </p>
                          <p>
                              <input type="radio" value="woman" name="gender" />ქალი
                          </p>
                          <h2>აირჩიეთ ტექნოლოგია</h2>
                          <p>
                              <input type="radio" value="html5" checked name="tech" />HTML5
                          </p>
                          <p>
                              <input type="radio" value="net" name="tech" />.NET
                          </p>
                          <p>
                              <input type="radio" value="java" name="tech" />Java
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მნიშვნელოვან ატრიბუტს წარმოადგენს value. იგი საშუალებას აძლევს სერვერს გაიგოს, თუ რომელი გადამრთველი იყო მონიშნული:
                  
                  HTML5-ის დოკუმენტი
                  
                  შენახვაზე დაჭერის შემდეგ სერვერს გადაეცემა ინფორმაცია gender=man და tech=html5 იმის მიხედვით, თუ რომელი გადამრთველები იყო ჩართული.`
              },
              {
                  title:"ელემენტები ფერის, url-ის, ელექტრონული ფოსტის და ტელეფონის ნომრისთვის",
                  data:`ფერის შეყვანის ველი

                  ფერის შეყვანის ველის მისაღებად ელემეტ input-ს უნდა მივანიჭოთ ატრიბუტი type="color":
                  
                  <label for="favcolor">აირჩიეთ ფერი</label>
                  <input type="color"  id="favcolor" name="favcolor" />
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ამ ელემენტის მნიშვნელობა იქნება თექვსმეტობითი რიცხვით გამოსახული არჩეული ფერის კოდი. 
                  
                  datalist-ის მეშვეობით ელემენტს შეიძლება დაემატოს სია, საიდანაც იქნება შესაძლებელი რეკომენდირებული ფერის არჩევა:
                  
                  <label for="favcolor">აირჩიეთ ფერი</label>
                  <input type="color" list="colors" id="favcolor" name="favcolor" />
                  <datalist id="colors">
                      <option value="#0000FF" label="blue">
                      <option value="#008000" label="green">
                      <option value="#ff0000" label="red">
                  </datalist>
                  HTML5-ის დოკუმენტი
                  
                  datalist-ის თითოეული ელემენტ option-ს მნიშვნელობად უნდა ჰქონდეს თექვსმეტობითი სახით წარმოდგენილი რიცხვი, მაგალითად "#0000FF". არჩევის შემთხვევაში ფერის შეყვანის ველი მიიღებს შესაბამის მნიშვნელობას.
                  
                  
                  
                  url-ის, email-ის და ტელეფონის შესაყვანი ველები
                  
                  input ელემენტზე სხვადასხვა type ატრიბუტის მინიჭებით შეიძლება მივიღოთ url-ის, email-ის და ტელეფონის შესაყვანი ველები. ამისათვის type-ს უნდა მივცეთ შესაბამისად შემდეგი მნიშვნელობები: url, email, tel. 
                  
                  მათი კონფიგურაციისთვის გამოიყენება იგივე ატრიბუტები, რაც ჩვეულებრივი ტექსტური ველებისთვის:
                  
                  dirname: ტექსტის მიმართულება
                  maxlength: სიმბოლოების მაქსიმალური რაოდენობა
                  pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი ტექსტი
                  placeholder: ტექსტი, რომელიც ჩანს ცარიელ ტექსტურ ველში
                  readonly: ამ ატრიბუტით ტექსტურ ველი ხდება მხოლოდ წაკითხვისთვის
                  required: უთითებს, რომ ველი აუცილებლად შესავსებია
                  size: ველის სიგანე ხილული სიმბოლოების რაოდენობით
                  value: ველის მნიშვნელობა ავტომატურად, სანამ არ შევცვლით
                  list: ველზე ებმება შესაბამისი datalist
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>HTML5</title>
                  </head>
                  <body>
                      <form>
                          <p>
                              <label for="email">Email: </label>
                              <input type="email" placeholder="user@gmail.com" id="email" name="email"/>
                          </p>
                          <p>
                              <label for="url">URL: </label>
                              <input type="url" id="url" name="url"/>
                          </p>
                          <p>
                              <label for="phone">ტელეფონი: </label>
                              <input type="tel" placeholder="(XXX)-XXX-XX XX XX" id="phone" name="phone"/>
                          </p>
                          <p>
                              <button type="submit">შენახვა</button>
                          </p>
                      </form>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ასეთი ველების ძირითადი უპირატესობა მდგომარეობს იმაში, რომ თუ ჩვენ შევიყვანთ არასწორ მნიშვნელობას და შევეცდებით მის სერვერზე გაგზავნას, ბრაუზერი შეგვატყობინებს შეცდომის შესახებ და მონაცემებს არ გააგზავნის:`
              },
              {
                title:"ელემენტები თარიღისა და დროის შესაყვანად",
                data:`თარიღისა და დროის შესაყვანად HTML5-ში განსაზღვრულია input ელემენტის შემდეგი ტიპები:

                datetime-local: თარიღი და დრო
                date: თარიღი
                month: თვე
                time: დრო
                week: კვირა
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form>
                            <p>
                                <label for="firstname">სახელი: </label>
                                <input type="text" id="firstname" name="firstname"/>
                            </p>
                            <p>
                                <label for="date">დაბადების თარიღი: </label>
                                <input type="date" id="date" name="date" value="1995-05-12"/>
                            </p>
                            <p>
                                <button type="submit">შენახვა</button>
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                თრიღის შესაყვანად შეიძლება ჩამოვშალოთ კალენდარი:
                
                 
                
                HTML5-ის დოკუმენტი
                
                უნდა აღინიშნოს, რომ ამ ელემენტის მოქმედება დამოკიდებულია ბრაუზერზე. ზემოთ მოცემული სურათი აღებულია Google Chrome-დან. Microsoft Edge-ში მას ექნება შემდეგი სახე:
                
                HTML5-ის დოკუმენტი
                
                ხოლო IE 11-ს და Firefox-ს საერთოდ არა აქვს ამ ელემენტის მხარდაჭერა.
                
                თარიღისა და დროის სხვა ელემენტების გამოყენებისთვის ვნახოთ მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form>
                            <p>
                                <label for="week">კვირა: </label>
                                <input type="week" name="week" id="week" />
                            </p>
                            <p>
                                <label for="localdate">თარიღი და დრო: </label>
                                <input type="datetime-local" id="localdate" name="date"/>
                            </p>
                            <p>
                                <label for="month">თვე: </label>
                                <input type="month" id="month" name="month"/>
                            </p>
                            <p>
                                <label for="time">დრო: </label>
                                <input type="time" id="time" name="time"/>
                            </p>
                            <p>
                                <button type="submit">შენახვა</button>
                            </p>
                        </form>
                    </body>
                </html>
                 `
            },  {
                title:"ფაილების გაგზავნა",
                data:`ფაილების გასაგზავნად გამოიყენება ელემენტი input ატრიბუტით type="file:"

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form enctype="multipart/form-data" method="post" action="http://localhost:8080/postfile.php">
                            <p>
                                <input type="file" name="file" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                "Choose File" ღილაკზე დაჭერისას იხსნება ფაილის არჩევის ფანჯარა, ხოლო ფაილის არჩევის შემდეგ ღილაკის გვერდით გაჩნდება არჩეული ფაილის სახელი.
                
                მნიშვნელოვანია აღინიშნოს, რომ ფაილის სერვერზე გაგზავნის ფორმას უნდა ჰქონდეს ატრიბუტი enctype="multipart/form-data".
                
                ატრიბუტების მეშვეობით შეიძლება ელემენტის კონფიგურაციის შეცვლა:
                
                accept: ფაილის ტიპი, რომლის არჩევა იქნება შესაძლებელი
                multiple: საშუალებას იძლევა ავირჩიოთ რამდენიმე ფაილი
                required: ფაილის არჩევა აუცილებელია
                მაგალითად, მრავალი ფაილის არჩევის შესაძლებლობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form enctype="multipart/form-data" method="post" action="http://localhost:8080/postfile.php">
                            <p>
                                <input type="file" name="file" multiple />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                ამ შემთხვევაში ფაილის არჩევის ფანჯარაში შესაძლებელი იქნება რამდენიმე ფაილის არჩევა, ხოლო არჩევის მერე ღილაკის გვერდით გაჩნდება წარწერა არჩეული ფაილების რაოდენობით`
            },  {
                title:"ელემენტი select (სია)",
                data:` 

                ელემენტი select ქმნის სიას. ატრიბუტების მნიშვნელობების მიხედვით ეს შეიძლება იყოს ჩამოსაშლელი სია ან სია, რომელშიც შეიძლება ერთდროულად რამდენიმე ელემენტის არჩევა.
                
                შევქმნათ ჩამოსაშლელი სია:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label>
                                <select id="phone" name="phone">
                                    <option value="iphone 6s">iPhone 6S</option>
                                    <option value="lumia 950">Lumia 950</option>
                                    <option value="nexus 5x">Nexus 5X</option>
                                    <option value="galaxy s7">Galaxy S7</option>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ელემენტ select-ის შიგნით მოთავსებულია ელემენტები option -სიის ელემენტები. თითოეულ სიის ელემენტს აქვს ატრიბუტი value. ამასთან, არაა აუცილებელი, რომ value-ს მნიშვნელობა ემთხვეოდეს ტექსტს.
                
                ატრიბუტის selected მეშვეობით შეგვიძლია მივუთითოთ არჩეული ელემენტი. მაგალითად:
                
                <select id="phone" name="phone">
                     <option value="iphone 6s">iPhone 6S</option>
                     <option value="lumia 950">Lumia 950</option>
                     <option value="nexus 5x">Nexus 5X</option>
                     <option value="galaxy s7">Galaxy S7</option>
                </select>
                disabled ატრიბუტის მეშვეობით შეგვიძლია სიის რომელიმე ელემენტის არჩევა შევზღუდოთ. იგი ძირითადად გამოიყენება სათურების შესაქმნელად:
                
                <select id="phone" name="phone">
                    <option disabled selected>აირჩიეთ მოდელი</option>
                    <option value="iphone 6s">iPhone 6S</option>
                    <option value="lumia 950">Lumia 950</option>
                    <option value="nexus 5x">Nexus 5X</option>
                    <option value="galaxy s7">Galaxy S7</option>
                </select>
                 
                
                
                
                ბევრი ელემენტის ასარჩევი სიის შესაქმნელად გამოიყენება ატრიბუტი multiple:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label> <br/>
                            
                                <select multiple id="phone" name="phone">
                                    <option value="iphone 6s">iPhone 6S</option>
                                    <option value="lumia 950">Lumia 950</option>
                                    <option value="nexus 5x">Nexus 5X</option>
                                    <option value="galaxy s7">Galaxy S7</option>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                Ctrl კლავიშზე დაჭერით და მაუსის მეშვეობით შესაძლებელია რემდენიმე ელემენტის ერთდროულად მონიშვნა:
                
                HTML5-ის დოკუმენტი
                
                optgroup ტეგის გამოყენებით შესაძლებელია სიიის ელემენტების დაჯგუფება:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">აირჩიეთ მოდელი:</label>
                            
                                <select id="phone" name="phone">
                                    <optgroup label="Apple">
                                        <option value="iphone 6s">iPhone 6S</option>
                                        <option value="iphone 6s plus">iPhone 6S Plus</option>
                                        <option value="iphone 5se">iPhone 5SE</option>
                                    </optgroup>
                                    <optgroup label="Microsoft">
                                        <option value="lumia 950">Lumia 950</option>
                                        <option value="lumia 950 xl">Lumia 950 XL</option>
                                        <option value="lumia 650">Lumia 650</option>
                                    </optgroup>
                                </select>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                დაჯგუფების გამოყენება შესაძლებელია როგორც ჩამოსაშლელი სიებისთვის, ასევე მრავალი არჩევის მქონე სიებისთვისაც.`
            },  {
                title:"ტექსტური არე (Textarea)",
                data:` 


                მრავალსტრიქონიანი ტექსტური ველისთვის გამოიყენება ელემენტი textarea:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="comment">თქვენი კომენტარი:</label><br/>
                                <textarea name="comment" id="comment" placeholder="არაუმეტეს 200 სიმბოლოსი" maxlength="200"></textarea>  
                            </p>
                            <p>
                                <input type="submit" value="დამატება" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5
                
                დამატებითი პარამეტრების cols და rows მეშვეობით შესაძლებელია სვეტების და სტრიქონების რაოდენობის განსაზღვრა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="comment">თქვენი კომენტარი:</label><br/>
                                <textarea name="comment" id="comment" placeholder="შეიყვანეთ კომენტარი"
                                    cols="30" rows="7"></textarea>  
                            </p>
                            <p>
                                <input type="submit" value="დამატება" />
                            </p>
                        </form>
                    </body>
                </html>`
            },  {
                title:"ფორმების ვალიდაცია",
                data:` 


                ხშირად საჭირო ხდება ფორმებში მონაცემების შეტანის დროს შეიზღუდოს გარკვეული მნიშვნელობების შეტანა, რადგან მომხმარებელს ხშირად შეჰყავს არასწორი მონაცემები, მაგალითად, ველში, სადაც მხოლოდ ციფრები უნდა შეჰყავდეს, შეჰყავს ასოები და ა. შ. ამის თავიდან ასაცილებლად HTML5-ში არსებობს ვალიდაციის მექანიზმი. ვალიდაციის უპირატესობა მდგომარეობს იმაში, რომ მომხმარებელი დროულად იგებს შეცდომის შესახებ და ასწორებს შეტანილ მონაცემებს.
                
                ვალიდაციისთვის გამოიყენება შემდეგი ატრიბუტები:
                
                required: მოითხოვს მნიშვნელობის აუცილებლად შეყვანას. გამოიყენება ელემენტებისთვის textarea, select, input (ტიპით text, password, checkbox, radio, file, datetime-local, date, month, time, week, number, email, url, search, tel)
                min და max: მინიმალური და მაქსიმალური მნიშვნელობა. გამოიყენება ელემენტისთვის input ტიპით datetime-local, date, month, time, week, number, range
                pattern: შაბლონი, რომელსაც უნდა შეესაბამებოდეს შეყვანილი მნიშვნელობა. გამოიყენება ელემენტისთვის input ტიპით text, password, email, url, search, tel
                ატრიბუტი required
                
                ატრიბუტი required გულისხმობს, რომ ელემენტს აუცილებლად უნდა ჰქონდეს მნიშვნელობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="login">მომხმარებელი:</label>
                                <input type="text" required id="login" name="login" />
                            </p>
                            <p>
                                <label for="password">პაროლი:</label>
                                <input type="password" required id="password" name="password" />
                            </p>
                            <p>
                                <input type="submit" value="შესვლა" />
                            </p>
                        </form>
                    </body>
                </html
                თუ ველებს არ შევავსებთ და დავაჭერთ შესვლას, გამოვა გაფრთხილება, რომ აუცილებელი ველები არაა შევსებული:
                
                HTML5
                
                ბრაუზერების მიხედვით შეუვსებელი აუცილებელი ველები სხვადასხვანაირად გამოისახება, მაგალითად Firefox-ში და Microsoft Edge-ში ასეთ ველებს უკეთდება წითელი ჩარჩო:
                
                Firefox
                
                HTML5
                
                Microsoft Edge
                
                HTML5
                
                ატრიბუტები min და max
                
                შესაყვანი მნიშვნელობების დიაპაზონის შესაზღუდავად გამოიყენება ატრიბუტები min და max:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="age">ასაკი:</label>
                                <input type="number" min="1" max="100" value="18" id="age" name="age"/>
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                 
                
                HTML5
                
                ატრიბუტი pattern
                
                ატრიბუტი pattern წარმოადგენს შაბლონს, რომელსაც უნდა შეესაბამებოდეს შეყვანილი მნიშვნელობები. შაბლონისთვის გამოიყენება ე. წ. რეგულარული გამოსახულებები (Regular expression). 
                
                განვიხილოთ მარტივი მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get">
                            <p>
                                <label for="phone">ტელეფონი:</label>
                                <input type="text" placeholder="123-45-67"
                                        pattern="\d{3}-\d{2}-\d{2}-\d{2}" id="phone" name="phone" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" />
                            </p>
                        </form>
                    </body>
                </html>
                ტელეფონის ნომრის შაბლონისთვის გამოყენებულია რეგულარული გამოსახულება "\d{3}-\d{2}-\d{2}-\d{2}". \d ნიშნავს ნებისმიერ ციფრს 0-დან 9-ის ჩათვლით, \d{3} ნიშნავს, რომ ზედიზედ 3 ციფრი უნდა ეწეროს. \d{2} ნიშნავს ზედიზედ 2 ციფრს. საბოლოოდ შეყვანილ ტელეფონის ნომერს უნდა ჰქონდეს სახე 123-45-67. თუ შევიყვანთ ისეთ ტექსტს, რომელიც შაბლონს არ შეესაბამება, ბრაუზერი გამოგვიტანს შეცდომის შეტყობინებას:
                
                HTML5
                
                ტელეფონის ნომერი უნდა ეწეროს შემდეგი სახით: 577-12-55-01.
                
                ვალიდაციის გამორთვა
                
                ფორმის ვალიდაცია ყოველთვის არაა სასურველი. ამ შემთხვევაში ფორმას უნდა ჰქონდეს ატრიბუტი novalidate ან gagzavnis Rilaks formnofalidate.
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ვალიდაცია HTML5-ში</title>
                    </head>
                    <body>
                        <form method="get" novalidate>
                            <p>
                                <label for="phone">ტელეფონი:</label>
                                <input type="text" placeholder="123-45-67"
                                        pattern="\d{3}-\d{2}-\d{2}-\d{2}" id="phone" name="phone" />
                            </p>
                            <p>
                                <input type="submit" value="გაგზავნა" formnovalidate />
                            </p>
                        </form>
                    </body>
                </html>`
            },  {
                title:"ელემენტები fieldset და legend",
                data:`ფორმის ელემენტების დაჯგუფებისთვის ხშირად გამოიყენება ელემენტი fieldset. ის ავლებს საზღვრებს მასში მოქცეული ელემენტების გარეთ და ქმნის მათგან ჯგუფს. მასთან ერთად გამოიყენება ელემენტი legend, რომელიც ქმნის სათაურს ჯგუფისთვის:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>HTML5</title>
                    </head>
                    <body>
                        <h2>საიტზე შესვლა</h2>
                        <form>
                            <fieldset>
                                <legend>შეიყვანეთ მონაცემები:</legend>
                                <label for="login">მომხმარებელი:</label><br>
                                <input type="text" name="login" id="login" /><br>
                                <label for="password">პაროლი:</label><br>
                                <input type="password" name="password" id="password" /><br>
                                <input type="submit" value="ავტორიზაცია">
                            </fieldset>
                        </form>
                    </body>
                </html>`
            }, 
            ]
        },
        {
            title:"	თავი 4. გვერდის სემანტიკური სტრუქტურა",
            content:[
                {
                    title:"ელემენტი article",
                    data:` 


                    ელემენტი article წარმოადგენს ინფორმაციის ერთიან ბლოკს ვებგვერდზე, რომელიც შეიძლება ცალკე განვიხილოთ და გამოვიყენოთ. მაგალითად, ეს შეიძლება იყოს პოსტი ფორუმზე ან სტატია ბლოგზე, მომხმარებლის კომენტარი.
                    
                    ერთი ელემენტი article შეიძლება შეიცავდეს რამდენიმე ელემენტს article. მაგალითად, შეიძლება ერთი article იყოს მთლიანად სტატია ბლოგზე, რომელიც შეიცავს სხვა ელემენტებს article, როგორც მომხმარებლების კომენტარებს ამ სტატიაზე.ანუ სტატია ბლოგზე ჩვენ შეგვიძლია განვიხილოთ, როგორც ცალკე სემანტიკური ერთეული, ამავე დროს თვითონ კომენტარებიც განვიხილოთ ცალკე, ვებგვერდის სხვა შიგთავსისგან დამოუკიდებლად.
                    
                    გამოვიყენოთ article ბლოგის სტატიისა და მისი კომენტარებისთვის:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სემანტიკური მარკირება HTML5-ში</title>
                    </head>
                    <body>
                        <article>
                            <h2>Lorem ipsum</h2>
                            <div>
                                Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna
                                aliquam erat ...
                            </div>
                            <div>
                                <h3>კომენტარები</h3>
                                <article>
                                    <h4>არა უშავს</h4>
                                    <p>ნორმალური სტატიაა...</p>
                                </article>
                                <article>
                                    <h4>სისულელეა</h4>
                                    <p>მე არ მომეწონა</p>
                                </article>
                                <article>
                                    <h4>გაუგებარია</h4>
                                    <p>ნეტა, რაზეა საერთოდ?</p>
                                </article>
                            </div>
                        </article>
                    </body>
                    </html>
                     
                    
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    აქ მთლიანი სტატია მოქცეულია ერთ article ელემენტში, ამასთან ყოველი ახალი კომენტარი წარმოადგენს ცალკე article-ს.
                    
                    article გამოყენებისას უნდა გვახსოვდეს, რომ თითოეული ელემენტი უნდა იდენტიფიცირდებოდეს h1-h6 სათაურის მეშვეობით.`
                },
                {
                  title:"ელემენტი section",
                  data:` 
                  
                  
                  ელემენტი seqtion აერთიანებს html გვერდის ერთმანეთთან დაკავშირებულ ცალკეულ ნაწილებს და ქმნის მათგან ჯგუფს. მაგალითად, seqtion შეიძლება აერთიანებდეს ჩანართების ერთობლიობას, ახალ ამბებს, გაერთიანებულს კატეგორეიბად და ა.შ.
                  
                  თითოეული ელემენტი უნდა იდენტიფიცირდებოდეს h1-h6 სათაურის მეშვეობით.
                  
                  ერთი ელემენტი section შეიძლება შეიცავდეს რამდენიმე ელემენტ article-ს, ასევე, ერთი ელემენტი article შეიძლება შეიცავდეს რამდენიმე ელემენტ section-ს.
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სემანტიკური მარკირება HTML5-ში</title>
                  </head>
                  <body>
                      <article>
                          <h1>Lorem ipsum</h1>
                          <section>
                              <h2>შინაარსი</h2>
                              <p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh
                              euismod tincidunt ut laoreet dolore magna aliquam erat ...</p>
                          </section>
                          <section>
                              <h3>კომენტარი</h3>
                              <article>
                                  <h4>არა უშავს</h4>
                                  <p>ნორმალური სტატიაა</p>
                              </article>
                              <article>
                                  <h4>სისულელეა</h4>
                                  <p>მე არ მომეწონა...</p>
                              </article>
                              <article>
                                  <h4>გაუგებარია</h4>
                                  <p>ნეტა, რაზეა საერთოდ?</p>
                              </article>
                          </section>
                      </article>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ ძირითადი შინაარსის ბლოკისთვის შეცმნილია სექცია, ასევე კომენტარებისთვისაც შექმნილია სექცია რამდენიმე არტიკლით.`
              },
              {
                  title:"ელემენტი nav",
                  data:` 


                  ელემენტი nav გამოიყენება იმ ელემენტების გასაერთიანებლად, რომელთა დანიშნულება საიტზე ნავიგაციაა. როგორც წესი, ეს დაუნომრავი სიაა ბმულებით.
                  
                  ერთ ვებგვერდზე შესაძლებელია გამოვიყენოთ რამდენიმე ელემენტი nav. მაგალითად, ერთი ელემენტი nav საიტის გვერდებზე გადასასვლელად, მეორე კი გვერდის შიგნით ნავიგაციისთვის.
                  
                  არაა აუცილებელი ყველა ბმული მოვათავსოთ ელემენტში nav. ზოგიერთი ბმულები შეიძლება არ წარმოადგენდნენ ურთიერთდაკავშირებულ ბლოკს ნავიგაციისთვის. მაგალითად, ბმული, რომელსაც გადავყავართ მთავარ გვერდზე, ბმული სალიცენზიო ხელშეკრულებაზე, რომლებიც ხშირად მოთავსებულია გვერდის ბოლოში, არაა აუცილებელი, რომ მოვაქციოთ ელემენტში nav.
                  
                  გამოვიყენოთ ელემენტი nav სანავიგაციო ბმულებისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სემანტიკური მარკირება HTML5-ში</title>
                  </head>
                  <body>
                      <nav>
                          <ul>
                              <li><a href="/">მთავარი</a></li>
                              <li><a href="/blog">ბლოგი</a></li>
                              <li><a href="/contacts">კონტაქტი</a></li>
                          </ul>
                      </nav>
                      <article>
                          <header>
                              <h2>მოთხრობა 2 ნაწილად</h2>
                          </header>
                          <nav>
                              <ul>
                                  <li><a href="#part1">ნაწილი 1</a></li>
                                  <li><a href="#part2">ნაწილი 2</a></li>
                              </ul>
                          </nav>
                          <div>
                              <section id="part1">
                                  <h2>ნაწილი 1</h2>
                                  <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry.
                                  Lorem Ipsum has been the industry...</p>
                              </section>
                              <section id="part2">
                                  <h2>ნაწილი 2</h2>
                                  <p>There are many variations of passages of Lorem Ipsum available..</p>
                              </section>
                          </div>
                          <footer>
                              
                          </footer>
                      </article>
                      <footer>
                          <p><a href="/license">სალიცენზიო ხელშეკრულება</a> |
                          <a href="/about">საიტის შესახებ</a> |
                          <a href="/donation">Donations</a></p>
                          <p><small>© Copyright 2016 MyCorp.</small></p>
                      </footer>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ გამოყენებულია ნავიგაციის 2 ბლოკი: ერთი გვერდებს შორის ნავიგაციისთვის, მეორე გვერდის შიგნით ნავიგაციისთვის.
                  
                  არაა აუცილებელი ყველა ბმული მოვათავსოთ ელემენტში nav. ზოგიერთი ბმული ამ გვერდზე მოთავსებულია ელემენტში footer.`
              },
              {
                  title:"ელემენტები header, footer და address",
                  data:` 

 
                  
                  ელემენტი header გამოიყენება როგორც შესავალი ნაწილი, რომელიც წინ უსწრებს ძირითად შინაარსს. აქ შეიძლება იყოს გვერდის სათაური, ნავიგაცია, სხვადასხვა დამხმარე საშუალებები. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <header>
                              <h1>ტელეფონების ონლაინ მაღაზია</h1>
                                  <nav>
                                      <ul>
                                          <li><a href="/apple">Apple</a>
                                          <li><a href="/microsoft">Microsoft</a>
                                          <li><a href="/samsung">Samsung</a>
                                      </ul>
                                  </nav>
                          </header>
                          <div>
                              ინფორმაცია მობილურების ბაზრის სიაახლეების შესახებ...
                          </div>
                      </body>
                  </html>
                  ელემენტ header-ში არ შეიძლება მოვათავსოთ ელემენტი address, footer ან სხვა header.
                  
                  footer
                  
                  ელემენტი footer როგორც წესი შეიცავს ინფორმაციას კონტენტის ავტორის, კოპირაიტის, პუბლიკაციის თარიღის შესახებ, ბმულების ბლოკს მსგავს რესურსებზე და ა. შ. როგორც წესი, მსგავსი ინფორმაცია თავსდება გვერდის ბოლოში, თუმცა footer არ გააჩნია მკაცრად განსაზღვრული ადგილი და შეიძლება მოთავსდეს ვებგვერდის სხვადასხვა ადგილას.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <h1>Xiaomi Mi 5</h1>
                          <div>
                              Xiaomi Mi 5 აღჭურვილია რვაბირთვიანი პროცესორით Qualcomm Snapdragon 820.
                              შიდა მეხსიერების მოცულობა - 32 ან 64 МБ.
                          </div>
                          <footer>
                              <p><a href="/license">სალიცენზიო შეთანხმება</a><br/>
                              Copyright © 2016. SomeSite.com</p>
                          </footer>
                      </body>
                  </html>
                  აქ footer განსაზღვრულია მთელი გვერდისთვის . მასში მოთავსებულია ბმული სალიცენზიო შეთანხმებაზე და ინფორმაცია კოპირაიტზე.
                  
                  footer არაა აუცილებელი იყოს მთელი გვერდისთვის. ის შეიძლება იყოს როგორც კონტენტის ცალკე სექცია:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <section>
                              <h1>ბოლო სტატიები</h1>
                              <article>
                                  <h2>ანონსი Samsung Galaxy S7</h2>
                                  <p>გამოვიდა ახალი ფლაგმანი კომპანიისგან Samsung Galaxy S7.....</p>
                                  <footer>
                                      გამოქვეყნების თარიღი: <time datetime="2016-03-16T15:16-00:00">16.03.2016 15:16</TIME>
                                  </footer>
                              </article>
                              <article>
                                  <h2>ფასდაკლებები Microsoft Lumia 950</h2>
                                  <p>1 მარტიდან Microsoft Lumia 950 ღირს 50 ლარით იაფი...</p>
                                  <footer>
                                      გამოქვეყნების თარიღი: <time datetime="2016-03-01T14:36-00:00">01.03.2016 14:36</TIME>
                                  </footer>
                              </article>
                          </section>
                      </body>
                  </html>
                  address
                  
                  ელემენტი address განკუთვნილია საკონტაქტო ინფორმაციისთვის, რომელიც დაკავშირებულია უახლოეს ელემენტთან article ან body. ხშირად იგი მოთავსებულია footer-ის შიგნით.
                  
                  <footer>
                      <address>
                          საკონტაქტო ინფორმაცია <a href="mailto:js@example.com">ტომ სმიტი</a>.
                      </address>
                      <p>© copyright 2016 Example Corp.</p>
                  </footer>`
              },
              {
                  title:"ელემენტი aside",
                  data:` 


                  ელემენტი aside განკუთვნილია შიგთავსისთვის, რომელიც ირიბადაა დაკავშირებული გვერდის დანარჩენ კონტენტთან და რომელიც შეიძლება განვიხილოთ მისგან დამოუკიდებლად. იგი შეიძლება გამოვიყენოთ საიდბარებისთვის, სარეკლამო ბლოკებისთვის და ა. შ.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <aside style="float:right; width:200px;">
                              <h2>ფასდაკლება Microsoft Lumia 950</h2>
                              <p>მხოლოდ 31 მარტამდე Microsoft Lumia 950 იქნება 50 ლარით იაფი. 
                                  ამასთან, საჩუქრად მიიღებთ უფასო ჩუპა-ჩუპსს. <a href="buy/id=3">ყიდვა</a></p>
                          </aside>
                          <article>
                              <h2>Samsung Galaxy S7</h2>
                              <p>კომპანია სამსუნგმა გამოუთვა ახალი სმარტფონი Samsung Galaxt S7. ახალ სმარტფონთან ერთად
                              სამსუნგმა წარმოადგინა ვირტუალური რეალობის ახალი შლემი Gear VR...</p>
                          </article>
                      </body>
                  </html>`
              },
              {
                  title:"ელემენტი main",
                  data:` 


                  ელემენტი main წარმოადგენს ვებგვერდის ძირითად ნაწილს. ეს წარმოადგენს უნიკალურ კონტენტს და იქ არ უნდა იყოს სხვადასხვა გვერდებზე განმეორებადი საიდბარები, ნავიგაციის ბმულები, ინფორმაცია კოპირაიტზე, ლოგოტიპები და ა. შ. გამოვიყენოთ ელემენტი main:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სემანტიკური მარკირება HTML5-ში</title>
                      </head>
                      <body>
                          <main>
                              <h1>მოდელები Snapdragon 808-ით</h1>
                              <p>მოდელები, რომელთაც გააჩნიათ პროცესორი Snapdragon 808</p>
                              
                              <article>
                                <h2>Google Nexus 5X</h2>
                                <p>Nexus 5X წარმოადგენს კომპაქტურ და მძლავრ მოწყობილობას ყოველდღიური ამოცანების გადასაწყვეტად.
                                აღჭურვილია 5.2 დუიმიანი ეკრანით და ექვსბირთვიანი პროცესორით Snapdragon 808...</p>
                              </article>
                    
                              <article>
                                <h2>Microsoft Lumia 950</h2>
                                <p>Microsoft Display Dock-ის დახმარებით თქვენი სმარტფონი Lumia 950 Dual SIM გარე მონიტორით,
                                   კლავიატურით და მაუსით გადაიქცევა სრულფასოვან კომპიუტერად...</p>
                              </article>
                            </main>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  არაა საჭირო, რომ ვიფიქროთ, თითქოს მთელი ვებგვერდი უნდა მოვაქციოთ ელემენტშო main. მასთან ერთად ასევე უნდა გამოვიყენოთ სხვა ელემენტებიც, მაგალითად header,footer და ა. შ.
                  
                  <body>
                      <header>
                          ..............
                      </header>
                      <main>
                          .................  
                      </main>
                      <footer>
                          .................  
                      </footer>
                  </body>
                   
                  
                  უნდა გავითვალისწინოთ, რომ ელემენტი main არ შეიძლება იყოს მოქცეული ისეთი ელემენტების შიგნით, როგორიცაა article, aside, footer, header, nav.
                  
                  IE 11 და წინა ვერსიებს არ გააჩნიათ main ელემენტის მხარდაჭერა. ამიტომ სასურველია გამოვიტენოთ ასევე ატრიბუტი role:
                  
                  <main role="main">
                      ...
                  </main>`
              },
           
            ]
        },
        {
            title:"თავი 5. CSS3-ის საფუძვლები. სელექტორები",
            content:[
                {
                    title:"სტილები",
                    data:` 
                    
                    
                    რამდენ ელემენტსაც არ უნდა შეიცავდეს, html დოკუმენტი იქნება უსიცოცხლო სტილების გამოყენების გარეშე. სტილები, ანუ უფრო ზუსტად სტილების კასკადური ცხრილები (Cascading Style Sheets) ან უბრალოდ CSS განსაზღვრავს დოკუმენტის გარეგნულ იერსახეს.მოკლედ განვიხილოთ სტილების გამოყენება HTML5-ში.
                    
                    CSS სტილი წარმოადგენს წესს და უთითებს ბრაუზერს, თუ როგორ უნდა გამოისახოს ესა თუ ის ელემენტი, როგორ მოხდეს მისი ფორმატირება. ფორმატირება გულისხმობს ელემენტის ფერს, ფონს, შრიფტს, ზომებს და ა. შ.
                    
                    სტილის განსაზღვრა შედგება ორი ნაწილისგან: სელექტორი, რომელიც მიუთითებს ელემენტზე და სტილის გამოცხადების ბლოკი - ბრძანებების ნაკრები, რომლებიც ადგენენ ფორმატირების წესებს. მაგალითად:
                    
                    div{
                        background-color:red;
                        width: 100px;
                        height: 60px;
                    }
                    მოცემულ მაგალითში სელექტორს წარმოადგენს div. ეს სელექტორი მიუთითებს, რომ მოცემული სტილი გამოიყენება ყველა div ელემენტისთვის. სელექტორის შემდეგ ფიგურულ ფრჩხილებში მოცემულია სტილების გამოცხადების ბლოკი. ფიგურულ ფრჩხილებში მოქცეულია ბრძანებები, რომლებიც განსაზღვრავენ, თუ როგორ უნდა მოხდეს ელემენტების ფორმატირება.
                    
                    თითოეული ბრძანება შედგება თვისებისგან და მნიშვნელობისგან. მაგალითად ბრძანებაში 
                    
                    background-color:red;
                    background-color წარმოადგენს თვისებას, ხოლო red - მნიშვნელობას. თვისება განსაზღვრავს კონკრეტულ სტილს. თვისებები CSS-ში მრავლადაა. მაგალითად, background-color განსაზღვრავს ფონის ფერს. ორწერტილის შემდეგ მოდის ამ თვისების მნიშვნელობა. ზემოთ მოცემული ბრძანება განსაზღვრავს, რომ ფონის ფერი არის წითელი. ყოველი ასეთი ბრძანების ბოლოს იწერება წერტილმძიმე.
                    
                    ასეთი სტილების ერთობლიობას უწოდებენ სტილების ცხრილს ანუ CSS (Cascading Style Sheets). არსებობს სტილების გამოცხადების სხვადასხვა ხერხი.
                    
                    ატრიბუტი style
                    
                    სტილების გამოცხადების ერთ-ერთი ხერხი მდგომარეობს იმაში, რომ ხდება სტილის ჩაშენება უშუალოდ ელემენტში style ატრიბუტის სახით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                        </head>
                        <body>
                            <h2 style="color:blue;">სტილები</h2>
                            <div style="width: 100px; height: 100px; background-color: red;"></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    აქ მოცემულია ორი ელემენტი: სათაური h2 და div. სათურს განსაზღვრული აქვს ტექსტის ფერი თვისების color მეშვეობით, ხოლო div ელემენტს თვისებები სიგანე (width), simaRle(height) და ფონის ფერი (background-color).
                    
                    მეორე მეთოდი მდგომარეობს html დოცუმენტში style ელემენტის გამოყენება. იგი უთითებს ბრაუზერს, რომ მის შიგნით არსებული მონაცემები წარმოადგენს CSS კოდს, და არა html-ს:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                            <style>
                            h2{
                                color:blue;
                            }
                            div{
                                width: 100px;
                                height: 100px;
                                background-color: red;
                            }
                            </style>
                        </head>
                        <body>
                            <h2>სტილები</h2>
                            <div></div>
                        </body>
                    </html>
                    ამ შემთხვევაშიც შედეგი იქნება ზუსტად ისეთივე, როგორც წინა შემთხვევაში.
                    
                    ელემენტი style ძირითადად განისაზღვრება head ელემენტის შიგნით, თუმცა შეიძლება იყოს სხვა ადგილზეც. იგი შეიცავს სტილების ერთობლიობას. თითოეული სტილი შედგება სელექტორისგან და ფიგურულ ფრჩხილებში მოქცეული თვისებებისაგან თავისი მნიშვნელობებით. 
                    
                    
                    
                    პირველისგან განსხვავებით, მეორე ხერხი კოდს ხდის უფრო სუფთას სტილების ცალკე ელემენტად გამოტანის გამო. ასევე არსებობს მესამე ხერხიც, რომელიც მდგომარეობს სტილების ცალკე ფაილად გატანაში.
                    
                    შევქმნათ იგივე საქაღალდეში, სადაც ჩვენი html ფაილია, ფაილი styles.css და შიგნით ჩავწეროთ იგივე სტილები, რაც გვქონდა style ელემენტში.:
                    
                    h2{
                        color:blue;
                    }
                    div{
                        width: 100px;
                        height: 100px;
                        background-color: red;
                    }
                    თვითონ html ფაილის ტექსტი შევცვალოთ შემდეგნაირად:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>სტილები</title>
                            <link rel="stylesheet" type="text/css" href="styles.css"/>
                            </style>
                        </head>
                        <body>
                            <h2>სტილები</h2>
                            <div></div>
                        </body>
                    </html>
                    html დოკუმენტში ახლა უკვე არა გვაქვს ელემენტი style, სამაგიეროდ დაემატა ელემენტი link, რომელიც ახდენს ჩვენს მიერ შექმნილი სტილების ფაილის styles.css ჩართვას: <link rel="stylesheet" type="text/css" href="styles.css"/>.
                    
                    ამგვარად, ცალკე ფაილში სტილების განსაზღვრის შედეგად html კოდი უფრო სუფთაა, გვერდის სტრუქტურა გამოყოფილია მისი სტილიზაციისაგან. ასეთი მიდგომისას უფრო იოლია სტილების მოდიფიცირება, ვიდრე იმ შემთხვევაში, თუ სტილები იქნებოდა ელემენტ style-ში ან თითოეული ელემენტის ატრიბუტ style-ში. შესაბამისად ასეთი მიდგომა უფრო მიღებული და უპირატესია HTML5-ში.
                    
                    ცალკე ფაილებში სტილების გატანა ამცირებს დატვირთვას ვებსერვერზე კეშირების მექანიზმის გამოყენებით. რადგან ვებბრაუზერს შეუძლია მოახდინოს CSS ფაილის კეშირება და შემდგომში მიმართავს კეშირებულ ფაილს სერვერის ნაცვლად.
                    
                    შესაძლებელია მოხდეს ამ სამი მეთოდის შერწყმა, როდესაც ერთი ელემენტის ზოგიერთი თვისება განსაზღვრულია ცალკე css ფაილში, ზოგი style ელემენტში, ხოლო ზოგი თვითონ ამ ელემენტის style ატრიბუტში. მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <link rel="stylesheet" type="text/css" href="styles.css"/>
                            <style>
                                div{
                                    width:200px;
                                }
                            </style>
                        </head>
                        <body>
                            <div style="width:120px;"></div>
                        </body>
                    </html>
                     
                    
                    div{
                        width:50px;
                        height:50px;
                        background-color:red;
                    }
                    მოცემულ მაგალითში div ელემენტისთვის ერთი და იგივე თვისება width განსაზღვრულია 3 ადგილას სხვადასხვა მნიშვნელობებით. რომელ მნიშვნელობას მიიღებს ელემენტი? მოქმედებს პრიორიტეტების შემდეგი სისტემა:
                    
                    თუ ელემენტს განსაზღვრული აქვს ჩაშენებული სტილები (inline-სტილი) style ატრიბუტის სახით, ისინი წარმოადგენენ უმაღლეს პრიორიტეტს. ჩვენს შემთხვევაში ელემენტის სიგანე იქნება 12 პიქსელი.
                    შემდეგი პრიორიტეტში მოდის სტილები, განსაზღვრული ელემენტში style.
                    ცალკე ფაილებში განსაზღვრულ სტილებს აქვთ ყველაზე დაბალი პრიორიტეტი.
                    html ატრიბუტები და CSS
                    
                    html-ის ბევრ ელემენტს აქვს შესაძლებლობა სტილები განესაზღვროს ატრიბუტების მეშვეობით. მაგალითად, ბევრ ელემენტს აქვს ატრიბუტები width და height სიგანისა და სიმაღლის მისათითებლად. თუმცა ყოველთვის უმჯობესია თავი ავარიდოთ სტილების ამგვარად განსაზღვრას და გამოვიყენოთ CSS სტილები. უმჯობესია html-ში მოცემული იყოს ვებგვერდის სტრუქტურა, ხოლო სტილიზაცია მოხდეს CSS სტილების მეშვეობით.
                    
                    CSS კოდის ვალიდაცია
                    
                    CSS კოდის დაწერისას შეიძლება წამოიჭრას კითხვები, სწორად არის ტუ არა განსაზღვრული სტილები, კორექტულია თუ არა ისინი. ასეთ შემთხვევაში შეიძლება ვისარგებლოთ CSS ვალიდატორით, რომელიც ხელმისაწვდომია მისამართზე: http://jigsaw.w3.org/css-validator/ .
                    
                    `
                },
                {
                  title:"სელექტორები",
                  data:` 
                  
                  
                  სტილის განსაზღვრა იწყება სელექტორით:
                  
                  div{
                      width:50px; /* სიგანე */
                      height:50px; /* სიმაღლე */
                      background-color:red; /* ფონის ფერი */
                      margin: 10px; /* დაშორება სხვა ელემენტებისგან */
                  }
                  მოცემულ მაგალითში სელექტორს წარმოადგენს div. რიგ სელექტორებს აქვთ იმ ელემენტის სახელი, რომლის ფორმატირებასაც ისინი ემსახურებიან. მაგალითად, div, p, h2 და ა. შ. ასეთი სელექტორებით განსაზღვრული სტილები ვრცელდება ყველა შესაბამის ელემენტზე. შესაბამისად, ზემოთ განსაზღვრული სტილი გავრცელდება გვერდის ყველა div ელემენტზე:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              div{
                                  width:50px;
                                  height:50px;
                                  background-color:red;
                                  margin: 10px;
                              }
                          </style>
                      </head>
                      <body>
                          <h2>სელექტორები</h2>
                          <div></div>
                          <div></div>
                          <div></div>
                      </body>
                  </html>
                  აქ სამი div ელემენტია და სამივე მიიღებს განსაზღვრულ სტილს:
                  
                  HTML5-ის დოკუმენტი
                  
                  კლასები
                  
                  ზოგჯერ ერთი და იგივე ელემენტებისთვის საჭიროა სხვადასხვანაირი სტილის მიცემა. ამისთვის გამოიყენება კლასები. კლასის სელექტორის განსაზღვრისთვის მისი სახელის წინ დაისმის წერტილი:
                  
                  .redBlock{
                      background-color:red;
                  }
                  კლასის დასახელება შეიძლება იყოს ნებისმიერი. ჩვენს მაგალითში კლასის სახელია redBlock. კლასის დასახელებაში დასაშვებია ასოების, ციფრების, ტირეს და ქვედა ტირეს გამოყენება, პირველი სიმბოლო აუცილებლად უნდა იყოს ასო.
                  
                  მნიშვნელობა აქვს ასოების რეგისტრს: "article" და "ARTICLE" იქნება სხვადასხვა კლასი.
                  
                  კლასის განსაზღვრის შემდეგ მისი გამოყენება შეიძლება ელემენტთან class ატრიბუტის სახით. მაგალითად:
                  
                  <div class="redBlock"></div>
                  განვსაზღვროთ და გამოვიყენოთ რამდენიმე კლასი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>კლასები</title>
                          <style>
                              div{
                                  width: 50px;
                                  height: 50px;
                                  margin: 10px;
                              }
                              .redBlock{
                                  background-color: red;
                              }
                              .blueBlock{
                                  background-color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <h2>კლასები</h2>
                          <div class="redBlock"></div>
                          <div class="blueBlock"></div>
                          <div class="redBlock"></div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                   
                  
                  
                  
                   
                  
                  იდენტიფიკატორები
                  
                  ვებგვერდის უნიკალური ელემენტების იდენტიფიცირებისთვის გამოიყენება იდენტიფიკატორები, რომლებიც გამოისახება ატრიბუტით id. მაგალითად, გვერდზე შეიძლება იყოს სათაურის ბლოკი:
                  
                  <div id="header"></div>
                  იდენტიფიკატორებისთვის სტილის განსაზღვრა კლასებისთვის სტილის განსაზღვრის იდენტურია, მხოლოდ სელექტორის წინ წერტილის ნაცვლად დაისმის სიმბოლო #:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>იდენტიფიკატორები</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid #222;
                              }
                              #header{
                                  height: 80px;
                                  background-color: #ccc;
                              }
                              #content{
                                  height: 180px;
                                  background-color: #eee;
                              }
                              #footer{
                                  height: 80px;
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">საიტის სათაური</div>
                          <div id="content">ძირითადი ნაწილი</div>
                          <div id="footer">ქვედა ნაწილი</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  უნდა აღინიშნოს, რომ იდენტიფიკატორები ძირითადად გამოიყენება არა სტილიზაციისთვის, არამედ ვებგვერდის სტრუქტურის ასაგებად. სტილიზაციისთვის ძირითადად გამოიყენება კლასები.
                  
                  უნივერესალური სელექტორი
                  
                  CSS-ში არის ე. წ. უნივერსალური სელექტორი ვარსკვლავის (8) სახით. ის ანიჭებს  სტილს ვებგვერდის ყველა ელემენტს:
                  
                  *{     
                      background-color: red;
                  }
                   
                  
                  სელექტორთა ჯგუფების სტილიზაცია
                  
                  ზოგჯერ სტილები განისაზღვრება სელექტორთა მთელი ჯგუფისთვის. მაგალითად, თუ გვინდა ყველა სათაურისთვის ხაზგასმის გამოყენება, შესაბამისი სელექტორები უნდა ჩამოვთვალოთ მძიმით გამოყოფილი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h1, h2, h3, h4{
                                  text-decoration: underline;
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <h1>CSS3<h1>
                          <h2>სელექტორები</h2>
                          <h3>სელექტორების ჯგუფი</h3>
                          <p>ტექსტი...</p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჯგუფში შეიძლება გაერთიანებული იყოს როგორც ტეგების, ასევე კლასების და იდენტიფიკატორების სელექტორები:
                  
                  h1, #header, .redBlock{   
                      color: red;
                  }`
              },
              {
                  title:"შთამომავლების სელექტორები",
                  data:` 
                  
                  
                  ვებგვერდს გააჩნია რთული ორგანიზაცია, რომლის დროსაც ერთი ელემენტები შეიცავენ სხვა ელემენტებს. ჩასმულ ელემენტებს (რომლებიც სხვა ელემენტის შიგნით არიან ჩასმული) მეორენაირად "შთამომავლებს" უწოდებენ, ხოლო კონტეინერს, რომელიც შეიცავს ამ ელემენტებს - მშობელს.
                  
                  ვთქვათ, ელემენტი body-ს აქვს შემდეგი სახე:
                  
                  <body>
                      <h2>სათაური</h2>
                      <div>
                         <p>ტექსტი</p>
                      </div>
                  </body>
                  body ელემენტის შიგნით გვაქვს სამი ჩასმული ელემენტი: h2, div და p. სამივე მათგანი წარმოადგენს body ელემენტის შთამომავალს.
                  
                  div ელემენტის შიგნით ჩასმულია ერთი ელემენტი p, ამიტომ div-ს მხოლოდ ერთი შთამომავალი გააჩნია.
                  
                  სპეციალური სელექტორების მეშვეობით შეგვიძლია მოვახდინოთ სტილიზაცია მკაცრად განსაზღვრული ელემენტების შთამომავლებისთვის. მაგალითად, შეიძლება გვქონდეს p ელემენტი როგორც ძირითადი ნაწილის შიგნით, ასევე ფუტერში, მაგრამ გვინდოდეს მათთვის სხვადასხვა შრიფტის მინიჭება.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              #main p{
                                  font-size: 16px;
                              }
                              #footer p{
                                  font-size: 13px;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="main">
                              <p>პირველი აბზაცი</p>
                              <p>მეორე აბზაცი</p>
                          </div>
                          <div id="footer">
                              <p>ფუტერის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩასმული ელემენტისთვის სტილის მისაყენებლად გამოიყენება სელექტორი, რომელიც შეიცავს ჯერ მშობელ ელემენტს და შემდეგ ჩასმულს:
                  
                  #main p{
                          font-size: 16px;
                   }
                  ეს სტილი გავრცელდება მხოლოდ იმ p ელემენტებზე, რომლებიც იმყოფებიან main იდენტიფიკატორის მქონე ელემენტის შიგნით.
                  
                  ვნახოთ მეორე მაგალითი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              li .redLink{
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <ul>
                              <li>Samsung: <a class="redLink">Galaxy S7 Edge</a></li>
                              <li>Apple: <a>iPhome SE</a></li>
                              <li>LG: <a class="redLink">LG G5</a></li>
                              <li>Microsoft: <a>Lumia 650</a></li>
                          </ul>
                      </body>
                  </html>
                  აქ სტილი გამოიყენება ელემენტებისათვის კლასით "redLink", რომლებიც <li>ელემენტის შიგნითაა:
                  
                  HTML5-ის დოკუმენტი
                  
                  მიაქციეთ ყურადღება, რომ li ელემენტსა და .redLink კლასს შორის ადგილია გამოტოვებული. ადგილის გამოტოვებას დიდი მნიშვნელობა აქვს. იგი მიუთითებს, რომ სტილი ეხება მხოლოდ იმ ელემენტებს, რომელთა კლასია "redLink" და ამასთან იმყოფებიან li ელემენტის შიგნით.
                  
                  თუ მოვაშორებთ ადგილის გამოტოვებას, სელექტორის შინაარსი შეიცვლება:
                  
                   
                  
                  li.redLink{
                      color: red;
                  }
                   
                  
                  ახლა უკვე სტილი ეხება იმ liელემენტებს, რომელთაც აქვთ კლასი "redLink". იგი ეხება ქვემოთ მოცემულ ელემენტს:
                  
                  <li class="redLink">Microsoft: <a>Lumia 650</a></li>
                  მაგრამ არა ამ ელემენტს:
                  
                  <li>LG: <a class="redLink">LG G5</a></li>`
              },
              {
                  title:"შვილი ელემენტების სელექტორები",
                  data:`HTML & CSS სახელმძღვანელო
                  "შვილი" ელემენტების სელექტორები
                  
                  
                  შვილი ელემენტების სელექტორები შთამომავლების სელექტორებისგან განსხვავდება იმით, რომ ეხება მხოლოდ პირველი დონის ჩასმულ ელემენტებს. მაგალითად:
                  
                  <body>
                      <h2>სათაური</h2>
                      <div>
                          <p>ტექსტი</p>
                      </div>
                  </body>
                  მოცემულ მაგალითში body ელემენტისთვის ჩასმულ ელემენტებს წარმოადგენენ h2, div და p, მაგრამ მათგან შვილი ელემენტი მხოლოდ ორია - h2 და div, რადგან იმყოფებიან პირველ დონეზე. 
                  
                  შვილი ელემენტებისადმი მიმართვის სელექტორში გამოიყენება კუთხოვანი ფრჩხილი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              .article > p{            
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <div class="article">
                              <p>სტატიის ანოტაცია</p>
                              <div class="content">
                                  <p>სტატიის ტექსტი</p>
                              </div>
                          </div>
                      </body>
                  </html>
                   
                  
                  ბლოკში კლასით "article" არის ორი პარაგრაფი p, მაგრამ სელექტორი .article>p ეხება მხოლოდ იმ პარაგრაფს, რომელიც უშუალოდ .article ბლოკის შიგნითაა:
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩვენ რომ გამოგვეყენებინა სელექტორი ადგილის გამოტოვებით კუთხოვანი ფრჩხილის ნაცვლად, სტილი გავრცელდებოდა ყველა p ელემენტზე, რადგან მივიღებდით სელექტორს შთამომავლებისთვის:
                  
                  .article p{   
                      color: red;
                  }`
              },
              {
                  title:"სელექტორები ერთი დონის ელემენტებისთვის",
                  data:`ერთი დონის ელემენტებს მეორენაირად სიბლინგებს (siblings)  ან დებს უწოდებენ.მაგალითდ:

                  <body>
                      <h2>Заголовок</h2>
                      <div>
                          <p>Текст первого блока</p>
                      </div>
                      <div>
                          <p>Текст второго блока</p>
                      </div>
                  </body>
                   
                  
                  მოცემულ მაგალითში ელემენტი h2 და ორივე ელემენტი div წარმოადგენს ერთი დონის ელემენტებს. ხოლო პარაგრაფის ელემენტები p არ წარმოადგენენ მათთვის იგივე დონის ელემენტებს, რადგან ისინი div ელემენტების შიგნით იმყოფებიან. 
                  
                  ერთ დონეზე მყოფი პირველი მომდევნო ელემენტის სტილიზაციისთვის სელექტორში გამოიყენება + ნიშანი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h2+div { color: red; }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <div>
                              <p>პირველი ბლოკის ტექსტი</p>
                          </div>
                          <div>
                              <p>მეორე ბლოკის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  სელექტორი h2+div საშუალებას იძლევა მოხდეს სტილიზაცია იმ div ბლოკის, რომელიც უშუალოდ h2 ელემენტის შემდეგ მოდის:
                  
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ამ სელექტორით div ბლოკის სტილიზაცია ხდება მხოლოდ იმ შემთხვევაში, თუ ის უშუალოდ h2 ელემენტის შემდეგაა. თუ შუაში სხვა ელემენტიც იქნება, სელექტორი div ბლოკს არ შეეხება.
                  
                  თუ ჩვენ გვინდა მოვახდინოთ h2 ელემენტთან ერთ დონეზე მყოფი ყველა div ელემენტის სტილიზაცია, მაშინ +-ს ნაცვლად უნდა გამოვიყენოთ სიმბოლო ~ :
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              h2~div { color: red; }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <p>ანოტაცია</p>
                          <div>
                              <p>პირველი ბლოკის ტექსტი</p>
                          </div>
                          <div>
                              <p>მეორე ბლოკის ტექსტი</p>
                          </div>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ფსევდოკლასები",
                  data:`ტეგების (ელემენტების), კლასების და იდენტიფიკატორების გარდა არსებობს ასევე სელექტორები ფსევდოკლასებისთვის, რომლებიც გვაძლევენ დამატებით შესაძლებლობებს. ჩამოვთვალოთ ისინი:

                  :root: საშუალებას გვაძლევს ავირჩიოთ ვებგვერდის ამოსავალი ელემენტი. ყველაზე ნაკლებგამოყენებადი სელექტორია, რადგან ვებგვერდზე ამოსავალი ელემენტი თითქმის ყოველთვის არის <html>
                  :link: გამოიყენება ბმულებისთვის და წარმოადგენს მათ ჩვეულებრივ მდგომარეობაში, ანუ როცა ამ ბმულიდან გადასვლა ჯერ არ განხორციელებულა
                  :visited: გამოიყენება ბმულებისთვის და წარმოადგენს ბმულს, რომლითაც გადასვლა უკვე განხორციელდა
                  :active: გამოიყენება ბმულებისთვის და წარმოადგენს მათ იმ მომენტისთვის, როცა მასზე ხდება დაჭერა
                  :hover: წარმოადგენს ელემენტს იმ მომენტში, როცა მისკენ მიმართულია მაუსი. ძირითადად გამოიყენება ბმულებისთვის, თუმცა შეიძლება გამოვიყენოთ სხვა ელემენტებისთვისაც, მაგალითად პარაგრაფისთვის
                  :focus: წარმოადგენს ელემენტს, რომელსაც მიღებული აქვს ფოკუსი მაუსით დაწერის ან Tab კლავიშით ელემენტზე გადასვლის დროს 
                  :not: შესაძლებლობას გვაძლევს გამოვრიცხოთ რაღაც ელემენტები სიიდან, რომელთათვისაც გამოიყენება სტილი
                  :lang: გვაძლევს საშუალებას ელემენტების სტილიზაციისთვის lang ატრიბუტის მიხედვით
                  :empty: ირჩევს ელემენტებს, რომლებიც ცარიელია, ანუ არ გააჩნიათ ჩასმული ელემენტები
                  ფსევდოკლასების წინ ყოველთვის იწერება ორწერტილი. მაგალითად, მოვახდინოთ ბმულების სტილიზაცია ფსევდოკლასების გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              a:link    {color:blue; text-decoration:none}
                              a:visited {color:pink; text-decoration:none}
                              a:hover   {color:red; text-decoration:underline}
                              a:active  {color:yellow; text-decoration:underline}
                              input:hover {border:2px solid red;}
                          </style>
                      </head>
                      <body>
                          <a href="index.html">CSS3-ის სახელმძღვანელო</a>
                          <input type="text" />
                      </body>
                  </html>
                   
                  
                  სელექტორი :not
                  
                  სელექტორი :not საშუალებას გვაძლევს ავირჩიოთ გარკვეული ტიპის ყველა ელემენტი, გარდა :not-ით მონიშნულისა, ანუ გამოვრიცხოთ რაღაც ელემენტები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:not(.blueLink) { color: red; }
                          </style>
                      </head>
                      <body>
                          <a>პირველი ბმული</a><br/>
                          <a class="blueLink">მეორე ბმული</a><br/>
                          <a>მესამე ბმული</a>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სელექტორი a:not(.blueLink) მიუთითებს, რომ სტილი გამოიყენება ყველა ბმულისთვის, გარდა იმათი, რომელთაც აქვთ კლასი "blueLink". ფრჩხილებში ფსევდოკლასს not  ეთითება ის ელემენტები, რომელთა ამოღებაც გვინდა სტილიდან.
                  
                  ფსევდოკლასი :lang
                  
                  ფსევდოკლასი :lang ირჩევს ელემენტებს  lang ატრიბუტის მიხედვით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              :lang(ka) {
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                             
                              <p lang="ka-GE">მე ვსწავლობ CSS3</p>
                              <p lang="ru-RU">Я изучаю CSS3</p>
                              <p lang="en-US">I study CSS3</p>
                          </form>
                      </body>
                  </html>`
              },
              {
                  title:"ფსევდოკლასები შვილი ელემენტებისთვის",
                  data:`ფსევდოკლასების ცალკე ჯგუფს შეადგენს ფსევდოკლასები შვილი ელემენტებისთვის, რომლებიც საშუალებას გვაძლევენ ავარჩიოთ განსაზღვრული შვილი ელემენტები:

                  :first-child: პირველი შვილი ელემენტი
                  :last-child: ბოლო შვილი ელემენტი
                  :only-child: ელემენტი, რომელიც ერთადერთია კონტეინერში
                  :only-of-type: ელემენტი, რომელიც ერთადერთი ამ ტიპის ელემენტია კონტეინერში
                  :nth-child(n): შვილი ელემენტი, რომელიც არის რიგით n კონტეინერში, მაგალითად, მეორე ელემენტი
                  :nth-last-child(n): შვილი ელემენტი, რომელიც არის რიგით n ბოლოდან კონტეინერში, მაგალითად, ბოლოდან მეორე ელემენტი
                  :nth-of-type(n): განსაზღვრული ტიპის შვილი ელემენტი, რომელიც არის რიგით n კონტეინერში
                  :nth-last-of-type(n): განსაზღვრული ტიპის შვილი ელემენტი, რომელიც არის რიგით n ბოლოდან კონტეინერში
                  ფსევდოკლასი first-child
                  
                  გამოვიყენოთ ფსევდოკლასი :first-child ბლოკში პირველი ბმულისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:first-child{            
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <h3>პლანშეტები</h3>
                          <div>
                              <a>Microsoft Surface Pro 4</a><br/>
                              <a>Apple iPad Pro</a><br/>
                              <a>ASUS ZenPad Z380KL</a>
                          </div>
                          <h3>სმარტფონები</h3>
                          <div>
                              <p>ტოპ-სმარტფონები 2016</p>
                              <a>Samsung Galaxy S7</a><br/>
                              <a>Apple iPhone SE</a><br/>
                              <a>Huawei P9</a>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სელექტორი a:first-child-ით განსაზღვრული სტილი გამოიყენება იმ ბმულებისთვის, რომელიც პირველი ელემენტია ნებისმიერი კონტეინერის შიგნით.
                  
                  პირველ ბლოკში ბმული პირველი ელემენტია, ამიტომ მასზე ვრცელდება სელექტორით განსაზღვრული სტილი. ხოლო მეორე ბლოკში ბმული არაა პირველი ელემენტი (პირველი ელემენტია პარაგრაფი), ამიტომ მასზე სტილი არ ვრცელდება.
                  
                  ფსევდოკლასი last-child
                  
                  გამოვიყენოთ ფსევდოკლასი :last-child ბლოკში ბოლო ბმულისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              a:last-child{            
                                  color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <h3>სმარტფონები</h3>
                          <div>
                              <a>Samsung Galaxy S7</a><br/>
                              <a>Apple iPhone SE</a><br/>
                              <a>Huawei P9</a>
                          </div>
                          <h3>პლანშეტები</h3>
                          <div>
                              <a>Microsoft Surface Pro 4</a><br/>
                              <a>Apple iPad Pro</a><br/>
                              <a>ASUS ZenPad Z380KL</a>
                              <p>2016 წლის მონაცემები</p>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი :last-child-ით განსაზღვრული სტილი გამოიყენება იმ ბმულებისთვის, რომელიც ბოლო ელემენტია ნებისმიერი კონტეინერის შიგნით.
                  
                  პირველ ბლოკში ბმული ბოლო ელემენტია, ამიტომ მასზე ვრცელდება სელექტორით განსაზღვრული სტილი. ხოლო მეორე ბლოკში ბმული არაა ბოლო ელემენტი (ბოლო ელემენტია პარაგრაფი), ამიტომ მასზე სტილი არ ვრცელდება.
                  
                  სელექტორი only-child
                  
                  სელექტორი :only-child გამოიყენება იმ ელემენტებისათვის, რომლებიც ერთადერთი შვილი ელემენტია თავის კონტეინერში:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                          p:only-child{
                              color:red;
                          }
                          </style>
                      </head>
                      <body>
                          <h2>სათაური</h2>
                          <div>
                              <p>ტექსტი1</p>
                          </div>
                          <div>
                              <p>ტექსტი2</p>
                              <p>ტექსტი3</p>
                          </div>
                          <div>
                              <p>ტექსტი4</p>
                          </div>
                      </body>
                  </html>
                  მოცემულ მაგალითში ტექსტი1 და ტექსტი4 წარმოადგენენ ერთადერთ ელემენტს თავის კონტეინერში, ამიტომ მათზე ვრცელდება ფსევდოკლასით განსაზღვრული სტილი, ხოლო ტექსტი2 და ტექსტი3 ერთიდაიმავე კონტეინერშია მოთავსებული, შესაბამისად არ არიან ერთადერთნი თავის კონტეინერში და მათზე სტილი არ ვრცელდება.
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი only-of-type
                  
                  ფსევდოკლასი :only-of-type არჩევს ელემენტებს, რომლებიც ერთადერთი ამ ტიპის ელემენტია კონტეინერში. სხვა ტიპის ელემენტები იმავე კონტეინერში შეიძლება იყოს ნებისმიერი რაოდენობით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                          span:only-of-type{        
                              color: green;   /* зеленый цвет */
                          }
                          p:only-of-type{        
                              color: red; /* წითელი */
                          }
                          div:only-of-type{        
                              color: blue;    /* ლურჯი */
                          }
                          </style>
                      </head>
                      <body>
                          <div>
                              სათაური
                          </div>
                          <p>ერთადერთი პარაგრაფი და <span>ელემენტი span</span></p>
                          <div>
                              ფუტერი
                          </div>
                      </body>
                  </html>
                  თუმცა სტილი განსაზღვრულია divელემენტებისთვის, იგი არ იქნება გამოყენებული, ვინაიდან body ელემენტის შიგნით რამდენიმე div ელემენტია. სამაგიეროდ, body-ში არის ერთადერთი პარაგრაფი და მასზე გავრცელდება p:only-of-type სელექტორით განსაზღვრული სტილი. ასევე, p პარაგრაფში არის მხოლოდ ერთი ელემენტი span, შესაბამისად მასზე გავრცელდება შესაბამისი სტილი.
                  
                  HTML5-ის დოკუმენტი
                  
                  
                  
                  ფსევდოკლასი nth-child
                  
                  ფსევდოკლასი :nth-child საშუალებას  იძლევა მოხდეს ყოველი მეორე, ყოველი მესამე და ა. შ. ან კენტ ან ლუწ ადგილზე მყოფი ელემენტის სტილიზაცია. მაგალითად, მოვახდინოთ ცხრილის კენტი და ლუწი სტრიქონების სტილიზაცია:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>სელექტორები</title>
                          <style>
                              tr:nth-child(odd) { background-color: #32F39F; }
                              tr:nth-child(even) { background-color: #F5EE31; }
                          </style>
                      </head>
                      <body>
                          <h3>სმარტფონები</h3>
                          <table>
                              <tr><td>Samsung</td><td>Galaxy S7 Edge</td><td>60000</td></tr>
                              <tr><td>Apple</td><td>iPhone SE</td><td>39000</td></tr>
                              <tr><td>Microsoft</td><td>Lumia 650</td><td>13500</td></tr>
                              <tr><td>Alcatel</td><td>Idol S4</td><td>30000</td></tr>
                              <tr><td>Huawei</td><td>P9</td><td>60000</td></tr>
                              <tr><td>HTC</td><td>HTC 10</td><td>50000</td></tr>
                              <tr><td>Meizu</td><td>Pro 6</td><td>40000</td></tr>
                              <tr><td>Xiaomi</td><td>Mi5</td><td>35000</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  კენტი ელემენტების სტილიზაციისთვის სელექტორს პარამეტრად გადაეცემა odd:
                  
                  tr:nth-child(odd){background-color: #32F39F;}
                  ლუწი ელემენტების სტილიზაციისთვის სელექტორს პარამეტრად გადაეცემა even:
                  
                  tr:nth-child(even){background-color: #F5EE31;}
                  ასევე პარამეტრად შეიძლება გადავცეთ რიგითი ნომერი:
                  
                  tr:nth-child(3){background-color: #bbb;}
                  ამ შემთხვევაში ხდება რიგით მესამე ელემენტის სტილიზაცია.
                  
                  კიდევ ერთი შესაძლებლობაა ამ ფსევდოკლასის გამოყენების - შეგვიძლია პარამეტრად გადავცეთ ფორმულა n-ის შემცველობით:
                  
                  tr:nth-child(2n+1){background-color: #bbb;}
                  ამ შემთხვევაში სტილიზაცია ხდება იმ ელემენტების, რომელთა რიგით ნომერსაც მივიღებთ n-ის ნაცვლად მთელი რიცხვების ჩასმით დაწყებული 0-დან, ანუ 2*0+1=1,2*1+1=3,2*2+1=5 და ა. შ. ე.ი. მოხდება სტილიზაცია პირველი, მესამე, მეხუთე, მეშვიდე და ა. შ. ელემენტების.
                  
                  თუ ჩენ გვინდა ყოველი მესამე ელემენტის სტილიზაცია, დაწყებული მე-2-დან, უნდა დავწეროთ:
                  
                  tr:nth-child(3n+2){background-color: #bbb;}
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასს :nth-last-child გააჩნია ზუსტად იგივე ფუნქციონალი, ოღონდ ათვლა იწყება ბოლოდან:
                  
                  tr:nth-last-child(2){background-color: #81F760;}
                  tr:nth-last-child(2n+1){background-color: #83E3F8;}`
              },
              {
                  title:"ფორმის ფსევდოკლასები",
                  data:`რიგი ფსევდოკლასებისა გამოიყენება ფორმის ელემენტებთან სამუშაოდ:

                  :enabled: ელემენტები, რომლებიც ხელმისაწვდომია (ანუ რომელთაც არა აქვთ ატრიბუტი disabled)
                  :disabled: ელემენტები, რომლებიც არაა ხელმისაწვდომი (ანუ რომელთაც აქვთ ატრიბუტი disabled)
                  :checked: ელემენტები, რომელთაც აქვთ ატრიბუტი checked (ალმებისა და გადამრთველებისთვის (რადიოღილაკებისთვის))
                  :default: ელემენტი, რომელიც არის უპირატესი
                  :valid: ელემენტი, რომელიც გადის HTML5 ვალიდაციას
                  :invalid: ელემენტი, რომელიც ვერ გადის HTML5 ვალიდაციას
                  :in-range: ელემენტი, რომლის მნიშვნელობა გარკვეულ დიაპაზონშია (გამოიყენება ელემენტისთვის მცოცავი ველი)
                  :out-of-range: ელემენტები, რომელთა მნიშვნელობა გარკვეულ დიაპაზონს გარეთაა
                  :required: ელემენტები, რომელთაც მინიჭებული აქვთ ატრიბუტი required
                  :optional: ელემენტები, რომელთაც არა აქვთ მინიჭებული ატრიბუტი required
                  ფსევდოკლასები enabled და disabled
                  
                  ფსევდოკლასები enabled და disabled გამოიყენება იმის მიხედვით, აქვს თუ არა ელემენტს მინიჭებული ატრიბუტი disabled:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :enabled {
                                  border: 2px blue solid;
                                  color: green;
                              }
                              :disabled {
                                  border: 2px black solid;
                                  color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <p><input type="text" value="Enabled" /></p>
                          <p><input type="text" disabled value="Disabled" /></p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი checked
                  
                  ფსევდოკლასი :checked გამოიყენება ფორმის იმ ელემენტებისათვის, რომელთაც აქვთ ატრიბუტი checked:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :checked + span {
                                  color: red;
                                  font-weight: bold;            }
                          </style>
                      </head>
                      <body>
                              <h2>აირჩიეთ ტექნოლოგია</h2>
                              <p>
                                  <input type="checkbox" checked name="html5"/><span>HTML5</span>
                              </p>
                              <p>
                                  <input type="checkbox" name="dotnet"/><span>.NET</span>
                              </p>
                              <p>
                                  <input type="checkbox" name="java"/><span>Java</span>
                              </p>
                              
                              <h2>მიუთითეთ სქესი</h2>
                              <p>
                                  <input type="radio" value="man" checked name="gender"/><span>კაცი</span>
                              </p>
                              <p>
                                  <input type="radio" value="woman" name="gender"/><span>ქალი</span>
                              </p>
                      </body>
                  </html>
                  სელექტორი :checked+span საშუალებას გვაძლევს ავირჩიოთ span ელემენტი, რომელიც მოსდევს მონიშნულ ელემენტს:
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასი default
                  
                  ფსევდოკლასი :default განკუთვნილია იმ ელემენტის სტილიზაციისთვის, რომელიც უპირატესია ფორმაზე. როგორც წესი, ასეთ ელემენტს ფორმაზე წარმოადგენს გაგზავნის ღილაკი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :default {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <input name="login"/>
                              <input type="submit" value="შესვლა" />
                          </form>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  
                  
                  ფსევდოკლასები valid და invalid
                  
                  ფსევდოკლასები valid და invalid ახდენენ ელემენტების სტილიზაციას იმის მიხედვით, გადიან ისინი ვალიდაციას თუ არა:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              input:invalid {
                                  border: 2px solid red;
                              }
                              input:valid {
                                  border: 2px solid green;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p><input type="text" name="login" placeholder="მომხმარებელი" required /></p>
                              <p><input type="password" name="password" placeholder="პაროლი" required /></p>
                              <input type="submit" value="შესვლა" />
                          </form>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასები in-range და out-of-range
                  
                  ფსევდოკლასები in-range და out-of-range გამოიყენება იმის მიხედვით, არის თუ არა ელემენტის მნიშვნელობა გარკვეულ დიაპაზონში ან მის გარე. ეს პირველ რიგში ეხება ელემენტს <input type="number" >.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :in-range {
                                  border: 2px solid green;
                              }
                              :out-of-range {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="age">თქვენი ასაკი:</label>
                                  <input type="number" min="1" max="100" value="10" id="age" name="age"/>
                              </p>
                              <input type="submit" value="შესრულება" />
                          </form>
                      </body>
                  </html>
                  აქ ატრიბუტები min და max განსაზღვრავს დიაპაზონს, რომელშიც უნდა იყოს მნიშვნელობა:
                  
                  HTML5-ის დოკუმენტი
                  
                  ფსევდოკლასები required და optional
                  
                  ფსევდოკლასები required და optional გამოიყენება იმის მიხედვით, აქვს თუ არა ელემენტს ატრიბუტი required:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ფსევდოკლასები</title>
                          <style>
                              :optional {
                                  border: 2px solid blue;
                              }
                              :required {
                                  border: 2px solid red;
                              }
                          </style>
                      </head>
                      <body>
                          <form>
                              <p>
                                  <label for="login">მომხმარებელი:</label>
                                  <input type="text" id="login" name="login" required />
                              </p>
                              <p>
                                  <label for="password">პაროლი:</label>
                                  <input type="password" id="password" name="password" required />
                              </p>
                              <p>
                                  <label for="name">სახელი:</label>
                                  <input type="text" id="name" name="name"/>
                              </p>
                              <input type="submit" value="რეგისტრაცია" />
                          </form>
                      </body>
                  </html>`
              },
              {
                title:"ფსევდოელემენტები",
                data:`ფსევდოელემენტები იძლევა დამატებით შესაძლებლობებს ვებგვერდის ელემენტების სტილიზაციისთვის და ჰგვანან ფსევდოკლასებს. ფსევდოელემენტებია:

                ::first-letter: იძლევა ტექსტის პირველი ასოს სტილიზაციის საშუალებას
                
                ::first-line: ახდენს ტექსტის პირველი სტრიქონის სტილიზაციას
                
                ::before: ამატებს შეტყობინებას (ტექსტს) ელემენტის წინ
                
                ::after: ამატებს შეტყობინებას (ტექსტს) ელემენტის შემდეგ
                
                ::selection: მომხმარებლის მიერ მონიშნული ტექსტის სტილიზაცია
                
                CSS2-ში ფსევდოელემენტების წინ, ისევე როგორც ფსევდოკლასების წინ იწერებოდა ერთი ორწერტილი, CSS3-ში ფსევდოელემენტების წინ იწერება ორი ორწერტილი, რათა გაემიჯნათ ფსევდოკლასებისგან. თუმცა ძველი ბრაუზერების თავსებადობისთვის დასაშვებია ერთი ორწერტილის გამოყენებაც - :before.
                
                ტექსტის სტილიზაციისთვის გამოვიყენოთ first-letter и first-line:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            ::first-letter { color:red; font-size: 25px; }
                            ::first-line { font-size: 20px; }
                        </style>
                    </head>
                    <body>
                        <p>ყმაწვილი კაცი... აღვწეროთ მისი პორტრეტი ერთი კალმის მოსმით.
                            წარმოიდგინეთ დონ კიხოტი, ოღონდ 18 წლისა; დონ კიხოტი მსუბუქად
                            ჩაცმული, უჯავშნოდ და უმუზარადოდ, დონ კიხოტი ლურჯი შალის ქურთუკით,
                            რომელიც ისე გახუნებულიყო, რომ რაღაც უცნაური, მომწვანო ცისფერი
                            მიეღო, წარმოიდგინეთ გრძელი და შავგვრემანი პირისახე; ამოწეული
                            ყვრიმალი — ცხადი ნიშანი ცბიერებისა; ყბები მეტისმეტად განვითარებული —
                            ამ ნიშნით გამოირჩევა გასკონელი, თუნდ ბერეტიც არ ეხუროს, ჩვენს გმირს კი
                            ეხურა სწორედ ასეთი ბერეტი, რომელიც რაღაც ფრთით დაემშვენებინა. </p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გამოვიყენოთ ფსევდოელემენტები before და after:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            .warning::before{ content: "ყურადღება! "; font-weight: bold; }
                            .warning::after { content: " იყავით ფრთხილად!"; font-weight: bold;}
                        </style>
                    </head>
                    <body>
                        <p><span class="warning">ნუ შეყოფთ ენას დენის წყაროში.</span></p>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                აქ ფსევდოელემენტები გამოყენებულია ელემენტებისთვის კლასით "warning". ორივე ფსევდოელემენტს გააჩნია თვისება "content" რომელშიც ინახება დასამატებელი ტექსტი. ასევე ორივე ელემენტს გამუქებული აქვს შრიფტი, რისთვისაც გამოყენებულია თვისება font-weight: bold;.
                
                გამოვიყენოთ ფსევდოელემენტი selection მონიშნული ტექსტის სტილიზაციისთვის:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ფსევდოელემენტები</title>
                        <style>
                            ::selection {
                                color: white;
                                background-color: #DD0F0F;
                            }
                        </style>
                    </head>
                    <body>
                        <p>ფსევდოელემენტები CSS3-ში იძლევა ტექსტის სტილიზაციის საშუალებას.</p>
                    </body>
                </html>`
            },
            {
                title:"ატრიბუტთა სელექტორები",
                data:`ელემენტთა სელექტორების გარდა შეიძლება გამოვიყენოთ სელექტორები მათი ატრიბუტებისთვის. მაგალითად, ვებგვერდზე გვაქვს რამდენიმე ელემენტი input, მაგრამ გვინდა მხოლოდ ტექსტური ელემენტების ჩარჩოს ფერი იყოს წითლი. სწორედ ამ დროს გამოიყენება სელექტორები ატრიბუტებისთვის:

                input[type="text"]{    
                    border: 2px solid red;
                }
                ელემენტის შემდეგ კვადრატულ ფრჩხილებში მოდის ატრიბუტი და მისი მნიშვნელობა. ამ შემთხვევაში ყველა ტექსტურ ველს ექნება წითელი ჩარჩო 2 პიქსელი სისქის:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ატრიბუტთა სელექტორები</title>
                        <style>
                            input[type="text"]{
                                border: 2px solid red;
                            }
                        </style>
                    </head>
                    <body>
                        <p><input type="text" id="login" /></p>
                        <p><input type="password" id="password" /></p>
                        <input type="submit" value="გაგზავნა" />
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ატრიბუტების სელექტორის გამოყენება შეიძლება არა მხოლოდ ელემენტებისთვის, არამედ კლასებისა და იდენტიფიკატორებისთვისაც. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ატრიბუტთა სელექტორები</title>
                        <style>
                            .link[href="http://apple.com"]{            
                                color: red;
                            }
                        </style>
                    </head>
                    <body>
                        <a class="link" href="http://microsoft.com">Microsoft</a> |
                        <a class="link" href="https://google.com">Google</a> |
                        <a class="link" href="http://apple.com">Apple</a>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                სპეციალური სიმბოლოებით სესაძლებელია მოხდეს ატრიბუტთა მნიშვნელობის დაკონკრეტება. მაგალითად, სიმბოლო ^ საშუალებას იძლევა ავარჩიოთ ყველა ატრიბუტი, რომელიც იწყება განსაზღვრული ტექსტით. მაგალითად, ვთქვათ გვინდა მოვახდინოთ სტილიზაცია ყველა ბმულის, რომელიც იყენებს https პროტოკოლს, ანუ იწყება "https://"-ით. ამისთვის გამოვიყენებთ შემდეგ სელექტორს:
                
                a[href^="https://"]{   
                    color: red;
                }
                თუ ატრიბუტის მნიშვნელობა უნდა ბოლოვდებოდეს გარკვეული ტექსტით, უნდა გამოვიყენოთ სიმბოლო $. მაგალითად, გვინდა ავირჩიოთ ყველა სურათი გაფართოებით .jpg. ამისთვის უნდა მოვძებნოთ ყველა ელემენტი, რომლის ატრიბუტი src ბოლოვდება ".jpg"-ით:
                
                img[src$=".jpg"]{      
                    width: 100px;
                }
                კიდევ ერთი სიმბოლო * საშუალებას გვაძლევს ავარჩიოთ ის ელემენტები, რომელთა ატრიბუტის მნიშვნელობა შეიცავს გარკვეულ ტექსტს (არა აქვს მნიშვნელობა თავში, ბოლოში თუ შუაში):
                
                a[href*="microsoft"]{   
                    color: red;
                }   `
            },
            {
                title:"სტილების მემკვიდრეობითობა",
                data:`სტილების განსაზღვრის გასამარტივებლად სტილებს გააჩნია მემკვიდრეობითობა. ჩასმულ ელემენტებს შეუძლიათ მიიღონ მათი მშობელი ელემენტის სტილები. ვთქვათ ვებგვერდზე გვაქვს პარაგრაფი და სათაური, რომელთაც უნდა ჰქონდეთ წითელი ფერი. ჩვენ შეგვიძლია თითოეულს ცალ-ცალკე განვუსაზღვროთ შრიფტის ფერი:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების მემკვიდრეობითობა</title>
                        <style>
                            p {color: red;}
                            h2 {color: red;}
                        </style>
                    </head>
                    <body>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </body>
                </html>
                მაგრამ ვინაიდან ორივე ეს ელემენტი არის ელემენტ body-ს შიგნით, მათ შეუძლიათ ბევრი სტილი მემკვიდრეობით მიიღონ body-სგან:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების მემკვიდრეობითობა</title>
                        <style>
                            body {color: red;}
                        </style>
                    </head>
                    <body>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </body>
                </html>
                მივიღებთ იგივე შედეგს.
                
                თუ არ გვინდა, რომ რომელიმე ელემენტმა მემკვიდრეობით მიიღოს სტილი მშობლისგან, შეგვიძლია ამ ელემენტს თვითონ განვუსაზღვროთ სტილი:
                
                     body {color: red;}
                     p {color: green;}
                მრავალდონიანი ჩასმული ელემენტების შემთხვევაში სტილის მემკვიდრეობით მიღება ხდება მხოლოდ უშუალო მშობლისგან:
                
                 
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>სტილების მემკვიდრეობითობა</title>
                    <style>
                        body {
                            color: red;
                        }
                        div {
                            color: green;
                        }
                    </style>
                </head>
                <body>
                    <div>
                        <h2>სტილების მემკვიდრეობითობა</h2>
                        <p>ტექსტი სტილების მემკვიდრეობითობაზე</p>
                    </div>
                    <p>Copyright © MyCorp.com</p>
                </body>
                </html>
                 
                
                რადგან div ელემენტისთვის ცალკეა განსაზღვრული სტილი, მასში შემავალი ელემენტები მისგან იღებენ მემკვიდრეობით სტილს, ხოლო ელემენტი p რომელიც უშუალოდ body-ს შიგნითაა, იგი სტილს მემკვიდრეობით body-სგან ღებულობს:
                
                HTML5-ის დოკუმენტი
                
                მაგრამ CSS-ის ყველა თვისებისთვის არ მოქმედებს მემკვიდრეობითობის პრინციპი. მემკვიდრეობით არ გადაეცემა ტექსტის დაშორებები (margin, padding) და ჩარჩოები (border).
                
                გარდა ამისა ბრაუზერები, იმ შემთხვევაში, თუ სპეციალურად არაა განსაზღვრული, ცალკეული ელემენტების მიმართ იყენებენ განსაზღვრულ სტილებს. მაგალითად, სათაურებს (h1-h6) აქვთ გარკვეული სიმაღლე და ა. შ.`
            },
            {
                title:"სტილების კასკადურობა",
                data:`როცა ელემენტისთვის გამოიყენება ერთი სტილი, ყველაფერი შედარებით მარტივია. მაგრამ როცა ერთ ერთ ელემენტზე რამდენიმე სტილი მოქმედებს, ისმება კითხვა, რომელ სტილს მიიღებს ელემენტი?

                CSS-ში მოქმედებს კასკადურობის მექანიზმი, როგორც წესების ერთობლიობა, რომელიც განსაზღვრავს ერთი და იმავე ელემენტზე ბევრი სტილის მოქმედების თანმიმდევრობას.
                
                ვნახოთ მაგალითი:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            .redLink {color: red;}  /* ტექსტის წითელი ფერი */
                            .footer a {font-weight: bold;}  /* შრიფტის გამუქება */
                            a {text-decoration: none;}  /*ხაზგასმის მოხსნა */
                        </style>
                    </head>
                    <body>
                        <p class="footer">დამატებითი ინფორმაციისთვის გადადით ბმულზე:
                            <a class="redLink" href="css3.html">CSS3-ის საფუძვლები</a></p>
                    </body>
                </html>
                CSS-ში განსაზღვრულია სამი სტილი და სამივე მიესადაგება ბმულს. თუ ვებგვერდის ელემენტს მიესადაგება რამდენიმე სტილი, რომელიც ერთმანეთთან კონფლიქტში არ მოდის, ისინი ერთიანდება ერთ სტილში. მოცემულ შემთხვევაში სტილები ერთმანეთთან კონფლიქტში არ მოდის, შესაბამისად ბმულზე იმოქმედებს სამივე:
                
                HTML5-ის დოკუმენტი
                
                თუ სტილები კონფლიქტში მოდიან ერთმანეთთან, ამ შემთხვევაში მოქმედებს თითოეული სტილის მნიშვნელობის განსაზღვრის რთული სისტემა. ყველა ეს წესი აღწერილია CSS-ის სპეციფიკაციაში, რომლის სანახავად შეგიძლიათ გადახვიდეთ ბმულზე Calculating a selectors specificity. მოკლედ გავარჩიოთ ეს წესი.
                
                ელემენტის სტილის განსაზღვრისთვის გამოიყენება მრავალი სელექტორი. თითოეულის მნიშვნელობა ელემენტისთვის განისაზღვრება ქულებით. რაც უფრო მეტი ქულა აქვს სელექტორს, მით უფრო მეტია მისი მნიშვნელობა ელემენტისთვის და მას გააჩნია უფრო მაღალი პრიორიტეტი სხვა სელექტორებით განსაზღვრულ სტილებთან შედარებით.
                
                ტეგის სელექტორის მნიშვნელობა განისაზღვრება 1 ქულით
                კლასის, ატრიბუტის და ფსევდოკლასის მნიშვნელობა განისაზღვრება 10 ქულით
                იდენტიფიკატორის სელექტორის მნიშვნელობა განისაზღვრება 100 ქულით
                ელემენტში ჩაშენებული ინლინე-სტილის მნიშვნელობა განისაზღვრება 1000 ქულით
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            #index {color: navy;}   /* ტექსტის მუქი ლურჯი ფერი */
                            .redLink {color: red; font-size: 20px;} /* ტექსტის ფერი წითელი და შრიფტის ზომა 20 პიქსელი */
                            a {color: black; font-weight: bold;}    /* ტექსტის შავი ფერი და გამუქება */
                        </style>
                    </head>
                    <body>
                        <a id="index" class="redLink" href="index.php">CSS3-ის საფუძვლები</a>
                    </body>
                </html>
                მოცემულ მაგალითში ბმულისთვის განსაზღვრულია ერთდროულად 3 სტილი. მათ შორის 2 ერთმანეთთან კონფლიქტში არაა:
                
                font-size: 20px;
                font-weight: bold;
                ვინაიდან განსაზღვრულია მხოლოდ ერთ სტილში, შესაბამისად ისინი შეჯამდება და ორივე შეცვლის ბმულის სტილს.
                
                მაგრამ სამივე სტილი შეიცავს ტექსტის სხვადასხვა ფერს, შესაბამისად ისინი ერთმანეთთან კონფლიქტში მოდიან. მაგრამ ვინაიდან იდენტიფიკატორის სტილის მნიშვნელობა ელემენტისთვის უფრო მაღალია, ვიდრე კლასის და ტეგის სტილის, საბოლოოდ ელემენტს ექნება მუქი ლურჯი ფერი:
                
                #index {color: navy;} 
                თუ სელექტორი შედგენილია, მაშინ ხდება ქულების დათვლა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>სტილების კასკადურობა</title>
                        <style>
                            a {font-size: 18px;}
                            .nav li a {color: red;}
                            #menu a {color: navy;} 
                            .nav .menuItem {color: green;}
                            a.menuItem:not(.newsLink) {color: orange;}
                            div ul li a {color: gray; }
                        </style>
                    </head>
                    <body>
                        <div id="menu">
                            <ul class="nav">
                                <li><a class="menuItem">მთავარი</a></li>
                                <li><a class="menuItem">ფორუმი</a></li>
                                <li><a class="menuItem">ბლოგი</a></li>
                                <li><a class="menuItem">საიტის შესახებ</a></li>
                            </ul>
                        </div>
                    </body>
                </html>
                CSS-ში განსაზღვრულია ხუთი სტილი, რომლებიც ბმულის ფერს ადგენს. იმისათვის, რომ გავიგოთ, რა ფერი ექნება ბმულს, შევადგინოთ ცხრილი:
                
                სელექტორი	იდენტიფიკატორი	კლასი	ტეგი	ჯამი
                .nav li a	0	1	2	12
                #menu a	1	0	1	101
                .nav .menuItem	0	2	0	20
                a.menuItem:not(.newsLink)	0	2	1	21
                div ul li a	0	0	4	4
                როგორც ცხრილიდან ჩანს, სელექტორს #menu a აქვს ყველაზე მაღალი ქულა 101, შესაბამისად ბმულის ფერსაც ის განსაზღვრავს და იქნება მუქი ლურჯი.
                
                წესი !important
                
                CSS-ში არის საშუალება სელექტორების მნიშვნელობებს ავუაროთ გვერდი. ამისთვის არსებობს ბრძანება !important:
                
                a {font-size: 18px; color: red !important;}
                #menu a {color: navy;}
                ასეთ დროს მიუხედავად სხვა სელექტორის არსებობისა უფრო მაღალი ქულებით, გამოიყენება წითელი ფერი, რადგანაც მონიშნულია ბრძანებით  !important.`
            },
           
            ]
        },
        {
            title:"თავი 6. CSS3-ის საფუძვლები. თვისებები",
            content:[
                {
                    title:"ფერი CSS-ში",
                    data:`CSS-ში ფართო გამოყენება აქვს ფერებს. ფერი ენიჭება ტექსტს, ფონს, ჩარჩოებს. მაგალითად, div ელემენტის ფონს მივანიჭოთ წითელი ფერი:

                    div{
                        background-color: red;
                    }
                     
                    
                    CSS-ში არის რამდენიმე თვისება, რომელსაც უნდა მიენიჭოს ფერი. ტექსტის ფერის მისანიჭებლად გამოიყენება თვისება color, ფონისთვის - border-color, ჩარჩოს ფერისთვის - border-color.
                    
                    ფერის განსაზღვრისთვის რამდენიმე ხერხი არსებობს:
                    
                    თექვსმეტობითი რიცხვი - თექვსმეტობით სისტემაში ხდება წითელი, მწვანე და ლურჯი ფერის მნიშვნელობების კოდირება. მაგალითად, #1C4463. პირველი ორი სიმბოლო 1C აღნიშნავს წითელს, მომდევნო ორი - 44 მწვანეს, ბოლო ორი - 63 ლურჯს. საბოლოო ფერი მიიღება ამ ფერების შეზავებით. თუ ყველა წყვილი განმეორებადი სიმბოლოებისგან შედგება, შეიძლება მათი შემცირება თითომდე, მაგალითად #5522AA-ს ნაცვლად შეიძლება ჩავწეროთ #52A, #eeeeee-ს ნაცვლად - #eee. ამასთან, რეგისტრს მნიშვნელობა არა აქვს.
                    RGB მნიშვნელობა - RGB წარმოადგენს წითელი, მწვანე და ლურჯი ფერების რიცხვით მნიშვნელობათა თანმიმდევრობას (Red - წითლი, Green - მწვანე, Blue - ლურჯი). რიცხვითი მნიშვნელობა შეიძლება იყოს გამოსახული პროცენტებში (0-დან 100 %-მდე) ან რიცხვებით (0-დან 255-მდე). მაგალითად:
                      background-color: rgb(100%,100%,100%);
                    აქ თითოეულ ფერს აქვს მნიშვნელობა 100%, შედეგად მივიღებთ თეთრ ფერს. თუ სამივე ფერი იქნებოდა 0%, მივიღებდით შავს.
                    
                    უფრო ხშირად გამოიყენება არა პროცენტული, არამედ რიცხვითი მნიშვნელობები. მაგალითად:
                    
                      background-color: rgb(28,68,99);
                    RGBA მნიშვნელობა - ეს იგივეა, რაც RGB, რომელსაც დამატებული აქვს გამჭვირვალობის კოეფიციენტი (Alpha). ის ღებულობს მნიშვნელობას 0-დან (სრულიად გამჭვირვალე) 1-მდე (გაუმჭვირვალე). მაგალითად:
                      background-color: rgb(28, 68, 99, 0.6);
                    HSL მნიშვნელობა - HSL წარმოადგენს აბრევიატურას: Hue - ტონი, Saturation - გაჯერებულობა, Lightness - განათებულობა. Hue არის კუთხე ფერების წრეში 0-დან 360 გრადუსამდე. Saturation მიუთითებს, რამდენად გაჯერებულია ფერი. იგი გამოისახება პროცენტებით 0-დან 100 %-მდე. Lightness განათებულობა ასევე პროცენტებში გამოისახება და ღებულობს მნიშვნელობას 0-დან (განათებულობის არარსებობა, ანუ შავი) 100%-მდე (მთლიანად განათებული, ანუ თეთრი). სუფთა ფერის მისაღებად გამოიყენება 50 %. მაგალითად:
                      background-color: hsl(206, 56%, 25%);
                    ეს ფერი წარმოადგენს #1C4463 და rgb(28, 68, 99) ფერების ეკვივალენტს.
                    
                    HSLA მნიშვნელობა - RGBA-ს ანალოგიურად მიიღება HSL-ისგან გამჭვირვალობის (Alpha)დამატებით. მაგალითად:
                      background-color: hsl(206, 56%, 25%, 0.6);
                    ტექსტური მნიშვნელობა - ზოგიერთი ფერისთვის არსებობს ტექსტური მნიშვნელობა, მაგალითად red - წითელი, green - მწვანე, blue - ლურჯი, yellow - ყვითელი და ა. შ. მაგალითად:
                      background-color: darkblue;
                    darkblue - მუქი ლურჯი, წარმოადგენს #00008B-ს ეკვივალენტს.
                    
                    გამჭვირვალობა
                    
                    ფერების მნიშვნელობებში გათვალისწინებულია გამჭვირვალობა (RGBA, HSLA). თუმცა CSS-ში არის ცალკე თვისებაც, რომელიც განსაზღვრავს გამჭვირვალობას. ეს თვისებაა opacity. ის ღებულობს მნიშვნელობას 0-დან (სრულად გამჭვირვალე) 1-მდე (გაუმჭვირვალე). მაგალითად:
                    
                    div{
                        width: 100px;
                        height: 100px;
                        
                        background-color: red;
                        opacity: 0.4;
                    }`
                },
                {
                  title:"შრიფტების სტილიზაცია",
                  data:`თვისება font-family განსაზღვრავს შრიფტის ოჯახს. მაგალითად:

                  body{
                      font-family: Arial;
                  }
                  მოცემულ შემთხვევაში გამოიყენება შრიფტი Arial. 
                  
                  ეს თვისება იმუშავებს მხოლოდ იმ შემთხვევაში, თუ მომხმარებელს კომპიუტერზე გააჩნია ასეთი შრიფტი. ამიტომ უპირატესად გამოიყენება ისეთი შრიფტები, რომლებიც ფართოდაა გავრცელებული, როგორიცაა Arial, Verdana და ა. შ. ასევე ხშირად ეთითება რამდენიმე შრიფტი. მაგალითად:
                  
                  body{
                      font-family: Arial, Verdana, Helvetica;
                  }
                  ამ შემთხვევაში ძირითადი შრიფტია Arial. თუ მომხმარებელს ეს შრიფტი არ აღმოაჩნდა, გამოიყენება მეორე - Verdana და ა. შ.
                  
                  თუ შრიფტის დასახელება რამდენიმე სიტყვისგან შედგება, უნდა ჩავსვათ ბრჭყალებში:
                  
                  body{
                      font-family: "Times New Roman";
                  }
                  კონკრეტული შრიფტების გარდა შეიძლება მიეთითოს საერთო უნივერსალური შრიფტები, რაც გამოისახება მნიშვნელობით sans-serif და serif:
                  
                  body{
                      font-family: Arial, Verdana, sans-serif;
                  }
                  შრიფტის სისქე
                  
                  თვისება font-weight განსაზღვრავს შრიფტის სისქეს. ის იღებს 9 მნიშვნელობას: 100,200,300,...,900. 100 ძალიან წვრილიდან 900 ძალიან სქელამდე.
                  
                  რეალობაში ძირითადად გამოიყენება ორი მნიშვნელობა: normal (ნორმალური, ჩვეულებრივი) და bold (ნახევრადსქელი):
                  
                  font-weight: normal;
                  font-weight: bold;
                  შრიფტის დახრა
                  
                  თვისება font-style საშუალებას გვაძლევს გამოვიყენოთ დახრილი შრიფტი. ამისთვის გამოიყენება მნიშვნელობა italic:
                  
                  font-style: italic;
                  თუ გვინდა დახრის გაუქმება,გამოიყენება მნიშვნელობა normal:
                  
                  font-style: normal;
                  შრიფტის ფერი
                  
                  თვისება color განსაზღვრავს შრიფტის ფერს:
                  
                  p {
                      color: red;
                  }`
              },
              {
                  title:"გარე შრიფტები",
                  data:`სტანდარტული შრიფტების გამოყენება ყოველთვის არ არის მისაღები. ხშირად საჭიროა რაღაც განსხვავებული შრიფტის გამოყენება, რომელიც არაა ფართოდ გავრცელებული და მომხმარებლის კომპიუტერზე შეიძლება არ აღმოჩნდეს. ასეთ შემთხვევაში გამოიყენება თვისება font-face:

                  @font-face {   
                              font-family: 'unicode_3d';
                              src: url(3d_unicode.ttf);
                           }
                  src ატრიბუტის მნიშვნელობა არის შრიფტის მისამართი. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>სტილების კასკადურობა</title>
                      <style>
                          @font-face {   
                              font-family: 'unicode_3d';
                              src: url(3d_unicode.ttf);
                           }
                          @font-face {
                              font-family: 'bpg_extramt';
                              src: url(bpg_extrasquare_mtavruli_2009.ttf);
                          }
                          .mtavr {
                              font-family: bpg_extramt;           
                          }
                          .daxr {
                              font-family: unicode_3d;
                          }
                      </style>
                  </head>
                  <body>
                      <p class="mtavr">იყო არაბეთს როსტევან, მეფე ღმრთისაგან სვიანი,</p>
                      <p class="daxr">მაღალი, უხვი, მდაბალი, ლაშქარმრავალი, ყმიანი...</p>
                  </body>
                  </html> 
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  არსებობს შრიფტის სხვადასხვა ფორმატი: TrueType( გაფართოება ttf), Open Type (გაფართოება otf), Embedded Open Type (გაფართოება eot), Web Open Font Format (woff/woff2), Scalable Vector Graphic (svg). სხვადასხვა ბრაუზერს შეიძლება ჰქონდეს სხვადასხვა ტიპის შრიფტის მხარდაჭერა. ამ პრობლემის გადასაჭრელად, ხშირად შრიფტის შემქმნელები ერთი და იგივე შრიფტს ქმნიან სხვადასხვა ფორმატში და შესაძლებელია ერთდროულად რამდენიმე ფორმატის მითითება:
                  
                  @font-face {   
                     font-family:'FontAwesome';
                     src: url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.eot');
                     src: url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.eot?#iefix') format('embedded-opentype'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.woff2') format('woff2'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.woff') format('woff'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.ttf') format('truetype'),
                          url('https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/fonts/fontawesome-webfont.svg') format('svg');
                  }
                  შრიფტის სხვადასხვა ვერსია
                  
                  ხანდახან შრიფტი შედგება არა ერთი, არამედ რამდენიმე ფაილისგან, მაგალითად შრიფტს ცალკე ფაილებში შეიძლება ჰქონდეს bold, italic, bold-italic და ა. შ. ვერსიები. ასეთ შემთხვევაში იქმნება რამდენიმე font-face და ფაილის მისამართთან ერთად ეთითება შრიფტის ტიპი. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Regular.ttf);
                                  font-weight: normal;
                                  font-style: normal;
                              }
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Italic.ttf);
                                  font-weight: normal;
                                  font-style: italic;
                              }
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-Bold.ttf);
                                  font-weight: bold;
                                  font-style: normal;
                              }            
                              @font-face {
                                  font-family: 'Roboto';
                                  src: url(fonts/Roboto-BoldItalic.ttf);
                                  font-weight: bold;
                                  font-style: italic;
                              }
                              p{
                                  font-family: Roboto;
                              }
                          </style>
                      </head>
                      <body>
                          <p>Font Roboto <i>Italic</i>, <b>Bold</b>, <b><i>Bold Italic</i></b></p>
                      </body>
                  </html> 
                   `
              },
              {
                  title:"შრიფტის ზომა",
                  data:`შრიფტისთვის ზომის მისაცემად გამოიყენება თვისება font-size:

                  div{
                      font-size: 18px;
                  }
                  მოცემულ მაგალითში შრიფტის ზიმა (სიმაღლე) არის 18 პიქსელი. პიქსელი წარმოადგენს ყველაზე ხშირად გამოყენებულ ზომის ერთეულს. ის არინიშნება "px"-ით, რომელიც იწერება რიცხვითი მნიშვნელობის შემდეგ.
                  
                  თუ ტექსტის ზომას არ მივუთითებთ, ჩვეულებრივი ტექსტისთვის შრიფტის ზომა იქნება 16 პიქსელი. სხვადასხვა ბაზურ ელემენტს სხვადასხვა სტანდარტული შრიფტის ზომა გააჩნია. მაგალითად, თუ პარაგრაფისთვის (p) იგი 16 პიქსელის ტოლია, h1 სათაურისთვის ის 32 პიქსელია, h2-სთვის 24 პიქსელი და ა. შ.
                  
                  შრიფტის ზომისთვის ასევე გამოიყენება სხვადასხვა ზომის ერთეულები.
                  
                  შრიფტის ტექსტური ზომები
                  
                  CSS-ში არის შემდეგი შრიფტის ზომები:
                  
                  medium: საბაზისო ზომა (16 პიქსელი)
                  small: 13 პიქსელი
                  x-small: 10 პიქსელი
                  xx-small: 9 პიქსელი
                  large: 18 პიქსელი
                  x-large: 24 პიქსელი
                  xx-large: 32 პიქსელი
                  მაგალითად:
                  
                  font-size: x-large;
                  
                  შრიფტის ზომა პროცენტებით
                  
                  პროცენტები საშუალებას გვაძლევს შრიფტის ზომა მივუთითოთ პროცენტებით საბაზისო ან მემკვიდრეობით მიღებული შრიფტის ზომისგან. მაგალითად:
                  
                  font-size: 150%;
                  
                  ამ შემთხვევაში შრიფტის ზომა იქნება საბაზისო ზომის (16px) 150% ანუ 24 px.
                  
                  შრიფტის ზომის პროცენტებით მითითებისას მემკვიდრეობითობამ შეიძლება შეცვალოს შრიფტის საბოლოო ზომა. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              div {font-size: 10px;}
                              p {font-size: 150%;}
                          </style>
                      </head>
                      <body>
                      <div>
                          <p>შრიფტის ზომა მემკვიდრეობითობის გათვალისწინებით.</p>
                      </div>
                      </body>
                  </html>
                  მოცემულ მაგალითში პარაგრაფი p ელემენტისგან div მემკვიდრეობით იღებს შრიფტის ზომას 10 პიქსელს. შესაბამისად, შრიფტის საბაზისო ზომა მისთვის იქნება არა 16, არამედ 10 პიქსელი, საიდანაც დაითვლება p სელექტორში მითითებული 150 % და მივიღებთ საბოლოო შრიფტის ზომას 15 პიქსელს.
                  
                  ზომის ერთეული em
                  
                  ზომის ერთეული em პროცენტის მსგავსია. 1em არის 100%, 0.5em - 50% და ა. შ.`
              },
              {
                  title:"ტექსტის ფორმატირება",
                  data:`თვისება text-transform ცვლის შრიფტის რეგისტრს. შეიძლება მიიღოს შემდეგი მნიშვნელობები:

                  capitalize: სიტყვის პირველი ასო გადაჰყავს მაღალ რეგისტრში
                  uppercase: მთლი სიტყვა გადაჰყავს მაღალ რეგისტრში
                  lowercase: მთელი სიტყვა გადაჰყავს დაბალ რეგისტრში 
                  none: სიმბოლოების რეგისტრი არ იცვლება
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>
                          
                          <style>
                              p.lowercase {text-transform: lowercase;}
                              p.uppercase {text-transform: uppercase;}
                              p.capitalize { text-transform: capitalize;}
                          </style>
                      </head>
                      <body>
                      <div>
                          <p class="capitalize">Text with capitalize</p>
                          <p class="lowercase">Text with lowercase</p>
                          <p class="uppercase">Text with uppercase</p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება text-decoration
                  
                  თვისება text-decoration უმატებს ტექსტს დამატებით ეფექტს. მან შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                  
                  underline: ტექსტის ხაზგასმა (გახაზვა ქვემოდან)
                  overline: ტექსტის გახაზვა ზემოდან
                  line-through: ტექსტის გადახაზვა
                  none: ტექსტზე არ გამოიყენება დეკორატიული ეფექტები
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              p.under {
                                  text-decoration: underline;
                              }
                              p.over {
                                  text-decoration: overline;
                              }
                              p.line {
                                  text-decoration: line-through;
                              }
                              p.mixed {
                                  text-decoration: underline line-through;
                              }
                              a.none {
                                  text-decoration: none;
                              }
                          </style>
                      </head>
                      <body>
                      <div>
                          <p class="under">ხაზგასმული ტექსტი</p>
                          <p class="over">ზემოდან გახაზული ტექსტი</p>
                          <p class="line">გადახაზული ტექსტი</p>
                          <p class="mixed">ხაზგასმული და გადახაზული ტექსტი</p>
                          <p>ეფექტის გარეშე <a href="index.php" class="none">ბმული<a></p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  საჭიროების შემთხვევაში შესაძლებელია მნიშვნელობების კომბინირება. ბოლოსწინა სტრიქონში ერთდროულად გამოყენებულია ხაზგასმა და გადახაზვა.
                  
                  დაშორება სიმბოლოებს შორის
                  
                  CSS-ის ორი თვისება შესაძლებლობას გვაძლევს დავარეგულიროთ ასოებსა და სიტყვებს შორის დაშორებები. ასოებს შორის ინტერვალის დასარეგულირებლად გამოიყენება თვისება letter-spacing, ხოლო სიტყვებს შორის ინტერვალისთვის - word-spacing. მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>შრიფტები</title>        
                          <style>
                              p.smallLetterSpace {
                                  letter-spacing: -1px;
                              }
                              p.bigLetterSpace {
                                  letter-spacing: 2px;
                              }
                              p.smallWordSpace{
                                  word-spacing: -1px;
                              }
                              p.bigWordSpace{
                                  word-spacing: 5px;
                              }
                          </style>
                      </head>
                      <body>
                      <div>
                          <h3>ჩვეულებრივი ტექსტი</h3>
                          <p>ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>letter-spacing: -1px;</h3>
                          <p class="smallLetterSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>letter-spacing: 1px;</h3>
                          <p class="bigLetterSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>word-spacing: -1px</h3>
                          <p class="smallWordSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <h3>word-spacing: 1px</h3>
                          <p class="bigWordSpace">ნახეს, უცხო მოყმე ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                      </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  text-shadow
                  
                  თვისება text-shadow -ის მეშვეობით შესაძლებელია ტექსტისთვის ჩრდილების მიცემა. მნიშვნელობა შედგება 4 პარამეტრისაგან: ჰორიზონტალური წანაცვლება, ვერტიკალური წანაცვლება, გაბნევის ხარისხი და ჩრდილის ფერი.მაგალითად:
                  
                  h1{
                      text-shadow: 5px 4px 3px #999;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ მაგალითში ჩრდილის წანაცვლება ხდება მარჯვნივ 5 პიქსელით, ქვევით 4 პიქსელით, გაბნევადობის ხარისხია 3 პიქსელი და ჩრდილის ფერი #999. თუ ჩრდილის წანაცვლება გვინდა მარცხნივ ან ზევით, სესაბამისი მნიშვნელობები უნდა იყოს უარყოფითი. მაგალითად:
                  
                  h1{
                      text-shadow: -5px -4px 3px #999;
                  }
                   `
              },
              {
                  title:"აბზაცების სტილიზაცია",
                  data:`CSS-ის თვისებების ცალკე ჯგუფი ემსახურება ტექსტის დიდი ფრაგმენტების სტილიზაციას. მათი მეშვეობით შესაძლებელია სტრიქონებს შორის დაშორების შეცვლა, ტექსტის გასწორება კიდეებზე და ა. შ.

                  line-height
                  
                  თვისების line-height დანიშნულებაა სტრიქონებს შორის დაშორების რეგულირება. მისი მნიშვნელობა გამოისახება პიქსელებით, პროცენტებით ან em ერთეულით. ძირითადად გამოიყენება პროცენტები და em. მაგალითად:
                  
                   
                  
                  p{
                      line-height: 150%;
                  }
                  თუ ეს თვისება არაა მინიჭებული, ამ შემთხვევაში გამოიყენება line-height:120%.
                  
                  HTML5-ის დოკუმენტი
                  
                  text-align
                  
                  თვისება text-align ემსახურება ტექსტის გასწორებას გვერდის კიდეების მიმართ. ის ღებულობს შემდეგ მნიშვნელობებს:
                  
                  left: ტექსტის გასწორება მარცხნივ
                  right: ტექსტის გასწორება მარჯვნივ
                  justify: გასწორება ორივე კიდის მიმართ სიტყვებს შორის დაშორებების ხარჯზე
                  center: გასწორება ცენტრში
                  მაგალითად:
                  
                  p{
                      text-align: left;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  text-indent
                  
                  თვისება text-indent არეგულირებს აბზაცის პირველი სტრიქონის დაშორებას კიდიდან. მნიშვნელობისთვის გამოიყენება სტანდარტული ზომის ერთეულები: px, em:
                  
                  p{
                      text-indent: 35px;
                  }
                   `
              },
              {
                  title:"სიების სტილიზაცია",
                  data:`list-style-type 

                  CSS-ში არის სპეციალური თვისებები სიების სტილიზაციისთვის. ერთ-ერთ ასეთ თვისებას წარმოადგენს list-style-type. მან შეიძლება მიიროს შემდეგი მნიშვნელობები დანომრილი სიებისთვის:
                 decimal: ათწილადები, ათვლა იწყება 1-დან
                 decimal-leading-zero: 0-ით დაწყებული ათწილადები: 01, 02, 03, ...,98,99
                 lower-roman: დაბალი რეგისტრის რომაული რიცხვები: i, ii, iii, iv, v
                 upper-roman: მაღალი რეგისტრის რომაული რიცხვები: I, II, III, IV, V…
                 lower-alpha: დაბალი რეგისტრის ლათინური ასოები: a, b, c..., z
                 upper-alpha: მაღალი რეგისტრის ლათინური ასოები: A, B, C, … Z
                 georgian: ქართული ანბანის ასოები: ა,ბ,გ,...ჰ
                 დაუნომრავი სიებისთვის:
                 
                 disc: შავი წრე
                 circle: წარიელი წრეწირი
                 square: შავი კვადრატი
                 როგორც დანომრილ, ასევე უნომრო სიებში მარკერის გამოსართავად გამოიყენება list-style-type:none.
                 
                 მაგალითად:
                 
                 ul{
                     list-style-type: square;
                 }
                  
                 ol{
                     list-style-type: georgian;
                 }
                  
                 
                 HTML5-ის დოკუმენტი
                 
                 თვისება list-style-type შეიძლება გამოვიყენოთ როგორც მთლიანად სიის, ასევე სიის ცალკეული ელემენტის მიმართ:
                 
                 <!DOCTYPE html>
                 <html>
                 <head>
                     <meta charset="utf-8">
                     <title>სიების სტილიზაცია</title>
                     <style>            
                             .decimal{
                                 list-style-type: decimal;
                             }
                             ol{
                                 list-style-type: upper-roman;
                             }
                         </style>
                     </head>
                     <body>
                         <ol>
                             <li>ელემენტი 1</li>
                             <li class="decimal">ელემენტი 2</li>
                             <li>ელემენტი 3</li>
                             <li>ელემენტი 4</li>
                         </ol>
                     </body>
                 </html>
                  
                 
                 HTML5-ის დოკუმენტი
                 
                 list-style-position
                 
                 list-style-position თვისების მეშვეობით შეგვიძლია ვცვალოთ სიის მარკერის პოზიცია. ღებულობს ორ მნიშვნელობას:
                 
                 outside: მარკერი გამოწეულია
                 inside მარკერი შეწეულია
                 HTML5-ის დოკუმენტი
                 
                 list-style-image
                 
                 list-style-image თვისება საშუალებას გვაძლევს სიის მარკერად გამოვიყენოთ სურათი:
                 
                 <ul style="list-style-image:url(phone.jpeg);">
                         <li>iPhone 6S</li>
                         <li>Galaxy S7</li>
                         <li>Nexus 5X</li>
                         <li>Lumia 950</li>
                     </ul>
                 მნიშვნელობაში გადაეცემა იმ სურათის მისამართი, რომელიც უნდა გამოვიყენოთ მარკერად.`
              },
              {
                  title:"ცხრილების სტილიზაცია",
                  data:`CSS-ში განსაზღვრულია თვისებები, რომელთა მეშვეობით შესაძლებელია ცხრილების სტილიზაცია:

                  border-collapse: მიმდებარე უჯრებს შორის ჩარჩოს სტილიზაცია
                  border-spacing: მიმდებარე უჯრებს შორის არის სტილიზაცია
                  caption-side: განსაზღვრავს სათაურის მდებარეობას
                  empty-cells: სარიელი უჯრების დახატვის რეჟიმი
                  table-layout: განსაზღვრავს ცხრილის ზომებს
                  ჩარჩოები
                  
                  ცხრილის ჩარჩოებისთვის ადრე გამოიყენებოდა ატრიბუტი border, მაგალითად:
                  
                  <table border="2px" >
                  მაგრამ დღეისათვის ტენდენციაა ყველანაირი სტილიზაცია მოხდეს CSS-ის სტილების მეშვეობით. ამისთვის CSS-ში არის თვისება border:
                  
                  table {
                      border: 1px solid #ccc;  /* მთელი ცხრილის ჩარჩო */
                  }
                  tr {
                      border: 1px solid #ccc;  /* ჩარჩო სტრიქონებს შორის */
                  }
                  td, th {
                      border: 1px solid #ccc;  /* ჩარჩო სვეტებს შორის */
                  }
                  მიმდებარე უჯრებს შორის ჩარჩოების სტილიზაციისთვის იყენებენ თვისებას border-collapse, რომელსაც აქვს შემდეგი მნიშვნელობები:
                  
                  collapse: მიმდებარე უჯრებს საერთო ჩარჩო აქვთ
                  separate: მიმდებარე უჯრებს თავ-თავისი ჩარჩო აქვთ, რომელთა შორის სიცარიელეა
                  თუ მიმდებარე უჯრებს ცალ-ცალკე ჩარჩო აქვთ, border-spacing თვისების მეშვეობით შეიძლება ვცვალოთ ჩარჩოებს შორის დაშორება:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }        
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .collapsed{
                              border-collapse: collapse;
                          }
                          .separated{
                              border-collapse: separate;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Collapse</h3>
                          <table class="collapsed">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td>Apple</td><td>630</td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Separate</h3>
                          <table class="separated">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                              <tr><td>HTC 10</td><td>HTC</td><td>545</td></tr>
                              <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ცარიელი უჯრები
                  
                  თვისება empty-cells განსაზღვრავს, გამოცნდეს ცარიელი უჯრები თუ არა. მისი მნიშვნელობებია:
                  
                  show: ცარიელი უჯრის გამოჩენა (მნიშვნელობა მიუთითებლობისას)
                  hide:  ცარიელი უჯრის დამალვა
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }
                          
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .hidden-empty-cells{
                              empty-cells: hide;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Collapse</h3>
                          <table>
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td></td><td></td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Separate</h3>
                          <table class="hidden-empty-cells">
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                              <tr><td>HTC 10</td><td></td><td></td></tr>
                              <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სათაურის პოზიცია
                  
                  caption-side თვისების მეშვეობით შესაძლებელია ცხრილის სათაურის პოზიციის შეცვლა. ღებულობს შემდეგ მნიშვნელობებს:
                  
                  top: ცხრილის ზემოთ (მნიშვნელობა მიუთითებლობისას)
                  
                  bottom: ცხრილის ქვემოთ
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ცხრილების სტილიზაცია</title>
                          <style>
                          table {
                              border: 1px solid #ccc;
                              border-spacing: 3px;
                          }        
                          caption {
                          
                              font-weight: bold;
                          }        
                          td, th{
                              border: solid 1px #ccc;
                          }
                          .captionBottom{
                              caption-side: bottom;
                          }
                          </style>
                      </head>
                      <body>
                          <h3>Top</h3>
                          <table>
                              <caption>ფლაგმანები</caption>
                              <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                              <tr><td>Lumia 950</td><td>Microsoft</td><td>400</td></tr>
                              <tr><td>iPhone 6S</td><td>Apple</td><td>630</td></tr>
                              <tr><td>Nexus 6P</td><td>Huawei</td><td>450</td></tr>
                          </table>
                          <h3>Bottom</h3>
                          <table class="captionBottom">
                                  <caption>სიახლეები</caption>
                                  <tr><th>მოდელი</th><th>მწარმოებელი</th><th>ფასი</th></tr>
                                  <tr><td>G 5</td><td>LG</td><td>420</td></tr>
                                  <tr><td>HTC 10</td><td>HTC</td><td>545</td></tr>
                                  <tr><td>Nexus 5X</td><td>Google/LG</td><td>350</td></tr>   
                          </table>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ცხრილის ზომები
                  
                  table-layout თვისების მეშვეობით შესაძლებელია ცხრილის ზომების მართვა. მიუთითებლად მისი მნიშვნელობა არის auto, რომლის დროსაც სვეტის სიგანე ამ სვეტის ყველაზე გრზელი უჯრის სიგანის ტოლია. ცალკეული სვეტების სიგანეთა ჯამი შეადგენს ცხრილის სიგანეს. თუ table-layout თვისებას მივანიჭებთ მნიშვნელობას fixed, ცხრილს შეიძლება მივანიჭოთ ფიქსირებული სიგანე:
                  
                  table {
                      border: 1px solid #ccc;
                      border-spacing: 3px;
                      table-layout: fixed;
                      width:350px;
                  }
                  უჯრების ტექსტის ვერტიკალური გასწორება
                  
                  როგორც წესი, უჯრის შიგთავსი ვერტიკალურად შუაში თავსდება, თუმცა vertical-align თვისების მეშვეობით შეგვიძლია პოზიციის ცვლილება. მისი მნიშვნელობებია:
                  
                  top: გასწორება ზემოთ
                  baseline: ტექსტის პირველი სტრიქონის გასწორება ზემოთ
                  middle: გასწორება შუაში
                  bottom: გასწორება ქვემოთ
                  თვისება vertical-align გამოიყენება მხოლოდ <th> და <td> ელემენტებისთვის:
                  
                  td, th{
                      border: solid 1px #ccc;
                      vertical-align: bottom;
                      height: 30px;
                  }`
              },{
                title:"ბლოკისებური მოდელი",
                data:`ბრაუზერისთვის გვერდის ელემენტები წარმოადგენენ კონტეინერებს ანუ ბლოკებს. ასეთ ბლოკებს შეიძლება ჰქონდეთ სხვადასხვა შიგთავსი - ტექსტი, სურათი, სია, ცხრილი და სხვა. ბლოკის შიდა ელემენტები თვითონაც გამოდიან ბლოკების როლში. 

                სქემატურად ბლოკისებური მოდელი შეიძლება შემდეგნაირად გამოვსახოთ:
                
                HTML5-ის დოკუმენტი
                
                ყველა ელემენტი მოთავსებულია გარკვეულ კონტეინერში. ეს შეიძლება იყოს body, div და ა. შ. სხვა ელემენტებისაგან ის გამოყოფილია ერთგვარი სივრცით - გარე დაშორებით, რომელიც CSS-ში აღიწერება თვისებით margin. ანუ margin თვისება განსაზღვრავს ელემენტის დაშორებას სხვა ელემენტებისგან ან კონტეინერის კიდედან. 
                
                ამის შემდეგ მოდის თვითონ ელემენტი, რომელიც იწყება ჩარჩოთი. ჩარჩოს CSS-ში განსაზღვრავს თვისება border.
                
                ჩარჩოს შემდეგ მოდის ელემენტის შიდა დაშორება, რომელიც CSS-ში განისაზღვრება თვისებით padding. შიდა დაშორება განსაზღვრავს მანძილს ელემენტის საზღვრიდან მის შიგთავსამდე. 
                
                ამის მერე მოდის შიდა ელემენტები, რომელთაც ასევე აქვთ ბლოკისებური მოდელი. 
                
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკური მოდელი</title>
                        <style>
                            div{
                                margin: 15px; /* გარე დაშორება */
                                padding: 11px; /* შიდა დაშორება */
                                border: 3px solid red; /* ჩარჩო - 3 პიქსელი სისქის უწყვეტი წითელი ხაზი */
                            }
                        </style>
                    </head>
                    <body>
                        <div>
                            <p>პირველი ბლოკი</p>
                        </div>
                        <div>
                            <p>მეორე ბლოკი</p>
                        </div>
                    </body>
                </html>
                ბრაუზერში გაშვების შემდეგ ჩვენ დავინახავთ კონკრეტული ელემენტების ბლოკისებურ მოდელს. ამისათვის მაუსის მარჯვენა კლავიშით გამოსულ კონტექსტურ მენიუში უნდა ავირჩიოთ შესაბამისი ბრძანება. სხვადასხვა ბრაუზერში ამ ბრძანებას სხვადასხვა სახელი აქვს. Google Chrome-ში უნდა ავირჩიოთ ბრძანება Inspect:
                
                 HTML5-ის დოკუმენტი
                
                Mozilla Firefox-ში და  Microsoft Edge-ში შესაბამის ბრძანებას ჰქვია Inspect element.
                
                ამ ბრძანების შესრულების მერე გაჩნდება პანელი, რომელშიც მოცემულია ელემენტის კოდი, მისი სტილი და ბლოკისებური მოდელი:
                
                HTML5-ის დოკუმენტი
                
                თუ არ მივუთითებთ margin, padding და border თვისებების მნიშვნელობებს, ბრაუზერი მათ მიანიჭებს სტანდარტულ მნიშვნელობებს.`
            },{
                title:"გარე დაშორებები (margin)",
                data:`margin თვისება განსაზღვრავს ელემენტის დაშორებას სხვა ელემენტებისგან ან კონტეინერის საზღვრებიდან. CSS-ში არსებობს სპეციალური თვისებები თითოეული მხარისათვის:

                margin-top: დაშორება ზემოდან
                margin-bottom: დაშორება ქვემოდან
                margin-left: დაშორება მარცხნიდან
                margin-right: დაშორება მარჯვნიდან
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div{
                                margin-top: 30px; /* დაშორება ზემოდან */
                                margin-left: 25px; /* დაშორება მარცხნიდან */
                                margin-right: 20px; /* დაშორება მარჯვნიდან */
                                margin-bottom: 15px; /* დაშორება ქვემოდან */                
                                border: 3px solid red; /* საზღვარი */
                            }
                        </style>
                    </head>
                    <body>
                        <div>
                            <p>პირველი ბლოკი</p>
                        </div>
                        <div>
                            <p>მეორე ბლოკი</p>
                        </div>
                        <div>
                            <p>მესამე ბლოკი</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                შეიძლება 4 თვისების ნაცვლად გამოვიყენოთ ერთი:
                
                margin: 30px 20px 15px 25px;
                თვისება ენიჭება შემდეგი ფორმატით:
                
                margin: დაშორება_ზემოდან დაშორება_მარჯვნიდან დაშორება_ქვემოდან დაშორება_მარცხნიდან;
                თუ ყველა დაშორება ერთნაირია, შეგვიძლია მივუთითოთ მხოლოდ ერთხელ:
                
                margin: 25px;
                ამ შემთხვევაში დაშორება ყველა მხარეს იქნება 25 პიქსელი.
                
                დაშორების მნიშვნელობა შეიძლება მივუთითოთ პიქსელებში (px), em ერთეულებში, პროცენტული მნიშვნელობებში, ასევე შეიძლება მივუთიტოთ მნიშვნელობა auto - ამ შემთხვევაში დაშორება იქნება სტანდარტული.
                
                მაგალითად:
                
                margin: 2em;
                მნიშვნელობა 2em ნიშნავს, რომ დაშორება ელემენტის შრიფტის ზომაზე 2-ჯერ მეტია.
                
                პროცენტების გამოყენებისას ბრაუზერი დაშორებას ითვლის იმ კონტეინერის სიგანიდან გამომდინარე, რომელშიც მოქცეულია ელემენტი.
                
                როცა რამდენიმე ელემენტი არის მიმდებარედ, ბრაუზერი დაშორებას ანიჭებს ამ ორი ელემენტის შესაბამისი დაშორებებიდან უდიდესის მნიშვნელობით. ზემოთ მოყვანილ მაგალითში :
                
                 
                
                div{
                    margin-top: 30px; /* დაშორება ზემოდან */
                    margin-left: 25px; /* დაშორება მარცხნიდან */
                    margin-right: 20px; /* დაშორება მარჯვნიდან */
                    margin-bottom: 15px; /* დაშორება ქვემოდან */
                }
                დაშორება პირველ და მეორე ელემენტს შორის იქნება 30 პიქსელი, რადგან მეორე ელემენტის დაშორება ზემოდან არის 30 პიქსელი და ის მეტია პირველი ელემენტის დაშორებაზე ქვემოდან (15 პიქსელი).`
            },{
                title:"შიდა დაშორებები (padding)",
                data:`თვისება padding განსაზღვრავს დაშორებებს ელემენტის საქღვრებიდან სიგთავსამდე. ისევე როგორც margin-ისთვის, CSS-ში შიდა დაშორებებისთვისაც არის თვისებები, რომლებიც განსაზღვრავს შიდა დაშორებას თითოეული მხარისთვის:

                padding-top: დაშორება ზემოდან
                padding-bottom: დაშორება ქვემოდან
                padding-left: დაშორება მარცხნიდან
                padding-right: დაშორება მარჯვნიდან
                მაგალითად:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div.outer{                
                                margin: 25px;
                                
                                padding-top:30px;
                                padding-right: 25px;
                                padding-bottom: 35px;
                                padding-left: 28px;
                                
                                border: 2px solid red;
                            }
                            div.inner{
                                
                                height: 50px;
                                background-color:blue;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            <div class="inner"></div>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ისევე როგორც mangin-ის შემთხვევაში, padding-ის მნიშვნელობა შეიძლება გამოისახოს პროცენტებით (ელემენტის ზომებიდან გამომდინარე).
                
                შიდა დაშორებების ჩაწერაც შეიძლება შემოკლებულად:
                
                padding: 30px 25px 35px 28px;
                თანმიმდევრობა აქაც იგივეა: დაშორება ზემოდან, დაშორება მარჯვნიდან, დაშორება ქვემოდან, დაშორება მარცხნიდან.
                
                თუ ოთხივე მნიშვნელობა ერთნაირია, შეიძლება მივუთიტოთ მხოლოდ ერთხელ:
                
                padding: 25px;`
            },{
                title:"ჩარჩოები",
                data:`ჩარჩო გამოყოფს ელემენტის შიგთავსს გარემოცვისაგან, ამავე დროს ჩარჩო წარმოადგენს ელემენტის შემადგენელ ნაწილს. 

                ჩარჩოს კონფიგურაციისთვის გამოიყენება რამდენიმე თვისება:
                
                border-width: ჩარჩოს სისქე
                border-style: ჩარჩოს სტილი
                border-color: ჩარჩოს ფერი
                ჩარჩოს სისქე border-width შეიძლება გამოისახოს px და em ერთეულებით:
                
                border-width: 2px;
                ასევე ჩარჩოს სისზე შეიძლება გამოისახოს კონსტანტებით: thin (თხელი - 1px), medium (საშუალო - 3 px), thick (სქელი - 5px).
                
                თვისება border-color მნიშვნელობად ღებულობს CSS-ის ფერებს:
                
                border-color: red;
                თვისება border-style განსაზღვრავს ჩარჩოს სტილს. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                none: ჩარჩოს გარეშე
                solid: ჩარჩო ჩვეულებრივი ხაზის სახით
                dashed: წყვეტილი ხაზი
                dotted: წერტილოვანი ხაზი
                double: წყვილი ხაზი
                groove: ხაზი სამგანზომილებიანი ეფექტით
                inset: ჩაზნექილი ხაზი
                outset: ამოზნექილი ხაზი
                ridge: ასევე სამგანზომილებიანი ეფექტით
                HTML5-ის დოკუმენტი
                
                საჭიროების შემთხვევაში ჩარჩოს სისქე, სტილი და ფერი შეიძლება განვსაზღვროთ თითოეული მხარისთვის ცალ-ცალკე: 
                
                /* ზედა ჩარჩო */
                border-top-width
                border-top-style
                border-top-color
                 
                /* ქვედა ჩარჩო */
                border-bottom-width
                border-bottom-style
                border-bottom-color
                 
                /* მარცხენა ჩარჩო */
                border-left-width
                border-left-style
                border-left-color
                 
                /* მარჯვენა ჩარჩო */
                border-right-width
                border-right-style
                border-right-color
                თვისება border
                
                ცალ-ცალკე თვისებების ნაცვლად შეიძლება გამოვიყენოთ ერთი თვისება border:
                
                border: სისქე სტილი ფერი;
                მაგალითად:
                
                border: 2px solid red;
                ცალ-ცალკე მხარეებისთვის გამოიყენება თვისებები:
                
                border-top
                border-bottom
                border-left
                border-right
                მაგალითად:
                
                border-top: 2px solid red;
                ჩარჩოს რადიუსი
                
                თვისება border-radius საშუალებას იძლევა მომრგვალდეს ჩარჩოს კუთხეები. იგი ღებულობს მნიშვნელობას px ან em ერთეულებში. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ბლოკისებური მოდელი</title>
                        <style>
                            div{
                                width: 100px;
                                height:100px;
                                border: 2px solid red;
                                border-radius: 30px;
                            }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                ახლა ჩარჩოს ყველა კუთხე იქნება მომრგვალებული 30 პიქსელიანი რადიუსით:
                
                
                რადიუსი შეიძლება განისაზღვროს თითოეული კუთხისთვის ცალ-ცალკე. ამისთვის border-radius მიიღებს 4 მნიშვნელობას (ზედა მარცხენა, ზედა მარჯვენა, ქვედა მარჯვენა, ქვედა მარცხენა):
                
                border-radius: 15px 30px 5px 40px;
                 
                
                
                საერთო მნიშვნელობის ნაცვლად შეიძლება მივანიჭოთ მნიშვნელობები ცალ-ცალკე:
                
                border-top-left-radius: 15px;
                border-top-right-radius: 30px;
                border-bottom-right-radius: 5px;
                border-bottom-left-radius: 40px;
                შესაძლებელია კუთხე მომრგვალდეს ოვალურად, რისთვისაც გამოიყენება ორი რადიუსი:
                
                border-radius: 40px/20px;
                ამ დროს იგულისხმება, რომ X ღერძის მიმართ რადიუსი იქნება 40 პიქსელი, ხოლო Y ღერძის მიმართ - 20 პიქსელი:`
            },{
                title:"ელემენტის ზომები",
                data:`ელემენტებს ზომები ენიჭება თვისებებით width (სიგანე) და height (სიმაღლე).

                მიუთითებლობისას ამ თვისებების მნიშვნელობაა auto, ანუ ბრაუზერი ელემენტს ანიჭებს ამ ელემენტისთვის განკუთვნილ სტანდარტულ მნიშვნელობას. სიგანე და სიმაღლე გამოისახება ზომების სტანდარტული ერთეულებით: px და em, ასევე პროცენტებით:
                
                width: 150px;
                width: 75%;
                height: 15em;
                px - პიქსელი განსაზღვრავს ზუსტ სიგანეს და სიმაღლეს. em დამოკიდებულია ელემენტის შრიფტის ზომაზე - თუ შრიფტის ზომა 16 პიქსელია და ელემენტის ზომას მივუთითებთ 15em, ეს ნიშნავს რომ ზომა იქნება 15*16=240 px. თუ ელემენტს შრიფტის ზომა არა აქვს განსაზღვრული, აიღება მემკვიდრეობით მიღებული ზომა ან ზომა მიუთითებლობისას.
                
                პროცენტული მნიშვნელობა ნიშნავს, რომ ზომა გამოითვლება კონტეინერის ზომიდან პროცენტულად. მაგალითად, თუ body ელემენტის სიგანე 1000 პიქსელია, ხოლო მასში div ელემენტს სიგანე აქვს 75 %, ეს ნიშნავს, რომ ელემენტის სიგანე იქნება 1000*75/100=750 პიქსელი. თუ ბრაუზერის ფანჯრის სიგანეს შევცვლით, პროპორციულად შიცვლება div ელემენტის ზომა. ზუსტად ანალოგიურად ითვლება სიმაღლე პროცენტული მნიშვნელობისას - ოღონდ ამ შემთხვევაში კონტეინერის სიმაღლე მრავლდება მითითებულ პროცენტულ მნიშვნელობაზე.
                
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div.outer{
                            width: 75%;
                            height: 200px;
                            margin: 10px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                        }
                        div.inner{
                        
                            width: 80%;
                            height: 80%;
                            margin: auto;
                            border: 1px solid red;
                            background-color: blue;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            <div class="inner"></div>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ამავე დროს, ელემენტის ფაქტიური ზომები შეიძლება განსხვავდებოდეს width და height თვისებების მნიშვნელობებისაგან. მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div.outer{
                            width: 200px;
                            height: 100px;
                            margin: 10px;
                            padding: 10px;
                            border: 5px solid #ccc;
                            background-color: #eee;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer">
                            ფაქტიური ზომები CSS3ში
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                როგორც სკრინშოტიდან ჩანს, თვისება width განსაზღვრავს ელემენტის შიგთავსს, ხოლო მთლიანად ბლოკისთვის გამოყოფილი ადგილი შედგება შიგთავსს (width) + შიდა დაშორება (padding) + ჩარჩოს სისქე (border-width) + გარე დაშორება (margin). შესაბამისად, თვითონ ელემენტის სიგანე ტოლი იქნება არა 200, არამედ 230 პიქსელისა ჩარჩოების ჩათვლით, ხოლო ელემენტისთვის გამოყოფილი სიგანე გარე დაშორების ჩათვლით იქნება 250 პიქსელი. ანალოგიურად გამოითვლება სიმაღლეც.
                
                დამატებითი თვისებების მეშვეობით შეიძლება შეიზღუდოს ელემენტის მინიმალური და მაქსიმალური ზომები:
                
                min-width: მინიმალური სიგანე
                max-width: მაქსიმალური სიგანე
                min-height: მინიმალური სიმაღლე
                max-height: მაქსიმალური სიმაღლე
                min-width: 200px;
                width:50%;
                max-width: 300px;
                ამ შემთხვევაში ელემენტის სიგანე მისი შემცველი კონტეინერის 50 %-ია, მაგრამ არანაკლებ 200 პიქსელისა და არაუმეტეს300 პიქსელისა.
                
                თვისება box-sizing
                
                box-sizing თვისების მეშვეობით შეიძლება შევცვალოთ ელემენტის ზომების დათვლის წესი. მან შეიძლება მიიღოს შემდეგი მნიშვნელობები:
                
                content-box: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც ელემენტის რეალური ზომა შედგება width და height, მნიშვნელობებს დამატებული შიდა დაშორება და ჩარჩოს სისქე.
                padding-box: ამ დროს width და height მნიშვნელობები უკვე შეიცავენ შიდა დაშორებას და რეალური ზომის დასათვლელად ემატება მხოლოდ ჩარჩოს სისქე.
                border-box: ამ დროს width და height მნიშვნელობები უკვე შეიცავენ როგორც შიდა დაშორებებს, ასევე ჩარჩოს სისქესაც. შესაბამისად, width და height მნიშვნელობები შეადგენენ ელემენტის რეალურ ზომებს.
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ზომები</title>
                        <style>
                        div{
                            width: 200px;
                            height: 100px;
                            margin: 10px;
                            padding: 10px;
                            border: 5px solid #ccc;
                            background-color: #eee;
                        }
                        div.outer1{
                            box-sizing: content-box;
                        }
                        div.outer2{
                            box-sizing: border-box;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="outer1">
                            ელემენტის რეალური ზომები CSS3-ში
                        </div>
                        <div class="outer2">
                            ელემენტის რეალური ზომები CSS3-ში
                        </div>
                    </body>
                </html>
                პირველ შემთხვევაში ზომებს ემატება შიდა დაშორება და ჩარჩოს სისქე ამიტომ მისი ზომა უფრო დიდია:`
            },{
                title:"ელემენტის ფონი",
                data:`ელემენტის ფონი CSS-ში აღიწერება თვისებით background. ის ფაქტობრივად, ის წარმოადგენს შემდეგი თვისებების შემოკლებულ ვარიანტს:

                background-color: ფონის ფერი
                background-color: #ff0507;
                background-image: ელემენტის ფონად გამოიყენებს სურათს
                background-image: url(dubi.png);
                იგი ღებულობს ერთ მნიშვნელობას - url, რომელსაც მოსდევს ფრჩხილებში ჩასმული ფაილის მისამართი. მოცემულ შემთხვევაში იგულისხმება, რომ ვებგვერდთან ერთად იმავე საქაღალდეში არის ფაილი dubi.png. შეიძლება მიეთითოს ფაილის როგორც სრული მისამართი , ასევე ფარდობითი მისამართი:
                
                background-image: url(http://mysite.ge/files/dubi.png);
                background-image: url(../files/dubi.png);
                background-repeat: ფონური გამოსახულების განმეორების რეჟიმი
                background-size: ფონური გამოსახულების ზომა
                background-position: ფონური გამოსახულების მდებარეობა
                background-attachment: აწესრიგებს ფონური გამოსახულების ელემენტთან მიბმის რეჟიმს
                background-clip: განსაზღვრავს არეს, რომელიც ამოიჭრება სურათიდან და გამოიყენება ფონის სახით
                background-origin: განსაზღვრავს ფონური გამოსახულების საწყის პოზიციას
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 200px;
                            margin: 10px;
                     color: white;
                        }        
                        .colored{
                            background-color: #ff0507;
                        }        
                        .imaged{
                            background-image: url(kanioni.png);
                        }
                        </style>
                    </head>
                    <body>
                        <div class="colored">">პირველი ბლოკი</div>
                        <div class="imaged">">მეორე ბლოკი</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გამოსახულების გამეორება
                
                იმ შემთხვევაში, თუ ელემენტის ზომები მეტია ფონად გამოყენებული სურათის ზომებზე, ხდება სურათის გამეორება ისე, რომ ელემენტი მთლიანად შეივსოს ფონით. background-repeat თვისების მეშვეობით შესაძლებელია სურათის გამეორების მართვა. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                repeat-x: გამეორება მხოლოდ ჰორიზონტალურად
                repeat-y: გამეორება მხოლოდ ვერტიკალურად
                repeat: გამეორება ორივე მიმართულებით (მნიშვნელობა მიუთითებლობისას)
                space: სურათი მეორდება ელემენტის სრულად შესავსებად, მაგრამ არ წარმოქმნის არასრულ ფრაგმენტებს 
                round: ხდება სურათის მასშტაბირება ელემენტის სრულად შესავსებად
                no-repeat: სურათი არ მეორდება
                მაგალითად:
                
                background-image: url(nature.jpg);
                background-repeat: round;
                გამოსახულების ზომა
                
                background-size თვისების გამოყენებით შესაძლებელია შევცვალოთ ფონად გამოყენებული გამოსახულების ზომა. ზომები (თანმიმდევრობით სიგანე, სიმაღლე) შეიძლება მივუთითოთ სტანდარტული ზომის ერთეულებით (px, em), პროცენტებით ან ერთ-ერთი წინასწარ განსაზღვრული მუდმივათი:
                
                contain: ხდება სურათის მასშტაბირება უდიდესი მხარის მიხედვით პროპორციების შენარჩუნებით
                cover:ხდება სურათის მასშტაბირება უმცირესი მხარის მიხედვით პროპორციების შენარჩუნებით
                auto: მნიშვნელობა მიუთითებლობისას. სურათის ზომები არ იცვლება
                თუ გვინდა სურათის მასშტაბირება ისე, რომ მან სრულად შეავსოს ელემენტი გამეორებების გარეშე, სიგანეში და სიმაღლეში უნდა მივუთითოთ 100 %:
                
                background-size:100% 100%;
                ზომების მითითებისას ჯერ ეთითება სიგანე, მერე სიმაღლე:
                
                background-size:150px 100px;
                შეიძლება ერთი ზომა მივუთითოთ ზუსტად, მეორეში კი ჩავწეროთ auto და მეორე ზომას ბრაუზერი პროპორციულად გადათვლის:
                
                background-size:150px auto;
                 
                
                სურათის მდებარეობა
                
                background-position თვისება განსაზღვრავს ფონად გამოყენებული სურათის პოზიციას ელემენტის მიმართ. ის ღებულობს მნიშვნელობას ელემენტის მარცხენა ზედა კიდიდან ჰორიზონტალური და ვერტიკალური დაშორების სახით. მაგალითად:
                
                background-position: 30px 15px;
                ნიშნავს, რომ ფონის გამოსახულება მარცხენა კიდიდან დაშორებულია 30 პიქსელით, ხოლო ზემოთა კიდიდან - 15 პიქსელით.
                
                გარდა ამისა, აღნიშნულმა თვისებამ შესაძლოა მიიროს შემდეგი მნიშვნელობები:
                
                top: სურათი სწორდება ელემენტის ზედა კიდის მიმართ
                left: სურათი სწორდება ელემენტის მარცხენა კიდის მიმართ
                right:სურათი სწორდება ელემენტის მარჯვენა კიდის მიმართ
                bottom: სურათი სწორდება ელემენტის ქვედა კიდის მიმართ
                center: სურათი სწორდება ელემენტის ცენტრში
                მაგალითად:
                
                background-position: top right;
                აქ ფონის სურათი სწორდება ელემენტის ზედა და მარჯვენა კიდეებთან.
                
                background-attachment
                
                background-attachment თვისება განსაზღვრავს, თუ როგორ იქნება ფონის გამოსახულება მიმაგრებული ელემენტზე. ის ღებულობა შემდეგ მნიშვნელობებს:
                
                fixed: ფონი დაფიქსირებულია ელემენტის მიმართ და არ იცვლება ელემენტის შიგთავსის გადახვევისას (scroll)
                local: გადახვევისას (scroll) ელემენტის ფონი იცვლება (მიყვება გადახვევას)
                scroll: ფონი დაფიქსირებულია ელემენტის მიმართ და არ იცვლება ელემენტის შიგთავსის გადახვევისას (scroll). fixed-ისგან განსხვავებით, ამ შემთხვევაში ელემენტებს შესაძლებლობა აქვთ გამოიყენონ სხვადასხვა ფონი, fixed-ის შემთხვევაში ყველა ელემენტს საერთო ფონი აქვს.
                მაგალითად:
                
                div{
                    width: 300px;
                    height: 250px;    
                            
                    overflow:scroll;    /* გადახვევის დამატება  */
                    border: 1px solid #ccc;
                    
                    background-image: url(nature.png);
                    background-size: 512px 384px;
                    background-attachment: scroll;
                    background-repeat: no-repeat;
                }
                background-origin
                
                თვისება background-origin განსაზღვრავს პოზიციას, საიდანაც დაიწყება ელემენტის ფონის გამოსახულება. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                border-box: ფონი იწყება ელემენტის ჩარჩოდან
                padding-box: ფონი იწყება შიდა დაშორებიდან
                content-box: ფონი იწყება ელემენტის შიგთავსიდან
                გამოვიყენოთ სამივე მნიშვნელობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 155px;
                            margin: 10px;
                            display: inline-block;  /*მოვათავსოთ ბლოკები გვერდიგვერდ */
                            
                            padding:15px;
                            border: 15px solid rgba(0,0,165,0.2);
                            
                            background-image: url(tiger.jpg);
                            background-size: cover;
                            background-repeat: no-repeat;
                        }
                        .borderBox {background-origin: border-box;}
                        .paddingBox {background-origin: padding-box;}
                        .contentBox {background-origin: content-box;}
                        </style>
                    </head>
                    <body>
                        <div class="borderBox"></div>
                        <div class="paddingBox"></div>
                        <div  class="contentBox"></div>
                    </body>
                </html>
                HTML5-ის დოკუმენტი
                
                background-clip
                
                background-clip თვისება განსაზღვრავს, სურატის რა ნაწილი გამოიყენება ფონად. ის ღებულობს იმავე მნიშვნელობებს, რასაც background-origin:
                
                border-box: სურათი ჩამოიჭრება ელემენტის ჩარჩოებთან
                padding-box: სურათი ჩამოიჭრება ელემენტის შიდა დაშორებასთან, ჩარჩოს ქვემოთ მოქცეული ნაწილი ჩამოიჭრება
                content-box: სურათი ჩამოიჭრება შიგთავსთან, შიდა დაშორებების ქვეშ მოქცეული ნაწილი ჩამოეჭრება
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ელემენტის ფონი</title>
                        <style>
                        div{
                            width: 250px;
                            height: 155px;
                            margin: 10px;
                            display: inline-block;  /*მოვათავსოთ ბლოკები გვერდიგვერდ */
                            
                            padding:15px;
                            border: 15px solid rgba(0,0,165,0.2);
                            
                            background-image: url(tiger.jpg);
                            background-size: cover;
                            background-repeat: no-repeat;
                        }
                        .borderBox {background-clip: border-box;}
                        .paddingBox {background-clip: padding-box;}
                        .contentBox {background-clip: content-box;}
                        </style>
                    </head>
                    <body>
                        <div class="borderBox"></div>
                        <div class="paddingBox"></div>
                        <div  class="contentBox"></div>
                    </body>
                </html>`
            },{
                title:"ელემენტის ჩრდილი",
                data:`ელემენტისთვის ჩრდილის მისაცემად გამოიყენება თვისება box-shadow. ის იღებს ერთდროულად რამდენიმე მნიშვნელობას:

                box-shadow: hoffset voffset blur spread color inset
                hoffset: ჩრდილის ჰორიზონტალური წანაცვლება ელემენტის მიმართ. დადებითი მნიშვნელობისას ჩრდილი წანაცვლებულია მარჯვნივ, უარყოფითისას - მარცხნივ
                voffset: ჩრდილის ვერტიკალურიწანაცვლება ელემენტის მიმართ. დადებითი მნიშვნელობისას ჩრდილი წანაცვლებულია ქვევით, უარყოფითისას - ზევით
                blur: არააუცილიებელი მნიშვნელობა. განსაზღვრავს ჩრდილის კუთხეების გაბნეულობის რადიუსს. რაც უფრო მეტია, მით უფრო ნაკლებად გამოხატულია კუთხეები. მიუთითებლობისას მისი მნიშვნელობა 0-ის ტოლია
                spread: არააუცილებელი მნიშვნელობა. განსაზღვრავს ჩრდილის მიმართულებას. დადებითი მნიშვნელობისას ჩრდილი მიმართულია ელემენტიდან გარეთ, ხოლო უარყოფითისას - ელემენტისკენ
                color: არააუცილებელი მნიშვნელობა. განსაზღვრავს ჩრდილის ფერს
                inset: არააუცილებელი მნიშვნელობა, რომელიდ ჩრდილს მიმართავს ელემენტის შიგნით
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>ჩრდილი</title>
                        <style>
                        div{
                            width: 128px;
                            height: 96px;
                            margin: 20px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                            box-shadow: 10px 4px 10px 3px #888;
                        }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ერთ ელემენტს შეიძლება განესაზღვროს რამდენიმე ჩრდილი, ისინი გამოიყოფა მძიმეებით:
                
                box-shadow: 5px 3px 8px 3px #faa, 10px 4px 10px 3px #888 inset;`
            },{
                title:"ელემენტის კონტურები",
                data:`ელემენტის კონტურების გამოყენება ჩარჩოების მსგავსია, მაგრამ მათ სხვადასხვა დანიშნულება აქვთ. კონტურები გამოიყენება რაღაც ელემენტების სხვებისაგან გამოსაყოფად, ყურადღების მისაქცევად. კონტურები ელემენტის გარეთაა ჩარჩოს შემდეგ.

                კონტურებისთვის CSS3-ში გამოიყენება თვისება outline, რომელიც შემდეგი თვისებების შემოკლებაა:
                
                outline-color: კონტურის ფერი
                outline-offset: კონტურის წანაცვლება
                outline-style: კონტურის სტილი, იღებს იმავე მნიშვნელობებს, რასაც border-style:
                none: კონტურის გარეშე
                solid: კონტური ჩვეულებრივი ხაზით
                dashed: წყვეტილი ხაზი
                dotted: წერტილოვანი ხაზი
                double: ორმაგი ხაზი
                outline-width: კონტურის სისქე
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>კონტურები</title>
                        <style>
                        div{
                            width: 128px;
                            height: 96px;
                            margin: 20px;
                            border: 1px solid #ccc;
                            background-color: #eee;
                            outline-color: red;
                            outline-style: dashed;
                            outline-width: 2px;
                        }
                        </style>
                    </head>
                    <body>
                        <div></div>
                    </body>
                </html>
                 
                
                 
                
                
                outline თვისების გამოყენებით შეიძლება ეს ყველაფერი შემოკლებულად ჩავწეროთ:
                
                outline: red dashed 2px;`
            },{
                title:"თვისება float",
                data:`როგორც წესი, ვებგვერდის ყველა ბლოკი და ელემენტი ბრაუზერში გამოჩნდება იმ თანმიმდევრობით, რა თანმიმდევრობითაც არის ისინი html კოდში. მაგრამ თვისება float საშუალებას იძლევა მოვახდინოთ ობიექტების მიმაგრება კიდეებზე. იგი ღებულობს შემდეგ მნიშვნელობებს:

                left: ელემენტი გადაადგილდება მარცხნივ, ხოლო ყველა მისი მომდევნო ელემენტი გარსშემოედინება მას მრჯვნიდან
                right: ელემენტი გადაადგილდება მარჯვნივ
                none: აუქმებს გარსშემოდინებას და ობიექტი ბრუნდება ჩვეულებრივ პოზიციაში
                float თვისების გამოყენებისას გარდა img ელემენტისა სასურველია გამოვიყენოთ თვისება width.
                
                ვნახოთ float თვისების გამოყენება კონკრეტულ მაგალითზე. განვალაგოთ ერთი და იგივე ელემენტები float თვისების გამოყენების გარეშე და მისი გამოყენებით.
                
                float თვისების გამოყენების გარეშე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>        
                         .image {
                            margin:10px;
                            margin-top:0px;
                        }
                        .sidebar{
                            border: 2px solid #ccc;
                            background-color: #eee;
                            width: 150px;
                            padding: 10px;
                            margin-left:10px;
                            font-size: 20px;
                        }
                        p{
                            text-align: justify;
                        }
                        </style>
                    </head>
                    <body>
                        <div>
                            <div class="sidebar">ნოდარ დუმბაძე.<br />მე, ბებია, ილიკო და ილარიონი</div>
                            <img src="cover.jpg" class="image" alt="მე, ბებია, ილიკო და ილარიონი" />
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის
                                ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული,
                                რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდგილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება.
                                მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო
                                მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი,
                                ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                float თვისების გამოყენებით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>        
                         .image {
                            float:left;
                            margin:10px;
                            margin-top:0px;
                        }
                        .sidebar{
                            border: 2px solid #ccc;
                            background-color: #eee;
                            width: 200px;
                            padding: 10px;
                            margin-left:10px;
                            font-size: 20px;
                            float: right;
                        }
                        p{
                            text-align: justify;
                        }
                        </style>
                    </head>
                    <body>
                        <div>
                            <div class="sidebar">ნოდარ დუმბაძე.<br />მე, ბებია, ილიკო და ილარიონი</div>
                            <img src="cover.jpg" class="image" alt="მე, ბებია, ილიკო და ილარიონი" />
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის
                                ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული,
                                რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდგილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება.
                                მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო
                                მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი,
                                ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ელემენტებს, რომლებზეც გამოყენებულია თვისება float, მცურავ ელემენტებსაც (floating elements) ეძახიან.
                
                გარსშემოდინების აკრძალვა. თვისება clear
                
                ხანდახან საჭიროა გარსშემოდინების აკრძალვა. ეს საჭირო ხდება იმ შემთხვევაში, როცა გვინდა მომდევნო ბლოკის გადატანა ახალ სტრიქონზე და არა მცურავი ელემენტის გარსშემოდინება.მაგალითად, ფუტერი უნდა იყოს მკაცრად გვერდის ბოლოში მთელ სიგანეზე და არ უნდა შემოედინებოდეს სხვა ელემენტებს. ამისთვის გამოიყენება თვისება clear. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                left: ელემენტი გარსშემოედინება მცურავ ელემენტს მარჯვნიდან, ხოლო მარცხნიდან - არა
                right: ელემენტი გარსშემოედინება მცურავ ელემენტს მარცხნიდან, ხოლო მარჯვნიდან - არა
                both: ელემენტი გარსშემოედინება მცურავ ელემენტს, მაგრამ გადაადგილდება მის მიმართ ქვემოთ
                none: ელემენტი იქცევა სტანდარტულად, ანუ გარსშემოედინება მცურავ ელემენტებს
                მაგალითად, ვთქვათ გვაქვს ვებგვერდი ფუტერით:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>თვისება float</title>
                        <style>
                        .image {
                            float:left;
                            margin:10px;
                            margin-top:0px;
                        }
                        .footer{
                            border-top: 1px solid #ccc;
                        }
                        </style>
                    </head>
                    <body>    
                        <img src="tiger.jpg" class="image" alt="ვეფხვი" />
                        <div class="footer">Copyright © MyCorp. 2017</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თუ შევცვლით ფუტერის სტილს, იგი გადაინაცვლებს ქვევით:
                
                .footer{
                    border-top: 1px solid #ccc;
                    clear:both;
                }
                 `
            },{
                title:"ელემენტების გადახვევა",
                data:`ვებგვერდის შექმნის დროს ხშირად არის სიტუაცია, როცა ელემენტის შიგთავსი უფრო დიდია, ვიდრე თვითონ ელემენტის ზომები. ასეთ დროს ბრაუზერი მაინც აჩენს შიგთავსს მთლიანად, მიუხედავად იმისა, რომ ის გამოდის ელემენტის საზღვრებს გარეთ.

                თვისება overflow საშუალებას გვაძლევს დავამატოთ ასეთ დროს გადახვევა (scroll) ელემენტზე. ის ღებულობს შემდეგ მნიშვნელობებს:
                
                auto: თუ ელემენტის შიგთავსი (კონტენტი) გამოდის ელემენტის საზღვრებს გარეთ, ჩნდება გადახვევის ზოლი (ჰორიზონტალური, ვერტიკალური). სხვა დროს გადახვევის ზოლები არ ჩანს
                hidden: ჩანს შიგთავსის მხოლოდ ის ნაწილი, რაც ეტევა ელემენტის ზომებს შიგნით. გადახვევის ზოლები არ ჩნდება
                scroll: გადახვევის ზოლები ჩანს ყოველთვის, მაშინაც, როცა სიგთავსი ეტევა ელემენტის შიგნით
                visible: მნიშვნელობა მიუთითებლობისას. გადახვევის ზოლები არ ჩნდება, შიგთავსი ჩანს იმის მიუხედავად, ეტევა ელემენტის საზღვრებში თუ არა
                მაგალითად:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>გადახვევის ზოლი</title>
                        <style>
                        .article1{
                            width: 300px;
                            height: 150px;
                            margin:15px;
                            border: 1px solid #ccc;
                            overflow: auto;
                        }
                        .article2{
                            width: 300px;
                            height: 150px;
                            margin:15px;
                            border: 1px solid #ccc;
                            overflow: hidden;
                        }
                        </style>
                    </head>
                    <body>
                        <div class="article1">
                        <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                            შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული, რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდნილ
                            წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება. მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                            მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                            სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი, ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                        <div class="article2">
                            <p>ჩემს სოფელს მარჯვნივ გუბაზოული ჩაუდის, მარცხნივ - ლაშის ღელე, რომელიც სავსეა კიბორჩხალებით, ღორჯოებით და
                                შარვალაკაპიწებული ბიჭებით. გუბაზოულზე ხიდია გადებული, რომელსაც ბოგას ეძახიან. ყოველ გაზაფხულზე მოვარდნილ
                                წყალს მიაქვს ხიდი და ჩვენ მხოლოდ ხიდის თავი გვრჩება. მიუხედავად ამისა, ჩემი სოფელი მაინც ყველაზე ლამაზი და
                                მხიარული სოფელია გურიაში, მე იგი ყველა სოფელზე უფრო მიყვარს ამქვეყნად, რადგან არ შეიძლება სხვაგან იყოს
                                სოფელი, რომელშიც ვცხოვრობდე მე, ჩემი ბებია, ილარიონი, ილიკო და ჩემი ძაღლი მურადა.</p>
                        </div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                თვისება overflow მართავს ელემენტის გადახვევას როგორც ჰორიზონტალური, ასევე ვერტიკალური მიმართულებით. დამატებითი თვისებებით overflow-x და overflow-y შეიძლება ელემენტს ცალ-ცალკე განესაზღვროს გადახვევა ჰორიზონტალური და ვერტიკალური მიმართულებისთვის. ისინი ღებულობენ იმავე მნიშვნელობებს, რასაც overflow. მაგალითად:
                
                overflow-x: auto;
                overflow-y: hidden;`
            },
            {
                title:"წრფივი გრადიენტი",
                data:`გრადიენტი წარმოადგენს ერთი ფერის თანდათანობით გადასვლას მეორეში. CSS3-ში არსებობს ჩაშენებული გრადიენტები, რომლებიც შიძლება გამოვიყენოთ ელემენტის ფონად.

                გრადიენტისთვის CSS-ში არაა ცალკე თვისება, იგი გამოისახება მნიშვნელობით, რომელიც უნდა მივანიჭოთ თვისებას background-image.
                
                წრფივი გრადიენტი იწყება ელემენტის ერთი ბოლოდან და ვრცელდება მოპირდაპირე ბოლომდე, ამასთან ფერი თანდათანობით გადადის ერთიდან მეორეში.
                
                წრფივი გრადიენტის შესაქმნელად უნდა მივუთითოთ დაწყების ადგილი და რამდენიმე ფერი:
                
                background-image: linear-gradient(left,blue,red);
                მოცემულ მაგალითში გრადიენტი იწყება ელემენტის მარცხენა ბოლოდან (left) ლურჯი ფერით (blue) და ვრცელდება მარჯვენა ბოლომდე, ამასთან ფერი თანდათანობით გადადის წითლში (red).
                
                გრადიენტის გამოყენებას გააჩნია ერთი ნაკლი: ბრაუზერების მრავალფეროვნების გამო აუცილებელია მივუთითოთ შესაბამისი პრეფიქსი:
                
                -webkit- : ბრაუზერებისთვის Google Chrome, Safari, Microsoft Edge, Opera მე-15 ვერსიის ზევით
                -moz- : ბრაუზერისთვის Mozilla Firefox 
                -o- : ბრაუზერისთვის Opera მე-15 ვერსიამდე
                ბრაუზერების გათვალისწინებით გრადიენტის გამოყენება შემდეგნაირად გამოიყურება:
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>გრადიენტი</title>
                    <style>
                        div {
                            width: 200px;
                            height: 100px;
                            background-image: linear-gradient(left,blue,red,gold);
                            background-image: -o-linear-gradient(left,blue,red,gold);
                            background-image: -moz-linear-gradient(left,blue,red,gold);
                            background-image: -webkit-linear-gradient(left,blue,red,gold);
                        }
                    </style>
                </head>
                <body>
                    <div></div>
                </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                გრადიენტის დაწყების ადგილის მისათითებლად გამოიყენება მნიშვნელობები:
                
                left: მარცხნიდან მარჯვნივ
                right: მარჯვნიდან მარცხნივ
                top: ზემოდან ქვემოთ
                bottom: ქვემოდან ზემოთ
                მაგალითად, გრადიენტი ქვემოდან ზემოთ:
                
                background-image: linear-gradient(bottom,blue,red);
                ასევე შეიძლება დიაგონალური გრადიენტის მიღება ორი მნიშვნელობის მითითებით:
                
                background-image: linear-gradient(top left,blue,red);
                 
                
                HTML5-ის დოკუმენტი
                
                მიმართულების განსაზღვრისთვის კონკრეტული მნიშვნელობების გარდა (top left) შეიძლება მიეთითოს კუთხის გრადუსული მნიშვნელობა 0-დან 360 გრადუსამდე. კუთხის რიცხვითი მნიშვნელობის მერე იწერება deg:
                
                background-image: linear-gradient(30deg,blue,red);
                მაგალითად, 0 გრადუსი ნიშნავს, რომ გრადიენტი იწყება მარცხენა ბოლოდან და მიემართება ჰორიზონტალურად მარჯვენა ბოლომდე, ხოლო 45 გრადუსის შემთხვევაში, გრადიენტი იწყება მარცხენა ქვედა კუთხეში და 45 გრადუსიანი კუთხით მიემართება მეორე ბოლოსკენ.
                
                გრადიენტის დაწყების ადგილის მერე ეთითება ფერები. ფერი შეიძლება იყოს რამდენიმე. გრადიენტში თითოეული ფერი თანაბრად ნაწილლდება. თუმცა შესაძლებელია მიეთითოს კონკრეტული ფერის ადგილი. ამისთვის ფერის მერე ეთითება მეორე მნიშვნელობა, რომელიც განსაზღვრავს ამ ფერის ადგილს:
                
                background-image: linear-gradient(left, #ccc, red 20%, red 80%, #ccc);
                განმეორებადი გრადიენტი
                
                repeating-linear-gradient-ის მეშვეობით შესაძლებელია განმეორებადი გრადიენტის შექმნა. მაგალითად:
                
                background-image: repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                background-image: -moz-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                background-image: -webkit-repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);
                 
                
                მოცემულ მაგალითში გრადიენტი იწყება მარცხნიდან ნაცრისფერი 20 პიქსელიანი ზოლით, შემდეგ 30 პიქსელამდე მიდის გადასვლა წითელში, შემდეგ 40 პიქსელამდე გადადის ღია ცისფერში. ამის შემდეგ ბრაუზერი იმეორებს ყველაფერს თავიდან ელემენტის ბოლომდე.`
            },
            {
                title:"რადიალური გრადიენტი",
                data:`წრფივი გრადიენტისგან განსხვავებით, რადიალური გრადიენტი ვრცელდება ცენტრიდან კიდეებისკენ წრიულად. რადიალური გრადიენტის შესაქმნელად საკმარისია მივუთითოთ ფერი, რომელიც იქნება ცენტრში და მეორე ფერი, რომელშიც თანაბრად გადავა. ეს ფერები გადაეცემა ფუნქციას radial-gradient. მაგალითად: 

                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>გრადიენტი</title>
                    <style>
                        div {
                            width: 200px;
                            height: 200px;
                            border-radius: 100px;            
                            background-color: #eee;
                            background-image: radial-gradient(white, black);
                            background-image: -moz-radial-gradient(white, black);
                            background-image: -webkit-radial-gradient(white, black);
                        }
                        p{
                            margin: 0;
                            padding-top: 60px;
                            text-align: center;
                            color: #eee;
                        }
                        </style>
                    </head>
                    <body>
                        <div><p>რადიალური გრადიენტი</p></div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                ისევე, როგორც წრფივი გრადიენტის შემთხვევაში, აქაც საჭიროა პრეფიქსების გამოყენება სხვადასხვა ბრაუზერების მხარდაჭერისათვის.
                
                რადიალურ გრადიენტს შეიძლება ჰქონდეს ორი ფორმა: წრიული და ელიფსური. ელიფსური ფორმა წარმოადგენს გრადიენტის გავრცელებას ელიფსური სახით და ამისთვის მიეთითება მნიშვნელობა ellipse:
                
                background-image: radial-gradient(ellipse, white, black);
                ვინაიდან ეს მნიშვნელობა არის მნიშვნელობა მიუთითებლობისას, შესაძლებელია ის გამოვტოვოთ.
                
                წრიული გრადიენტისთვის გამოიყენება circle:
                
                background-image: radial-gradient(circle, white, black);
                როგორც წესი, გრადიენტი იწყება ელემენტის ცენტრიდან, მაგრამ შესაბამისი პარამეტრებით შევცვალოთ დაწყების ადგილი, ამისათვის ეთითება პარამეტრი background-position:
                
                background-image: radial-gradient(25% 30%, circle, white, black);
                25% 30% ნიშნავს, რომ გრადიენტის ცენტრი მდებარეობს ელემენტის მარცხენა საზღვრიდან 25%-ის და ზედა საზღვრიდან 30%-ის დაშორებით.
                
                HTML5-ის დოკუმენტი
                
                სპეციალური დამატებითი პარამეტრების მეშვეობით შეიძლება შევცვალოთ გრადიენტის ზომა:
                
                closest-side: გრადიენტი ვრცელდება ცენტრიდან ელემენტის უახლოეს მხარემდე, ანუ გრადიენტი ელემენტის შიგნით რჩება
                closest-corner: გრადიენტის სიგქანე ითვლება ცენტრიდან უაზლოეს კუთხემდე. შესაბამისად, გრადიენტი შეიძლება გავიდეს ელემენტის საზღვრებს გარეთ
                farthest-side: გრადიენტი ვრცელდება ცენტრიდან ყველაზე დაშორებულ მხარემდე
                farthest-corner: გრადიენტის სიგანე ითვლება ცენტრიდან ყველაზე დაშორებულ კუთხემდე
                background-image: radial-gradient(25% 30%, circle farthest-corner, white, black);`
            },
            



              
            ]
        },
        {
            title:"თავი 7. გვერდის მაკეტის შექმნა",
            content:[
                {
                    title:"ბლოკისებური მაკეტი. 1-ლი ნაწილი",
                    data:`როგორც წესი, ვებგვერდი შედგება უამრავი ელემენტისაგან, რომელთაც შეიძლება ჰქონდეთ რთული სტრუქტურა. ამიტომ ვებგვერდის შექმნის პროცესში მნიშვნელოვანია ამ ელემენტების პოზიციონირება და სტილიზაცია, რათა მათ ჰქონდეთ საჭირო განლაგება. ამ დროს წარმოიქმნება გვერდის მაკეტის შექმნის აუცილებლობა.

                    არსებობს გვერდის მაკეტის შექმნის სხვადასხვა მეთოდები და მიდგომები. თავიდან გავრცელებული იყო ვებგვერდის მაკეტი ცხრილების საფუძველზე, რადგანაც ცხრილები საშუალებას იძლევა მარტივად დავყოთ გვერდი სვეტებად და სტრიქონებად. სვეტების და სტრიქონების მართვა შედარებით ადვილია და მათში ელემენტების პოზიციონირებაც მარტივია, რაც განაპირობებდა ამ მეთოდის პოპულარობას.
                    
                    მაგრამ ცხრილური მაკეტი არაა საკმარისად მოქნილი დიზაინის კუთხით, ვინაიდან მომხმარებელთა ეკრანის გაფართოება მეტად განსხვავებულია ფართოეკრანიანი ტელევიზორებიდან დაწყბული დამთავრებული პლანშეტებით და ტელეფონებით. გაფართოების ასეთი მრავალფეროვანი მოთხოვნების დასაკმაყოფილებლად ცხრილური მაკეტი არ აღმოჩნდა მოხერხებული. ამიტომ ნელ-ნელა მისი ადგილი დაიკავა ე. წ. ბლოკისებურმა მაკეტმა. ბლოკისებური მაკეტი პირობითი სახელწოდებაა ვებგვერდის მაკეტისა, სადაც ძირითადად გამოიყენება თვისება float, ხოლო ვებგვერდის ელემენტები ძირითადად მოქცეულია ელემენტებში <div> ანუ ბლოკებში. ამ ელემენტების მეშვეობით შესაძლებელია რამდენიმე სვეტიანი მაკეტის შექმნა, რომელიც გაცილებით უფრო მოქნილია, ვიდრე ცხრილები.
                    
                    წინა თემებში განხილული იყო float თვისების მოქმედება. გამოვიყენოთ იგი ორსვეტიანი ვებგვერდის ასაწყობად. ვთქვათ, გვინდა გვერდი შედგებოდეს სათაურისა და ქვედა ნაწილისგან (ფუტერისგან), ხოლო შუაში იყოს ორი სვეტი: ერთი მენიუთი ან ნავიგაციის პანელით და მეორე ძირითადი ნაწილით.
                    
                    ჯერ განვსაზღვროთ ყველა ბლოკი. float თვისების გამოყენებისას მნიშვნელობა აქვს ელემენტების თნმიმდევრობას. მცურავი ელემენტი უნდა მოდიოდეს იმ ელემენტის წინ, რომელიც გარს უნდა შემოეკრას. ჩვენს შემთხვევაში ეს არის ნავიგაციის პანელი (საიდბარი).
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ბლოკისებური მაკეტი</title>
                            <style>
                                div{
                                    margin: 10px;
                                    border: 1px solid black;
                                    font-size: 20px;
                                    height: 80px;
                                }
                                #header{
                                    background-color: #ccc;
                                }
                                #sidebar{
                                    background-color: #ddd;
                                }
                                #main{
                                    background-color: #eee;
                                    height: 200px;
                                }
                                #footer{
                                    background-color: #ccc;
                                }
                            </style>
                        </head>
                        <body>
                            <div id="header">საიტის სათაური</div>
                            <div id="sidebar">საიდბარი</div>
                            <div id="main">ძირითადი შიგთავსი</div>
                            <div id="footer">ფუტერი</div>
                        </body>
                    </html>
                    შედეგად ვღებულობთ ჯერ-ჯერობით შემდეგ გვერდს:
                    
                    HTML5-ის დოკუმენტი
                    
                    ბლოკების სიმაღლე, ჩარჩოები და დაშორებები დამატებულია მხოლოდ იმისთვის, რომ შეგვეძლოს ბლოკების იდენტიფიცირება და ერთმანეთისგან გარჩევა.
                    
                    საიდბარის ძირითადი ბლოკის მარცხნივ მოსათავსებლად საჭიროა მას მივცეთ თვისება float:left. სიგანე უნდა იყოს ფიქსირებული, მაგალითად 150px ან 8em. ასევე შეიძლება პროცენტების გამოყენება, მაგალითად 30%. ერთის მხრივ, ფიქსირებული სიგანის ბლოკების მართვა უფრო ადვილია, მაგრამ პროცენტული მნიშვნელობისას ისინი უფრო მოქნილნი არიან ბრაუზერის ზომების შეცვლისას.
                    
                    რადგანაც ელემენტი, რომელიც გარსშემოედინება მცურავ ელემენტს გარს ეკვრის მას არა მხოლოდ მარჯვნიდან, არამედ ქვემოდანაც, აუცილებელია მას მივუთითოთ გარე დაშორება არანაკლებ მცურავი ელემენტის სიგანისა. თუ საიდბარის სიგანე იქნება 150 პიქსელი, ძირითადი ბლოკის გარე დაშორება მივუთითოთ 170 პიქსელი, რათა დარჩეს ცარიელი ადგილი საიდბარსა და ძირითად ბლოკს შორის. ამასთან ძირითად ბლოკს უმჯობესია არ მივცეთ ზუსტი სიგანე და ამ შემთხვევაში ის შეავსებს მთლიანად ბრაუზერის დარჩენილ ნაწილს.
                    
                    შევცვალოთ შესაბამისად საიდბარისა და ძირითადი ბლოკის სტილიზაცია:
                    
                    #sidebar{
                        background-color: #ddd;
                        float: left;
                        width: 150px;
                    }
                    #main{
                        background-color: #eee;
                        height: 200px;
                        margin-left: 170px;           
                    }
                    შედეგად მივიღებთ საიდბარს ძირითადი ბლოკის მარცხნივ:
                    
                    HTML5-ის დოკუმენტი
                    
                    ბლოკების სიმაღლე მითითებულია თვალსაჩინოებისთვის, სინამდვილეში სიმაღლეს კონტენტიდან გამომდინარე ბრაუზერი მიანიჭებს ავტომატურად.
                    
                    მარჯვენა საიდბარის შექმნა ანალოგიურია, უბრალოდ საიდბარს ექნება თვისება float:right და ძირითად ბლოკს გარე დაშორება მიეთითება მარჯვნიდან:
                    
                    #sidebar{
                        background-color: #ddd;
                        float: right;
                        width: 150px;
                    }
                    #main{
                        background-color: #eee;
                        height: 200px;
                        margin-right: 170px;           
                    }
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    თვითონ html-ის ტექსტი არ შეიცვლება, საიდბარი ისევ წინ უნდა იყოს ძირითად ბლოკზე.`
                },
                {
                  title:"ბლოკისებური მაკეტი. მე-2 ნაწილი",
                  data:`წინა თემაში განხილული იყო გვერდის შექმნა ორი სვეტით. ანალოგიურად ჩვენ შეგვიძლია გვერდის შექმნა უფრო მეტი სვეტებით და უფრო რთული სტრუქტურით. მაგალითად, დავამატოთ მეორე საიდბარი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid black;
                                  font-size: 20px;
                                  height: 80px;
                              }
                              #header{
                                  background-color: #ccc;
                              }
                              #leftSidebar{
                                  background-color: #ddd;
                              }
                              #rightSidebar{
                                  background-color: #bbb;
                              }
                              #main{
                                  background-color: #eee;
                                  height: 200px;
                              }
                              #footer{
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">საიტის სათაური</div>
                          <div id="leftSidebar">მარცხენა საიდბარი</div>
                          <div id="rightSidebar">მარჯვენა საიდბარი</div>
                          <div id="main">ძირითადი შიგთავსი</div>
                          <div id="footer">ფუტერი</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თითოეული საიდბარის html კოდი წინ უნდა უსწრებდეს ძირითადი ბლოკის კოდს, რომელიც გარს უნდა შემოეკრას ამ საიდბარებს.
                  
                  ახლა მოვახდინოთ საიდბარების და ძირითადი ბლოკის სტილიზაცია:
                  
                  #leftSidebar{
                      background-color: #ddd;
                      float: left;
                      width: 150px;
                  }
                  #rightSidebar{
                      background-color: #bbb;
                      float: right;
                      width: 150px;
                  }
                  #main{
                      background-color: #eee;
                      height: 200px;
                      margin-left: 170px;
                      margin-right: 170px;
                  }
                   `
              },
              {
                  title:"ჩასმული მცურავი ბლოკები",
                  data:`ხშირად არის სიტუაცია, როდესაც ბლოკში, რომელიც გარსშემოედინება სხვა ელემენტებს, ჩასმულია მცურავი ელემენტები. მაგალითად, ძირითადი ბლოკი შეიძლება შეიცავდეს ძირითად შიგთავსს და მენიუს. ასეთი ბლოკებისადმი გამოიყენება იგივე პრინციპები. 

                  ჯერ განვსაზღვროთ ვებგვერდის ბლოკები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              div{
                                  margin: 10px;
                                  border: 1px solid black;
                                  font-size: 20px;
                                  height: 80px;
                              }
                              #header{
                                  background-color: #ccc;
                              }
                              #sidebar{
                                  background-color: #bbb;
                                  float: right;
                                  width: 150px;
                              }
                              #main{
                                  background-color: #fafafa;
                                  height: 200px;
                                  margin-right: 170px;
                              }
                              #menu{
                                  background-color: #ddd;
                              }
                              #content{
                                  background-color: #eee;
                              }
                              #footer{
                                  background-color: #ccc;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">გვერდის სათაური</div>
                          <div id="sidebar">მარჯვენა საიდბარი</div>
                          <div id="main">
                              <div id="menu">მენიუ</div>
                              <div id="content">ძირითადი შინაარსი</div>
                          </div>
                          <div id="footer">ფუტერი</div>
                      </body>
                  </html>
                  ძირითად ბლოკში ელემენტები მოთავსებულია საჭირო თანმიმდევრობით: ჯერ მენიუ, შემდეგ ძირითადი შინაარსი.
                  
                  HTML5-ის დოკუმენტი
                  
                  ახლა კი მივანიჭოთ საჭირო თვისებები ელემენტებს:
                  
                  #menu{
                      background-color: #ddd;
                      float: left;
                      width: 160px;
                  }
                  #content{
                      background-color: #eee;
                      margin-left: 180px;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად შეიძლება მენიუ გადავიტანოთ მარჯვნივ:
                  
                  #menu{
                      background-color: #ddd;
                      float: right;
                      width: 160px;
                  }
                  #content{
                      background-color: #eee;
                      margin-right: 180px;
                  }`
              },
              {
                  title:"სვეტების გათანაბრება სიმაღლეში",
                  data:`გვერდის ბლოკისებურად აწყობის დროს შეიძლება გაჩნდეს პრობლემა სვეტების სიმაღლეთა შორის განსხვავების გამო, განსაკუთრებით მაშინ, როცა მათ გააჩნიათ სხვადასხვა ფონი. განვიხილოთ მაგალითი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ბლოკისებური მაკეტი</title>
                          <style>
                              body, h2, p{
                                  margin:0;
                                  padding:0;
                              }
                              body{
                                  font-size: 18px;
                              }
                              #header{
                                  background-color: #eee;
                                  border-bottom: 1px solid #ccc;
                                  height: 80px;
                              }
                              #menu{
                                  background-color: #ddd;
                                  float: left;
                                  width: 150px;
                              }
                              #main{
                                  background-color: #f7f7f7;
                                  border-left: 1px solid #ccc;
                                  margin-left: 150px;
                                  padding: 10px;
                              }
                              #footer{
                                  border-top: 1px solid #ccc;
                                  background-color: #dedede;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header"><h2>Сайт MySyte.com</h2></div>
                          <div id="menu">
                              <ul>
                                  <li><a href="#">მთავარი</a></li>
                                  <li><a href="#">ბლოგი</a></li>
                                  <li><a href="#">კონტაქტები</a></li>
                                  <li><a href="#">საიტის შესახებ</a></li>
                              </ul>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
                                  incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis
                                  nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                                  Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
                                  fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
                                  culpa qui officia deserunt mollit anim id est laborum.
                                  has been the industry...</p>
                          </div>
                          <div id="footer">
                              <p>Copyright © MySyte.com, 2016</p>
                          </div>
                      </body>
                  </html>
                  აქ უკვე გაკეთებულია გარსშემოდინება და იგი კარგად მუშაობს, მაგრამ შიგთავსის მიხედვით ერთი სვეტი უფრო მაღალია, ვიდრე მეორე:
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში, მენიუს ბლოკს აქვს არასაკმარისი სიმაღლე.
                  
                  ყველაზე გავრცელებული მეთოდი აღნიშნული ხარვეზის გამოსასწორებლად არის ძირითადი ნაწილის და მენიუს ჩასმა კონტეინერში, რომელსაც ენიჭება ფონი და ეს ფონი ექნება უფრო დაბალი სიმაღლის მქონე ბლოკს, ჩვენს შემთხვევაში მენიუს. მეორე ბლოკს ეძლევა თავისი ფონი და შესაბამისად, იქმნება ილუზია, რომ სვეტები ერთი და იმავე სიმაღლისაა:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ბლოკისებური მაკეტი</title>
                      <style>
                          body,
                          h2,
                          p {
                              margin: 0;
                              padding: 0;
                          }
                          body {
                              font-size: 18px;
                          }
                          #header {
                              background-color: #eee;
                              border-bottom: 1px solid #ccc;
                              height: 80px;
                          }
                          #wrapper {
                              background-color: #ddd;
                          }
                   
                          #menu {
                              float: left;
                              width: 150px;
                          }
                          #main {
                              background-color: #f7f7f7;
                              border-left: 1px solid #ccc;
                              margin-left: 150px;
                              padding: 10px;
                          }
                          #footer {
                              border-top: 1px solid #ccc;
                              background-color: #dedede;
                          }
                      </style>
                  </head>
                   
                  <body>
                      <div id="header">
                          <h2>Сайт MySyte.com</h2>
                      </div>
                      <div id="wrapper">
                          <div id="menu">
                              <ul>
                                  <li>
                                      <a href="#">მთავარი</a>
                                  </li>
                                  <li>
                                      <a href="#">ბლოგი</a>
                                  </li>
                                  <li>
                                      <a href="#">კონტაქტები</a>
                                  </li>
                                  <li>
                                      <a href="#">საიტის შესახებ</a>
                                  </li>
                              </ul>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
                                  magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
                                  consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
                                  Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
                                  has been the industry...</p>
                          </div>
                      </div>
                      <div id="footer">
                          <p>Copyright © MySyte.com, 2016</p>
                      </div>
                  </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში ძირითადი ნაწილი და მენიუ ჩასმულია კონტეინერში wrapper, რომელსაც აქვს მენიუს ფონი, ხოლო ძირითად ნაწილს მიცემული აქვს თავისი ფონი.`
              },
              {
                  title:"თვისება display",
                  data:`გარდა float თვისებისა, რომელიც საშუალებას იძლევა შევცვალოთ ელემენტის ადგილმდებარეობა, CSS-ში არის კიდევ ერთი მნიშვნელოვანი თვისება display. ის საშუალებას იძლევა ბლოკის მართვის შესაძლებლობას და ასევე გავლენა აქვს მის პოზიციაზე სხვა ელემენტების მიმართ.

                  თვისება display იღებს შემდეგ მნიშვნელობებს:
                  
                  inline: ელემენტი ხდება სტრიქონული, როგორც სიტყვები სტრიქონში
                  block: ელემენტი ხდება ბლოკისებური, როგორც პარაგრაფი
                  inline-block: ელემენტი თავსდება როგორც სტრიქონი
                  list-item: ელემენტი იღებს პოზიციას, როგორც სიის ელემენტი, როგორც წესი, მარკერის დამატებით წერტილის ან რიგითი ნომრის სახით
                  run-in: ბლოკის ელემენტის ტიპი დამოკიდებულია გარემომცველ ელემენტებზე
                  flexbox: იძლევა ელემენტების მოქნილი პოზიციონირების საშუალებას
                  table, inline-table: საშუალებას იძლევა განლაგდეს ელემენტები ცხრილის სახით
                  none: ელემენტი არ ჩანს
                  მაშასადამე, მნიშვნელობა block იძლევა ბლოკისებური ელემენტის განსაზღვრის საშუალებას. ასეთი ელემენტი ვიზუალურად გამოიყოფა სხვა ელემენტებისაგან სტრიქონის გადატანით, როგორც, მაგალითად, პარაგრაფი p ან ბლოკი div, რომლებიც მიუტითებლობისას წარმოადგენენ ბლოკისებურ ელემენტებს.
                  
                  ელემენტი span მათგან განსხვავებით არ წარმოადგენს ბლოკისებურ ელემენტს. ვნახოთ, როგორ შეიცვლება მისი მდებარეობა display:block მნიშვნელობის მინიჭებით:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              span{
                                  color: red;
                              }
                              .blockSpan{
                                  display: block;
                              }
                          </style>
                      </head>
                      <body>
                          <div>ეს <span>სტრიქონული</span> span ელემენტია</div>
                          <div>ეს <span class="blockSpan">ბლოკისებური</span> span ელემენტია</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ მოცემულია ორი ელემენტი span. ერთ მათგანს მინიჭებული აქვს სტილი display:block. ამიტომ ეს ელემენტი გადატანილია ახალ სტრიქონზე.
                  
                  ბლოკისებური ელემენტებისგან განსხვავებით სტრიქონული ელემენტები თავსდება სტრიქონში, რადგან მათ მინიჭებული აქვს მნიშვნელობა display:inline. span ელემენტს მიუტითებლობისას სწორედ ეს მნიშვნელობა აქვს მინიჭებული, ამიტომაც თავსდება სტრიქონში და არ გადადის ახალ სტრიქონში, როგორც პარაგრაფი p და div. ახლა div ელემენტი გავხადოთ სტრიქონული:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              div{
                                  display: inline;
                              }
                          </style>
                      </head>
                      <body>
                          <div>პირველი სტრიქონული ელემენტი div.</div>
                          <div>მეორე სტრიქონული ელემენტი div.</div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  გასათვალისწინებელია, რომ როცა ვიყენებთ მნიშვნელობას display:inline, ბრაუზერი იგნორირებას უკეთებს ზოგიერთ თვისებას, როგორიცაა width, height, margin.
                  
                  inline-block
                  
                  კიდევ ერთი მნიშვნელობა - inline-block წარმოადგენს ელემენტს, რომელიც წარმოადგენს ბლოკისებური და სტრიქონული ელემენტის ნარევს. მეზობელი ელემენტების მიმართ ის წარმოადგენს სტრიქონულს, ანუ, არ გამოიყოფა  მათგან ახალ სტრიქონზე გადატანით. თუმცა ჩასმული ელემენტებისთვის წარმოადგენს ბლოკისებურს. ასეთი ელემენტებისათვის გამოიყენება თვისებები width, height, margin.
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              span{
                                  width: 100px;
                                  height: 30px;
                                  background-color: #aaa;
                              }
                              .inineBlockSpan{
                                  display: inline-block;
                              }
                          </style>
                      </head>
                      <body>
                          <p>ნახეს, უცხო <span>მოყმე</span> ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                          <p>ნახეს, უცხო <span class="inineBlockSpan">მოყმე</span> ვინმე, ჯდა მტირალი წყლისა პირსა...</p>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველი ელემენტი span წარმოადგენს სტრიქონულს, ვინაიდან მას აქვს მნიშვნელობა inline, ამიტომ მისთვის width და height თვისებების გამოყენებას აზრი არა აქვს. სამაგიეროდ, მეორე ელემენტი span ბლოკისებურია და ის იღებს შესაბამის ზომებს. ასევე შეიძლება მისთვის დაშორებების გამოყენება.
                  
                  run-in
                  
                  მნიშვნელობა run-in განსაზღვრავს ელემენტს, რომელიც დამოკიდებულია მეზობელ ელემენტებზე. არსებობს სამი შესაძლო ვარიანტი:
                  
                  როცა ელემენტი გარშემორტყმულია ბლოკისებური ელემენტებით, ფაქტიურად თვითონაც აქვს მნიშვნელობა display:block, ანუ ხდება ბლოკისებური
                  როცა ელემენტი გარშემორტყმულია სტრიქონული ელემენტებით, ფაქტიურად თვითონაც აქვს მნიშვნელობა display:inline, ანუ ხდება სტრიქონული
                  ყველა სხვა შემთხვევაში ელემენტი არის ბლოკისებური
                  ცხრილისებური წარმოდგენა
                  
                  მნიშვნელობა table ელემენტს აქცევს ცხრილად. ვნახოთ სიის მაგალითზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              ul{
                                  display: table;
                                  margin: 0;
                              }
                              li{
                                  list-style-type: none;
                                  display: table-cell;
                                  padding: 10px;
                              }
                          </style>
                      </head>
                      <body>
                          <ul>
                              <li>Item 1</li>
                              <li>Item 2</li>
                              <li>Item 3</li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ ცხრილი პრაქტიკულად გადაიქცა ცხრილად, ხოლო სიის თითოეული ელემენტი - უჯრად. ამისათვის სიის ელემენტებს მინიჭებული აქვთ თვისება display: table-cell. ფაქტიურად, სიის ნაცვლად შეგვეძლო გამოგვეყენებინა სტანდარტული ცხრილი.
                  
                  ელემენტის დამალვა
                  
                  მნიშვნელობა none საშუალებას იძლევა დავმალოთ ელემენტი:
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>თვისება display</title>
                      <style>
                              .invisible{
                                  display: none;
                              }
                          </style>
                      </head>
                      <body>
                          <p>პირველი პარაგრაფი</p>
                          <p class="invisible">მეორე პარაგრაფი</p>
                          <p>მესამე პარაგრაფი</p>
                      </body>
                  </html>
                   `
              },
              {
                  title:"ნავიგაციის პანელის შექმნა",
                  data:`ნავიგაციის პანელი მნიშვნელოვან როლს ასრულებს საიტზე, იგი უზრუნველყოფს გადასვლას საიტის გვერდებზე თუ გარე რესურსებზე. ვნახოთ მარტივი ნავიგაციის პანელის შექმნა.

                  პრაქტიკულად, ნავიგაციის პანელი არის ბმულების ერთობლიობა, ხშორად უნომრო სიის სახით. ნავიგაციის პანელი მრავალნაირი შეიძლება იყოს: ჰორიზონტალური ან ვერტიკალური, ერთდონიანი ან მრავალდონიანი, მაგრამ ნავიგაცია ყოველთვის დაფუძნებულია <a> ელემენტზე. ამიტომ ნავიგაციის პანელის შექმნისას შეიძლება შეგვხვდეს ბმულის ელემენტის შეზღუდვებთან დაკავშირებული სიძნელეები. <a> ელემენტი წარმოადგენს სტრიქონულს და ამიტომ არ შეგვიძლია მას მივუთითოთ სიგანე, სიმაღლე, დაშორებები. ბმული ავტომატურად იკავებს იმ ადგილს, რამდენიც მას სჭირდება ტექსტიდან გამომდინარე.
                  
                  ვერტიკალური მენიუ
                  
                  აღნიშნული პრობლემის ერთ-ერთი ყველაზე გავრცელებული გადაწყვეტაა ბმულის გადაქცევა ბლოკისებურ ელემენტად display:block თვისების გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              ul.nav a {
                                  display: block;
                                  width: 7em;
                                  padding:10px;
                                  background-color: #f4f4f4;
                                  border-top: 1px dashed #333;
                                  border-right: 1px dashed #333;
                                  border-left: 5px solid #333;
                                  text-decoration: none;
                                  color: #333;
                              }
                              ul.nav li:last-child a {
                                  border-bottom: 1px dashed #333;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჰორიზონტალური მენიუ
                  
                  ჰორიზონტალური მენიუს შესაქმნელად შეიძლება გამოვიყენოთ ორი მეთოდი: პირველი მდგომარეობდ მცურავი ელემენტების გამოყენება (თვისება float), მეორე - ბმულების სტრიქონის შექმნა display: inline-block თვისების გამოყენებით.
                  
                  float თვისების გამოყენება
                  
                  float თვისების გამოყენებისას სიის ელემენტებს ენიჭებათ მნიშვნელობა float:left, ხოლო თვითონ ბმულებს - display:block,  რათა შეგვეძლოს მათთვის სიმაღლის, სიგანისა და დაშორებების მინიჭება.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              .nav li {
                                  float: left;
                              }
                              ul.nav a {
                                  display: block;
                                  width: 7em;
                                  padding:10px;
                                  margin: 0 5px;
                                  background-color: #f4f4f4;
                                  border: 1px dashed #333;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              ul.nav a:hover{
                                  background-color: #333;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">ბლოგი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  inline და inline-block
                  
                  ჰორიზონტალური პანელის შესაქმნელად სიის ელემენტებს უნდა მივანიჭოთ თვისება display:inline, ხოლო თვითონ ბმულებს display:inline-block:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ნავიგაციის პანელი</title>
                          <style>
                              ul.nav{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              .nav li {
                                  display: inline;
                              }
                              ul.nav a {
                                  display: inline-block;
                                  width: 7em;
                                  padding:10px;
                                  background-color: #f4f4f4;
                                  border: 1px dashed #333;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              ul.nav a:hover{
                                  background-color: #333;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <ul class="nav">
                              <li><a href="#">მთვარი</a></li>
                              <li><a href="#">ბლოგი</a></li>
                              <li><a href="#">კონტაქტი</a></li>
                              <li><a href="#">საიტის შესახებ</a></li>
                          </ul>
                      </body>
                  </html>`
              },
              {
                  title:"მცურავი ელემენტების გასწორება",
                  data:`მცურავ ელემენტებტან მუშაობისას ხშირია შემთხვევა, როცა ელემენტი ამოვარდნილია გვერდიდან. ამ პრობლემას აქვს სხვადასხვა ასპექტი და მათი გადაწყვეტა. განვიხილოთ ეს ასპექტები.

                  ვთქვათ, გვაქვს შემდეგი ბლოკი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                          <style>
                              #sidebar{
                                  float: left;
                                  width: 25%;
                                  padding: 10px;
                              }
                              #main{
                                  border-left: 1px solid #ccc;
                                  width:75%;
                                  padding: 15px;
                                  margin-left: 25%;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="sidebar">
                              <h2>The standard Lorem Ipsum passage</h2>
                              <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
                                  eiusmod tempor incididunt ut labore et dolore...</p>
                          </div>
                          <div id="main">
                              <h2>Lorem Ipsum</h2>
                              <p>Lorem ipsum dolor sit amet, in quis eu leo,
                              sapien iaculis pede montes id cras nulla, sed in.
                              Mattis risus, donec risus quisque augue cum, dui
                              lacus vel est magna. Proin cras sodales tortor lectus
                              pretium id. Amet orci, nulla nibh, lorem velit. Molestie accumsan et,
                              ut vestibulum maecenas sed arcu. Arcu viverra illum luctus ac in pellentesque,
                              turpis sed, auctor orci a vestibulum duis vestibulum auctor, tellus suspendisse.
                              Lacus scelerisque pellentesque odio nec enim cum. Lorem adipisci, orci ante
                              consectetuer facilisis ac sem porta.</p>
                          </div>
                      </body>
                  </html>
                  საიდბარში საკმაოდ დიდი ტექსტია, ველოდებით რომ, ეფექტურად ჩაჯდება მცურავი ელემენტის საზღვრებში.
                  
                  HTML5-ის დოკუმენტი
                  
                  სინამდვილეში ვხედავთ, რომ საიდბარიდან ასოები გადმოდის საზღვრის გარეთ, მიუხედავად იმისა, რომ მას აქვს 10 პიქსელი შიდა დაშორებაც მარჯვენა მხარეს.
                  
                  რატომ ხდება ასე? ხშირად ბრაუზერები თავისებურ ინტერპრეტაციას აძლევენ ელემენტის ზომებს. კერძოდ, ყველა ელემენტს მიუთითებლობისას box-sizing თვისების მნიშვნელობა აქვს content-box. ამ დროს ელემენტის ზომებს (width, height) ემატება ჩარჩოების და შიდა დაშორებების ზომები. ამიტომ ხშირად ყველა ელემენტისთვის უთითებენ box-sizing თვისების მნიშვნელობად border-box-ს, შესაბამისად ყველა ელემენტი იზომება ერთნაირად:
                  
                  *{
                       box-sizing: border-box;
                   }
                  თუ ჩვენს მიერ განხილულ მაგალითში დავამატებთ ამ თვისებას, მივიღებთ სულ სხვა შედეგს:
                  
                  HTML5-ის დოკუმენტი
                  
                  განვიხილოთ სხვა პრობლემა, რომელიც დაკავშირებულია მცურავი ელემენტის პოზიციონირებასთან კონტეინერის შიგნით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              #header{
                                  background-color: #eee;
                              }
                              #nav{
                                  background-color: #f4f4f4;
                                  border-top: 1px solid #ccc;
                                  border-bottom: 1px solid #ccc;
                              }
                              #nav ul{
                                  margin-left: 0px;
                                  padding-left: 0px;
                                  list-style: none;
                              }
                              #nav li {
                                  float: left;
                              }
                              #nav ul a {
                                  display: block;
                                  width: 9em;
                                  padding:10px;
                                  border-left: 1px solid #ccc;
                                  text-decoration: none;
                                  color: #333;
                                  text-align: center;
                              }
                              #nav ul li:last-child a {
                                  
                                  border-right: 1px solid #ccc;
                              }
                              #nav ul a:hover{
                                  background-color: #aaa;
                                  color: #f4f4f4;
                              }
                          </style>
                      </head>
                      <body>
                          <div id="header">
                              <h1>კეთილი იყოს თქვენი მობრძანება</h1>
                              <div id="nav">
                                  <ul>
                                      <li><a href="#">მთავარი</a></li>
                                      <li><a href="#">ბლოგი</a></li>
                                      <li><a href="#">კონტაქტი</a></li>
                                      <li><a href="#">საიტის შესახებ</a></li>
                                  </ul>
                              </div>
                          </div>
                          <div id="content"><p>helo world</p></div>
                      </body>
                  </html>
                  HTML5-ის დოკუმენტი
                  
                  როგორც სურათიდან ჩანს, არის შემდეგი პრობლემები: სათურის ზემოთ და მარცხნივ არის გაურკვეველი დაშორებები, მენიუს ზოლი, მიუხედავად იმისა, რომ განსაზღვრულია header-ის შიგნით, ვიზუალურად აშკარად მის გარეთაა, ბლოკი "hello world" ჩაჯდა მენიუში.
                  
                  დაშორებების პრობლემა გამოწვეულია იმით, რომ ელემენტებს გააჩნიათ დაშორებები მიუთითებლობისას. ამის თავიდან ასაცილებლად ხშირად ყველაზე ფართოდ გამოყენებულ ელემენტებს აშორებენ მიუთითებლობის ზოგიერთ პარამეტრს:
                  
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd,
                  ol, ul, li, form, table, caption, tr, th, td, article, aside, footer, header{
                                 
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  მეორე პრობლემა - div ელემენტის მენიუში ჩაჯდომა მარტივად სწორდება. საკმარისია ამ ელემენტს მივუთიტოთ სტილი:
                  
                  clear: both;
                  ცოტა უფრო რთულია მცურავი ელემენტების კონტეინერიდან ამოვარდნის პრობლემა. აქ შეიძლება გამოვიყენოთ გადაწყვეტის ორი ვარიანტი. პირველი გადაწყვეტა მდგომარეობს იმ ელემენტისთვის, რომელიც წარმოადგენს ნავიგაციის პანელს, შემდეგი სტილის დამატებაში:
                  
                  ul:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  მეორე გადაწყვეტა მდგომარეობს იმაში, რომ თვითონ ნავიგაციის პანელი გავხადოთ მცურავი ელემენტი:
                  
                  #nav{
                      background-color: #f4f4f4;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                      
                      float:left;
                      width: 100%;
                      clear: both;
                  }
                  თუ შევცვლით ვებგვერდის სტილებს ზემოთ მითითებული შესწორებების მიხედვით (html-ის ტექსტი უცვლელი რჩება), მივიღებთ:
                  
                  *{
                      box-sizing: border-box;
                  }
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd,
                  ol, ul, li, form, table, caption, tr, th, td, article, aside, footer, header{
                                  
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  #header{
                      background-color: #eee;
                  }
                  #header h1{
                      font-size: 1.3em;
                      padding: 15px;
                  }
                  #nav{
                      background-color: #f4f4f4;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav ul{
                      margin-left: 0px;
                      padding-left: 0px;
                      list-style: none;
                  }
                  #nav li {
                      float: left;
                  }
                  #nav ul a {
                      display: block;
                      width: 7em;
                      padding: 10px;
                      border-left: 1px solid #ccc;
                      text-decoration: none;
                      color: #333;
                      text-align: center;
                  }
                  #nav ul li:last-child a {
                                  
                      border-right: 1px solid #ccc;
                  }
                  #nav ul a:hover{
                      background-color: #aaa;
                      color: #f4f4f4;
                  }
                  #nav ul:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  #content{
                      clear: both;
                  }
                  ვებგვერდი მიიღებს სასურველ სახეს:`
              },
              {
                  title:"მარტივი მაკეტის შექმნა",
                  data:`წინა თემებში შესწავლილი მასალის მიხედვით შევქმნათ მარტივი ვებგვერდის მაკეტი. პირველ რიგში განვსაზღვროთ გვერდის სტრუქტურა:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <link href="styles.css" rel="stylesheet">
                          <title>ვებგვერდის ბლოკისებური მაკეტი</title>
                      </head>
                      <body>
                          <div id="header">
                              <h1>MySyte.com - Lorem Ipsum</h1>
                              <div id="nav">
                                  <ul>
                                      <li><a href="#">მთვარი</a></li>
                                      <li><a href="#">ბლოგი</a></li>
                                      <li><a href="#">ფორუმი</a></li>
                                      <li><a href="#">კონტაქტი</a></li>
                                      <li><a href="#">საიტის შესახებ</a></li>
                                  </ul>
                              </div>
                          </div>
                          <div class="wrapper">
                              <div id="sidebar1" class="aside">
                                  <h2>The standard Lorem Ipsum passage</h2>
                                  <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt
                                  ut labore et dolore magna aliqua..."</p>
                                  </div>
                              <div id="sidebar2" class="aside">
                                  <h2>1914 translation by H. Rackham</h2>
                                  <p>It is a long established fact that a reader will be distracted by the readable
                                  content of a page when looking at its layout.</p>
                                  <h3>Options</h3>
                                  <ul>
                                      <li>Item1</li>
                                      <li>Item2</li>
                                      <li>Item3</li>
                                  </ul>
                              </div>
                              <div id="article">
                                  <h2>What is Lorem Ipsum?</h2>
                                  <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry...</p>
                                  <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of
                                  classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock,
                                  a Latin professor at Hampden-Sydney College in Virginia...</p>
                              </div>
                          </div>
                          <div id="footer">
                              <p>Contacts: admin@mysyte.com</p>
                              <p>Copyright © MySyte.com, 2016</p>
                          </div>
                      </body>
                  </html>
                  ჯერ მოდის საიტის ქუდი - ბლოკი header, რომელიც შეიცავს გვერდის სათაურს და ნავიგაციის პანელს. შემდეგ მოდის ბლოკი wrapper რომელშიც მოთავსებულია ორი საიდბარი და გვერდის ძირითადი შიგთავსი. ბოლოს კი ფუტერი.
                  
                  ვებგვერდის დასაწყისში განსაზღვრულია styles.css ფაილის ჩაბმა. ეს ფაილი განსაზღვრავს სტილს ვებგვერდის ელემენტებისთვის. ამისათვის ვებგვერდთან ერთად იმავე საქაღალდეში უნდა შევქმნათ ფაილი styles.css და ჩავწეროთ მასში შემდეგი სტილები:
                  
                  * {
                      box-sizing: border-box;
                  }
                  html, body, div, span, h1, h2, h3, h4, h5, h6, p, a, ul, li{
                                  
                      margin: 0;
                      padding: 0;
                      border: 0;
                      font-size: 100%;
                      vertical-align: baseline;
                  }
                  body {
                      font-family: Verdana, Arial, sans-serif;   
                      background-color: #f7f7f7;
                  }
                  #header{
                      background-color: #f4f4f4;
                  }
                  #header h1 {
                      font-size: 24px;
                      text-transform: uppercase;
                      font-weight: bold;
                      padding: 30px 30px 30px 10px;
                      clear: both;
                  }
                  #nav {
                      background-color: #eee;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav li {
                      float: left;
                      list-style: none;  
                  }
                  #nav a {
                      display: block;
                      color: black;
                      padding: 10px 25px;
                      text-decoration: none;
                      border-right: 1px solid #ccc;
                  }
                  #nav li:last-child a {
                      border-right: none;
                  }
                  #nav a:hover {
                      font-weight: bold;
                  }
                  #nav:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  .wrapper{
                      background-color: #f7f7f7;
                  }
                  .aside h2 {
                      font-size: 0.95em;
                      margin-top: 15px;
                  }
                  .aside h3 {
                      font-size: 0.85em;
                      margin-top: 10px;
                  }
                  .aside p, .aside li {
                      font-size: .75em;
                      margin-top: 10px;  
                  }
                  .aside li{
                      list-style-type: none;
                  }
                  #sidebar1 {
                      float: left;
                      width: 20%;
                      padding: 0 10px 0 20px;
                  }
                  #sidebar2 {
                      float: right;
                      width: 20%;
                      padding: 0 20px 0 10px;
                  }
                  #article{
                      background-color: #fafafa;
                      border-left: 1px solid #ccc;
                      border-right: 1px solid #ccc;
                      margin-left: 20%;
                      margin-right: 20%;
                      padding: 15px;
                      width: 60%;
                  }
                  #article:after{
                      clear:both;
                      display:table;
                      content:'';
                  }
                  #article h2{
                      font-size: 1.3em;
                      margin-bottom:15px;
                  }
                  #article p{
                      line-height: 150%;
                      margin-bottom: 15px;
                  }
                  #footer{
                      border-top: 1px solid #ccc;
                      font-size: .8em;   
                      text-align: center;
                      padding: 10px 10px 30px 10px;
                  }
                  #nav ul, #header h1, .wrapper, #footer p {
                      max-width: 1200px;
                      margin: 0 auto;
                  }
                  .wrapper, #nav, #header, #footer{
                      min-width: 768px;
                  }
                  პირველი სამი სტილი აუქმებს ელემენტების თვისებებს მიუთითებლობისას და ადგენს სტილს body-სთვის.
                  
                  მომდევნო ორი სტილი განსაზღვრავს ქუდის და გვერდის სათაურის სტილს:
                  
                  #header{
                      background-color: #f4f4f4;
                  }
                  #header h1 {
                      font-size: 24px;
                      text-transform: uppercase;
                      font-weight: bold;
                      padding: 30px 30px 30px 10px;
                      clear: both;
                  }
                  შემდეგი რამდენიმე სტილი განსაზღვრავს ჰორიზონტალური ნავიგაციის პანელის იერსახეს:
                  
                  #nav {
                      background-color: #eee;
                      border-top: 1px solid #ccc;
                      border-bottom: 1px solid #ccc;
                  }
                  #nav li {
                      float: left;
                      list-style: none;  
                  }
                  #nav a {
                      display: block;
                      color: black;
                      padding: 10px 25px;
                      text-decoration: none;
                      border-right: 1px solid #ccc;
                  }
                  #nav li:last-child a {
                      border-right: none;
                  }
                  #nav a:hover {
                      font-weight: bold;
                  }
                  #nav:after {
                      content: " ";
                      display: table;
                      clear: both;
                  }
                  ჰორიზონტალური ნავიგაციის პანელის შექმნა დაწვრილებით იყო აღწერილი წინა თემებში.
                  
                  შემდეგ მოდის გვერდის შუა ნაწილისკერძოდ, საიდბარების იერსახის განმსაზღვრელი სტილები:
                  
                  .wrapper{
                      background-color: #f7f7f7;
                  }
                  .aside h2 {
                      font-size: 0.95em;
                      margin-top: 15px;
                  }
                  .aside h3 {
                      font-size: 0.85em;
                      margin-top: 10px;
                  }
                  .aside p, .aside li {
                      font-size: .75em;
                      margin-top: 10px;  
                  }
                  .aside li{
                      list-style-type: none;
                  }
                  #sidebar1 {
                      float: left;
                      width: 20%;
                      padding: 0 10px 0 20px;
                  }
                  #sidebar2 {
                      float: right;
                      width: 20%;
                      padding: 0 20px 0 10px;
                  }
                  wrapper კლასის სტილი საშუალებას გვაძლებს განვსაზღვროთ ფონი გვერდითა პანელებისთვის. თითოეული საიდბარისთვის გამოყოფილია გვერდის სიგანის 20 %. პროცენტული ზომები საშუალებას გვაძლევს ავტომატურად ვცვალოთ საიდბარების ზომები ბრაუზერის ზომების შეცვლისას. 
                  
                  შემდეგ მოდის გვერდის ძირითადი შიგთავსის და ფუტერის სტილიზაცია. 
                  
                  #article{
                      background-color: #fafafa;
                      border-left: 1px solid #ccc;
                      border-right: 1px solid #ccc;
                      margin-left: 20%;
                      margin-right: 20%;
                      padding: 15px;
                      width: 60%;
                  }
                  #article:after{
                      clear:both;
                      display:table;
                      content:'';
                  }
                  #article h2{
                      font-size: 1.3em;
                      margin-bottom:15px;
                  }
                  #article p{
                      line-height: 150%;
                      margin-bottom: 15px;
                  }
                  #footer{
                      border-top: 1px solid #ccc;
                      font-size: .8em;   
                      text-align: center;
                      padding: 10px 10px 30px 10px;
                  }
                  რადგანაც გვერდითა პანელებს აქვთ სიგანე 20 %, ძირითადი ნაწილისთვის სიგანე მითითებულია 60 % და მარჯვენა და მარცხენა გარე დაშორებები 20 %-ის ოდენობით.
                  
                  სულ ბოლოს მოდის ორი საკმაოდ მნიშვნელოვანი სტილი:
                  
                  #nav ul, #header h1, .wrapper, #footer p {
                      max-width: 1200px;
                      margin: 0 auto;
                  }
                  .wrapper, #nav, #header, #footer{
                      min-width: 768px;
                  }
                  ჯერ განსაზღვრულია ძირითადი სელექტორებისთვის მაქსიმალური სიგანე 1200 პიქსელი. რაც იმას ნიშნავს, რომ ამ ელემენტების სიგანე არ იქნება 1200 პიქსელზე მეტი. ავტომატური გარე დაშორებები მარჯვნიდან და მარცხნიდან ვებგვერდს გაასაშუალებს ჰორიზონტალურად. შესაბამისად, თუ ბრაუზერის სიგანე იქნება 1200 პიქსელზე მეტი, მაგალითად, 1400 პიქსელი, ყველა ელემენტი მოთავსდება 1200 პიქსელ სიგანეში და მარჯვნივ და მარცხნივ გაჩნდება (1400-1200)/2=100 პიქსელის სიგანის გარე დაშორება.
                  
                  მეორე სტილი ზღუდავს მინიმალურ სიგანეს და თუ ბრაუზერის სიგანე ჩამოცდება 768 პიქსელს, გაჩნდება ჰორიზონტალური გადახვევის ზოლი.
                  
                  შედეგად ვღებულობთ ასეთ ვებგვერდს:`
              },
              {
                  title:"პოზიციონირება",
                  data:`CSS იძლევა ელემენტების პოზიციონირების საშუალებას, ანუ ელემენტის მოთავსებას ვებგვერდის გარკვეულ ადგილას. ძირითადი თვისება, რომელიც ამისთვის გამოიყენება არის position. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  static: სტანდარტული პოზიციონირება, მნიშვნელობა მიუთითებლობისას
                  absolute: ელემენტის პოზიციონირება ხდება მისი შემცველი ელემენტის, კონტეინერის მიმართ, თუ  კონტეინერს არ აქვს მნიშვნელობა position:static
                  relative: ელემენტის მდებარეობა განისაზღვრება მიუთითებლობისას მისი პოზიციის მიმართ. როგორც წესი ის გამოიყენება არა ელემენტის პოზიციის განსაზღვრისთვის, არამედ მასში შემავალი ელემენტებისთვის ათვლის წერტილის დასადგენად აბსოლუტური პოზიციონირებისას
                  fixed: ელემენტის პოზიცია განისაზღვრება ბრაუზერის ფანჯრის მიმართ, რაც საშუალებას გვაძლევს შევქმნათ ფიქსირებული ელემენტები, რომლებიც უძრავნი რჩებიან გადახვევისას
                  არ შეიძლება float თვისებასთან ერთად პოზიციონირების გამოყენება static მნიშვნელობის გარდა.
                  
                  აბსოლუტური პოზიცია
                  
                  აბსოლუტური პოზიცია განისაზღვრება მნიშვნელობით absolute. ბრაუზერს გააჩნია ზედა, ქვედა, მარჯვენა და მარცხენა კიდეები. თითოეული მათგანისთვის CSS-ში არის შესაბამისი თვისება: left (დაშორება მარცხნიდან), right (დაშორება მარჯვნიდან), top (დაშორება ზემოდან), bottom (დაშორება ქვემოდან). მათი მნიშვნელობები მიეთითება პიქსელებში px, em  ერთეულებში ან პროცენტებში. არაა აუცილებელი ოთხივე კიდიდან დაშორების მითითება, როგორც წესი, საკმარისია ზედა და მარცხენა კიდეებიდან დაშორების მითითება:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .header {
                                  position: absolute;
                                  left: 100px;
                                  top: 50px;
                                  width: 430px;
                                  height: 100px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="header"></div>
                          <p>HELLO WORLD</p>
                      </body>
                  </html>
                  ელემენტი div აბსოლუტური პოზიციონირებით იქნება მოთავსებული ბრაუზერის მარცხენა კიდიდან 100 პიქსელის და ზედა კიდიდან 50 პიქსელის დაშორებით
                  
                  HTML5-ის დოკუმენტი
                  
                  ამასთან, არა აქვს მნიშვნელობა, რომ div ელემენტის მერე კიდევ მოდის სხვა ელემენტები. მას მიუხედავად ყველაფრისა ექნება ეს პოზიცია.
                  
                  თუ ელემენტი, რომელსაც აქვს აბსოლუტური პოზიცია, მოთავსებულია სხვა ელემენტის (კონტეინერის) შიგნით და ამ კონტეინერის position თვისების მნიშვნელობა განსხვავებულია static-საგან, ელემენტი პოზიციას პიიღებს კონტეინერის მიმართ. 
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .outer {
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 430px;
                                  height: 100px;
                                  border: 1px solid #ccc;
                              }
                              .inner{
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 50px;
                                  height: 50px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="outer">
                              <div class="inner"></div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ფარდობითი პოზიცია
                  
                  ფარდობითი პოზიცია განისაზღვრება მნიშვნელობით relative. კონკრეტული პოზიციის მისათითებლად, თუ რამდენზე ხდება პოზიციის წანაცვლება, გამოიყენება იგივე თვისებები: left, right, top, bottom:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              .outer {
                                  position: relative;
                                  left: 80px;
                                  top: 40px;
                                  width: 300px;
                                  height: 100px;
                                  border: 1px solid #ccc;
                              }
                              .inner{
                                  position: absolute;
                                  left: 80px;
                                  top: 40px;
                                  width: 50px;
                                  height: 50px;
                                  background-color: rgba(128, 0, 0, 0.5);
                              }
                          </style>
                      </head>
                      <body>
                          <div class="outer"><div class="inner"></div></div>
                      </body>
                  </html>
                   
                  
                  თვისება z-index
                  
                  მიუთითებლობისას, თუ ორი ელემენტის მდებარეობა იკვეთება ერთმანეთში, ზემოდან გამოჩნდება ის ელემენტი, რომელიც html-ში არის აღწერილი ბოლოს. z-index თვისების მეშვეობით შესაძლებელია ამ თანმიმდევრობის შეცვლა. z-index ღებულობს რიცხვით მნიშვნელობებს. ელემენტი, რომლის z-index მეტია, გამოჩნდება ზემოდან.
                  
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>პოზიციონირება</title>
                          <style>
                              body{
                                  margin:0;
                                  padding:0;
                              }
                              .content{
                                  position: relative;
                                  top: 15px;
                                  left: 20px;
                                  width: 250px;
                                  height: 180px;
                                  background-color: #eee;
                                  border: 1px solid #ccc;
                              }
                              .redBlock{
                                  position: absolute;
                                  top: 20px;
                                  left:50px;
                                  width: 80px;
                                  height: 80px;
                                  background-color: red;
                              }
                              .blueBlock{
                                  position: absolute;
                                  top: 80px;
                                  left: 80px;
                                  width: 80px;
                                  height: 80px;
                                  background-color: blue;
                              }
                          </style>
                      </head>
                      <body>
                          <div class="content">
                              <div class="redBlock"></div>
                              <div class="blueBlock"></div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მივუთითოთ z-index ბლოკისთვის redBlock:
                  
                  .redBlock{
                      z-index: 100;
                                                  
                      position: absolute;
                      top: 20px;
                      left:50px;
                      width: 80px;
                      height: 80px;
                      background-color: red;
                  }
                  z-index მნიშვნელობა მითითებულია 100, თუმცა ვინაიდან მეორე ელემენტს z-index მითითებული არა აქვს და, შესაბამისად ნულის ტოლია, საკმარისია მივუთითოთ ნებისმიერი ნულზე მეტი რიცხვი.
                  
                  ახლა უკვე წითელი ელემენტი გადაფარავს ლურჯს:`
              },
              {
                title:"ფიქსირებული პოზიცია",
                data:`ფიქსირებული პოზიცია წარმოადგენს ელემენტების ბრაუზერში უძრავად მოთავსების გავრცელებულ მეთოდს. საკმაოდ ხშირად საიტებზე შეიძლება ვნახოთ ნავიგაციის პანელი, რომელიც არ იცვლის პოზიციას და არის უძრავად გადახვევის დროს.

                ელემენტისთვის ფიქსირებული პოზიციის მისაცემად საჭიროა მივანიჭოთ მნიშვნელობა position: fixed და left, right, top, bottom თვისებებით განვუსაზღვროთ მდებარეობა:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <title>პოზიციონირება</title>
                        <style>
                            body{
                                margin:0;
                                padding:0;
                                overflow: auto;
                            }
                            .toolbar{
                                position: fixed;
                                top: 0;
                                left: 0;
                                right: 0;
                                background-color: #222;
                                border-bottom: 1px solid #ccc;
                            }
                            .toolbar a{
                                color: #eee;
                                display: inline-block;
                                padding: 10px;
                                text-decoration: none;
                                font-family: Verdana;
                            }
                            .content{
                                margin-top: 50px;
                                padding: 10px;              
                            }
                        </style>
                    </head>
                    <body>
                        <div class="toolbar">
                            <a href="#">მთავარი</a>
                            <a href="#">ბლოგი</a>
                            <a href="#">კონტაქტი</a>
                            <a href="#">საიტის შესახებ</a>
                        </div>
                        <div class="content"><h3>XXXV ღამით ყველა კატა ნაცრისფერია</h3>
                                მოუთმენლად ელოდნენ ამ საღამოს პორთოსი და დ'არტანიანი და, როგორც
                                იქნა, ეღირსათ დაღამება.
                                დ'არტანიანი, ჩვეულებრივ, ცხრა საათზე მივიდა მილედის სანახავად. მას
                                არასოდეს არ მიუღია იგი ასე კარგად. გასკონელმა მაშინვე იგრძნო, რომ
                                ქალბატონისათვის კეტის მიერ გადაცემული წერილი იყო მიზეზი მისი
                                მხიარულებისა.
                                შემოვიდა კეტი და შარბათი მოართვა. მასაც მხიარული, აღტაცებული სახით
                                შეჰყურებდა მილედი და ტკბილად უღიმოდა. მაგრამ ისეთი დაღონებული იყო
                                საბრალო გოგო, რომ ვერც კი შეამჩნია თავისი ქალბატონის გულკეთილობა.
                                დ'არტანიანი ხან ერთ ქალს შეხედავდა, ხან მეორეს და იძულებული იყო,
                                ეღიარებინა თავისი თავის წინაშე, რომ შეცდომა დაეშვა ბუნებას ამ ქალების
                                შექმნაში, როდესაც ცნობილი ქალბატონისათვის საზიზღარი, სათნოების
                                უარმყოფელი სული ჩაედგა, ხოლო მოახლისათვის, პირიქით, — დიდებულის</div>
                    </body>
                </html>
                 
                
                HTML5-ის დოკუმენტი
                
                იმისათვის, რომ ფიქსირებული ბლოკი გაიშალოს ბრაუზერის მთელ სიგანეზე, მას ენიჭება სამი მნიშვნელობა:
                
                top: 0;
                left: 0;
                right: 0;
                ფიქსირებული ბლოკი (ისევე როგორც აბსოლუტური პოზიციის მქონე) თითქოს არ არსებობს დანარჩენი ბლოკებისთვის, რადგან იგი ამოვარდნილია html-ის ჩვეულებრივი თანმიმდევრობისაგან. ამიტომ ფიქსირებული ელემენტებით შეიძლება გადაიფაროს სხვა ელემენტები. ასე რომ არ მოხდეს, ძირითადი ბლოკისთვის მიცემულია დაშორება ზემოდან margin-top:50px. ვინაიდან ეს დაშორება ითვლება ზედა ბრაუზერის კიდიდან (და არა ფიქსირებული ელემენტიდან), იგი მეტი უნდა იყოს ფიქსირებული ელემენტის სიმაღლეზე.`
            }
           
            ]
        },
        {
            title:"	თავი 8. ტრანსფორმირება, გადასვლები და ანიმაციები",
            content:[
                {
                    title:"ტრანსფორმირება",
                    data:`CSS3-ის ერთ-ერთი სიახლე წინა ვერსიებთან შედარებით არის ჩაშენებული ელემენტის ტრანსფორმირების შესაძლებლობა. ტრანსფორმირების ქვეშ იგულისხმება ელემენტის ბრუნვა, მასშტაბირება, დახრა ან გადაადგილება ჰორიზონტალური ან ვერტიკალური მიმართულებით. ტრანსფორმირებისთვის გამოიყენება თვისება transform.

                    ბრუნვა
                    
                    ელემენტის მოსატრიალებლად თვისება transform იყენებს ფუნქციას rotate:
                    
                    transform: rotate(30deg);
                    სიტყვა rotate-ს შემდეგ ფრჩხილებში იწერება ბრუნვის კუთხე გრადუსებში, ჩვენს შემთხვევაში 30 გრადუსი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .rotated{
                                    transform: rotate(30deg);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="rotated">rotate(30deg)</div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    უნდა აღინიშნოს, რომ ტრიალისას ელემენტი შეიძლება გადაეფაროს სხვა ელემენტებს, ვინაიდან ჯერ ხდება ელემენტისთვის ადგილის გამოყოფა და მერე ტრიალი.
                    
                    ბრუნვის კუთხე შეიძლება იყოს უარყოფითიც. ამ შემთხვევაში ელემენტი ტრიალდება საპირისპირო მიმართულებით.
                    
                    მასშტაბირება
                    
                    მასშტაბირებას აქვს შემდეგი სახე:
                    
                    transform: scale(1.5);
                    მოცემულ მაგალითში ელემენტის ზომები იზრდება 1.5-ჯერ.
                    
                    ვნახოთ მაგალითი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .halfScale{
                                    transform: scale(0.5);
                                }
                                .doubleScale{
                                    transform: scale(2);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="doubleScale">scale(2)</div>
                            <div></div>
                            <div class="halfScale">scale(0.5)</div>
                        </body>
                    </html>
                    1-ზემეტი მნიშვნელობისას ელემენტის ზომები იზრდება, 1-ზე ნაკლებისას - მცირდება.
                    
                    მასშტაბირება შეიძლება გამოვიყენოთ ცალ-ცალკე ვერტიკალური და ჰორიზონტალური მიმართულებებისთვის:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .scale1{
                                    transform: scale(2, 0.5);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="scale1">scale(2, 0.5)</div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    მოცემულ მაგალითში ჰორიზონტალურად ხდება სკალირება კოეფიციენტით 2 (იზრდება ორჯერ), ხოლო ვერტიკალურად - კოეფიციენტით 0.5 (მცირდება ორჯერ).
                    
                    ასევე შეიძლება სკალირება მხოლოდ ერთი მიმართულებით ფუნქციების: scaleX() -სკალირება ჰორიზონტალურად და scaleY() - სკალირება ვერტიკალურად, მეშვეობით.
                    
                    სკალირებისთვის უარყოფითი მნიშვნელობის მინიჭებით შესაძლებელია მივიღოღ სარკისებური ანარეკლის ეფექტი:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .scale1{
                                    transform: scaleX(-1);
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="scale1">scaleX(-1)</div>
                            <div></div>
                        </body>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გადაადგილება
                    
                    ელემენტის გადასასდგილებლად გამოიყენება ფუნქცია translate:
                    
                    transform: translate(offset_X, offset_Y);
                    offset_X-ის მნიშვნელობა განსაზღვრავს, რამდენით გადაადგილდება ელემენტი ჰორიზონტალური მიმართულებით, offset_Y - ვერტიკალური მიმართულებით. მაგალითად, გადავაადგილოთ ბლოკი 30 პიქსელით ქვევით და 50 პიქსელით მარჯვნივ:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .translated{
                                    transform: translate(50px, 30px);
                                    background-color:red;
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="translated"></div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გადაადგილების ერთეულებად შეიძლება CSS-ის ნებისმიერი ერთეულის გამოყენება: px, em, % და ა. შ.
                    
                    დამატებითი ფუნქციების მეშვეობით შესაძლებელია გადაადგილება მხოლოდ ჰორიზონტალური (ფუნქცია translateX()) ან ვერტიკალური (ფუნქცია translateY()) მიმართულებით.
                    
                    უარყოფითი მნიშვნელობების მინიჭებით შესაძლებელია გადაადგილება საწინააღმდეგო მიმართულებებით.
                    
                    დახრა
                    
                    ელემენტის დახრისთვის გამოიყენება ფუნქცია skew().
                    
                    transform: skew(X, Y);
                    პირველი პარამეტრი განსაზღვრავს დახრის კუთხეს X ღერძის მიმართ, მეორე - Y ღერძის მიმართ.
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 120px;
                                    height: 120px;
                                    margin:5px;
                                    padding: 40px 10px;
                                    
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                    display: inline-block;
                                }
                                .skewed{
                                    transform: skew(30deg, 10deg);
                                    background-color:red;
                                }
                            </style>
                        </head>
                        <body>
                            <div></div>
                            <div class="skewed"></div>
                            <div></div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    ელემენტის დასახრელად მხოლოდ ერთი ღერძის მიმართ, მეორე ღერძის მიმართ დახრის 0-ის ტოლი კუთხე უნდა მივუთითოთ.
                    
                    მაგალითად, 45 გრადუსით მხოლოდ X ღერძის მიმართ:
                    
                     
                    
                    transform: skew(45deg, 0);
                    45 გრადუსით მხოლოდ Y ღერძის მიმართ:
                    
                    transform: skew(0,45deg);
                    მხოლოდ X და Y ღერძის მიმართ დახრისთვის არსებობს დამატებითი ფუნქციებიც: skewX() და skewY(). მაგალითად:
                    
                    transform: skewX(45deg);
                    დახრის კუთხე შეიძლება იყოს უარყოფითი. ამ შემთხვევაში ელემენტის დახრა ხდება საწინააღმდეგო მიმართულებით:
                    
                    transform: skewX(-30deg);
                    კომბინირება
                    
                    თუ ერთდროულად რამდენიმე ტრანსფორმირების განხორციელება გვინდა, შესაძლოა მათი კომბინირება:
                    
                    transform: translate(50px, 100px) skew(30deg, 10deg) scale(1.5) rotate(90deg);
                     
                    
                    ტრანსფორმაციის ამოსავალი წერტილი
                    
                    მიუთითებლობისას ტრანსფორმირების ამოსავალ წერტილად (რომლის მიმართაც ხდება ელემენტის ტრანსფორმირება) ბრაუზერი იყენებს ელემენტის ცენტრს. transform-origin თვისების მეშვეობით შესაძლებელია ამოსავალი წერტილის შეცვლა. იგი იღებს მნიშვნელობას px, em და % ერთეულებში. magaliTad:
                    
                    transform-origin: 20% 40%;
                    ასევე შეიძლება მიეთითოს ელემენტის ერთ-ერთი კუთხე:
                    
                    left top: მარცხენა ზედა კუთხე
                    left bottom: მარცხენა ქვედა კუთხე
                    right top: მარჯვენა ზედა კუთხე
                    right bottom: მარჯვენა ქვედა კუთხე
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>ტრანსფორმირება</title>
                            <style>
                                div{
                                    background-color: #ccc;
                                    width: 100px;
                                    height: 100px;
                                    margin: 80px 30px;
                                    float: left;
                                    box-sizing: border-box;
                                    border: 1px solid #333;
                                }
                                .transform1{
                                    transform: rotate(-45deg);
                                }
                                .transform2{
                                    transform-origin: left top;
                                    transform: rotate(-45deg);
                                }
                                .transform3{
                                    transform-origin: right bottom;
                                    transform: rotate(-45deg);
                                }
                            </style>
                        </head>
                        <body>
                            <div class="transform1"></div>
                            <div class="transform2"></div>
                            <div class="transform3"></div>
                        </body>
                    </html>`
                },
                {
                  title:"გადასვლები",
                  data:`გადასვლა (transition) წარმოადგენს ანიმაციას ერთი სტილიდან მეორეში გარკვეული პერიოდის განმავლობაში.

                  გადასვლისთვის პირველ რიგში, საჭიროა ორი განსხვავებული სტილი ელემენტისთვის: ერთი - საწყისი, რომელიც ეექნება ელემენტს თავიდან და მეორე - გადასვლის შედეგი. ვნახოთ გადასვლის მარტივი მაგალითი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>გადასვლები</title>
                          <style>
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                  
                                  background-color: #ccc;
                                  transition-property: background-color;
                                  transition-duration: 2s;
                              }
                              div:hover{
                                  background-color: red;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  აქ ხდება div ელემენტის ფონის ანიმაცია. როცა გადავატარებთ მაუსს ფერი შეიცვლება წითელზე არა ერთბაშად, არამედ 2 წამის განმავლობაში და როცა მოვაშორებთ მაუსს დაუბრუნდება საწყის ფერს ასევე 2 წამის განმავლობაში. 
                  
                  იმისათვის, რომ მივუთითოთ თუ რომელი თვისების ანიმირება ხდება, ეს თვისება უნდა მივუთითოთ მნიშვნელობად თვისებას transition-property.
                  
                  transition-property: background-color;
                  შესაძლებელია სხვა თვისებების ანიმირებაც. მაგალითად: color, background-color, border-color. იმ თვისებების სრული სია, რომელთა ანიმირებაც შესაძლებელია, შეგიძლიათ ნახოთ მისამართზე: http://www.w3.org/TR/css3-transitions/#animatable-properties.
                  
                  გადასვლას უნდა მიეთითოს ხანგრძლივობა:
                  
                  transition-duration: 2s;
                  მისი მნიშვნელობა შეიძლება განისაზღვროს წამებით (s) ან მილიწამებით (ms):
                  
                  transition-duration: 500ms;
                  და ბოლოს, საჭიროა ანიმაციის ინიციატორი და ანიმირებადი თვისების ფინალური მნიშვნელობა. ინიციატორს წარმოადგენს მოქმედება, რომლის დროსაც ხდება ერთი სტილის შეცვლა მეორით. ჩვენს შემთხვევაში ინიციატორს წარმოადგენს ფსევდოკლასო :hover. ანუ ანიმაცია მოქმედებაში მოდის მაუსის გადატარებისას.
                  
                  :hover ფსევდოკლასის გარდა ინიციატორად შეიძლება გამოვიყენოთ სხვა ფსევდოკლასებიც, მაგალითად :active (ბმული მაუსის დაჭერის დროს), :focus (ელემენტის მიერ ფოკუსის მიღება).
                  
                  ასევე გადასვლის ანიმაციის გასაშვებად შეიძლება JavaScript-ის გამოყენებაც.
                  
                  ანიმაცია რამდენიმე თვისებით
                  
                  საჭიროებისას შესაძლებელია ერთდროულად CSS-ის რამდენიმე თვისების ანიმირება. მაგალითად, შევცვალოთ წინა მაგალითში სტილები:
                  
                  div{
                      width: 100px;
                      height: 100px;
                      margin: 40px 30px;
                      border: 1px solid #333;
                      background-color: #ccc;
                      
                      transition-property: background-color, width, height, border-color;
                      transition-duration: 2s;
                  }
                  div:hover{
                      background-color: red;
                      width: 120px;
                      height: 120px;
                      border-color: blue;
                  }
                  აქ ხდება ერთდროულად 4 თვისების ანიმირება. ანიმაციის დრო თოთოეულისთვის არის 2 წამი. თუმცა შესაძლებელია თითოეული თვისებისთვის სხვადასხვა დრო მიეთითოს:
                  
                  transition-property: background-color, width, height, border-color;
                  transition-duration: 2s, 3s, 1s, 2s;
                  ისევე როგორც transition-property-ში არის ჩამოთვლილი თვისებები, transition-duration-სი ჩამოთვლილია შესაბამისი ხანგრძლივობები იგივე თანმიმდევრობით. მაგალითად, width თვისების ანიმაციის ხანგრძლივობა იქნება 2 წამი.
                  
                  მძიმეებით ჩამოთვლის გარდა შესაძლებელია მიეთითოს ერთდროულად ყველა თვისების ანიმაცია. ამისთვის მიეთითება all:
                  
                  ​​​​​​​transition-property: all;
                  transition-duration: 2s;
                  ანიმაციის ფუნქციები
                  
                  თვისება transition-timing-function საშუალებას იძლევა გაკონტროლდეს ანიმაციის ხანგრძლივობა და შესრულება. ანუ ეს თვისება განსაზღვრავს, როდის აჩქარდეს ან შენელდეს ანიმაცია. იგი იღებს შემდეგ მნიშვნელობებს:
                  
                  linear: წრფივი ფუნქცია, რომლის დროსაც ანიმაცია თანაბრად სრულდება
                  ease: ფუნქცია, რომლის დროსაც ანიმაცია სწრაფდება შუისკენ და ნელდება ბოლოსკენ. იგი უზრუნველყოფს ანიმაციის უფრო ბუნებრივ შესრულებას
                  ease-in: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის დასაწყისში
                  ease-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის ბოლოს
                  ease-in-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება დასაწყისში და ბოლოსკენ
                  cubic-bezier: ანიმაციისთვის გამოიყენება ბესიეს კუბური ფუნქცია
                  გამოვიყენოთ ფუნქცია ease-in-out:
                  
                  ​​​​​​​<!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>გადასვლები</title>
                          <style>
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                  
                                  background-color: #ccc;
                                  transition-property: background-color, width;
                                  transition-duration: 2s, 10s;
                                  transition-timing-function: ease-in-out;
                              }
                              div:hover{
                                  background-color: red;
                                  width: 200px;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  ბეზიეს კუბური ფუნქციის გამოყენებისთვის მას უნდა გადავცეთ გარკვეული პარამეტრები:
                  
                  transition-timing-function: cubic-bezier(.5, .6, .24, .18);
                  გადასვლის დაყოვნება
                  
                  თვისება transition-delay საშუალებას გვაძლევს დავაყოვნოთ გადასვლის დაწყება:
                  
                  transition-delay: 500ms;
                  დრო ასევე მიეთითება წამებში (s) ან მილიწამებში (ms).
                  
                  თვისება transition
                  
                  თვისება transition წარმოადგენს ზემოთ განხილული ყველა თვისების შემოკლებულ ჩანაწერს. ნაცვლად შემდეგი ჩამონათვალისა:
                  
                  transition-property: background-color;
                  transition-duration: 3s;
                  transition-timing-function: ease-in-out;
                  transition-delay: 500ms;​​​​​​​
                  შეგვიძლია ჩავწეროთ შემოკლებულად:
                  
                  transition: background-color 3s ease-in-out 500ms;`
              },
              {
                  title:"ანიმაცია",
                  data:`
                  ანიმაცია ელემენტის სტილის ანიმირების მრავალფეროვან საშუალებას იძლევა. თუ გადასვლის დროს ჩვენ გვაქვს მხოლოდ საწყისი და საბოლოო სტილის მითითების საშუალება, ანიმაციის დროს ასევე შეგვიძლია მრავალი შუალედური სტილის მინიჭებაც.
                  
                  ანიმაცია ეყრდნობა საკვანძო კადრების (keyframes) თანმიმდევრულ ცვლას. თითოეული საკვანძო კადრი წარმოადგენს თვისებების ნაკრებს. მათი თანმიმდევრული ცვლა ქმნის ანიმაციას.
                  
                  საკვანძო კადრების გამოცხადება ხდება შემდეგნაირად:
                  
                  @keyframes ანიმაციის_დასახელება {
                      from {
                          /* საწყისი CSS სტილი */
                      }
                      to {
                          /* საბოლოო CSS სტილი */
                      }
                  }
                  საკვანძო სიტყვას @keyframes მოსდევს მისი დასახელება. შემდეგ ფიგურულ ფრჩხილებში ხდება სულ მცირე, ორი სტილის განსაზღვრა. from სიტყვის შემდეგ მოდის სტილი, რომელიც ელემენტს გააჩნია ანიმაციის დასაწყისში, to-ს შემდეგ კი - სტილი, რომელსაც ელემენტი იღებს ანიმაციის ბოლოს. თითოეული სტილი ფორმირდება ჩვეულებრივი CSS-ის სტილის მსგავსად ერთი ან რამდენიმე თვისების მითითებით.
                  
                  მაგალითად, შევქმნათ ანიმაცია ელემენტის ფონის ფერისთვის:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ანიმაცია</title>
                          <style>
                              @keyframes backgroundColorAnimation {
                                  from {
                                      background-color: red;
                                  }
                                  to {
                                      background-color: blue;
                                  }
                              }
                              div{
                                  width: 100px;
                                  height: 100px;
                                  margin: 40px 30px;
                                  border: 1px solid #333;
                                   
                                  background-color: #ccc;
                                  animation-name: backgroundColorAnimation;
                                  animation-duration: 2s;
                              }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  მოცემულ მაგალითში ანიმაციის სახელია "backgroundColorAnimation". ზოგადად, ანიმაციის სახელი შეიძლება ნებისმიერი იყოს.
                  
                  ამ ანიმაციაში ხდება წითელი ფერიდან ლურჯში გადასვლა. ანიმაციის დასრულების შემდეგ ელემენტი მიიღებს იმ ფერს, რომელიც განსაზღვრული აქვს ელემენტს შესაბამისი სტილით.
                  
                  იმისათვის, რომ ანიმაცია გამოვიყენოთ ელემენტისთვის, ამ ელემენტს სტილში ეთითება თვისება animation-name, რომლის მნიშვნელობაშიც უნდა მივუთიტოთ იმ ანიმაციის სახელი, რომლის გამოყენებაც გვსურს. ელემენტს ასევე ეთითება თვისება animation-duration, რომელიც ანიმაციის ხანგრძლივობას განსაზღვრავს. მოცემულ შემთხვევაში - 2 წამი.
                  
                  აღწერილ შემთხვევაში ანიმაცია იწყება გვერდის ჩატვირთვისას. თუმცა შეიძლება ანიმაციის გაშვება მომხმარებლის მოქმედებისას. მაგალითად, ფსევდოკლასის :hover გამოყენებით ანიმაცია გაიშვებს ელემენტზე მაუსის გადატარებისას:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ანიმაცია</title>
                          <style>
                            @keyframes backgroundColorAnimation {
                              from {
                                  background-color: red;
                              }
                              to {
                                  background-color: blue;
                              }
                          }
                          div{
                              width: 100px;
                              height: 100px;
                              margin: 40px 30px;
                              border: 1px solid #333;
                              background-color: #ccc;
                          }
                          div:hover{                         
                              animation-name: backgroundColorAnimation;
                              animation-duration: 2s;
                          }
                          </style>
                      </head>
                      <body>
                          <div></div>
                      </body>
                  </html>
                  ბევრი საკვანძო კადრი
                  
                  როგორც უკვე აღინიშნა, გარდა საწყისი და საბოლოო კადრისა, შეიძლება ასევე შუალედური კადრების განსაზღვრაც. შუალედურ კადრებს ეთითება პროცენტული მნიშვნელობა, რომლიდანაც ეს კადრი იმოქმედებს.
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                      }
                      25%{
                          background-color: yellow;
                      }
                      50%{
                          background-color: green;
                      }
                      75%{
                          background-color: blue;
                      }
                      to {
                          background-color: violet;
                      }
                  }
                  ანიმაცია დაიწყება წითელი ფერით. დროის 25 %-ის გასვლის შემდეგ ის შეიცვლება ყვითელით, კიდევ 25 %-ის გასვლის შემდეგ - მწვანით და ა. შ.
                  
                  ასევე შეიძლება ერთ საკვანძო კადრში რამდენიმე თვისების ანიმირება მოხდეს:
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                          opacity: 0.2;
                      }
                      to {
                          background-color: blue;
                          opacity: 0.9;
                      }
                  }
                  ასევე შეიძლება განისაზღვროს რამდენიმე დამოუკიდებელი ანიმაცია, ხოლო მათი გამოყენება მოხდეს ერთად:
                  
                  @keyframes backgroundColorAnimation {
                      from {
                          background-color: red;
                      }
                      to {
                          background-color: blue;
                      }
                  }
                  @keyframes opacityAnimation {
                      from {
                          opacity: 0.2;
                      }
                      to {
                          opacity: 0.9;
                      }
                  }
                  div{
                      width: 100px;
                      height: 100px;
                      margin: 40px 30px;
                      border: 1px solid #333;
                      background-color: #ccc;
                      
                      animation-name: backgroundColorAnimation, opacityAnimation;
                      animation-duration: 2s, 3s;
                  }
                  ასეთ დროს თვისებაში animation-name ჩამოითვლება მძიმით გამოყოფილი საჭირო ანიმაციების სახელები. იგივე თანმიმდევრობით მიენიჭება დრო ანიმაციებს.
                  
                  ანიმაციის დასრულება
                  
                  ზოგადად ანიმაციისთვის განკუთვნილი დროის გასვლის შემდეგ ანიმაცია სრულდება. თუმცა დამატებითი თვისებებით შეგვიძლია შევცვალოთ ეს წესი.
                  
                  ასე, მაგალითად, animation-iteration-count განსაზღვრავს, რამდენჯერ უნდა განმეორდეს ანიმაცია:
                  
                  animation-iteration-count: 3;
                  თუ გვინდა, რომ ანიმაცია დაუსრულებლად გაგრძელდეს, ამ თვისებას უნდა მივანიჭოთ მნიშვნელობა infinite:
                  
                  animation-iteration-count: infinite;
                  გამეორებისას ანიმაცია იწყება ისევ საწყისი საკვანძო კადრიდან. მაგრამ animation-direction: alternate; თვისების გამოყენებით გამეორებისას ანიმაცია შესრულდება უკუმიმართულებით.
                  
                  animation-name: backgroundColorAnimation, opacityAnimation;
                  animation-duration: 2s, 2s;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  ანიმაციის დასრულების შემდეგ ბრაუზერი ელემენტს ანიჭებს იმ სტილს, რომელიც მას ჰქონდა ანიმაციის დაწყებამდე. მაგრამ animation-fill-mode: forwards თვისების გამოყენებით ელემენტს ანიმაციის დასრულების მერე ენიჭება ის სტილი, რომელიც იყო განსაზღვრული ბოლო საკვანძო კადრით.
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 2s;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  animation-fill-mode: forwards;
                  ანიმაციის დაყოვნება
                  
                  animation-delay თვისების გამოყენებით შეიძლება დავაყოვნოთ ანიმაციის დაწყება:
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 5s;
                  animation-delay: 1s;    /* დაყოვნება 1 წამით */
                  ანიმაციის ფუნქციები
                  
                  ისევე როგორც გადასვლებისთვის, თვისება transition-timing-function საშუალებას იძლევა გაკონტროლდეს ანიმაციის ხანგრძლივობა და შესრულება. ანუ ეს თვისება განსაზღვრავს, როდის აჩქარდეს ან შენელდეს ანიმაცია. იგი იღებს შემდეგ მნიშვნელობებს:
                  
                  linear: წრფივი ფუნქცია, რომლის დროსაც ანიმაცია თანაბრად სრულდება
                  ease: ფუნქცია, რომლის დროსაც ანიმაცია სწრაფდება შუისკენ და ნელდება ბოლოსკენ. იგი უზრუნველყოფს ანიმაციის უფრო ბუნებრივ შესრულებას
                  ease-in: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის დასაწყისში
                  ease-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება მხოლოდ ანიმაციის ბოლოს
                  ease-in-out: ფუნქცია, რომლის დროსაც აჩქარება ხდება დასაწყისში და ბოლოსკენ
                  cubic-bezier: ანიმაციისთვის გამოიყენება ბესიეს კუბური ფუნქცია
                  თვისება animation
                  
                  თვისება animation საშუალებას იძლევა ყველა ზემოთჩამოთვლილი თვისება გაერთიანდეს და შემოკლებულად ჩაიწეროს:
                  
                  animation: animation-name animation-duration animation-timing-function animation-iteration-count animation-direction animation-delay animation-fill-mode;
                  ამასთან სავალდებულოა მხოლოდ პირველი ორი პარამეტრი: დასახელება და ხანგრძლივობა. დანარჩენი მიეთითება მხოლოდ საჭიროებისამებრ.
                  
                  ავიღოთ თვისებების შემდეგი ერთობლიობა:
                  
                  animation-name: backgroundColorAnimation;
                  animation-duration: 5s;
                  animation-timing-function: ease-in-out;
                  animation-iteration-count: 3;
                  animation-direction: alternate;
                  animation-delay: 1s;
                  animation-fill-mode: forwards;
                  იგივე შეიძლება ჩავწეროთ შემოკლებულად:
                  
                  animation: backgroundColorAnimation 5s ease-in-out 3 alternate 1s forwards;
                  ბანერის შექმნა ანიმაციის მეშვეობით
                  
                  მაგალითისთვის ანიმაციის მეშვეობით შეგვიძლია შევქმნათ ბანერი:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>CSS3-ბანერი</title>
                      <meta charset="utf-8" />
                      <style type="text/css">
                      @keyframes text1
                      {
                          10%{opacity: 1;}
                          40%{opacity: 0;}
                      } 
                      @keyframes text2
                      {
                          30%{opacity: 0;}
                          60%{opacity:1;}
                      }
                      @keyframes banner
                      {
                          10%{background-color: #008978;}
                          40%{background-color: #34495e;}
                          80%{background-color: green;}
                      }
                      .banner
                      {
                          width: 600px;
                          height: 120px;
                          background-color: #777;
                          margin: 0 auto;
                          position: relative;
                      }
                      .text1,.text2
                      {
                          position: absolute;
                          width: 100%;
                          height: 100%;
                          line-height: 120px;
                          text-align: center;
                          font-size: 40px;
                          color: #fff;
                          opacity: 0;
                      } 
                      .text1
                      {
                          animation : text1 6s infinite;
                      } 
                      .text2
                      {
                          animation : text2 6s infinite;
                      } 
                      .animated
                      {
                          opacity: 0.8;
                          position: absolute;
                          width: 100%;
                          height: 100%; 
                          background-color: #34495e;
                          animation: banner 6s infinite;
                      }
                      </style>
                  </head>
                  <body>
                      <div class="banner">
                          <div class="animated">
                              <div class="text1">მხოლოდ ამ თვეში</div>
                              <div class="text2">ფასდაკლება 20%</div>
                          </div>
                      </div>
                  </body>
                  </html>
                  აქ ერთდროულად მუშაობს სამი ანიმაცია. ანიმაცია banner ცვლის ბანერის ფონს, ხოლო text1 და text2 აჩენენ და მალავენ ტექსტს გამჭვირვალობის თვისების გამოყენებით. როცა ჩანს პირველი ტექსტი, მეორე დამალულია და პირიქით. ამით ჩვენ ვღებულობთ ტექსტის ანიმაციას ბანერში.`
              },
          
            ]
        },
        {
            title:"თავი 9. ადაპტირებული დიზაინი",
            content:[
                {
                    title:"შესავალი ადაპტირებულ დიზაინში",
                    data:`დღეისათვის სულ უფრო და უფრო მეტ გავრცელებას პოულობს სხვადასხვა სახის გაჯეტები - სმარტფონები, პლანშეტები, ჭკვიანი საათები და სხვა მოწყობილობები, რომელთაც აქვთ კავშირი ინტერნეტთან და საიტების დათვალიერების საშუალება. ზოგიერთი გათვლებით მთელი ინტერნეტ-ტრაფიკის თითქმის ნახევარი მოდის ასეთ გაჯეტებზე, რომელთა ეკრანი გარჩევადობა (ეკრანის ზომა) მნიშვნელოვნად განსხვავდება ჩვეულებრივი კომპიუტერის ეკრანის გარჩევადობისგან. მთელი პრობლემა მდგომარეობს იმაში, რომ ვებგვერდი სხვადასხვა გარჩევადობის ეკრანზე სხვადასხვანაირად გამოიყურება. თავდაპირველი გადაწყვეტა ამ პრობლემის იყო მათთვის ცალკე ვერსიების დამზადება.

                    მობილური ტელეფონების განვითარების საწყის ეტაპზე მათ მომხმარებლებს შეეძლოთ WAP პროტოკოლის მეშვეობით მიეღოთ სპეციალური wap-საიტები, რომლებიც შექმნილი იყო wml -ის - xml საფუძველზე შექმნილი html-ის მსგავსი ენის მეშვეობით.
                    
                    თუმცა გაჯეტების განვითარებამ მიგვიყვანა იქამდე, რომ დღეისატვის მობილურ ტელეფონებს აქვთ გაცილებით უფრო მეტი შესაძლებლობები ინფორმაციის ეკრანზე გამოტანისთვის, ვიდრე ადრეულ მოწყობილობებს. ამიტომ ვებ-გვერდები მათთვის იქმნება იგივე HTML5-ის და  CSS3-ის გამოყენებით.
                    
                    გარდა ამისა, დიდი რაოდენობის სხვადასხვა სახის მოწყობილობების გაჩენამ შექმნა აუცილებლობა, რომ ვებგვერდები ადაპტირებული იყოს არა მხოლოდ სმარტფონებისა და პლანშეტებისთვის, არამედ ასევე დიდ ეკრანიანი ტელევიზორებისა და სხვა მოწყობილობებისთვის, რომელთაც აქვთ ინტერნეტთან კავშირის და ვებსაიტების დათვალიერების შესაძლებლობა. 
                    
                    ამ პრობლემის გადასაწყვეტად შეიქმნა ადაპტირებული დიზაინის კონცეფცია. მისი არსი მდგომარეობს ეკრანის სიგანიდან გამომდინარე ელემენტების მასშტაბირებასა და გადაწყობაში.
                    
                    თუმცა ახლაც ვხვდებით შემთხვევებს, როცა მობილური მოწყობილობებისთვის იქმნება ცალკე საიტები, რომელთაც ხშირად პრეფიქსად აქვს m.
                    
                    ადაპტირებული დიზაინის ტესტირება
                    
                    ადაპტირებული დიზაინის მქონე ვებგვერდის შექმნის პროცესში შეიძლება გადავაწყდეთ ტესტირების პრობლემებს, ვინაიდან ვებგვერდის შექმნა, როგორც წესი, ჩვეულებრივ კომპიუტერში ხდება. საბედნიეროდ, თანამედროვე ბრაუზერების უმეტესობას საშუალება აქვს მოახდინოს სხვადასხვა ზომის ეკრანის ემულაცია.
                    
                    მაგალითად, Google Chrome-ში უნდა გადავიდეთ More tools => Developer tools (ან დავაჭიროთ F12 კლავიშს კლავიატურაზე). გაიხსნება დეველოპერის პანელი, სადაც არის მობილურის გამოსახულებიანი ღილაკი, რომელზე დაჭერითაც გადავალთ ადაპტირებული დიზაინის ტესტირების რეჟიმში სხვადასხვა მოწყობილობებისთვის:
                    
                    HTML5-ის დოკუმენტი
                    
                    შესაძლებელია ავირჩიოთ კონკრეტული მოწყობილობა (სურათზე არჩეულია iPhone5) ან ავირჩიოთ Responsive და ხელით დავაყენოთ სასურველი ეკრანის ზომები.
                    
                    ადაპტირებული დიზაინის ტესტირების რეჟიმი აქვს სხვა ბრაუზერებსაც. მაგალითად, Mozilla Firefox-ში უნდა შევიდეთ Developer=>Responsive Design Mode.
                    
                    `
                },
                {
                  title:"მეტატეგი Viewport",
                  data:`პირველ რიგში განვიხილოთ ადაპტირებული დიზაინის საკვანძო მომენტი - მეტატეგი Viewport. პრაქტიკულად ამ ტეგიდან იწყება ადაპტირებული დიზაინი. ვთქვათ გვაქვს ასეთი ვებგვერდი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>ჩვეულებრივი ვებგვერდი</title>
                      </head>
                      <body>
                          <h2>ჩვეულებრივი ვებგვერდი</h2>
                      </body>
                  </html>
                  ეს სტანდარტული ვებგვერდია, რომელიც ბრაუზერში ჩანს ასეთნაირად:
                  
                  HTML5-ის დოკუმენტი
                  
                  მაგრამ თუ იგივე გვერდს გავუშვებთ მობილურში ან ბრაუზერის მობილური მოწყობილობის ემულატორში, გაჭირვებით შევძლებთ წაკითხვას, თუ რა წერია:
                  
                  HTML5-ის დოკუმენტი
                  
                  მასშტაბირების გამოყენებით მომხმარებელი შეძლებს წაიკითხოს, თუ რა წერია, მაგრამ ჯერ ერთი, ეს არც ისე მოხერხებულია, მეორეც - ვებგვერდზე ბევრი ცარიელი ადგილი იქნება, რაც არც ისე ლამაზია.
                  
                  რატომ ხდება ასე? საქმე იმაშია, რომ მობილური ბრაუზერი გვერდს თავიდანვე აძლევს რაღაც ზომებს და შემდეგ ცდილობს მისი შიგთავსი ჩაატიოს ამ ზომებში. 
                  
                  ბრაუზერი მთელი ხილვადი არე  ეკრანზე აღიწერება ცნებით Viewport. არსებითად Viewport წარმოადგენს არეს, რომელსიც ბრაუზერი ცდილობს მოათავსოს მთელი ვებგვერდი. მაგალითად, ბრაუზერი Safari iPhone-ზე და iPod-ზე მიუთითებლობისას Viewport-ის სიგანეს განსაზღვრავს 980 პიქსელით. როცა ბრაუზერი მიიღებს ვებგვერდს და ჩასვამს 980 პიქსელ სიგანეში, შემდეგ ახდენს ყველაფრის მასშტაბირებას (შემცირებას) ისე, რომ ჩაეტიოს მობილურის ეკრანის სიგანეში.მაგალითად, ტუ სმარტფონის სიგანე 320 პიქსელია, ბრაუზერი ახდენს ვებგვერდის მასშტაბირებას 320/980 კოეფიციენტით, რის გამოც ყველაფერი დაახლოებით სამჯერ მცირდება.
                  
                  რატომ იღებს Viewport-ის სიგანედ 980 პიქსელს და არა ეკრანის რეალურ ზომას? საქმე იმაშია, რომ ბრაუზერი თვლის, რომ ვებგვერდი განკუთვნილია ჩვეულებრივი დესკტოპ კომპიუტერებისთვის, ხოლო მათთვის სტანდარტულ სიგანედ შეიძლება ჩაითვალოს 980 პიქსელი.
                  
                  სხვა ბრაუზერებში Viewport-ის სიგანე მიუთითებლობისას შეიძლება სხვა იყოს, მაგრამ თითოეული მათგანი ახდენს მასშტაბირებას.
                  
                  ამ პრობლემის თავიდან ასაცილებლად იყენებენ მეტატეგს viewport. იგი განისაზღვრება შემდეგნაირად:
                  
                  <meta name="viewport" content="მეტატეგის_პარამეტრები">
                  content ატრიბუტში შეიძლება განისაზღვროს შემდეგი ატრიბუტები:
                  
                  პარამეტრი	მნიშვნელობა	აღწერა
                  width	იღებს მნიშვნელობად მთელ რიცხვებს პიქსელებში ან მნიშვნელობას device-width	განსაზღვრავს viewport-ის სიგანეს
                  height	იღებს მნიშვნელობად მთელ რიცხვებს პიქსელებში ან მნიშვნელობას device-width	
                  განსაზღვრავს viewport-ის სიგანეს
                  
                  initial-scale	ათწილადი 0.1 -დან ზევით	განსაზღვრავს მასშტაბირების კოეფიციენტს. მნიშვნელობა 1.0-ს შემთხვევაში მასშტაბირება არ ხდება
                  user-scalable	no/yes	განსაზღვრავს, შეუძლია თუ არა მომხმარებელს მასშტაბირება თავისი სურვილით
                  minimum-scale	ათწილადი 0.1 -დან ზევით	განსაზღვრავს viewport-ის მინიმალურ მასშტაბს
                  maximum-scale	ათწილადი 0.1 -დან ზევით	
                  განსაზღვრავს viewport-ის მაქსიმალურ მასშტაბს
                  
                  მოდით, შევცვალოთ ჩვენი ვებგვერდი მეტატეგის გამოყენებით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>           
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width">
                          <title>ჩვეულებრივი ვებგვერდი</title>
                      </head>
                      <body>
                          <h2>ჩვეულებრივი ვებგვერდი</h2>
                      </body>
                  </html>
                  HTML5-ის დოკუმენტი
                  
                  ვებგვერდი მობილურის ეკრანზე გაცილებით უკეთ გამოიყურება. პარამეტრის width=device-width გამოყენებითჩვენ ვეუბნებით ბრაუზერს, რომ Viewport-ის სიგანედ ჩათვალოს არა 980 პიქსელი ან სხვა რაღაც ზომა, არამედ უშუალოდ მობილური მოწყობილობის სიგანე, შესაბამისად არ მოხდება მასშტაბირება.
                  
                  შეგვიძლია გამოვიყენოთ სხვა პარამეტრებიც, მაგალითად, ავუკრძალოთ მომხმარებელს მასშტაბირება:
                  
                  <meta name="viewport" content="width=device-width, maximum-scale=1.0, minimum-scale=1.0">`
              },
              {
                  title:"Media Query CSS-ში",
                  data:`მეორე მნიშვნელოვანი ელემენტი ადაპტირებული დიზაინის შესაზმნელად არის Media Query, რომელიც განსაზღვრავს სტილს ბრაუზერის ზომების მიხედვით.

                  მაგალითად, ზოგიერთი ელემენტისთვის შეიძლება განისაზღვროს ცალკე სტილი მობილური მოწყობილობებისთვის. CSS2-ში უკვე იყო სტილების გამიჯვნის საშუალება media-ს სახით, რომელშიც ეთითებოდა, თუ რომელი მოწყობილობისთვისაა ესა თუ ის სტილი:
                  
                  <html>
                   <head>
                    <title>Адаптивная веб-страница</title>
                    <link media="handheld" rel="stylesheet" href="mobile.css">
                    <link media="screen" rel="stylesheet" href="desktop.css">
                   </head>
                   <body>
                  ......................
                  წესი media="handheld" მიუთითებს, რომ ეს სტილი გამოიყენება მობილური მოწყობილობებისათვის, ხოლო media="screen" მიუთითებს, რომ ეს სტილი ჩვეულებრივი დესკტოპ კომპიუტერებისთვისაა.
                  
                  თუმცა თანამედროვე ბრაუზერების უმეტესობა თვლის, რომ იგი განკუთვნილია ჩვეულებრივი კომპიუტერებისთვის, ამიტომ ამ წესზე დაყრდნობა არაა მიზანშეწონილი.
                  
                  ამ პრობლემის გადასაწყვეტად CSS3-ში შემოვიდა მექანიზმი Media Query. მობილურებისთვის განკუთვნილი სტილი შეგვიძლია მივუთითოთ შემდეგნაირად:
                  
                  <html>
                   <head>
                    <title>Адаптивная веб-страница</title>
                    <meta name="viewport" content="width=device-width">
                    <link rel="stylesheet" type="text/css" href="desctop.css" />
                    <link rel="stylesheet" type="text/css" media="(max-device-width:480px)" href="mobile.css" />
                   </head>
                   <body>
                  ................................
                  ატრიბუტის მნიშვნელობა media (max-device-width:480px) ნიშნავს იმას, რომ ეს სტილი განკუთვნილია მოწყობილობებისთვის, რომელთა ეკრანის მაქსიმალური სიგანე არის 480 პიქსელი. რეალურად სწორედ ესაა მობილური მოწყობილობები.
                  
                  and საკვანძო სიტყვის გამოყენებით შეგვიძლია მოვახდინოთ პირობების კომპინირება:
                  
                  <link rel="stylesheet" type="text/css" media="(min-width:481px) and (max-width:768px)" href="mobile.css" />
                  ეს სტილი გამოიყენება იმ მოწყობილობებისთვის, რომელთა სიგანე 481-დან 780 პიქსელამდეა.
                  
                  შესაძლოა განვსაზღვროთ ერთი css ფაილი და მასში დავაიმპორტოთ @import  დირექტივის მეშვეობით სხვა css ფაილები:
                  
                  @import url(desctop.css);
                  @import url(tablet.css) (min-device-width:481px) and (max-device-width:768);
                  @import url(mobile.css) (max-device-width:480px);
                  ასევე შეიძლება, რომ სტილები არ დაიყოს ფაილებად და იგივე ფაილში განისაზღვროს CSS3 Media Query წესები:
                  
                  body {
                      background-color: red;
                  }
                  /* და ა. შ.  სხვა სტილები */
                  @media (max-device-width:480px){
                      body {
                          background-color: blue;
                      }
                      /* და ა. შ. სხვა სტილები */
                  }
                  CSS3 Media Query-ში გამოიყენება შემდეგი ფუნქციები:
                  
                  aspect-ratio: ბრაუზერის გამოსახვის ნაწილის სიგანის შეფარდება სიმაღლესთან
                  device-aspect-ratio: მოწყობილობის ეკრანის სიგანის შეფარდება სიმაღლესთან
                  max-width/min-width и max-height/min-height: ბრაუზერის გამოსახვის არის მაქსიმალური/მინიმალური სიგანე და სიმაღლე
                  max-device-width/min-device-width и max-device-height/min-device-height: მოწყობილობის ეკრანის მაქსიმალური/მინიმალური სიგანე და სიმაღლე
                  orientation: ორიენტაცია (პორტრეტული ან ალბომური)
                  მაგალითად, ჩვენ შეგვიძლია განვსაზღვროთ სტილი ეკრანის ორიენტაციის მიხედვით:
                  
                  /* სტილი პორტრეტული ორიენტაციისთვის */
                  @media only screen and (orientation: portrait){   
                     }
                     /* სტილი ალბომური ორიენტაციისთვის */
                     @media only screen and (orientation: landscape){   
                     }
                  ამგვარად, ჩვენ ვცვლით სტილებს მოწყობილობების მიხედვით, ხოლო თვითონ სტილების შექმნის მექანიზმი იგივეა, რაც ჩვეულებრივი საიტებისთვის.
                  
                  როგორც წესი, სტილების განსაზღვრის დროს, უპირატესობა ენიჭება სტილებს მცირე ზომის ეკრანებისთვის, ე. წ. მიდგომა Mobile First, თუმცა ეს არაა აუცილებელი. მაგალითად შევქმნათ შემდეგი სახის ვებგვერდი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width">
                          <title>ადაპტირებული ვებგვერდი</title>
                          
                          <style>
                          body {
                              background-color: red;
                          }
                          /* პლანშეტებისა და ტბლეტებისთვის */
                          @media (min-width: 481px) and (max-width:768px) {
                              body {
                                  background-color: green;
                              }
                          }
                          /* ჩვეულებრივი დესკტოპ კომპიუტერებისთვის */
                          @media (min-width:769px) {
                              body {
                                  background-color: blue;
                              }
                          }
                  </style>
                      </head>
                      <body>
                          <h2>ადაპტირებული ვებგვერდი</h2>
                      </body>
                  </html>
                  ჯერ მოდის ჩვეულებრივი სტილი, რომელიც აქტუალურია მობილურებისთვის, ანუ მცირე ზომის ეკრანებისთვის 480 პიქსელამდე სიგანით, შემდეგ მოდის საშუალო ზომის მოწყობილობებისთვის (481-დან 768 პიქსელამდე სიგანით) და ბოლოს დესკტოპ კომპიუტერებისთვის (რომელთა სიგანე 768 პიქსელზე მეტია). 
                  
                  480 პიქსელი სიგანის მოწყობილობაზე გვერდი შემდეგნაირად გამოჩნდება:
                  
                  HTML5-ის დოკუმენტი
                  
                  ვებგვერდის ფონი არის წითელი. ჩვეულებრივი კომპიუტერის ბრაუზერში კი გვერდს ექნება ლურჯი ფონი, როგორც ეს არის განსაზღვრული შესაბამის სტილში 768 პიქსელზე მეტი სიგანის ბრაუზერებისთვის`
              },
             
            ]
        },
        {
            title:"თავი 10. მულტიმედია",
            content:[
                {
                    title:"ვიდეო",
                    data:`ვიდეოს გამოსატანად ეკრანზე HTML5-ში გამოიყენება ელემენტი video. მის დასაკონფიგურირებლად გამოიყენება შემდეგი ატრიბუტები:

                    src: ვიდეოს წყარო, ის შეიძლება იყოს რაიმე ტიპის ვიდეოფაილი
                    width: ელემენტის სიგანე
                    height: ელემენტის სიმაღლე
                    controls: ვიდეოს მართვის ელემენტები
                    autoplay: განსაზღვრავს ავტომატურ ჩვენებას
                    loop: განსაზღვრავს ვიდეოს განმეორებას
                    muted: თიშავს ხმას მიუთითებლობისას
                    სიგანისა და სიმაღლის მითითება ვიდეოს ასპექტურ ფარდობას (სიგანისა და სიმაღლის შეფარდებას) არ ცვლის. თუ ვიდეოს ფორმატია 375X240, ხოლო ჩვენ მივუთითებთ ზომებს width="375" height="280", ეს არ ნიშნავს, რომ ვიდეო ამ ზომებს მიიღებს: ის დაიკავებს ამ 280 პიქსელ სიმაღლის ცენტრში 240 პიქსელს. ეს თვიდან გვაცილებს ვიდეოს დამახინჯებას მისი გაწელვის გამო.
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Видео в HTML5</title>
                        </head>
                        <body>
                            <video src="Tom_and_Jerry.mp4" width="400" height="300" controls></video>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    გამოვიყენოთ ატრიბუტები autoplay და loop.
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls autoplay loop></video>
                    ახლა ვიდეო ავტომატურად ჩაირთვება და უსასრულოდ განმეორდება.
                    
                    თუ გვინდა, რომ ვიდეო ჩაირთოს უხმოდ, უნდა გამოვიყენოთ ატრიბუტო muted:
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls muted></video>
                    ატრიბუტი preload
                    
                    კიდევ ერთი ატრიბუტი reload განსაზღვრავს ვიდეოს ჩატვირთვის რეჟიმს. ის ღებულობს შემდეგ მნიშვნელობებს:
                    
                    auto:ვიდეო და მასთან დაკავშირებული მეტადატა ჩამოიტვირთება ვიდეოს გაშვებამდე
                    none: ვიდეო არ ჩამოიტვირთება ფონურად, სანამ მომხმარებელი არ დააჭერს გაშვების ღილაკს
                    metadata: ფონურ რეჟიმში ჩამოიტვირთება მხოლოდ მეტამონაცემები (ფაილის ფორმატი, ხანგრძლივობა და ა. შ.). თვითონ ფაილი ფონურად არ ჩამოიტვირთება
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls preload="auto"></video>
                     
                    
                    ატრიბუტი poster
                    
                    ატრიბუტი poster განსაზღვრავს გამოსახულებას, რომელიც გამოჩნდება ბრაუზერში ვიდეოს გაშვებამდე. მნიშვნელობის სახით მას გადაეცემა გამოსახულების ფაილის მისამართი:
                    
                    <video src="Tom_and_Jerry.mp4" width="400" height="300" controls poster="Tom_and_Jerry.jpg"></video>
                    ვიდეოს ფორმატების მხარდაჭერა
                    
                    მთავარი პრობლემა video ელემენტის გამოყენებისას არის სხვადასხვა ბრაუზერების მიერ ვიდეოს ფორმატების მხარდაჭერა. ჩასმული ელემენტის source მეშვეობით შეიძლება ვიდეოს გადავცეთ რამდენიმე წყარო:
                    
                    <video width="400" height="300" controls>
                       <source src="Tom_and_Jerry.mp4" type="video/mp4">
                       <source src="Tom_and_Jerry.webm" type="video/webm">
                       <source src="Tom_and_Jerry.ogv" type="video/ogg">
                    </video>
                    ელემენტი source იყენებს ორ ატრიბუტს:
                    
                    src: ფაილის მისამართი
                    type: ვიდეოს ტიპი (MIME Type)
                    თუ ბრაუზერს არა აქვს პირველი ტიპის ვიდეოს მხარდაჭერა, ის იყენებს მეორეს, თუ არა აქვს არც ამ ტიპის მხარდაჭერა - მესამეს და ა. შ.`
                },
                {
                  title:"აუდიო",
                  data:`გამოსახულების გარეშე ხმის ასაჟღერებლად HTML5-ში გამოიყენება ელემენტი audio. მისი კონფიგურაციისთვის შესაძლებელია შემდეგი ატრიბუტების გამოყენება:

                  src: აუდიო ფაილის მისამართი
                  controls: მართვის ელემენტები
                  autoplay: ავტოგაშვება
                  loop: აუდიო ფაილის განმეორება
                  muted: ხმის გამორთვა
                  preload: ფაილის ჩატვირთვის რეჟიმი
                  ყველა ამ ატრიბუტის მოქმედება video ელემენტისტვის მათი მოქმედების ანალოგიურია.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>აუდიო HTML5<-ში/title>
                      </head>
                      <body>
                          <audio src="mobile_phone.mp3" controls></audio>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სხვადასხვა ბრაუზერში ელემენტის იერსახე შეიძლება იყოს განსხვავებული.
                  
                  აუდიო ფორმატების მხარდაჭერა
                  
                  ვიდეოფაილების მსგავსად, აქაც აქტუალურია სხვადასხვა ბრაუზერის მიერ აუდიო ფორმატების მხარდაჭერის საკითხი. დღესდღეობით, თანამედროვე ბრაუზერების უმეტესობას აქვს mp3 ფორმატის მხარდაჭერა. თუმცა ყოველი შემთხვევისთვის აქაც შეგვიძლია გამოვიყენოთ ჩასმული ელემენტი source რამდენიმე აუდიო ფაილის მისათითებლად:
                  
                  <audio width="400" height="300" controls>
                     <source src="mobile_phone.mp3" type="audio/mpeg">
                     <source src="mobile_phone.m4a" type="audio/aac">
                     <source src="mobile_phone.ogg" type="audio/ogg">
                  </audio>`
              },
              {
                  title:"Media API. ვიდეოს მართვა JavaScript-დან",
                  data:`HTML5-ში ახალ audio და videoელემენტებთან ერთად დაემატა ახალი API JavaScript-ში ამ ელემენტების სამართავად. JavaScript-ის კოდის მეშვეობით შეგვიძლია მივიღოთ ელემენტების audio da video (ისევე როგორც ნებისმიერი სხვა ელემენტი) და გამოვიყენოთ მათი თვისებები. JavaScript-ში ეს ელემენტები წარმოდგენილია როგორც HTMLMediaElement, რომელიც თვისებების, მეთოდების და მოვლენების მეშვეობით მართავს ამ ელემენტების მოქმედებებს.ვნახოთ რამდენიმე ყველაზე მნიშვნელოვანი თვისება ამ ელემენტების კონფიგურაციისთვის:

                  playbackRate: სიჩქარე. მიუთითებლობისას ტოლია -ის
                  src: აბრუნებს რესურსის მისამართს, თუ ის მითითებულია ელემენტის html კოდში
                  duration: ფაილის ხანგრძლივობა წამებში
                  buffered: აბრუნებს ფაილის იმ ნაწილის ზომას, რომელიც უკვე ბუფერშია და მზად არის გამოსატანად
                  controls: აბრუნებს controls ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  loop: აბრუნებს loop ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  muted: აბრუნებს muted ატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  preload: ბრუნებს preloadატრიბუტის მნიშვნელობას. თუ ის მითითებულია, ბრუნდება true, წინააღმდეგ შემთხვევაში - false
                  volume: ხმის დონე 0.0-დან 1.0-მდე
                  currentTime: აბრუნებს აუდიოს ან ვიდეოს მიმდინარე დროს
                  მხოლოდ ელემენტისთვის video დამატებით შეიძლება გამოვიყენოთ შემდეგი თვისებები:
                  
                  poster: ატრიბუტ poster-ის მნიშვნელობა
                  height: ატრიბუტ height-ის მნიშვნელობა
                  width: ატრიბუტ width-ის მნიშვნელობა
                  videoWidth, videoHeight: აბრუნებს ვიდეოს სიგანეს და სიმაღლეს
                  აქვე აღსანიშნავია მეთოდები, რომლებითაც შეიძლება ვმართოთ მედია ფაილების გაშვება-შეჩერება:
                  
                  play(): გაშვება
                  pause(): შეჩერება
                  video და audio ელემენტების ძირითადი მოვლენებია:
                  
                  canplaythrough: ეს მოვლენა წარმოიშვება გვერდის ჩატვირთვისას, მას შემდეგ, რაც ბრაუზერი დაადგენს, რომ შეუძლია ამ ვიდეო/აუდიო ფაილის გაშვება
                  pause: ეს მოვლენა წარმოიშვება შეჩერებისას (დაპაუზებისას)
                  play: ეს მოვლენა წარმოიშვება ფაილის გაშვებისას
                  volumechange: წარმოიშვება ხმის აწევა-დაწევისას
                  ended: წარმოიშვება ფაილის დასრულებისას
                  timeupdate: წარმოიშვება ხანგრძლივობის შეცვლისას
                  error: გენერირდება შეცდომის დროს
                  loadeddata: წარმოიშვება ფაილის პირველი ფრეიმის ჩატვირთვისას
                  loadedmetadata: წარმოიშვება მეტამონაცემების (ფაილის ტიპი, ხანგრძლივობა და ა. შ.) ჩატვირთვისას
                  seeking: წარმოიშვება აუდიო/ვიდეო ფაილის მიმდინარეობის ადგილის შეცვლამდე
                  seeked: წარმოიშვება აუდიო/ვიდეო ფაილის მიმდინარეობის ადგილის შეცვლის შემდეგ
                  ახლა გამოვიყენოთ ზოგიერთი თვისება, მეთოდი და მოვლენა:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>ვიდეო HTML5-ში</title>
                      <style>
                          .hidden {
                              display: none;
                          }
                          #playBtn {
                              border: solid 1px #333;
                              padding: 5px;
                              cursor: pointer;
                          }
                      </style>
                  </head>
                  <body>
                      <video width="400" height="300">
                          <source src="Tom_and_Jerry.mp4" type="video/mp4">
                          <source src="Tom_and_Jerry.webm" type="video/webm">
                          <source src="Tom_and_Jerry.ogv" type="video/ogg">
                      </video>
                      <div id="controls" class="hidden">
                          <a id="playBtn">Play</a>
                          <span id="timer">00:00</span>
                          <input type="range" step="0.1" min="0" max="1" value="0" id="volume" />
                      </div>
                      <script>
                          // ელემენტების მიღება
                          var videoEl = document.getElementsByTagName('video')[0],
                              playBtn = document.getElementById('playBtn'),
                              vidControls = document.getElementById('controls'),
                              volumeControl = document.getElementById('volume'),
                              timePicker = document.getElementById('timer');
                   
                          // თუ ბრაუზერს შეუძლია ვიდეოს გაშვება, ვაშორებთ კლასს hidden
                          videoEl.addEventListener('canplaythrough', function () {
                              vidControls.classList.remove('hidden');
                              videoEl.volume = volumeControl.value;
                          }, false);
                         
                          // ვიდეოს გაშვება-დაპაუზება
                          playBtn.addEventListener('click', function () {
                              if (videoEl.paused) {
                                  videoEl.play();
                              } else {
                                  videoEl.pause();
                              }
                          }, false);
                          videoEl.addEventListener('play', function () {
                              playBtn.innerText = "Pause";
                          }, false);
                          videoEl.addEventListener('pause', function () {
                   
                              playBtn.innerText = "Play";
                          }, false);
                          volumeControl.addEventListener('input', function () {
                   
                              videoEl.volume = volumeControl.value;
                          }, false);
                          videoEl.addEventListener('ended', function () {
                              videoEl.currentTime = 0;
                          }, false);
                          videoEl.addEventListener('timeupdate', function () {
                              timePicker.innerHTML = secondsToTime(videoEl.currentTime);
                          }, false);
                          // დროის ასახვა
                          function secondsToTime(time) {
                   
                              var h = Math.floor(time / (60 * 60)),
                                  dm = time % (60 * 60),
                                  m = Math.floor(dm / 60),
                                  ds = dm % 60,
                                  s = Math.ceil(ds);
                              if (s === 60) {
                                  s = 0;
                                  m = m + 1;
                              }
                              if (s < 10) {
                                  s = '0' + s;
                              }
                              if (m === 60) {
                                  m = 0;
                                  h = h + 1;
                              }
                              if (m < 10) {
                                  m = '0' + m;
                              }
                              if (h === 0) {
                                  fulltime = m + ':' + s;
                              } else {
                                  fulltime = h + ':' + m + ':' + s;
                              }
                              return fulltime;
                          }
                      </script>
                  </body>
                  </html>
                  JavaScript-ის კოდში თავიდან ხდება ელემენტების დადგენა. შემდეგ ხდება მოვლენის canplaythrough დამუშავება და თუ ბრაუზერს შეუძლია ვიდეოს გაშვება, შორდება კლასი hidden და დგინდება ხმის სიმაღლე:
                  
                  videoEl.addEventListener('canplaythrough', function () {
                      vidControls.classList.remove('hidden');
                      videoEl.volume = volumeControl.value;
                  }, false);
                  ფაილის გასაშვებად საჭიროა Play ბმულზე დაჭერა:
                  
                  playBtn.addEventListener('click', function () {
                      if (videoEl.paused) {
                          videoEl.play();
                      } else {
                          videoEl.pause();
                      }
                  }, false);
                  გაშვებისა და დაპაუზების მოვლენების დამუშავებით შეგვიძლია წარწერის შეცვლა ბმულზე:
                  
                  videoEl.addEventListener('play', function () {
                      playBtn.innerText = "Pause";
                  }, false);
                  videoEl.addEventListener('pause', function () {
                      playBtn.innerText = "Play";
                  }, false);
                  ელემენტის input მოვლენის დამუშავებით, რომელიც წარმოიშვება მცოცავის გადაადგილებისას, შეგვიძლია მცოცავის მნიშვნელობის სინქრონიზაცია და ხმის რეგულირება:
                  
                  volumeControl.addEventListener('input', function () {
                      videoEl.volume = volumeControl.value;
                  }, false);
                   `
              },
              
            ]
        },
        {
            title:"თავი 11. Flexbox",
            content:[
                {
                    title:"რა არის Flexbox. Flex Container",
                    data:`Flexbox - ეს არის CSS3-ში არსებული Flexible Box Layout მოდულის მოკლე დასახელება. ეს მოდული განსაზღვრავს ვებგვერდის აწყობის განსაკუთრებულ რეჟიმს, რომელსაც ეწოდება flex layout. ამ მხრივ Flexbox  წარმოადგენს მომხმარებლის ინტერფეისის სხვა ცხრილისებური და ბლოკისებური აწყობისგან განსხვავებულ მიდგომას. მოდულის გაფართოებული აღწერა შეგიძლიათ ნახოთ მის სპეციფიკაციაში.

                    Flexbox-ის მეშვეობით უფრო ადვილია რთული ინტერფეისების შექმნა, სადაც მარტივად შეიძლება შეიცვალოს ელემენტების თანმიმდევრობა და გასწორებები და შეიქმნას ცხრილისმაგვარი ადაპტირებული გვერდები. ერთადერთი პრობლემა, რაც შეიძლება Flexbox-ის გამოყენებისას წარმოიშვას, ეს არის ბრაუზერების მიერ მისი მხარდაჭერა. მოძველებულ ბრაუზერებში მისი მხარდაჭერა არაა, თუმცა თანამეროვე ბრაუზერების უმრავლესობას ეს მხარდაჭერა გააჩნია.
                    
                    Flexbox-ის ძირითადი ელემენტებია flex-კონტეინერი flex-container და  flex-ელემენტები (flex-items). flex-კონტეინერი ერთგვარი ელემენტია, რომლის შიგნითაც მოთავსებულია flex-ელემენტები.
                    
                    ძირითადი ცნებები
                    
                    სანამ flexbox-ით ვებგვერდების აწყობაზე გადავიდოდოეთ, განვიხილოთ ძირითადი ცნებები.
                    
                    ერთ-ერთ საკვანძო ცნებას წარმოადგენს main axis ანუ ცენტრალური ღერძი. იგი flex-კონტეინერის პირობითი ღერძია, რომლის გასწვრივაც განლაგდება flex-ელემენტები.
                    
                    HTML5-ის დოკუმენტი
                    
                    ელემენტები ჰორიზონტალურად ლაგდება სტრიქონების, ხოლო ვერტიკალურად- - სვეტების სახით. განლაგების ტიპის მიხედვით იცვლება ცენტრალური ღერძიც. თუ განლაგება ხორციელდება სტრიქონების სახით, ღერძი მიმართულია მარცხნიდან მარჯვნივ, ხოლო ტუ ცვეტების სახით - მაშინ ზემოდან ქვემოთ.
                    
                    ტერმინები main start და main end აღნიშნავენ ცენტრალური ღერძის დასაწყისსა და დასასრულს, ხოლო ტერმინი main size განსაზღვრავს მათ შორის მანძილს.
                    
                    გარდა ძირითადი ღერძისა არის ასევე მისი მართობული ღერძი cross axis. როცა ელემენტები შტრიქონებადაა მოთავსებული, იგი მიმართულია ვერტიკალურად ზევიდან ქვევით, ხოლო როცა ელემენტები სვეტებშია - მარცხნიდან მარჯვნივ. cross axis ღერძის დასაწყისი და დასასრული აღინიშნება შესაბამისად cross start და cross end ტერმინებით, ხოლო მანძილი მათ შორის არის cross size.
                    
                    flex-კონტეინერის შექმნა
                    
                    flex-კონტეინერის შესაქმნელად საჭიროა ელემენტის display თვისებას მივანიჭოთ ერთ-ერთი ამ მნიშვნელობებიდან: flex ან inline-flex.
                    
                    შევქმნათ მარტივი ვებგვერდი, რომელიც იყენებს flexbox-ს:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Flexbox CSS3-ში</title>
                            <style>
                                .flex-container {
                                    display: flex;
                                }
                                .flex-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                }
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                            </style>
                        </head>
                        <body>
                            <div class="flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                        </body>
                    </html>
                    კონტეინერისთვის flex-container მინიჭებულია თვისება display:flex. შიგნით არის სამი flex-ელემენტი.
                    
                    HTML5-ის დოკუმენტი
                    
                    თუ flex მნიშვნელობა, განსაზღვრავს კონტეინერს, როგორც ბლოკურ ელემენტს, inline-flex განსაზღვრავს როგორც სტრიქონულ ელემენტს. ვნახოთ ორივე შემდეგ მაგალითზე:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <title>Flexbox CSS3-ში</title>
                            <style>
                                .flex-container {
                                    display: flex;
                                    border:2px solid #ccc;
                                }
                                .inline-flex-container {
                                    display: inline-flex;
                                    border:2px solid #ccc;
                                    margin-top:10px;
                                }
                                .flex-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                }
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                            </style>
                        </head>
                        <body>
                            <div class="flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                            
                            <div class="inline-flex-container">
                                <div class="flex-item color1">Flex Item 1</div>
                                <div class="flex-item color2">Flex Item 2</div>
                                <div class="flex-item color3">Flex Item 3</div>
                            </div>
                        </body>
                    </html>
                     
                    
                    HTML5-ის დოკუმენტი
                    
                    პირველ შემთხვევაში კონტეინერი გაწელილია ბრაუზერის მთელ სიგანეზე, ხოლო მეორე შემთხვევაში იკავებს ზუსტად იმ ადგილს, რაც სჭირდება.`
                },
                {
                  title:"მიმართულება - flex-direction",
                  data:`flex-ელემენტებს  flex-კონტეინერში გააჩნიათ გარკვეული მიმართულება. ისინი განლაგდებიან სტრიქონებად ან სვეტებად. მიმართულების მისანიჭებლად CSS-ში გამოიყენება თვისება flex-direction. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  row: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც ელემენტები განლაგდება სტრიქონებად მარცხნიდან მარჯვნივ
                  row-reverse: ელემენტები ასევე განლაგდება სტრიქონებად, ოღონდ საპირისპირო მიმართულებით, მარჯვნიდან მარცხნივ
                  column: ელემენტები განლაგდება სვეტებად ზემოდან ქვემოთ
                  column-reverse: ელემენტები განლაგდება სვეტებად საპირისპირო მიმართულებით, ქვემოდან ზემოთ
                  მაგალითად, განლაგება სტრიქონებად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border:1px solid #ccc;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად ხდება სვეტებად განლაგებაც:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border:1px solid #ccc;
                              }
                              .column {
                                  flex-direction: column;
                              }
                              .column-reverse {
                                  flex-direction: column-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                          </style>
                      </head>
                      <body>
                          <h3>Column</h3>
                          <div class="flex-container column">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                          
                          <h3>Column-reverse</h3>
                          <div class="flex-container column-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                          </div>
                      </body>
                  </html>`
              },
              {
                  title:"flex-wrap",
                  data:`თვისება flex-wrap განსაზღვრავს, იქნება თუ არა flex-კონტეინერში რამდენიმე რიგი (სტრიქონი ან სვეტი), როცა ელემენტები ერთ რიგში არ ეტევა. იგი ღებულობს შემდეგ მნიშვნელობებს:

 

                  nowrap: მნიშვნელობა მიუთითებლობისას, რომელიც განსაზღვრავს, რომ ელემენტები განლაგდება ერთ რიგში (სტრიქონში ან სვეტში)
                  wrap: თუ ელემენტები არ ეტევა კონტეინერში, ჩნდება დამატებითი რიგები (სტრიქონები ან სვეტები)
                  wrap-reverse: იგივეა, რაც wrap, ოღონდ ელემენტები განლაგდება საპირისპირო მიმართულებით
                  მაგალითად, ვნახოთ მნიშვნელობა nowrap:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.25em;
                                  flex-wrap:nowrap;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                  აქ თითოეულ კონტეინერში ხუთი ელემენტია, მაგრამ კონტეინერის სიგანეში ხუთივე არ ეტევა და ისინი გამოდიან კონტეინერის გარეთ:
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ დავამატებთ თვისებას კონტეინერზე flex-wrap:wrap, კონტეინერში გაჩნდება მეორე რიგი და ელემენტები მოთავსდება შიგნით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.25em;
                                  
                                  flex-wrap:wrap;
                              }
                              .row {
                                  flex-direction: row;
                              }
                              .row-reverse {
                                  flex-direction: row-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Row</h3>
                          <div class="flex-container row">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Row-reverse</h3>
                          <div class="flex-container row-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  სვეტებად განლაგების შემთხვევაში ჩნდება დამატებითი სვეტი:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>
                              
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  width: 60%;
                                  height:8.5em;
                                  flex-wrap:wrap;
                              }
                              .column {
                                  flex-direction: column;
                              }
                              .column-reverse {
                                  flex-direction: column-reverse;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <h3>Column</h3>
                          <div class="flex-container column">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                          
                          <h3>Column-reverse</h3>
                          <div class="flex-container column-reverse">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>`
              },
              {
                  title:"flex-flow. ელემენტების წესრიგი",
                  data:`თვისება flex-flow საშუალებას გვაძლევს ერთდროულად მივანიჭოთ ელემენტს ორი მნიშვნელობა flex-direction და flex-wrap. მას აქვს შემდეგი სინტაქსი:

                  flex-flow: [flex-direction] [flex-wrap]
                  მეორე თვისება შეიძლება გამოვტოვოთ, რადგან მას მიუთითებლობისას აქვს მნიშვნელობა nowrap.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  border: solid 0.25em #000;
                                  height:8.25em;
                                  flex-flow: row wrap;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5">Flex Item 5</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  თვისება order
                  
                  თვისება order საშუალებას გვაძლევს შევქმნათ ჯგუფები და ამით კონტეინერში ელემენტების განლაგების თანმიმდევრობა შევცვალოთ. მაგალითდ, ჯგუფი რომლის order თვისების მნიშვნელობაა 0 განლაგდება 1-ის ტოლი მნიშვნელობის ჯგუფის წინ, 1 მნიშვნელობის მქონე, 2-ის მნიშვნელობის მქონე ჯგუფის წინ და ა. შ.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  flex-flow: row wrap;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                                  opacity: 0.8;
                              }
                              .group1{
                                  order:-1;
                              }
                              .group2{
                                  order:1;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2 group2">Flex Item 2</div>
                              <div class="flex-item color3 group2">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                              <div class="flex-item color5 group1">Flex Item 5</div>
                          </div>
                  </html>
                  მოცემულ შემთხვევაში განსაზღვრულია სამი ჯგუფი. პირველი გამოისახება ბოლო ელემენტი, ვინაიდან მას orderთვისების მნიშვნელობა აქვს -1. თუ ელემენტს პირდაპირ არა აქვს მითითებული order თვისების მნიშვნელობა ჯგუფის მეშვეობით, იგულისხმება რომ ეს მნიშვნელობა არის 0-ის ტოლი. ამიტომაც მომდევნო ადგილს იკავებს პირველი და მეოთხე ელემენტი. მეორე და მესამე ელემენტი ბოლოშია, რადგან მათ ჯგუფს order-ის მნიშვნელობა აქვს 1.`
              },
              {
                  title:"ელემენტების გასწორება. justify-content",
                  data:`ხშირად არის შემთხვევა, როდესაც კონტეინერის ზომები განსხვავდება ელემენტებისთვის საჭირო ზომებისგან. შეიძლება ადგილი ჰქონდეს ორ შემთხვევას:

                  ელემენტები ვერ ავსებენ კონტეინერის სივრცეს
                  ელემენტები ვერ ეტევიან კონტეინერის შიგნით
                  ამ სიტუაციების სამართავად გამოიყენება თვისება justify-content. ის ასწორებს ელემენტებს მთვარი ღერძის main axis გასწვრივ და ღებულეობს შემდეგ მნიშვნელობებს:
                  
                  flex-start: მნიშვნელობა მიუთითებლობისას. პირველი ელემენტი თავსდება კონტეინერის დასაწყისში (მარცხნივ ან ზევით იმის მიხედვით, ელემენტები მოთავსებულია სტრიქონში თუ სვეტში), მას მოსდევს მეორე ელემენტი და ასე შემდეგ.
                  flex-end: პირველი ელემენტი თავსდება კონტეინერის ბოლოს(მარჯვნივ ან ქვევით იმის მიხედვით, ელემენტები მოთავსებულია სტრიქონში თუ სვეტში), მას მოსდევს მეორე ელემენტი და ასე შემდეგ.
                  center: ელემენტები სწორდება ცენტრში
                  space-between: თუ კონტეინერი შეიცავს მხოლოდ ერთ ელემენტს ან ელემენტები ვერ ეტევიან კონტეინერის შიგნით, მუშაობს როგორც  flex-start. სხვა შემთხვევაში პირველი ელემენტი სწორდება კონტეინერის დასაწყისში, ბოლო ელემენტი კონტეინერის ბოლოში, ხოლო დანარჩენი ელემენტები თანაბრად ნაწილდებიან მათ შორის თანაბარი ინტერვალებით.
                  space-around: თუ კონტეინერი შეიცავს მხოლოდ ერთ ელემენტს ან ელემენტები ვერ ეტევიან კონტეინერის შიგნით, მუშაობს როგორც center. სხვა შემთხვევაში ელემენტები თანაბრად ნაწილდებიან კონტეინერის მთელ სიგრძეზე თანაბარი ინტერვალებით, ამასთან პირველი და ბოლო ელემენტის დაშორება კონტეინერის საზღვრიდან ელემენტებს შორის დაშორების ნახევრის ტოლია.
                  ელემენტების გასწორება სტრიქონში განლაგების შემთხვევაში:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <title>Flexbox CSS3-ში</title>
                          <style>            
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-start{
                                  justify-content: flex-start;
                              }
                              .flex-end{
                                  justify-content: flex-end;
                              }
                              .center{
                                  justify-content: center;
                              }
                              .space-between{
                                  justify-content: space-between;
                              }
                              .space-around{
                                  justify-content: space-around;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                              <h3>Flex-start</h3>
                              <div class="flex-container flex-start">
                                  <div class="flex-item color1">Flex Item 1</div>
                                  <div class="flex-item color2">Flex Item 2</div>
                                  <div class="flex-item color3">Flex Item 3</div>
                                  <div class="flex-item color4">Flex Item 4</div>
                              </div>
                          <h3>Flex-end</h3>
                          <div class="flex-container flex-end">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Center</h3>
                          <div class="flex-container center">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Space-between</h3>
                          <div class="flex-container space-between">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Space-around</h3>
                          <div class="flex-container space-around">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ელემენტების გასწორება სვეტში განლაგების შემთხვევაში:`
              },
              {
                  title:"ელემენტების გასწორება. align-items და align-self",
                  data:`თვისება align-items ასევე ემსახურება ელემენტების გასწორებას, მაგრამ ახლა უკვე არა მთავარი ღერძის (main axis), არამედ მისი მართობული ღერძის (cross axis) მიმართ. iის ღებულობს შემდეგ მნიშვნელობებს:

                  stretch: მნიშვნელობა მიუთითებლობისას, რომლის დროსაც flex-ელემენტები ავსებს flex-კონტეინერის მთელ სიმაღლეს (სტრიქონში განლაგებისას) ან მთელ სიგანეს (სვეტში განლაგებისას)
                  flex-start: flex-ელემენტები სწორდება flex-კონტეინერის ზედა კიდეზე (სტრიქონში განლაგებისას) ან მარცხენა კიდეზე (სვეტში განლაგებისას)
                  flex-end: flex-ელემენტები სწორდება flex-კონტეინერის ქვედა კიდეზე (სტრიქონში განლაგებისას) ან მარჯვენა კიდეზე (სვეტში განლაგებისას)
                  center: flex-ელემენტები სწორდება flex-კონტეინერის ცენტრში
                  baseline: ელემენტები სწორდება საკუთარი საბაზისო ღერძის მიხედვით
                  ვნახოთ გასწორება სტრიქონში განლაგებისას:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>            
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  height:5em;
                              }
                              .flex-start{
                                  align-items: flex-start;
                              }
                              .flex-end{
                                  align-items: flex-end;
                              }
                              .center{
                                  align-items: center;
                              }
                              .baseline{
                                  align-items: baseline;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;                
                              }
                              .largest-item{
                                  padding-top:2em;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <h3>Flex-start</h3>
                          <div class="flex-container flex-start">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Flex-end</h3>
                          <div class="flex-container flex-end">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Center</h3>
                          <div class="flex-container center">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                          <h3>Baseline</h3>
                          <div class="flex-container baseline">
                              <div class="flex-item color1">Flex Item 1</div>
                              <div class="flex-item color2 largest-item">Flex Item 2</div>
                              <div class="flex-item color3">Flex Item 3</div>
                              <div class="flex-item color4">Flex Item 4</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ანალოგიურად მუშაობს სვეტში განლაგების დროსაც.
                  
                  თვისება align-self
                  
                  თვისება align-self საშუალებას იძლევა შევცვალოთ align-items თვისებით მიღებული გასწორების წესი ერთი ელემენტისთვის. ის ღბულობს იგივე მნიშვნელობებს, რასაც align-items და დამატებით მნიშვნელობას auto. auto არის მნიშვნელობა მიუთითებლობისას. ამ დროს ელემენტი სწორდება align-items--ისგან მემკვიდრეობით მიღებული წესით.
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  justify-content: space-between;
                                  align-items: stretch;
                                  height:12em;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; align-self: center; }
                              .item2 {background-color: #9BC850; align-self: flex-start;}
                              .item3 {background-color: #A62E5C; align-self: flex-end;}
                              .item4 {background-color: #2A9FBC; align-self: center;}
                          </style>
                      </head>
                      <body>
                          <h3>Align-self</h3>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                  </html>
                   `
              },
              {
                  title:"სტრიქონებისა და სვეტების გასწორება. align-content",
                  data:`თვისება align-content მართავს რიგების გასწორებას (სტრიქონების და სვეტების) და გამოიყენება იმ შემთხვევაში, თუ flex-wrap თვისების მნიშვნელობაა wrap ან wrap-reverse. იგი ღებულობს შემდეგ მნიშვნელობებს:

                  stretch: მნიშვნელობა მიუთითებლობისას, რომლის დროცას სტრიქონები (სვეტები) იწელება და იკავებს მთელ თავისუფალ სივრცეს
                  flex-start: სტრიქონები (სვეტები) სწორდება კონტეინერის დასაწყისში
                  flex-end: სტრიქონები (სვეტები) სწორდება კონტეინერის ბოლოში
                  center: სტრიქონები (სვეტები) სწორდება კონტეინერის ცენტრში
                  space-between: სტრიქონები (სვეტები) თანაბრად ნაწილდება მთელ კონტეინერში და ქმნის თანაბარ ინტერვალებს მათ შორის. თუ კონტეინერში ადგილი არასაკმარისია, მუშაობს როგორც fex-start მნიშვნელობის დროს
                  space-around: სტრიქონები (სვეტები) თანაბრად ნაწილდება კონტეინერში და ქმნის თანაბარ ინტერვალებს მათ შორის, ამასთან პირველი და ბოლო სტრიქონის (სვეტის) დაშორება საზღვრებიდან მეზობელ სტრიქონებს (სვეტებს) შორის დაშორების ნახევრის ტოლია
                  გასათვალისწინებელია, რომ ამ თვისებას მაშინ აქვს აზრი, როცა კონტეინერში ორი ან მეტი სტრიქონია (სვეტია).
                  
                  მაგალითად, სტრიქონების განლაგება კონტეინერის დასაწყისში:
                  
                  <!DOCTYPE html>
                  <html>
                   
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  flex-wrap: wrap;
                                  height:200px;
                                  align-content: flex-start;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 16px;
                                  padding: 10px;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7;}
                              .item2 {background-color: #9BC850;}
                              .item3 {background-color: #A62E5C;}
                              .item4 {background-color: #2A9FBC;}
                              .item5 {background-color: #F15B2A;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                              <div class="flex-item item5">Flex Item 5</div>
                              <div class="flex-item item1">Flex Item 6</div>
                              <div class="flex-item item2">Flex Item 7</div>
                              <div class="flex-item item3">Flex Item 8</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  შევცვალოთ კონტეინერის სტილი:
                  
                  .flex-container {
                      display: flex;
                      border:1px #ccc solid;
                      flex-wrap: wrap;
                      height:200px;
                      align-content: space-between;
                      flex-direction: column;
                  }
                  ამ შემთხვევაში მივიღებთ ერთმანეთისგან დაშორებული სვეტების ორ რიგს.`
              },
              {
                  title:"ელემენტების მართვა. flex-basis, flex-shrink და flex-grow",
                  data:` გარდა თვისებებისა, რომლებიც ემსახურება ელემენტების გასწორებას, არის კიდევ სამი თვისება, რომლებიც ელემენტების მართვისთვისაა განკუთვნილი:

                  flex-basis: განსაზღვრავს flex-ელემენტის საწყის ზომებს
                  flex-shrink: განსაზღვრავს, თუ როგორ უნდა შემცირდეს flex-ელემენტი სხვა flex-ელემენტების მიმართ flex-კონტეინერში
                  flex-grow: განსაზღვრავს, თუ როგორ უნდა გაიზარდოს flex-ელემენტი სხვა flex-ელემენტების მიმართ flex-კონტეინერში
                  flex-basis
                  
                  flex-კონტეინერი შეიძლება შემცირდეს ან გაიზარდოს მთავარი ღერძის გასწვრივ ბრაუზერის ზომების ცვლილებისას, თუ კონტეინერს არ გააჩნია ფიქსირებული ზომები. კონტეინერთან ერთად შეიძლება შემცირდეს ან გაიზარდოს მასში შემავალი flex-ელემენტებიც. თვისება flex-basis განსაზღვრავს flex-ელემენტის საწყის ზომებს, სანამ იგი დაიწყებს ზომების შეცვლას კონტეინერის ზომების ცვლილების კვალდაკვალ. ეს თვისება იღებს შემდეგ მნიშვნელობებს:
                  
                  auto: flex-ელემენტის საწყისი ზომა დგინდება ავტომატურად
                  content: flex-ელემენტის ზომა განისაზღვრება მისი შიგთავსის მოცულობიდან გამომდინარე
                  რიცხვითი მნიშვნელობა: ჩვენ შეგვიძლია მივუთითოთ კონტეინერის ზომები რიცხვითი მნიშვნელობების სახით
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-basis: auto; width:150px;}
                              .item2 {background-color: #9BC850; flex-basis: auto; width:auto;}
                              .item3 {background-color: #A62E5C; flex-basis: 200px;width:150px;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველ ელემენტს flex-basis თვისების მნიშვნელობა აქვს auto, ამიტომ ეს ელემენტი სიგანეს მიიღებს width თვისების მნიშვნელობიდან გამომდინარე. მეორე ელემენტს flex-basis თვისების მნიშვნელობა ასევე აქვს auto, width თვისების მნიშვნელობაც არის auto, ამიტომ ეს ელემენტი სიგანეს მიიღებს შიგთავსიდან გამომდინარე. მესამე ელემენტის flex-basis თვისებას აქვს კონკრეტული რიცხვითი მნიშვნელობა, შესაბამისად ელემენტი სიგანეს მიიღებს ამ მნიშვნელობიდან გამომდინარე და width  თვისების მნიშვნელობას არავითარი აზრი არა აქვს.
                  
                  flex-shrink
                  
                  თუ flex-კონტეინერს არა აქვს საკმარისი ადგილი მასში მოთავსებული ელემენტებისთვის, ამ ელემენტების შემდგომ ქცევას განსაზღვრავს თვისება flex-shrink.ის უჩვენებს, თუ რამდენად შემცირდება ეს ელემენტი სხვა ელემენტებთან შედარებით. 
                  
                  იგი ღებულობს რიცხვით მნიშვნელობებს. მიუთითებლობისას მისი მნიშვნელობა არის 1-ის ტოლი.
                  
                  ვნახოთ ამ თვისების მოქმედება შემდეგ მაგალითზე:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width:400px;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.2em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-basis: 200px; flex-shrink:1;}
                              .item2 {background-color: #9BC850; flex-basis: 200px; flex-shrink:2;}
                              .item3 {background-color: #A62E5C; flex-basis: 200px; flex-shrink:3;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  მოცემულ შემთხვევაში თიტოეული ელემენტის სიგანე (გამომდინარე flex-basis მნიშვნელობიდან) არის 200 პიქსელი, ანუ სამივე ელემენტის სიგანე ჯამში არის 600 პიქსელი. მაგრამ თვითონ კონტეინერის სიგანე მხოლოდ 400 პიქსელია. ამიტომ მოქმედებას იწყებს თვისება flex-shrink, რომელიც განსაზღვრული აქვს თიტოეულ ელემენტს.
                  
                  ზომების შესამცირებლად ბრაუზერი იყენებს შემცირების კოეფიციენტს (shrinkage factor). იგი გამოითვლება flex-basis და flex-shrink მნიშვნელობების გადამრავლებით:
                  
                  პირველი ელემენტი: 200*1=200
                  მეორე ელემენტი: 200*2=400
                  მესამე ელემენტი: 200*3=600
                  როგორც ვხედავთ, შემცირების კოეფიციენტი მეორე ელემენტს აქვს 2-ჯერ მეტი, ვიდრე პირველს, ხოლო მესამეს 3-ჯერ მეტი, ვიდრე პირველს. ამიტომაც შემცირების შემდეგ პირველი ელემენტი ორჯერ მეტი იქნება მეორეზე და სამჯერ მეტი მესამეზე.
                  
                  flex-grow
                  
                  თვისება flex-grow განსაზღვრავს ელემენტის გაფართოების წესს, თუ კონტეინერში არის დამატებითი ადგილი. მისი მოქმედება გარკვეულწილად ჰგავს flex-shrink თვისების მოქმედებას, ოღონდ ის მოქმედებს გაფართოების დროს.
                  
                  მნიშვნელობად იღებს არაუარყოფით რიცხვს, რომელიც განსაზღვრავს რამდენჯერ გაიზრდება ელემენტი გაფართოებისას სხვა ელემენტებთან შედარებით. მიუთითებლობისას ამ თვისების მნიშვნელობა არის 0-ის ტოლი.
                  
                  გამოვიყენოთ თვისება flex-grow:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container {
                                  display: flex;
                                  border:1px #ccc solid;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 1em;
                                  padding: 1.3em;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; flex-grow:0;}
                              .item2 {background-color: #9BC850; flex-grow:1;}
                              .item3 {background-color: #A62E5C; flex-grow:2;}
                          </style>
                      </head>
                      <body>
                          <div class="flex-container">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                          </div>
                  </html>
                   
                  
                  თითოეულ ელემენტს გააჩნია საწყისი საბაზისო ზომა. აქ ზომები არაა მითითებული, შესაბამისად ზომა განისაზღვრება შიგთავსიდან გამომდინარე, რასაც ემატება შიდა დაშორებები.
                  
                  HTML5-ის დოკუმენტი
                  
                  კონტეინერის გაფართოებასთან ერთად ელემენტები იწყებენ გაფართოებას flex-grow თვისების შესაბამისად, რომელიც მითითებული აქვს თითოეულ ელემენტს. სივრცეს, რომლითაც იზრდება კონტეინერის ზომა, ეწოდება დამატებითი სივრცე. 
                  
                  HTML5-ის დოკუმენტი
                  
                  რადგანაც პირველი ელემენტის flex-grow თვისების მნიშვნელობა 0-ის ტოლია, მისი ზომა არ შეიცვლება. მეორე ელემენტის flex-grow-ის მნიშვნელობა 1-ის ტოლია, მესამისა - 3-ის. 0+1+2=3. შესაბამისად, მეორე ელემენტი გაიზრდება ზომაში დამატებითი სიფრცის 1/3-ით, ხოლო მესამე ელემენტი - დამატებითი სივრცის 2/3-ით.
                  
                  თვისება flex
                  
                  თვისება flex წარმოადგენს flex-basis, flex-shrink და flex-grow თვისებების გაერთიანებას. მას აქვს შემდეგი ფორმალური სინტაქსი:
                  
                  flex: [flex-grow] [flex-shrink] [flex-basis]
                  მიუთითებლობისას მას აქვს მნიშვნელობა 0 1 auto:
                  
                  flex: 0 1 auto;
                  კონკრეტული მნიშვნელობების გარდა flex თვისებას შეიძლება ჰქონდეს ერთ-ერთი შემდეგი მნიშვნელობებიდან:
                  
                  flex: none: ეკვივალენტურია მნიშვნელობისა 0 0 auto, ამ დროს ელემენტი არ მცირდება და არ იზრდება კონტეინერის ზომების შეცვლისას
                  flex: auto: ეკვივალენტურია მნიშვნელობისა 1 1 auto
                  flex: initial: ეკვივალენტურია მნიშვნელობისა 0 1 auto
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <meta charset="utf-8">
                      <title>Flexbox CSS3-ში</title>
                      <style>
                              .flex-container1 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 600px;
                              }
                              .flex-container2 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 500px;
                              }
                              .flex-container3 {
                                  display: flex;
                                  border:1px #ccc solid;
                                  width: 700px;
                              }
                              .flex-item {
                                  text-align:center;
                                  font-size: 16px;
                                  padding: 10px 0;
                                  color: white;
                              }
                              .item1 {background-color: #675BA7; width: 150px; flex: 0 0 auto }
                              .item2 {background-color: #9BC850; width: 150px; flex: 1 0 auto;}
                              .item3 {background-color: #A62E5C; width: 150px; flex: 0 1 auto;}
                              .item4 {background-color: #2A9FBC; width: 150px; flex: 1 1 auto;}
                          </style>
                      </head>
                      <body>
                          <h1>width: 600</h1>       
                          <div class="flex-container1">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                          <h1>width: 500</h1> 
                          <div class="flex-container2">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                          <h1>width: 700</h1> 
                          <div class="flex-container3">
                              <div class="flex-item item1">Flex Item 1</div>
                              <div class="flex-item item2">Flex Item 2</div>
                              <div class="flex-item item3">Flex Item 3</div>
                              <div class="flex-item item4">Flex Item 4</div>
                          </div>
                  </html>
                   `
              },
              {
                title:"მრავალსვეტიანი დიზაინი Flexbox-ის მეშვეობით",
                data:`ახლა ვნახოთ, როგორ შეიძლება მარტივი მრავალსვეტიანი დიზაინის შექმნა Flexbox-ის მეშვეობით.

                ორსვეტიანი დიზაინი
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Flexbox CSS3-ში</title>
                    <style>
                            *{
                                box-sizing: border-box;
                            }
                            html,
                            body {
                                padding: 0;
                                margin: 0;
                                font-family: verdana, arial, sans-serif;
                            } 
                            body {
                                display: flex;
                                padding: 1em;
                                flex-direction: column;
                            } 
                            .item {
                                background-color: #455a64;
                                color: #fff;
                                font-size: 1.1em;
                                padding: 1em;
                            }
                 
                            .item:nth-child(even) {
                                background-color: #607d8b;
                            }
                            @media screen and (min-width: 600px) {
                    
                                body {
                                    flex-direction: row;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <div class="item">
                            <h2>What is Lorem Ipsum?</h2>
                            <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum
                                has been the industry's standard dummy text ever since the 1500s, when an unknown printer
                                took a galley of type and scrambled it to make a type specimen book. It has survived not only
                                five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.
                                It was popularised in the 1960s with the release of Letraset
                                sheets containing Lorem Ipsum passages, and more recently with desktop publishing software
                                like Aldus PageMaker including versions of Lorem Ipsum.</p>
                        </div>
                            
                        <div class="item">
                            <h2>Where does it come from?</h2>
                            <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a
                                piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard
                                McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of
                                the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through
                                the cites of the word in classical literature, discovered the undoubtable source.
                                Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum"
                                (The Extremes of Good and Evil) by Cicero, written in 45 BC. </p>
                        </div>
                    </body>
                </html>
                აქ flex-კონტეინერს წარმოადგენს body. რადგანაც მობილურ მოწყობილობებში (სმარტფონებში) ეკრანის ზომა არც ისე დიდია, მიუთითებლობისას ელემენტების განლაგება იყოს სვეტში. მაგრამ 600 პიქსელზე მეტი სიგანისთვის მოქმედებს წესი media-query, რომელიც განალაგებს ელემენტებს სტრიქონში. შესაბამისად მცირე ზომის ეკრანზე გამოჩნდება ასე:
                
                HTML5-ის დოკუმენტი 
                
                ხოლო 600 პიქსელის ზემოთ სიგანის ეკრანზე ასე:
                
                HTML5-ის დოკუმენტი
                
                სამსვეტიანი რეჟიმი
                
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <title>Flexbox CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html,
                        body {
                            padding: 0;
                            margin: 0;
                            font-family: verdana, arial, sans-serif;
                        }
                        body {
                            display: flex;
                            padding: 1em;
                            flex-direction: column;
                        }
                        .item {
                            background-color: #455a64;
                            color: #fff;
                            font-size: 1.1em;
                            padding: 1em;
                            flex: 1;
                        }
                 
                        .item:nth-child(1) {
                            background-color: #607d8b;
                        }
                        @media screen and (min-width: 600px) {
                 
                            body {
                                flex-direction: row;
                            }
                            .item:nth-child(2) {
                                order: -1;
                            }
                        }
                    </style>
                </head>
                <body>    
                    <div class="item">
                        <h2>What is Lorem Ipsum?</h2>
                        <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum
                            has been the industry's standard dummy text ever since the 1500s, when an unknown printer
                            took a galley of type and scrambled it to make a type specimen book...</p>
                    </div>           
                    <div class="item">
                        <h2>Where does it come from?</h2>
                        <p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a
                            piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard
                            McClintock, a Latin professor at Hampden-Sydney College in Virginia,... </p>
                    </div>
                    <div class="item">
                        <h3>Why do we use it?</h3>
                        <p>It is a long established fact that a reader will be distracted by the readable content
                            of a page when looking at its layout. The point of using Lorem Ipsum is that it has a
                            more-or-less normal distribution of letters, as opposed to using 'Content here, content here'...</p>
                    </div>
                </body>
                </html>
                წინა მაგალითისგან განსხვავებით, აქ დამატებულია კიდევ ერთი ელემენტი. გარდა ამისა, სვეტებს აქვთ ერთი და იგივე სიგანე, რისთვისაც სამივე სვეტს მინიჭებული აქვს თვისება flex:1. შესაბამისად, ზომების შეცვლისას სამივე სვეტი თანაბრად მასშტაბირდება. გარდა ამისა, 600 პიქსელზე ზევით სიგანისთვის მეორე ელემენტს მინიჭებული აქვს მნიშვნელობა order:-1, რის გამოც ეს ელემენტი თავსდება პირველი:
                
                HTML5-ის დოკუმენტი
                
                ასეთი სახით ჩვენ შეგვიძლია დავამატოთ სვეტების ნებისმიერი რაოდენობა. მაგრამ მოცემულ შემთხვევაში ყველა სვეტს აქვს ერთიდაიგივე სიგანე. თუ გვსურს, რომ რომელიმე სვეტი იყოს სხვა ზომის, სტილებში დავამატოთ ასეთი ჩანაწერი:
                
                 
                
                .item:first-child {
                    flex: 0 0 50%;
                }
                ახლა უკვე პირველი ელემენტი ყოველთვის დაიკავებს მთელი სივრცის 50 %-ს.`
            },
            {
                title:"ვებგვერდის მაკეტი Flexbox-ზე",
                data:`ახლა ვნახოთ ვებგვერდის სტანდარტული მაკეტის შექმნა, რომელიც შედგება ქუდის, ფუტერის და ცენტრალური ნაწილისაგან, რომელიც შედგება სამი სვეტისაგან: მთავარი შიგთავსი და ორი საიდბარი.

                ამისათვის განვსაზღვროთ შემდეგი ვებგვერდი:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Flexbox CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body {
                                padding: 0;
                                margin: 0;
                                font-family: verdana, arial, sans-serif;
                            }
                            body {
                                color: #fff;
                                font-size: 1.1em;
                                padding: 1em;
                                display: flex;
                                flex-direction: column;
                            }
                            main {
                                display: flex;
                                flex-direction: column;
                            }
                            article {
                                background-color: #546e7a;
                                flex: 2 2 12em;
                                padding: 1em;
                            }
                            nav, aside {
                                flex: 1;
                                background-color: #455a64;
                            }
                            nav {
                                order: -1;
                            }            
                            header, footer {
                                flex: 0 0 5em;
                                background-color: #37474f;
                            }            
                            @media screen and (min-width: 600px) {
                                
                                body{
                                    min-height: 100vh;
                                }
                                main {
                                    flex-direction: row;
                                    min-height: 100%;
                                    flex: 1 1 auto;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <header>
                            <p>Header</p>
                        </header>
                        <main>
                            <article>
                                <h1>What is Lorem Ipsum?</h1>
                                <p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has
                                    been the industry's standard dummy text ever since the 1500s, when an unknown printer
                                    took a galley of type and scrambled it to make a type specimen book. It has survived not
                                    only five centuries, but also the leap into electronic typesetting, remaining essentially
                                    unchanged...</p>
                            </article>
                            <nav>
                                <p>Navigation</p>
                            </nav>
                            <aside>
                                <p>Sidebar</p>
                            </aside>
                        </main>
                        <footer>
                            <p>Footer</p>
                        </footer>
                    </body>
                </html>
                 
                
                . HTML5-ის დოკუმენტი
                
                ზედა დონის flex-კონტეინერი ამ მაგალითში არის ელემენტი body. მისი flex-ელემენტებია header, main და footer. body-ში ელემენტები განლაგებულია სვეტში ზემოდან ქვემოთ. აღსანიშნავია, რომ როცა გვერდის სიგანე 600px და მეტია, body-ს სიმაღლე არის 100vh. (vh არის ზომის ერთეული, 1 vh არის viewport-ის სიმაღლის 1%, შესაბამისად 100vh არის viewport-ის სიმაღლის ტოლი. ანალოგიურად, 1vw არის viewport-ის სიგანის 1 %).
                
                ელემენტები header და footer ერთმანეთის ანალოგიურია. მათ აქვთ მნიშვნელობა 0 0 5em; .რაც იმას ნიშნავს, რომ კონტეინერის ზომების ნებისმიერი ცვლილებისას ისინი არ გნიცდიან მასშტაბირებას და მათი ზომა ყოველთვის 5em-ის ტოლია. ანუ, მათ აქვთ სტატიკური ზომა.
                
                უფრო რთულია ელემენტი main, რომელშიც მოქცეულია გვერდის ძირითადი შიგთავსი. იგი ერთდროულად flex-ელემენტიცაა და ამასთანავე flex-კონტეინერიც მასში მოქცეული ელემენტებისათვის. 600px-მდე სიგანის დროს მასში მოთავსებული flex-ელემენტები განლაგებულია სვეტში, რაც მოხერხებულია მობილურ მოწყობილობებზე.
                
                600px და მეტ სიგანეზე ელემენტები nav, article და aside განლაგდება სტრიქონში. რადგანაც ასეთი სიგანის დროს მშობელი ელემენტი body იკავებს ბრაუზერის მთელ სიმაღლეს, body კონტეინერის მთელი სიმაღლის შესავსებად მისი ცვლილებისას ელემენტს main მინიჭებული აქვს მნიშვნელობა flex:1 1 auto;
                
                main ელემენტში შემავალი flex-ელემენტებისთვის აღსანიშნავია, რომ კონტეინერის მასშტაბირებისას ნავიგაციის პანელისა და საიდბარის ზომები იქნება ერთნაირი, ხოლო article ელემენტის ზომა იქნება უფრო მეტი, რადგან ის შეიცავს ძირითად შინაარსს. მიუხედავად იმისა, რომ ელემენტი article უფრო ადრეა განსაზღვრული, ვიდრე ნავიგაციის პანელი, ეს უკანასკნელი იქნება ყოველთვის უფრო წინ თვისების order:-1 გამო.`
            },
          
            ]
        },
        {
            title:"თავი 12. Grid Layout",
            content:[
                {
                    title:"რა არის Grid Layout. Grid Container",
                    data:`Grid Layout არის CSS3-ის სპეციალური მოდული, რომელიც საშუალებას იძლევა განვალაგოთ ელემენტები ცხრილის სახით. ისევე, როგორც Flexbox, Grid Layout წარმოადგენს ელემენტების დალაგების მოქნილ სისტემას, ოღონდ თუ Flexbox-ში ელემენტები განთავსდებოდა ერთი მიმართულებით - სტრიქონში ან სვეტში, Grid Layout საშუალებას იძლევა ელემენტების მდებარეობა განვსაზღვროთ ორივე მიმართულებით, რაც წარმოქმნის ცხრილს.

                    Grid Layout მოდულის სრული სპეციფიკაცია შეგიძლია ნახოთ ამ მისამართზე https://www.w3.org/TR/css-grid-1.
                    
                    Grid Layout-ის გამოყენებისას უნდა გავითვალისწინოთ, რომ მისი მხარდაჭერა ბრაუზერებმა შედარებით გვიან დაიწყეს, შესაბამისად ადრინდელ ვერსიებში მისი მხარდაჭერა არ არსებობდა.
                    
                    grid-კონტეინერის შექმნა
                    
                    Grid Layout-ში განლაგების მთავარი ელემენტია grid-კონტეინერი, რომლის შიგნითაც არის მოთავსებული ელემენტები. მის შესაქმნელად საჭიროა ელემენტის display თვისებას მივანიჭოთ მნიშვნელობა grid ან grid-inline.
                    
                    შევქმნათ მარტივი ვებგვერდი Grid Layout-ის გამოყენებით:
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <meta name="viewport" content="width=device-width" />
                            <title>Grid Layout CSS3-ში</title>
                            <style>
                                .grid-container {
                                    border: solid 2px #000;
                                    display: grid;
                                }
                                .grid-item {
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                } 
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                                .color4 {background-color: #2A9FBC;}
                            </style>
                        </head>
                        <body>
                            <div class="grid-container">
                                <div class="grid-item color1">Grid Item 1</div>
                                <div class="grid-item color2">Grid Item 2</div>
                                <div class="grid-item color3">Grid Item 3</div>
                                <div class="grid-item color4">Grid Item 4</div>
                                <div class="grid-item color1">Grid Item 5</div>
                            </div>
                        </body>
                    </html>
                     
                    
                    კონტეინერისთვის grid-container განსაზღვრულია თვისება display:grid. მასში არის ხუთი ელემენტი:
                    
                    . HTML5-ის დოკუმენტი
                    
                    თუ მნიშვნელობა grid კონტეინერს განსაზღვრავს როგორც ბლოკისებურ ელემენტს, grid-inline განსაზღვრავს სტრიქონულს:
                    
                     
                    
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="utf-8">
                            <meta name="viewport" content="width=device-width" />
                            <title>Grid Layout CSS3-ში</title>
                            <style>
                                .grid-container {
                                    border: solid 2px #000;
                                    display: inline-grid;
                                } 
                                .grid-item {
                                    box-sizing: border-box;
                                    text-align:center;
                                    font-size: 1.1em;
                                    padding: 1.5em;
                                    color: white;
                                } 
                                .color1 {background-color: #675BA7;}
                                .color2 {background-color: #9BC850;}
                                .color3 {background-color: #A62E5C;}
                                .color4 {background-color: #2A9FBC;}
                            </style>
                        </head>
                        <body>
                            <div class="grid-container">
                                <div class="grid-item color1">Grid Item 1</div>
                                <div class="grid-item color2">Grid Item 2</div>
                                <div class="grid-item color3">Grid Item 3</div>
                                <div class="grid-item color4">Grid Item 4</div>
                                <div class="grid-item color1">Grid Item 5</div>
                            </div>
                        </body>
                    </html>
                     
                    
                     
                    
                    ამ შემთხვევაში grid-კონტეინერი იკავებს მხოლოდ იმ ადგილს, რაც ელემენტების დასატევად არის საჭირო.`
                },
                {
                  title:"სტრიქონები და სვეტები",
                  data:`გრიდი სტრიქონებისა და სვეტებისგან წარმოქმნის ბადეს, ხოლო მათ გადაკვეთაზე უჯრებს. სტრიქონებისა და სვეტების შესაქმნელად Grid Layout იყენებს CSS3-ის შემდეგ თვისებებს:

                  grid-template-columns: განსაზღვრავს სვეტებს
                  grid-template-rows: განსაზღვრავს სტრიქონებს
                  სვეტები
                  
                  სვეტების განსაზღვრისთვის Grid Layout იყენებს თვისებას grid-template-columns. მაგალითად, შევქმნათ გრიდი ორი სვეტით:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em 8em;
                              }
                              .grid-item {
                                  box-sizing: border-box;
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                          </div>
                      </body>
                  </html>
                  grid-template-columns თვისებას მნიშვნელობად გადაეცემა სვეტების სიგანე. რამდენი სვეტიც გვჭირდება, იმდენი მნიშვნელობა უნდა გადავცეთ. 
                  
                  HTML5-ის დოკუმენტი
                  
                  შესაბამისად, თუ ჩვენ გვინდა, რომ გრიდს ჰქონდეს სამი სვეტი, უნდა გადავცეთ სამი მნიშვნელობა:
                  
                  grid-template-columns: 8em 7em 8em;
                  თუ ელემენტები უფრო მეტია, ვიდრე სვეტები, მათი განთავსებისთვის მიუთითებლობისას ჩნდება ახალი სტრიქონები.
                  
                  სტრიქონები
                  
                  სტრიქონების განსაზღვრა სვეტების ანალოგიურია. ამისათვის გამოიყენება თვისება grid-template-rows. მას მნიშვნელობად გადაეცემა სტრიქონების სიმაღლეები:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns:30% 40% 30%;
                                  grid-template-rows: 4em 5em;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color3">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ ელემენტების რაოდენობა მეტია უჯრების რაოდენობაზე, ჩნდება დამატებითი სტრიქონი. ამიტომაც, ჩვენს მაგალითში, მიუხედავად იმისა, რომ განსაზღვრული იყო ორი სტრიქონი, რეალურად გვაქვს სამი.ამასთან, მესამე სტრიქონის სიმაღლე გამოითვლება ავტომატურად.
                  
                  დავამატოთ გრიდში კიდევ ორი სტრიქონი:
                  
                  .grid-container {
                       border: solid 2px #000;
                       display: grid;
                       grid-template-columns:30% 40% 30%;
                       grid-template-rows: 4em 5em 5em 5em;
                   }
                  ახლა განსაზღვრულია სამი სვეტი და ოთხი სტრიქონი. მაგრამ ვინაიდან უჯრების რაოდენობა უფრო მეტია, ვიდრე გრიდში ელემენტების რაოდენობა, მეოთხე სტრიქონი იქნება ცარიელი.`
              },
              {
                  title:"ფუნქცია repeat და თვისება grid",
                  data:`სტრიქონებისა და სვეტების გამეორება

                  თუ გვაქვს რამდენიმე სტრიქონი ან სვეტი, რომელთა ზომები ერთნაირია, აქვს აზრი გამოვიყენოთ ფუნქცია repeat(). მაგალითად, თუ გვაქვს განსაზღვრული შემდეგი გრიდი:
                  
                  .grid-container {
                      grid-template-columns: 8em 8em 8em;
                      grid-template-rows: 5em 5em 5em 5em;
                  }
                  repeat() ფუნქციის გამოყენებით შეგვიძლია ჩავწეროთ შემოკლებულად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(3, 8em);
                      grid-template-rows: repeat(4, 5em);
                  }
                  repeat() ფუნქციის პირველი პარამეტრი უჩვენებს გამეორებათა რაოდენობას, მეორე სვეტის ან სტრიქონის ზომას. შეიძლება ერთდროულად რამდენიმე სვეტის ან სტრიქონის განმეორების განსაზღვრაც:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(2, 7em 8em);
                      grid-template-rows: 6em repeat(3, 5em);
                  }
                  მოცემულ შემთხვევაში შეიქმნება ოთხი სვეტი: ორი სვეტი სიგანით 7em და 8em გამეორდება ორჯერ. სვეტების შემთხვევაში, შეიქმნება ოთხი სტრიქონი: ერთი სიმაღლით 6em და დანარჩენი სამი სიმაღლით 5em.
                  
                  თვისება grid
                  
                  თვისება grid აერთიანებს თვისებებს grid-template-columns და grid-template-rows და იძლევა სტრიქონებისა და სვეტების კონფიგურაციისშესაძლებლობას შემდეგი ფორმატით:
                  
                  grid: grid-template-rows / grid-template-columns;
                  მაგალითად, ვთქვათ, გვაქვს grid-კონტეინერი შემდეგი სტილით:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: 8em 8em 8em;
                      grid-template-rows: 5em 5em 5em 5em;
                  }
                  შეგვიძლია შევამოკლოთ შემდეგნაირად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid: 5em 5em 5em 5em / 8em 8em 8em;
                  }
                  ან repeat() ფუნქციის გამოყენებით კიდევ უფრო შევამოკლოთ:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid: repeat(4, 5em) / repeat(3, 8em);
                  }`
              },
              {
                  title:"სტრიქონებისა და სვეტების ზომა",
                  data:`ფიქსირებული ზომები

                  წინა სტატიებში განხილულ მაგალითებში სვეტების და სტრიქონების ზომების დასადგენად გამოიყენებოდა თვისებები grid-template-columns და grid-template-rows. ზომების მისათითებლად შესაძლოა გამოვიყენოთ სხვადასხვა ზომის ერთეულები (px, em, rem, pt, %). მაგალითად:
                  
                  .grid-container {
                      border: solid 2px #000;
                      display: grid;
                      grid-template-columns: repeat(3, 200px);
                      grid-template-rows: repeat(3, 4.5em);
                  }
                   
                  
                  ავტომატური ზომები
                  
                  გარდა ზუსტი ზომებისა შეიძლება მიენიჭოს ავტომატური ზომა auto.ამ შემთხვევაში სვეტების სიგანე და სტრიქონების სიმაღლე ენიჭება შიგთავსიდან გამომდინარე:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em auto auto;
                                  grid-template-rows: auto 4.5em auto;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color2">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  აქ განსაზღვრულია სამი სვეტი და სამი სტრიქონი. პირველ სვეტს აქვს ფიქსირებული სიგანე, სოლო მეორეს და მესამეს - ავტომატური. ასევე, პირველ და მესამე სტრიქონს აქვს ავტომატური სიმაღლე, ხოლო მეორეს - ფიქსირებული.
                  
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პროპორციული ზომები
                  
                  პროპორციული ზომების მისანიჭებლად გამოიყენება სპეციალური ზომის ერთეული fr. ის წარმოადგენს სივრცის ნაწილს (fraction), რომელიც განესაზღვრება მოცემულ სვეტს ან სტრიქონს. fr-ს მნიშვნელობას უწოდებენ flex-ფაქტორს (flex-factor).
                  
                  პროპორციული ზომები გამოითვლება ფორმულით:
                  
                  flex-factor *  ხელმისაწვდომი სივრცე / ყველა flex-factor-ის ჯამი.
                  ამასთან, ხელმისაწვდომ სივრცეს წარმოადგენს კონტეინერის მთლიან ზომას გამოკლებული ფიქსირებული ზომის სვეტების (სტრიქონების) ზომები.
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: 8em 2fr 1fr;
                                  grid-template-rows: 1fr 4.5em 1fr;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color2">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  პირველი სვეტის სიგანე ფიქსირებულია, ხოლო მეორე და მესამე სვეტისა - პროპორციული 2fr და 1fr. შესაბამისად, მეორე სვეტის სიგანე იქნება მთელი დარჩენილი სივრცის 2/(1+2) = 2/3 , ხოლო მესამე სვეტისა - 1/(1+2) = 1/3.
                  
                  ანალოგიურად, მეორე სტრიქონის სიმაღლე ფიქსირებულია, ხოლო პირველი და მესამე სტრიქონის სიმაღლე დარჩენილი სივრცის ნახევარი იქნება თითოეულისთვის 1/(1+1) = 1/2.
                  
                   `
              },
              {
                  title:"დაშორებები სვეტებსა და სტრიქონებს შორის",
                  data:`სვეტებსა და სტრიქონებს შორის დაშორებების შესაქმნელად გამოიყენება თვისებები grid-column-gap და grid-row-gap.

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-column-gap: 10px;
                                  grid-row-gap: 10px;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ grid-column-gap და grid-row-gap თვისებების მნიშვნელობები ერთმანეთს ემთხვევა, შეიძლება განისაზღვროს ერთი თვისება grid-gap, რომელიც განსაზღვრავს ორივე დაშორებას (როგორც სვეტებს შორის, ასევე სტრიქონებს შორის):
                  
                  .grid-container {
                      height: 100vh;
                      display: grid;
                      grid-template-columns: repeat(3, 1fr);
                      grid-template-rows: repeat(3, 1fr);
                      grid-gap: 10px;
                  }`
              },
              {
                  title:"ელემენტების განლაგება",
                  data:`გრიდი წარმოადგენს უჯრების ერთობლიობას, რომლებიც წარმოიქმნებიან სვეტებისა და სტრიქონების გადაკვეთისას. მაგრამ თვითონ სვეტები და სტრიქონები წარმოიქმნება grid-ხაზების მეშვეობით, რომლებიც ყოფენ გრიდს ვერტიკალურად და ჰორიზონტალურად:

                  HTML5-ის დოკუმენტი
                  
                  მიუთითებლობისას ყოველი ელემენტი გრიდში თავსდება ერთ უჯრაში რიგის მიხედვით, მაგრამ ელემენტების გრიდში ჩვენი სურვილის მიხედვით განლაგებისთვის გამოიყენება შემდეგი თვისებები:
                  
                  grid-row-start: განსაზღვრავს საწყის ჰორიზონტალურ grid-ხაზს, საიდანაც იწყება ელემენტი
                  grid-row-end: განსაზღვრავს, თუ რომელ ჰორიზონტალურ grid-ხაზამდე გრძელდება ელემენტი
                  grid-column-start: განსაზღვრავს საწყის ვერტიკალურ grid-ხაზს, საიდანაც იწყება ელემენტი
                  grid-column-end: განსაზღვრავს, თუ რომელ ვერტიკალურ grid-ხაზამდე გრძელდება ელემენტი
                  მაგალითად, მოვათავსოთ ელემენტი რამდენიმე სვეტში:
                  
                   
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              .grid-container {
                                  border: solid 2px #000;
                                  display: grid;
                                  grid-template-columns: repeat(4, 1fr);
                                  grid-template-rows: repeat(3, 5em);
                              }
                              .special-item{
                                  grid-column-start:2;
                                  grid-column-end: 5;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2 special-item">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color5">Grid Item 5</div>
                              <div class="grid-item color1">Grid Item 6</div>
                              <div class="grid-item color4">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  აქ განსაზღვრულია ოთხი სვეტი, ამასთან მე-2 ელემენტს მინიჭებული აქვს სპეციალური კლასი special-item, რომელიც თავსდება მე-2 grid-ხაზიდან ანუ მეორე სვეტიდან მე-5  grid-ხაზამდე ანუ მეოთხე სვეტის ბოლომდე.
                  
                  აუცილებელი არაა, რომ მე-2 ელემენტი იწყებოდეს მეორე სვეტიდან, ეს შეიძლება იყოს ნებისმიერი სვეტი: 1-ლი, მე-3, მე-4. მაგალითად, თუ მე-2 ელემენტს მოვათავსებთ მე-3 სვეტიდან (grid-column-start: 3;), მე-2 სვეტის ადგილას პირველ სტრიქონში დარჩება სიცარიელე:
                  
                  .special-item{
                      grid-column-start: 3;
                      grid-column-end: 5;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თუ მეორე ელემენტს მოვუთითებთ, რომ უნდა დაიწყოს პირველი სვეტიდან, მაშინ სი გადავა მე-2 სტრიქონში და დაიწყება პირველი სვეტიდან და დაიკავებს მთლიან სტრიქონს.
                  
                  .special-item{
                      grid-column-start: 1;
                      grid-column-end: 5;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  grid-column-start და grid-column-end თვისებების ნაცვლად შეიძლება გამოვიყენოთ ერთი - grid-column. ამ შემთხვევაში მნიშვნელობები მიეთითება სლეშით:
                  
                  grid-column: grid-column-start / grid-column-end;
                  მაგალითად, ჩვენ შეგვიძლია შევამოკლოთ special-item კლასის სტილი წინა მაგალითიდან შემდეგნაირად:
                  
                  grid-column: 1 / 5;
                  ზუსტად ანალოგიურად grid-row-start და grid-row-end თვისებების მეშვეობით შეგვიძლია ელემენტი მოვათავსოთ რამდენიმე სტრიქონში:
                  
                  .special-item{
                      grid-column-start:2;
                      grid-row-start: 1;
                      grid-row-end: 3;
                  }
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ჩანაწერის შესამოკლებლად აქაც შეგვიძლია გამოვიყენოთ თვისება grid-row ნაცვლად grid-row-start და grid-row-end-სა:
                  
                  .special-item{
                      grid-column-start:2;
                      grid-row-start: 1 / 3;
                  }
                   
                  
                  span
                  
                  სპეციალური სიტყვის span მეშვეობით შეგვიძლია ელემენტს მივუთითოთ უჯრების რაოდენობა, რომელსაც ის დაიკავებს. მაგალითად:
                  
                  .special-item{
                      grid-row: 1 / span 2;
                      grid-column: 2 / span 2;
                  }
                   
                  
                  ელემენტი დაიწყება პირველი სტრიქონისა და მეორე სვეტის გადაკვეთის ადგილში და დაიკავებს ორ უჯრას ჰორიზონტალურად და ორს ვერტიკალურად:
                  
                  HTML5-ის დოკუმენტი
                  
                  grid-area
                  
                  თვისება grid-area აერთიანებს თვისებებს grid-row და grid-column და ამოკლებს ჩანაწერს:
                  
                  grid-area: row-start / column-start / row-end / column-end
                  მაგალითად:
                  
                  .special-item{
                      grid-row: 1 / span 2;
                      grid-column: 2 / span 2;               
                      grid-area: 1 / 2 / 3 / 4;
                  }`
              },
              {
                  title:"ელემენტების გადაფარვა",
                  data:`ელემენტების განლაგების მანიპულირებით ადვილად შეიძლება გრიდის ერთი ელემენტები გადავფაროთ სხვა ელემენტებით, ანუ მოვათავსოთ ელემენტები ფენებად. მაგალითად, განვსაზღვროთ შემდეგი გრიდი:

                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-gap: 10px;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                                  z-index: 1;
                              }
                              .item1{
                                  grid-area: 1 / 1 / 3 / 4;
                                  opacity: 0.8;
                              }
                              .item2{
                                  grid-area: 1 / 1 / 2 / 2;
                              }
                              .item3{
                                  grid-area: 1 / 3 / 2 / 4;
                              }
                              .item4{
                                  grid-area: 2 / 1 / 3 / 2;
                              }
                              .item5{
                                  grid-area: 2 / 2 / 3 / 3;
                              }
                              .item6{
                                  grid-area: 2 / 3 / 3 / 4;
                              }
                              .item7{
                                  grid-area: 3 / 1 / 4 / 2;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item item1 color2">Grid Item 2</div>
                              <div class="grid-item item2 color1">Grid Item 1</div>
                              <div class="grid-item item3 color3">Grid Item 3</div>
                              <div class="grid-item item4 color4">Grid Item 4</div>
                              <div class="grid-item item5 color1">Grid Item 5</div>
                              <div class="grid-item item6 color4">Grid Item 6</div>
                              <div class="grid-item item7 color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                  აქ პირველი ელემენტი იკავებს იგივე ადგილს, რასაც მისი მომდევნო ხუთი ელემენტი. რადგან ყველა ელემენტს აქვს თვისება z-index: 1, ამიტომ პირველი ელემენტი დანარჩენი ელემენტებისთვის გამოცნდება როგორც ფონი:
                  
                  HTML5-ის დოკუმენტი
                  
                  საჭიროებისას შეგვიძლია პირველი ელემენტის ფენა გადმოვიტანოთ უფრო ახლოს და მისი მეშვეობით გადავფაროთ სხვა ელემენტები. ამისათვის საკმარისია გავუზარდოთ მას z-index:
                  
                  .item1{
                      grid-area: 1 / 1 / 3 / 4;
                      opacity: 0.8;
                      z-index: 10;
                  }`
              },
              {
                  title:"ელემენტების მიმართულება და თანმიმდევრობა",
                  data:`თვისება grid-auto-flow

                  მიუთითებლობისას ელემენტები გრიდში განლაგდება თანმიმდევრობით პირველ სტრიქონსი მარცხნიდან მარჯვნივ, როცა პირველ სტრიქონსი უჯრები გამოილევა, გადავა მეორე სტრიქონზე და ა. შ. მაგრამ grid-auto-flow თვისების მეშვეობით შეგვიძლია შევცვალოთ ეს თანმიმდევრობა. იგი ღებულობს შემდეგ მნიშვნელობებს:
                  
                  row: მნიშვნელობა მიუთითებლობისას. ელემენტები განლაგდება სტრიქონში თანმიმდევრობით, როცა მეტი ადგილი არ არის, გადავა მომდევნო სტრიქონზე
                  column: ელემენტები განლაგდება სვეტებში, როცა მეტი ადგილი არ არის, გადავა მომდევნო სვეტზე
                  მაგალითად:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                                  grid-auto-flow: row;
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2">Grid Item 2</div>
                              <div class="grid-item color3">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება grid-auto-flow აქვს მნიშვნელობა row, ამიტომ ელემენტები განლაგებულია სტრიქონებად. თუ შევცვლით მნიშვნელობაზე column, ელემენტები განლაგდება სვეტებში.
                  
                  grid-auto-flow: column;
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  თვისება order
                  
                  თვისება order გვაძლევს საშუალებას, შევცვალოთ ელემენტების თანმიმდევრობა. მიუთითებლობისას ყველა ელემენტისთვის მისი მნიშვნელობა 0-ის ტოლია. ამიტომ ელემენტები განლაგდება იმ თანმიმდევრობით, რა თანმიმდევრობითაც მოდიან html კოდში. მაგრამ თვისება order-ის მნიშვნელობის შეცვლით შეგვიძლია შევცვალოთ ეს თანმიმდევრობა:
                  
                  <!DOCTYPE html>
                  <html>
                      <head>
                          <meta charset="utf-8">
                          <meta name="viewport" content="width=device-width" />
                          <title>Grid Layout CSS3-ში</title>
                          <style>
                              *{
                                  box-sizing: border-box;
                              }
                              html, body{
                                  margin:0;
                                  padding:0;
                              }
                              .grid-container {
                                  height: 100vh;
                                  display: grid;
                                  grid-template-columns: repeat(3, 1fr);
                                  grid-template-rows: repeat(3, 1fr);
                              }
                              .grid-item {
                                  text-align:center;
                                  font-size: 1.1em;
                                  padding: 1.5em;
                                  color: white;
                              }
                              .last-item{
                                  order: 1;
                              }
                              .first-item{
                                  order: -1;
                              }
                              .color1 {background-color: #675BA7;}
                              .color2 {background-color: #9BC850;}
                              .color3 {background-color: #A62E5C;}
                              .color4 {background-color: #2A9FBC;}
                              .color5 {background-color: #4e342e;}
                          </style>
                      </head>
                      <body>
                          <div class="grid-container">
                              <div class="grid-item color1">Grid Item 1</div>
                              <div class="grid-item color2 last-item">Grid Item 2</div>
                              <div class="grid-item color3 last-item">Grid Item 3</div>
                              <div class="grid-item color4">Grid Item 4</div>
                              <div class="grid-item color1">Grid Item 5</div>
                              <div class="grid-item color4">Grid Item 6</div>
                              <div class="grid-item color5 first-item">Grid Item 7</div>
                          </div>
                      </body>
                  </html>
                   
                  
                  HTML5-ის დოკუმენტი
                  
                  ელემენტებს კლასით last-item (მე-2 და მე-3 ელემენტი) გააჩნიათ order:1 მნიშვნელობა და რადგან სხვა ელემენტებს, რომელთაც მითითებული არა აქვთ order-ის მნიშვნელობა მიუტითებლობისას აქვთ 0-ის ტოლი, ამიტომ მე-2 და მე-3 ელემენტი განთავსდება ყველაზე ბოლოს. ელემენტს კლასით first-item (მე-7 ელემენტი) order-ის მნიშვნელობა აქვს -1-ის ტოლი, ანუ ყველაზე ნაკლები, შესაბამისად ის განთავსდება გრიდში პირველი.
                  
                   
                  
                  
                  
                  `
              },
              {
            title:"grid-ხაზებისთვის სახელის მიცემა",
            data:`Grid Layout-ში ჩვენ შეგვიძლია გრიდის თითოეულ ხაზს მივცეთ სახელი, რომელიც ეთითება კვადრატულ ფრჩხილებში, შემდგომსი ამ სახელის გამოყენება შეიძლება ელემენტების პოზიციის განსაზღვრისთვის. მაგალითად:

            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width" />
                    <title>Grid Layout CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html, body{
                            margin:0;
                            padding:0;
                        }
                        .grid-container {
                            height:100vh;
                            display: grid;
                            grid-template-columns: [col1start] 1fr [col1end] 10px
                                                    [col2start] 1fr [col2end] 10px
                                                    [col3start] 1fr [col3end];
                            grid-template-rows: [row1start] 1fr [row1end] 10px [row2start] 1fr [row2end];
                        }
                         
                        .grid-item {
                            background-color: #ddd;
                        }
                        
                        .special-item{
                            grid-column: col1start / col2end;
                            grid-row: row1start;
                            background-color: #bbb;
                        }
                        .item1{
                            grid-column: col3start / col3end;
                            grid-row: row1start;
                        }
                        .item2{
                            grid-column: col1start / col1end;
                            grid-row: row2start;
                        }
                        .item3{
                            grid-column: col2start / col2end;
                            grid-row: row2start;
                        }
                        .item4{
                            grid-column: col3start / col3end;
                            grid-row: row2start;
                        }
                    </style>
                </head>
                <body>
                    <div class="grid-container">
                        <div class="grid-item special-item"></div>
                        <div class="grid-item item1"></div>
                        <div class="grid-item item2"></div>
                        <div class="grid-item item3"></div>
                        <div class="grid-item item4"></div>
                    </div>
                </body>
            </html>
            თითოეული ხაზის დასახელება მოქცეულია კვადრატულ ფრჩხილებში, ხოლო მათ შორის წერია ამ ხაზებით შემოსაზღვრული სვეტის ან სტრიქონის სიგანე ან სიმაღლე:
            
            grid-template-columns: [col1start] 1fr [col1end] 10px
                                   [col2start] 1fr [col2end] 10px
                                   [col3start] 1fr [col3end];
            grid-template-rows: [row1start] 1fr [row1end] 10px [row2start] 1fr [row2end];
            ამის შემდეგ გრიდის ხაზების გამოყენებით განისაზღვრება ელემენტების მდებარეობა:
            
            .special-item{
                grid-column: col1start / col2end;
                grid-row: row1start;
                background-color: #bbb;
            }
             
            
            HTML5-ის დოკუმენტი
            
            ვნახოთ მეორე მაგალითი გვერდის მაკეტის შექმნით:
            
            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width" />
                    <title>Grid Layout CSS3-ში</title>
                    <style>
                        *{
                            box-sizing: border-box;
                        }
                        html, body {
                            padding: 0;
                            margin: 0;
                        } 
                        .grid-container {
                            display: grid;
                            height: 100vh;
                            grid-template-rows: 6em 10px 1fr;
                            grid-template-columns: [mainstart] 1fr [mainend] 10px [sidebarestart] 25% [sidebarend];
                        } 
                        .grid-item-content {
                            background-color: #455a64;
                            grid-row: 3 / 4;
                            grid-column: mainstart / mainend;
                        } 
                        .grid-item-sidebar {
                            background-color: #37474f;
                            grid-row: 3 / 4;
                            grid-column: sidebarestart / sidebarend;
                        } 
                        .grid-item-header{
                            background-color: #263238;
                            grid-row: 1 / 2;
                            grid-column: mainstart / sidebarend;
                        } 
                        .grid-item {
                            color: #fff;
                            text-align: center;
                        }
                    </style>
                </head>
                <body>
                    <main class="grid-container">
                        <header class="grid-item grid-item-header">
                            <h1>Header</h1>
                        </header>                
                        <article class="grid-item grid-item-content">
                            <h1>Main Content</h1>
                        </article>            
                        <aside class="grid-item grid-item-sidebar">
                            <h1>Sidebar</h1>
                        </aside>
                    </main>
                </body>
            </html>`
              },
              {
                title:"სახელდებული grid-ხაზები და ფუნქცია repeat",
                data:`ადრე განხილული ფუნქციის repeat მეშვეობით შესაძლებელია იმ სვეტებისა და სტრიქონების ტირაჟირება, რომლებიც მოქცეულია სახელდებულ გრიდის ხაზებს შორის:

                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px);
                                grid-template-rows: 10px repeat(2, [row] 1fr [rowgutter] 10px);
                            }
                            
                            .grid-item {
                                background-color: #ddd;
                            }
                            
                            .special-item{
                                grid-column: column 2;
                                grid-row: row 1;
                                background-color: #bbb;
                            }
                            .item1{
                                grid-column: column 1;
                                grid-row: row 1;
                            }
                            .item2{
                                grid-column: column 3;
                                grid-row: row 1;
                            }
                            .item3{
                                grid-column: column 1;
                                grid-row: row 2;
                            }
                            .item4{
                                grid-column: column 2;
                                grid-row: row 2;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="grid-item special-item"></div>
                            <div class="grid-item item1"></div>
                            <div class="grid-item item2"></div>
                            <div class="grid-item item3"></div>
                            <div class="grid-item item4"></div>
                        </div>
                    </body>
                </html>
                ავიღოთ მოცემული მაგალითიდან სვეტების განსაზღვრა:
                
                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px);
                 
                
                პირველ სვეტს ექნება 10 პიქსელი სიგანე. შემდეგ მოდის repeat ფუნქციით ტირაჟირებული სვეტები. ის ქმნის მიმდევრობით ორი სვეტის სამ ასლს. პირველი სვეტის სიგანეა 1fr, ანუ მას აქვს პროპორციული ზომა და მოთავსებულია grid-ხაზებს "column" და "colgutter" შორის. შემდეგ მოდის 10 პიქსელი სიგანის სვეტი. ეს ორი სვეტი გამეორდება სამჯერ. საბოლოოდ, გრიდს ექნება შვიდი სვეტი.
                
                ანალოგიურად არის სტრიქონების შემთხვევაშიც. იქმნება 5 სტრიქონი.
                
                ელემენტების სტილის განსაზღვრის დროს გამოიყენება grid-ხაზის სახელი და რიგითი ნომერი. ჩვენ შეგვიძლია პირდაპირ მივუთითოთ, ტუ სად იქნება მოთავსებული ესა თუ ის ელემენტი grid-column და grid-row თვისებების მეშვეობით:
                
                .special-item{   
                   grid-column: column 2; /* მე-2 სვეტი სახელით column */
                   grid-row: row 1;       /* 1-ლი სტრიქონი სახელით row */
                }
                თვისება grid-column: column 2 უთითებს სვეტზე, რომელიც მოსდევს მე-2 grid-ხაზს სახელით "column". 
                
                ვღებულობთ ასეთ შედეგს:
                
                HTML5-ის დოკუმენტი
                
                შესაძლოა ასეთი მიდგომა ინტუიტიურად ბევრისთვის უფრო გასაგები იყოს.
                
                ჩვენ შეგვიძლია სახელდებული სვეტების და სრტიქონების განსაზღვრა repeat ფუნქციის გარეთაც:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-columns: 10px repeat(3, [column] 1fr [colgutter] 10px)
                                                       [sidebarstart] 150px [sidebarend] 10px;
                                grid-template-rows: 10px repeat(2, [row] 1fr [rowgutter] 10px);
                            }
                             
                            .grid-item {
                                background-color: #ddd;
                            }
                            
                            .special-item{
                                grid-column: column 2;
                                grid-row: row 1;
                                background-color: #bbb;
                            }
                            .item1{
                                grid-column: column 1;
                                grid-row: row 1;
                            }
                            .item2{
                                grid-column: column 3;
                                grid-row: row 1;
                            }
                            .item3{
                                grid-column: column 1;
                                grid-row: row 2;
                            }
                            .item4{
                                grid-column: column 2;
                                grid-row: row 2;
                            }
                            .sidebar{
                                grid-column: sidebarstart / sidebarend;
                                grid-row: 2 / 5;
                                background-color: #ccc;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="grid-item special-item"></div>
                            <div class="grid-item item1"></div>
                            <div class="grid-item item2"></div>
                            <div class="grid-item item3"></div>
                            <div class="grid-item item4"></div>
                            <div class="grid-item sidebar"></div>
                        </div>
                    </body>
                </html> 
                აქვე უნდა აღინიშნოს, რომ მიუხედავად იმისა, სახელდებულია grid-ხაზები თუ არა, მათზე მიმართვა რიგითი ნომრით ყოველთვის შესაძლებელია:
                
                .sidebar{
                       grid-column: sidebarstart / sidebarend;
                       grid-row: 2 / 5;
                       background-color: #ccc;
                 }`
                  },
            {
               title:"გრიდის არეები",
                data:`გრიდის შიგნით შესაძლებელია არეების (grid area) განსაზღვრა. არე განისაზღვრება ორი ვერტიკალური და ორი ჰორიზონტალური ხაზით. არაა აუცილებელი, რომ არე მოიცავდეს ერთ უჯრას, ის შეიძლება შეიცავდეს ვერტიკალური და ჰორიზონტალური ხაზებით შემოსაზღვრულ ბევრ უჯრას. არეების განსაზღვრა მოხერხებულია გვერდის სემანტიკური სტრუქტურის ასაგებად.

                არის განსაზღვრისთვის გამოიყენება თვისება grid-template-areas. მაგალითად, განვსაზღვროთ სამი არე:
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-areas: "header header"
                                                     "sidebar content"
                                                     "sidebar content";
                                grid-template-columns: 150px 1fr;
                                grid-template-rows: 100px 1fr 100px;
                            }
                            .header { grid-area: header; background-color: #bbb; }
                            .sidebar { grid-area: sidebar; background-color: #ccc; }
                            .content { grid-area: content; background-color: #eee; }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="header"></div>
                            <div class="sidebar"></div>
                            <div class="content"></div>
                        </div>
                    </body>
                </html>
                grid-კონტეინერს განსაზღვრული აქვს ორი სვეტი და სამი სტრიქონი:
                
                grid-template-columns: 150px 1fr;
                grid-template-rows: 100px 1fr 100px;
                 
                
                შესაბამისად გრიდს ექნება 3*2=6 უჯრა. html კოდში განსაზღვრულია სამი ელემენტი, რომელთაც აქვთ იგივე სახელი, რაც გრიდის არეებს: header, sidebar, content. თვისება grid-template-areas განსაზღვრავს, როგორ იქნება ეს არეები განლაგებული გრიდში:
                
                grid-template-areas: "header header"
                                                                 "sidebar content"
                                                                "sidebar content";
                 
                
                გამოსახულება "header header"  მიუთითებს, რომ header არე იკავებს პირველი სტრიქონის ორ უჯრას. შემდეგი სტრიქონი "sidebar content" განსაზღვრავს მეორე სტრიქონის უჯრებს, ანუ sidebar იკავებს მეორე სტრიქონის პირველ უჯრას, ხოლო content მეორე სტრიქონის მეორე უჯრას. მესამე სტრიქონი იმეორებს მეორეს. თუ შევხედავთ, გრიდში უჯრები იქნება შემდეგნაირად:
                
                header
                
                header
                
                sidebar
                
                content
                
                sidebar
                
                content
                
                 
                
                ელემენტებისათვის არის მისათითებლად გამოიყენება თვისება grid-area:
                
                .header {
                      grid-area: header; background-color: #bbb;
                }
                შედეგად ვღებულობთ ასეთ ვებგვერდს:
                
                HTML5-ის დოკუმენტი
                
                ვნახოთ მეორე, ცოტა უფრო რთული მაგალითი:
                
                 
                
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="utf-8">
                        <meta name="viewport" content="width=device-width" />
                        <title>Grid Layout CSS3-ში</title>
                        <style>
                            *{
                                box-sizing: border-box;
                            }
                            html, body{
                                margin:0;
                                padding:0;
                            }
                            .grid-container {
                                height:100vh;
                                display: grid;
                                grid-template-areas: "header header header header header"
                                                     ". . . . ."
                                                     "menu . content . sidebar"
                                                     ". . . . ."
                                                     "footer footer footer footer footer";
                                grid-template-columns: 130px 5px 1fr 5px 130px;
                                grid-template-rows: 90px 5px 1fr 5px 90px;
                            }
                            .header { grid-area: header; background-color: #bbb; }
                            .menu { grid-area: menu; background-color: #ccc; }
                            .sidebar { grid-area: sidebar; background-color: #ccc; }
                            .content { grid-area: content; background-color: #eee; }
                            .footer { grid-area: footer; background-color: #bbb; }
                        </style>
                    </head>
                    <body>
                        <div class="grid-container">
                            <div class="header"></div>
                            <div class="content"></div>
                            <div class="menu"></div>
                            <div class="sidebar"></div>
                            <div class="footer"></div>
                        </div>
                    </body>
                </html>
                 
                
                ახლა გრიდი შეიცავს 5 სვეტს და 5 სტრიქონს, ანუ სულ 25 უჯრას, რომლებშიც განლაგებულია 5 არე: header, menu, sidebar, content და footer.
                
                თვისება grid-template-areas განსაზღვრავს, თუ როგორაა განაწილებული ეს არეები უჯრების მიხედვით. მაგალითდ, პირველი სტრიქონი "header header header header header" მიუთითებს, რომ გრიდის პირველი სტრიქონის ხუთივე უჯრას იკავებს header ელემენტი. მეორე სტრიქონის, რომლის სიმაღლე 5 პიქსელია, განსაზღვრა განსხვავდება ჩვეულებრივისგან: ". . . . .".  წერტილი ნიშნავს, რომ ეს უჯრა არ ეკუთვნის არცერთ არეს და ცარიელია. თუ გვინდა 5 შეუვსებელი უჯრის განსაზღვრა, უნდა დავსვათ 5 წერტილი მათ შორის ადგილის გამოტოვებით. შედეგად ჩვენ მივიღებთ ხუთ არეს, რომელთა შორის ცარიელი სივრცეა:`
            
            },
             {
             title:"გვერდის მაკეტი Grid Layout-ის მეშვეობით",
              data:`შევქმნათ სტანდარტული ადაპტირებული ვებგვერდის მაკეტი Grid Layout-ის მეშვეობით, რომელსაც ექნება ქუდი (header), დაბოლოება (footer), ნავიგაციის პანელი (menu), ძირითადი ნაწილი (content) და გვერდითა პანელი (sidebar): 

              <!DOCTYPE html>
              <html>
                  <head>
                      <meta charset="utf-8">
                      <meta name="viewport" content="width=device-width" />
                      <title>Grid Layout CSS3-ში</title>
                      <style>
                          *{
                              box-sizing: border-box;
                          }
                          html, body{
                              margin:0;
                              padding:0;
                          }
                          .grid-container {
                              height:100vh;
                              display: grid;
                              grid-template-areas: "header"
                                                   "."
                                                   "menu"
                                                   "."
                                                   "content"
                                                   "."
                                                   "sidebar"
                                                   "."
                                                   "footer";
                              grid-template-columns: 1fr;
                              grid-template-rows: 80px 5px 80px 5px 1fr 5px 80px 5px 80px;
                          }
                          .header { grid-area: header; background-color: #bbb; }
                          .menu { grid-area: menu; background-color: #ccc; }
                          .sidebar { grid-area: sidebar; background-color: #ccc; }
                          .content { grid-area: content; background-color: #eee; }
                          .footer { grid-area: footer; background-color: #bbb; }
                          h3{
                              text-align:center;
                          }
                          @media screen and (min-width: 468px) {
                              
                              .grid-container {
                                  height:100vh;
                                  display: grid;
                                  grid-template-areas: "header header header header header"
                                                       ". . . . ."
                                                       "menu . content . sidebar"
                                                       ". . . . ."
                                                       "footer footer footer footer footer";
                                  grid-template-columns: 130px 5px 1fr 5px 130px;
                                  grid-template-rows: 90px 5px 1fr 5px 90px;
                              }
                          }
                      </style>
                  </head>
                  <body>
                      <div class="grid-container">
                          <div class="header"><h3>Header</h3></div>
                          <div class="content"><h3>Content</h3></div>
                          <div class="menu"><h3>Menu</h3></div>
                          <div class="sidebar"><h3>Sidebar</h3></div>
                          <div class="footer"><h3>Footer</h3></div>
                      </div>
                  </body>
              </html>
              აქ გამოიყენება წინა თემაში განხილული გრიდის არეები, რაც მეტად მოხერხებულია ვებგვერდის სემანტიკური მაკეტის შესაქმნელად.
              
              რადგანაც ვებგვერდი შეიძლება დათვალიერებული იყოს მობილური მოწყობილობის ეკრანზე, რომელსაც მცირე სიგანე გააჩნია, ამიტომ გრიდის არეები განისაზღვრება ორნაირად: 468 პიქსელის და მეტი სიგანის მქონე ეკრანებისთვის ელემენტები განლაგებულია ხუთ სვეტში, ხოლო ნაკლები სიგანის მქონე მოწყობილობებისთვის (მობილური მოწყობილობებისთვის) - ერთ სვეტში. შედეგად მობილურში გვერდი გამოიყურება შემდეგნაირად`
              },
                          
            ]
        }
    ]
},

javascript:{
    chapters:[
        {
            title:"თავი 1. შესავალი Javascript-ში",
            content:[
                {
                    title:"რას წარმოადგენს Javascript",
                    data:`დღეისათვის ვებსაიტების სამყაროს წარმოდგენა Javascript-ის გარეშე პრაქტიკულად წარმოუდგენელია. Javascript - ეს არის ის, რაც აცოცხლებს ვებსაიტებს, რომელთაც ყოველდღიურად ვათვალიერებთ ჩვენს ბრაუზერებში.

                    Javascript შეიქმნა 1995 წელს კომპანია Netscape-ს მიერ, როგორც სცენარების ენა ბრაუზერისთვის Netscape Navigator 2. თავდაპირველად ენას ერქვა LiveScript, მაგრამ იმ დროისათვის პოპულარული სხვა ენის Java LiveScript ტალღაზე გადაერქვა სახელი და დაერქვა JavaScript. ეს მომენტი გარკვეულ გაუგებრობას იწვევს : ზოგიერთ დამწყებ დეველოპერს Java და JavaScript ლამის ერთი ენა ჰგონია. სინამდვილეში ეს ორი აბსოლუტურად განსხვავებული ენაა, რომლებიც ერთმანეთთან მხოლოდ დასახელების მსგავსებითაა დაკავშირებული.
                    
                    თავდაპირველად JavaScript-ს გააჩნდა შეზღუდული შესაძლებლობები. მისი მიზანი იყო, დაემატებინა ვებგვერდისთვის მცირეოდენი ქცევა, რაც გამოიხატებოდა ღილაკზე დაჭერის დამუშავებაში, ასევე შეესრულებინა რაღაც ქმედებები, დაკავშირებული ძირითადად მართვის ელემენტებთან.
                    
                    მაგრამ ვებგარემოს განვითარებამ, HTML5-ის და Nide.js ტექნოლოგიების გამოჩენამ JavaScript-ს გადაუშალა უფრაო ფართო ასპარეზი. დღეს JavaScript ისევ გამოიყენება ვებგვერდების შესაქმნელად, მაგრამ მას ახლა გაცილებით უფრო მეტი შესაძლებლობები გააჩნია.
                    
                    JavaScript  ასევე გამოიყენება, როგორც პროგრამირების ენა სერვერის მხარეზე. თუ ადრე JavaScript გამოიყენებოდა მხოლოდ ვებგვერდებისთვის და სერვერის მხარეს უნდა გამოგვეყენებინა ისეთი ტექნოლოგიები, როგორიცაა PHP, ASP.NET, Ruby, Java, ამჟამად Nide.js-ის დამსახურებით სერვერზე მოსული მიმართვების დამუშავება ასევე შესაძლებელია Node.js-ის მეშვეობით.
                    
                    HTML5-ის სტანდარტების ფართო გავრცელებამ შესაძლებლობა მოგვცა რომ JavaScript გამოყენებული იქნეს ასევე მობილური მოწყობილობებისთვის აპლიკაციების შექმნის პროცესშიც. უფრო მეტიც, Windows 8/8.1/10 ოპერაციული სისტემების გამოჩენასთან ერთად JavaScript -ის გამოყენებით ამ ოპერაციული სისტემებისთვის პროგრამული უზრუნველყოფის შექმნაც გახდა შესაძლებელი. ამდენად, JavaScript -მა გადააბიჯა ვებბრაუზერის საზღვრებს, რაც მისთვის იყო შემოხაზული შექმნის დროს.
                    
                    ამდენად, JavaScript-ის გამოყენებას შეიძლება შევხდეთ პრაქტიკულად ყველგან და მისი გამოყენების სფერო უფრო და უფრო იზრდება.
                    
                    საჭირო ინსტრუმენტები
                    JavaScript-თან სამუშაოდ პირველ რიგში ფდაგვჭირდება რომელიმე ტექსტური რედაქტორი. ამ დროისათვის ერთ-ერთი ტექსტური რედაქტორი, რომელიც ფართოდ გამოიყენება არის Notepad++, მისი ნახვა და გადმოწერა შეიძლება შემდეგი მისამართიდან: http://notepad-plus-plus.org. მისი უპირატესობა მდგომარეობს იმაში რომ არის უფასო და გააჩნია კოდის შემოწმების ინსტრუმენტები.
                    
                    ასევე ფართოდ გამოიყენება კროსპლატფორმული ტექსტური რედაქტორი Visual Studio Code. მას გააჩნია უფრო მეტი შესაძლებლობები, ვიდრე Notepad++-ს და ასევე არის უფასო, გარდა ამისა, მისი გამოყენება შეიძლება როგორც Windows-ში, ასევე MacOS-ში და Linux-ის ბაზაზე არსებულ ოპერაციულ სისტემებში. ამ სახელმძღვანელოს შექმნის პროცესში გამოყენებულ იქნა Visual Studio Code.
                    
                    `
                },
                {
                    title:"პირველი პროგრამა JavaScript-ზე",
                    data:`შევქმნათ პირველი პროგრამა JavaScript-ზე. პირველ რიგში შევქმნათ საქაღალდე და ამ საქაღალდეში ფაილი index.html. ეს ფაილი წარმოადგენს ვებგვერდს.

                    გავხსნათ ეს ფაილი ტექსტურ რედაქტორში და ჩავწეროთ მასში შემდეგი კოდი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        alert('გამარჯობა, სამყაროვ!');
                        </script>   
                    </body>
                    </html>
                    აქ განსაზღვრულია სტანდარტული html ელემენტები. ელემენტში head განსაზღვრულია ვებგვერდის კოდირება utf-8 და გვერდის სათაური (title). body ელემენტში მოცემულია ვებგვერდის ტანი, რომელიც შედგება სათაურის ელემენტისაგან (h2) და ელემენტისაგან script.
                    
                    JavaScript-ის კოდის ჩართვა ვებგვერდზე ხორციელდება ტეგის <script> მეშვეობით. ეს ტეგი უნდა მოთავსდეს ან ვებგვერდის თავში (<head> და </head> ტეგებს შორის), ან ტანში (<body> და </body>). ხშირად ვებგვერდის ჩატვირთვის ოპტიმიზაციისთვის სკრიპტს ათავსებენ </body> დამხურავი ტეგის წინ.
                    
                    ადრე ტეგში <script> აუცილებელი იყო სკრიპტის ტიპის მითითება, რადგან ეს ტეგი სხვა ინსტრუქციების ჩატვირთვისთვისაც გამოიყენება. ზოგჯერ ახლაც შეიძლება ვებგვერდებზე შეგვხვდეს სკრიპტის ტიპის მითითება:
                    
                    <script type="text/javascript">
                    თუმცა დღეისათვის მიღებულია type ატრიბუტის გამოტოვება, რადგან მიუთითებლობისას ბრაუზერი თვლის, რომ ეს არის JavaScript-ის კოდი.
                    
                    ჩვენს მიერ გამოყენებული JavaScript-ის კოდი შეიცავს ერთ ინსტრუქციას:
                    
                    alert('გამარჯობა, სამყაროვ!');
                    JavaScript-ის კოდი შეიძლება შეიცავდეს ბევრ ინსტრუქციას და თითოეული მათგანი მთავრდება წერტილმძიმით. ჩვენი ინსტრუქცია იძახებს მეთოდს alert(), რომელსაც გამოაქვს შეტყობინება: 'გამარჯობა, სამყაროვ!'.
                    
                    როცა გავხსნით ვებგვერდს ბრაუზერში, გამოვა შეტყობინება:`
                },
                {
                    title:"JavaScript-ის კოდის შესრულება",
                    data:`როცა ბრაუზერი იღებს ვებგვერდს html-ისა და  JavaScript-ის კოდებით, ის ახდენს მის ინტერპრეტაციას. ინტერპრეტაციის შედეგი სხვადასხვა ელემენტების სახით - ღილაკები, შეყვანის ველები, ბლოკები, გამოისახება ბრაუზერში. ვებგვერდის ინტერპრეტაცია ხდება თანმიმდევრობით ზემოდან ქვემოთ.

                    როცა ბრაუზერი ხედავს JavaScript-ის კოდს, მოქმედებას იწყებს JavaScript-ის ინტერპრეტატორი. სანამ ის არ დაასრულებს მოქმედებას, ვებგვერდის შემდგომი ინტერპრეტაცია ჩერდება. 
                    
                    ვნახოთ შემდეგი მაგალითი:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                        <script>
                            alert("სექცია head");
                        </script>
                    </head>
                    <body>
                        <h2>პირველი სათაური</h2>   
                        <script>
                            alert("პირველი სათაური");
                        </script>
                        <h2>მეორე სათაური</h2>
                        <script>
                            alert("მეორე სათაური");
                        </script>
                    </body>
                    </html>
                    აქ არის სამი ჩანართი JavaScript-ის კოდით: ერთი სექცია <head>-ში, და თითო თითოეული სათურის შემდეგ.
                    
                    გავსხნათ ვებგვერდი ბრაუზერში:
                    
                    JavaScript
                    
                    მიუხედავად იმისა, რომ ვებგვერდში არის ორი სათაური, ბრაუზერში ისინი არ ჩანს, რადგან სრულდება ჯავასკრიპტის კოდი <head>-დან. სანამ შეტყობინებას არ დავხურავთ, ვებგვერდის შემდგომი ინტერპრეტაცია შეჩერებულია.
                    
                    შეტყობინების დახურვის შემდეგ ბრაუზერში გამოჩნდება პირველი სათაური და შესრულდება ჯავასკრიპტის შემდეგი კოდი, რომელიც გამოიტანს შეტყობინებას და ვებგვერდის ინტერპრეტაცია ისევ შეჩერდება შეტყობინების დახურვამდე:
                    
                    JavaScript
                    
                    შეტყობინების დახურვის შემდეგ გამოჩნდება მეორე სათაური და შეჩერდება მესამე ჯავასკრიპტის კოდზე:
                    
                    JavaScript
                    
                    მესამე შეტყობინების შემდეგ ბრაუზერი დაასრულებს ვებგვერდის ინტერპრეტაციას და ჩატვირთვა დასრულდება. ეს მომენტი მნიშვნელოვანიამ რადგან მოქმედებს ვებგვერდის წარმადობაზე, ამიტომ ხშირად ჯავასკრიპტის კოდს ათავსებენ </body> დამხურავი ტეგის წინ, როცა ვებგვერდის ძირითადი ნაწილი უკვე ჩატვირთულია.
                    
                    ჩვენს შემთხვევაში შეგვეძლო დაგვეწერა ასე:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                        <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი სათაური</h2>   
                        <h2>მეორე სათაური</h2>
                        <script>
                       alert("სექცია head");
                       alert("პირველი სათაური");
                           alert("მეორე სათაური");
                        </script>
                    </body>
                    </html>
                    javascript-ის სინტაქსის საფუძვლები
                    
                    სანამ გავაგრძელებთ პროგრამირების ენა javascript-ის შესწავლას, განვიხილოთ მისი სინტაქსის რამდენიმე ძირითადი მომენტი.
                    
                    javascript-ის კოდი შედგება ცალკეული ინსტრუქციებისაგან, რომლების ბოლოვდება წერტილმძიმით:
                    
                    alert("გამოსახულების გამოთვლა"); var a = 5 + 8; alert(a);
                    თუმცა თანამედროვე ბრაუზერების უმრავლესობას შეუძლია ჯავასკრიპტის ინსტრუქციების შესრულება იმ შემთხვევაში, თუ ისინი მოთავსებულია ცალ-ცალკე სტრიქონებზე წერტილმძიმის გარეშე:
                    
                    alert("გამოსახულების გამოთვლა")
                    var a = 5 + 8 
                    alert(a)
                    თუმცა კოდის გარჩევადობის ასამაღლებლად და შეცდომების თავიდან ასაცილებლად უმჯობესია თითოეული ინსტრუქცია მოთავსდეს ცალკე სტრიქონზე და დასრულდეს წერტილმძიმით:
                    
                    alert("გამოსახულების გამოთვლა");
                    var a = 5 + 8;
                    alert(a);
                    ჯავასკრიპტის კოდში შესაძლებელია კომენტარების გამოყენება. კომენტარს ინტერპრეტატორი არანაირად არ ითვალისწინებს და იგი არანაირ გავლენას არ ახდენს პროგრამის მუშაობაზე. ის განკუთვნილია კოდში ორიენტაციისთვის, იმის მისათითებლად, თუ რას აკეთებს მისი ესა თუ ის ნაწილი.
                    
                    კომენტარი შეიძლება იყოს ერთსტრიქონიანი, ამისთვის გამოიყენება ორმაგი სლეში:
                    
                    //შეტყობინების გამოტანა
                    alert("გამოსახულების გამოთვლა");
                    //არითმეტიკული ოპერაცია
                    var a = 5 + 8;
                    alert(a);
                    გარდა ერთსტრიქონიანისა, გამოიყენება მრავალსტრიქონიანი კომენტარებიც. ამისთვის გამოიყენება სიმბოლოები: /* კომენტარის ტექსტი */ . მაგალითად:
                    
                    /* შეტყობინების გამოტანა და
                        არითმეტიკული ოპერაცია */
                    alert("გამოსახულების გამოთვლა");
                    var a = 5 + 8;
                    alert(a);`
                    
                },
                {
                    title:"გარე ფაილის ჩართვა",
                    data:`ვებგვერდზე JavaScript-ის ჩართვის კიდევ ერთი საშუალებაა JavaScript-ის კოდის გატანა გარე ფაილში და ამ ფაილის ჩართვა ვებგვერდზე ტეგით <script>.

                    index.html ფაილთან იგივე საქაღალდეში შევქმნათ საქაღალდე js. იგი იქნება განკუთვნილი ჯავასკრიპტის ფაილების შესანახად. ამ საქაღალდის შიგნით შვქმნათ ფაილი myscript.js. ჯავასკრიპტის ფაილებს უნდა ჰქონდეს გაფართოება .js. გავხსნათ შექმნილი ფაილი და ჩავწეროთ შიგნით შემდეგი კოდი:
                    
                    var date = new Date(); // მიმდინარე თარიღის მიღება
                    var time = date.getHours(); // მიმდინარე დრო საათებში
                    if(time < 13) // შევადაროთ რიცხვს 13
                        alert('დილა მშვიდობისა!'); // მიმდინარე დრო ნაკლებია 13 საათზე
                    else
                        alert('საღამო მშვიდობისა!'); // მიმდინარე დრო მეტია 13 საათზე
                    ახლა ჩავრთოთ ჯავასკრიპტის ფაილი ვებგვერდზე:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script src="js/myscript.js"></script>
                    </body>
                    </html>
                     
                    
                    ვებგვერდზე ჯავასკრიპტის ფაილის ჩასართავად  გამოიყენება ტეგი <script>, რომელსაც აქვს ატრიბუტი src. ეს ატრიბუტი უჩვენებს ფაილის მისამართს. ვებგვერდის გაშვებისას გამოვა შეტყობინება:
                    
                    JavaScript
                    
                    ჯავასკრიპტის კოდის გარე ფაილში გატანას აქვს მთელი რიგი უპირატესობები:
                    
                    ერთი და იგივე კოდის გამოყენება შეგვიძლია სხვადასხვა ვებგვერდზე;
                    ბრაუზერი ახდენს ჯავასკრიპტის გარე ფაილების კეშირებას, შესაბამისად მომდევნო მიმართვებისას არ უწევს სერვერზე მიმართვა, რითაც მცირდება სერვერზე დატვირთვა და ბრაუზერს უწევს ნაკლები ინფორმაციის ჩამოტვირთვა;
                    ვებგვერდის კოდი არის უფრო "სუფთა". ის შეიცავს მხოლოდ html-კოდს, ხოლო ჯავასკრიპტის კოდი ინახება ცალკე ფაილებში. ამავდროულად შეიძლება html-კოდს და JavaScript-ის კოდზე მუშაობა დავაცალკევოთ.
                    ამიტომაც, ჯავასკრიპტის კოდისთვის ძირითადად გამოიყენება გარე ფაილები.
                    
                     `
                    
                },
                {
                    title:"ბრაუზერის კონსოლი. console.log და document.write",
                    data:`ჯავასკრიპტთან მუშაობისას შეუცვლელ ინსტრუმენტს წარმოადგენს ბრაუზერის კონსოლი, რომელიც გვეხმარება პროგრამის დახვეწის პროცესში. თანამედროვე ბრაუზერების უმეტესობას გააჩნია ასეთი კონსოლი. მაგალითად, Google Chrome-ში უნდა გავხსნათ More tools=>Developer tools და გახსნილ ჩანართში ავირჩიოთ Console:

 

                    JavaScript
                    
                    JavaScript
                    
                    კონსოლში შეგვიძლია პირდაპირ შევიყვანოთ ჯავასკრიპტის კოდი და Enter კლავიშზე დაჭერით კოდი შესრულდება. მაგალითად, ჩავწეროთ კონსოლში შემდეგი კოდი:
                    
                    alert("გამარჯობა, სამყაროვ");
                    Enter-ზე დაჭერის შემდეგ ჯავასკრიპტის კოდი შესრულდება და გამოვა შეტყობინება:
                    
                    JavaScript
                    
                    ბრაუზერის კონსოლში სხვადასხვა ინფორმაციის გამოსატანად გამოიყენება ფუნქცია console.log(). მაგალითად:
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        var a = 5 + 8;
                        console.log("ოპერაციის შედეგი:");
                        console.log(a);
                        </script>
                    </body>
                    </html>
                    ჯავასკრიპტის კოდში საკვანძო სიტყვის var მეშვეობით გამოცხადებულია ცვლადი a, რომელსაც ენიჭება მნიშვნელობად 5-სა და 8-ის ჯამი: var a=5+8. console.log() ფუნქციის მეშვეობით გამოგვაქვს a-ს მნიშვნელობა ეკრანზე. ვებგვერდის გაშვებისას ბრაუზერის კონსოლში ვხედავთ კოდის შესრულების შედეგს:
                    
                    JavaScript
                    
                    მეთოდი document.write
                    
                    საწყის ეტაპზე ასევე სასარგებლოა მეთოდის document.write გამოყენება, რომელიც წერს ინფორმაციას ვებგვერდზე. წინა მაგალითში შევცვალოთ ფუნქცია console.log() ფუნქციით document.write():
                    
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8" />
                    <title>JavaScript</title>
                    </head>
                    <body>
                        <h2>პირველი პროგრამა JavaScript-ზე</h2>
                        <script>
                        var a = 5 + 8;
                        document.write("ოპერაციის შედეგი:");
                        document.write(a);
                        </script>
                    </body>
                    </html>
                    ამ შემთხვევაში ინფორმაცია გამოდის უშუალოდ ვებგვერდზე.`
                    
                }
            ]
        },
        {
            title:"თავი 2. JavaScript-ის საფუძვლები",
            content:[
                {
                    title:"ცვლადები",
                    data:``
                },
                {
                  title:"მნიშვნელობათა ტიპები",
                  data:``
              },
              {
                  title:"ოპერაციები ცვლადებზე",
                  data:``
              },
              {
                  title:"მონაცემების გარდაქმნა",
                  data:``
              },
              {
                  title:"მასივები",
                  data:``
              },
              {
                  title:"პირობითი კონსტრუქციები",
                  data:``
              },
              {
                  title:"ციკლები",
                  data:``
              },
              
            ]
        },
        {
            title:"თავი 3. ფუნქციონალური პროგრამირება",
            content:[
                {
                    title:"ფუნქციები",
                    data:``
                },
                {
                  title:"ცვლადების ხედვის არე",
                  data:``
              },
              {
                  title:"რეკურსიული ფუნქციები",
                  data:``
              },
              {
                  title:"ფუნქციის ხელახალი განსაზღვრა",
                  data:``
              },
              {
                  title:"Hoisting",
                  data:``
              },
            
            ]
        },{
            title:"თავი 4. ობიექტზე ორიენტირებული პროგრამირება",
            content:[
                {
                    title:"ობიექტები",
                    data:``
                },
                {
                  title:"ჩასმული ობიექტები და მასივები ობიექტებში",
                  data:``
              },
              {
                  title:"მეთოდებისა და თვისებების არსებობის შემოწმება და გადარჩევა",
                  data:``
              },
              {
                  title:"ობიექტები ფუნქციებში",
                  data:``
              },
              {
                  title:"ობიექტის კონსტრუქტორი",
                  data:``
              },
              {
                  title:"ობიექტების გაფართოება. Prototype",
                  data:``
              },
              {
                  title:"ინკაფსულაცია",
                  data:``
              },
              {
                  title:"ფუნქცია, როგორც ობიექტი. მეთოდები call და apply",
                  data:``
              },
              {
                title:"მემკვიდრეობითობა",
                data:``
            },
            {
                title:"საკვანძო სიტყვა",
                data:``
            },
         
            ]
        },{
            title:"თავი 5. ჩაშენებული ობიექტები",
            content:[
                {
                    title:"ობიექტი Date. თარიღებთან მუშაობა",
                    data:``
                },
                {
                  title:"ობიექტი Math. მათემატიკური ოპერაციები",
                  data:``
              },
              {
                  title:"ობიექტი Array. მასივებთან მუშაობა",
                  data:``
              },
              {
                  title:"ობიექტი Number",
                  data:``
              },
            
            ]
        },{
            title:"თავი 6. სტრიქონები",
            content:[
                {
                    title:"ობიექტი String",
                    data:``
                },
                {
                  title:"ობიექტი RegExp. რეგულარული გამოსახულებები",
                  data:``
              },
              {
                  title:"რეგულარული გამოსახულება String ობიექტის მეთოდებში",
                  data:``
              },
              {
                  title:"რეგულარული გამოსახულების სინტაქსი",
                  data:``
              },
              
            ]
        },{
            title:"თავი 7. მუშაობა ბრაუზერთან და BOM (Browser Object Model)",
            content:[
                {
                    title:"Browser Object Model და ობიექტი window",
                    data:``
                },
                {
                  title:"ფანჯრების მართვა",
                  data:``
              },
              {
                  title:"ბრაუზერის ისტორია. ობიექტი history",
                  data:``
              },
              {
                  title:"ობიექტი location",
                  data:``
              },
              {
                  title:"ობიექტი navigator",
                  data:``
              },
              {
                  title:"ტაიმერი",
                  data:``
              },
       
            ]
        },{
            title:"თავი 8. DOM (Document Object Model)",
            content:[
                {
                    title:"DOM - შესავალი",
                    data:``
                },
                {
                  title:"ობიექტი document. ელემენტების ძებნა",
                  data:``
              },
              {
                  title:"document ობიექტის თვისებები",
                  data:``
              },
              {
                  title:"ობიექტი Node. ნავიგაცია DOM-ში",
                  data:``
              },
              {
                  title:"ელემენტების შექმნა, დამატება და წაშლა",
                  data:``
              },
              {
                  title:"ობიექტი Element. ელემენტების მართვა",
                  data:``
              },
              {
                  title:"ელემენტების სტილის შეცვლა",
                  data:``
              },
    
            ]
        },
        {
            title:"თავი 9. მოვლენები",
            content:[
                {
                    title:"შესავალი მოვლენების დამუშავებაში",
                    data:``
                },
                {
                  title:"მოვლენების დამმუშავებლები",
                  data:``
              },
              {
                  title:"ობიექტი Event",
                  data:``
              },
              {
                  title:"მოვლენების გავრცელება",
                  data:``
              },
              {
                  title:"მაუსის მოვლენები",
                  data:``
              },
              {
                  title:"კლავიატურის მოვლენები",
                  data:``
              },
              
            ]
        },
        {
            title:"თავი 10. მუშაობა ფორმებთან",
            content:[
                {
                    title:"ფორმები და მათი ელემენტები",
                    data:``
                },
                {
                  title:"ღილაკები",
                  data:``
              },
              {
                  title:"ტექსტური ველები",
                  data:``
              },
              {
                  title:"ალმები და გადამრთველები",
                  data:``
              },
              {
                  title:"სია select",
                  data:``
              },
           
            ]
        },
        {
            title:"თავი 11. JSON",
            content:[
                {
                    title:"შესავალი JSON-ში",
                    data:``
                },
            ]
        },
        {
            title:"თავი 12. მონაცემების შენახვა",
            content:[
                {
                    title:"cookie",
                    data:``
                },
                {
                  title:"Web Storage",
                  data:``
              },
             
            ]
        },
        {
            title:"თავი 13. Ajax",
            content:[
                {
                    title:"ობიექტი XMLHttpRequest",
                    data:``
                },
                {
                  title:"მონაცემების გაგზავნა",
                  data:``
              },
              {
                  title:"Promise Ajax მოთხოვნებში",
                  data:``
              },
          
            ]
        },
    ]
},
node:{
    chapters:[
        {
            title:"dsda",
            content:[
                {
                    title:"",
                    data:``
                },
                {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
            ]
        }
    ]

},
jquery:{
    chapters:[
        {
            title:"dsda",
            content:[
                {
                    title:"",
                    data:``
                },
                {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
            ]
        }
    ]

},
php:{
    chapters:[
        {
            title:"dsda",
            content:[
                {
                    title:"",
                    data:``
                },
                {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
              {
                  title:"",
                  data:``
              },
            ]
        }
    ]

}



}